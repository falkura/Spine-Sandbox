/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GUI\": () => (/* binding */ GUI$1),\n/* harmony export */   \"color\": () => (/* binding */ color),\n/* harmony export */   \"controllers\": () => (/* binding */ controllers),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"dom\": () => (/* binding */ dom$1),\n/* harmony export */   \"gui\": () => (/* binding */ gui)\n/* harmony export */ });\n/**\n * dat-gui JavaScript Controller Library\n * https://github.com/dataarts/dat.gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction ___$insertStyle(css) {\n  if (!css) {\n    return;\n  }\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  var style = document.createElement('style');\n\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n\n  return css;\n}\n\nfunction colorToString (color, forceCSSHex) {\n  var colorFormat = color.__state.conversionName.toString();\n  var r = Math.round(color.r);\n  var g = Math.round(color.g);\n  var b = Math.round(color.b);\n  var a = color.a;\n  var h = Math.round(color.h);\n  var s = color.s.toFixed(1);\n  var v = color.v.toFixed(1);\n  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {\n    var str = color.hex.toString(16);\n    while (str.length < 6) {\n      str = '0' + str;\n    }\n    return '#' + str;\n  } else if (colorFormat === 'CSS_RGB') {\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\n  } else if (colorFormat === 'CSS_RGBA') {\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  } else if (colorFormat === 'HEX') {\n    return '0x' + color.hex.toString(16);\n  } else if (colorFormat === 'RGB_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ']';\n  } else if (colorFormat === 'RGBA_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ',' + a + ']';\n  } else if (colorFormat === 'RGB_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + '}';\n  } else if (colorFormat === 'RGBA_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';\n  } else if (colorFormat === 'HSV_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + '}';\n  } else if (colorFormat === 'HSVA_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';\n  }\n  return 'unknown format';\n}\n\nvar ARR_EACH = Array.prototype.forEach;\nvar ARR_SLICE = Array.prototype.slice;\nvar Common = {\n  BREAK: {},\n  extend: function extend(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (!this.isUndefined(obj[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  defaults: function defaults(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (this.isUndefined(target[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  compose: function compose() {\n    var toCall = ARR_SLICE.call(arguments);\n    return function () {\n      var args = ARR_SLICE.call(arguments);\n      for (var i = toCall.length - 1; i >= 0; i--) {\n        args = [toCall[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  },\n  each: function each(obj, itr, scope) {\n    if (!obj) {\n      return;\n    }\n    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {\n      obj.forEach(itr, scope);\n    } else if (obj.length === obj.length + 0) {\n      var key = void 0;\n      var l = void 0;\n      for (key = 0, l = obj.length; key < l; key++) {\n        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {\n          return;\n        }\n      }\n    } else {\n      for (var _key in obj) {\n        if (itr.call(scope, obj[_key], _key) === this.BREAK) {\n          return;\n        }\n      }\n    }\n  },\n  defer: function defer(fnc) {\n    setTimeout(fnc, 0);\n  },\n  debounce: function debounce(func, threshold, callImmediately) {\n    var timeout = void 0;\n    return function () {\n      var obj = this;\n      var args = arguments;\n      function delayed() {\n        timeout = null;\n        if (!callImmediately) func.apply(obj, args);\n      }\n      var callNow = callImmediately || !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(delayed, threshold);\n      if (callNow) {\n        func.apply(obj, args);\n      }\n    };\n  },\n  toArray: function toArray(obj) {\n    if (obj.toArray) return obj.toArray();\n    return ARR_SLICE.call(obj);\n  },\n  isUndefined: function isUndefined(obj) {\n    return obj === undefined;\n  },\n  isNull: function isNull(obj) {\n    return obj === null;\n  },\n  isNaN: function (_isNaN) {\n    function isNaN(_x) {\n      return _isNaN.apply(this, arguments);\n    }\n    isNaN.toString = function () {\n      return _isNaN.toString();\n    };\n    return isNaN;\n  }(function (obj) {\n    return isNaN(obj);\n  }),\n  isArray: Array.isArray || function (obj) {\n    return obj.constructor === Array;\n  },\n  isObject: function isObject(obj) {\n    return obj === Object(obj);\n  },\n  isNumber: function isNumber(obj) {\n    return obj === obj + 0;\n  },\n  isString: function isString(obj) {\n    return obj === obj + '';\n  },\n  isBoolean: function isBoolean(obj) {\n    return obj === false || obj === true;\n  },\n  isFunction: function isFunction(obj) {\n    return obj instanceof Function;\n  }\n};\n\nvar INTERPRETATIONS = [\n{\n  litmus: Common.isString,\n  conversions: {\n    THREE_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    SIX_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9]{6})$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGB: {\n      read: function read(original) {\n        var test = original.match(/^rgb\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3])\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGBA: {\n      read: function read(original) {\n        var test = original.match(/^rgba\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3]),\n          a: parseFloat(test[4])\n        };\n      },\n      write: colorToString\n    }\n  }\n},\n{\n  litmus: Common.isNumber,\n  conversions: {\n    HEX: {\n      read: function read(original) {\n        return {\n          space: 'HEX',\n          hex: original,\n          conversionName: 'HEX'\n        };\n      },\n      write: function write(color) {\n        return color.hex;\n      }\n    }\n  }\n},\n{\n  litmus: Common.isArray,\n  conversions: {\n    RGB_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 3) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b];\n      }\n    },\n    RGBA_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 4) return false;\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2],\n          a: original[3]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b, color.a];\n      }\n    }\n  }\n},\n{\n  litmus: Common.isObject,\n  conversions: {\n    RGBA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b,\n          a: color.a\n        };\n      }\n    },\n    RGB_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b\n        };\n      }\n    },\n    HSVA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v,\n          a: color.a\n        };\n      }\n    },\n    HSV_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v\n        };\n      }\n    }\n  }\n}];\nvar result = void 0;\nvar toReturn = void 0;\nvar interpret = function interpret() {\n  toReturn = false;\n  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];\n  Common.each(INTERPRETATIONS, function (family) {\n    if (family.litmus(original)) {\n      Common.each(family.conversions, function (conversion, conversionName) {\n        result = conversion.read(original);\n        if (toReturn === false && result !== false) {\n          toReturn = result;\n          result.conversionName = conversionName;\n          result.conversion = conversion;\n          return Common.BREAK;\n        }\n      });\n      return Common.BREAK;\n    }\n  });\n  return toReturn;\n};\n\nvar tmpComponent = void 0;\nvar ColorMath = {\n  hsv_to_rgb: function hsv_to_rgb(h, s, v) {\n    var hi = Math.floor(h / 60) % 6;\n    var f = h / 60 - Math.floor(h / 60);\n    var p = v * (1.0 - s);\n    var q = v * (1.0 - f * s);\n    var t = v * (1.0 - (1.0 - f) * s);\n    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];\n    return {\n      r: c[0] * 255,\n      g: c[1] * 255,\n      b: c[2] * 255\n    };\n  },\n  rgb_to_hsv: function rgb_to_hsv(r, g, b) {\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var h = void 0;\n    var s = void 0;\n    if (max !== 0) {\n      s = delta / max;\n    } else {\n      return {\n        h: NaN,\n        s: 0,\n        v: 0\n      };\n    }\n    if (r === max) {\n      h = (g - b) / delta;\n    } else if (g === max) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n    h /= 6;\n    if (h < 0) {\n      h += 1;\n    }\n    return {\n      h: h * 360,\n      s: s,\n      v: max / 255\n    };\n  },\n  rgb_to_hex: function rgb_to_hex(r, g, b) {\n    var hex = this.hex_with_component(0, 2, r);\n    hex = this.hex_with_component(hex, 1, g);\n    hex = this.hex_with_component(hex, 0, b);\n    return hex;\n  },\n  component_from_hex: function component_from_hex(hex, componentIndex) {\n    return hex >> componentIndex * 8 & 0xFF;\n  },\n  hex_with_component: function hex_with_component(hex, componentIndex, value) {\n    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);\n  }\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Color = function () {\n  function Color() {\n    classCallCheck(this, Color);\n    this.__state = interpret.apply(this, arguments);\n    if (this.__state === false) {\n      throw new Error('Failed to interpret color arguments');\n    }\n    this.__state.a = this.__state.a || 1;\n  }\n  createClass(Color, [{\n    key: 'toString',\n    value: function toString() {\n      return colorToString(this);\n    }\n  }, {\n    key: 'toHexString',\n    value: function toHexString() {\n      return colorToString(this, true);\n    }\n  }, {\n    key: 'toOriginal',\n    value: function toOriginal() {\n      return this.__state.conversion.write(this);\n    }\n  }]);\n  return Color;\n}();\nfunction defineRGBComponent(target, component, componentHexIndex) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'RGB') {\n        return this.__state[component];\n      }\n      Color.recalculateRGB(this, component, componentHexIndex);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'RGB') {\n        Color.recalculateRGB(this, component, componentHexIndex);\n        this.__state.space = 'RGB';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nfunction defineHSVComponent(target, component) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'HSV') {\n        return this.__state[component];\n      }\n      Color.recalculateHSV(this);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'HSV') {\n        Color.recalculateHSV(this);\n        this.__state.space = 'HSV';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nColor.recalculateRGB = function (color, component, componentHexIndex) {\n  if (color.__state.space === 'HEX') {\n    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);\n  } else if (color.__state.space === 'HSV') {\n    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n  } else {\n    throw new Error('Corrupted color state');\n  }\n};\nColor.recalculateHSV = function (color) {\n  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);\n  Common.extend(color.__state, {\n    s: result.s,\n    v: result.v\n  });\n  if (!Common.isNaN(result.h)) {\n    color.__state.h = result.h;\n  } else if (Common.isUndefined(color.__state.h)) {\n    color.__state.h = 0;\n  }\n};\nColor.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];\ndefineRGBComponent(Color.prototype, 'r', 2);\ndefineRGBComponent(Color.prototype, 'g', 1);\ndefineRGBComponent(Color.prototype, 'b', 0);\ndefineHSVComponent(Color.prototype, 'h');\ndefineHSVComponent(Color.prototype, 's');\ndefineHSVComponent(Color.prototype, 'v');\nObject.defineProperty(Color.prototype, 'a', {\n  get: function get$$1() {\n    return this.__state.a;\n  },\n  set: function set$$1(v) {\n    this.__state.a = v;\n  }\n});\nObject.defineProperty(Color.prototype, 'hex', {\n  get: function get$$1() {\n    if (this.__state.space !== 'HEX') {\n      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);\n      this.__state.space = 'HEX';\n    }\n    return this.__state.hex;\n  },\n  set: function set$$1(v) {\n    this.__state.space = 'HEX';\n    this.__state.hex = v;\n  }\n});\n\nvar Controller = function () {\n  function Controller(object, property) {\n    classCallCheck(this, Controller);\n    this.initialValue = object[property];\n    this.domElement = document.createElement('div');\n    this.object = object;\n    this.property = property;\n    this.__onChange = undefined;\n    this.__onFinishChange = undefined;\n  }\n  createClass(Controller, [{\n    key: 'onChange',\n    value: function onChange(fnc) {\n      this.__onChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'onFinishChange',\n    value: function onFinishChange(fnc) {\n      this.__onFinishChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'setValue',\n    value: function setValue(newValue) {\n      this.object[this.property] = newValue;\n      if (this.__onChange) {\n        this.__onChange.call(this, newValue);\n      }\n      this.updateDisplay();\n      return this;\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.object[this.property];\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      return this;\n    }\n  }, {\n    key: 'isModified',\n    value: function isModified() {\n      return this.initialValue !== this.getValue();\n    }\n  }]);\n  return Controller;\n}();\n\nvar EVENT_MAP = {\n  HTMLEvents: ['change'],\n  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],\n  KeyboardEvents: ['keydown']\n};\nvar EVENT_MAP_INV = {};\nCommon.each(EVENT_MAP, function (v, k) {\n  Common.each(v, function (e) {\n    EVENT_MAP_INV[e] = k;\n  });\n});\nvar CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\nfunction cssValueToPixels(val) {\n  if (val === '0' || Common.isUndefined(val)) {\n    return 0;\n  }\n  var match = val.match(CSS_VALUE_PIXELS);\n  if (!Common.isNull(match)) {\n    return parseFloat(match[1]);\n  }\n  return 0;\n}\nvar dom = {\n  makeSelectable: function makeSelectable(elem, selectable) {\n    if (elem === undefined || elem.style === undefined) return;\n    elem.onselectstart = selectable ? function () {\n      return false;\n    } : function () {};\n    elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n    elem.unselectable = selectable ? 'on' : 'off';\n  },\n  makeFullscreen: function makeFullscreen(elem, hor, vert) {\n    var vertical = vert;\n    var horizontal = hor;\n    if (Common.isUndefined(horizontal)) {\n      horizontal = true;\n    }\n    if (Common.isUndefined(vertical)) {\n      vertical = true;\n    }\n    elem.style.position = 'absolute';\n    if (horizontal) {\n      elem.style.left = 0;\n      elem.style.right = 0;\n    }\n    if (vertical) {\n      elem.style.top = 0;\n      elem.style.bottom = 0;\n    }\n  },\n  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {\n    var params = pars || {};\n    var className = EVENT_MAP_INV[eventType];\n    if (!className) {\n      throw new Error('Event type ' + eventType + ' not supported.');\n    }\n    var evt = document.createEvent(className);\n    switch (className) {\n      case 'MouseEvents':\n        {\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,\n          0,\n          clientX,\n          clientY,\n          false, false, false, false, 0, null);\n          break;\n        }\n      case 'KeyboardEvents':\n        {\n          var init = evt.initKeyboardEvent || evt.initKeyEvent;\n          Common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);\n          break;\n        }\n      default:\n        {\n          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);\n          break;\n        }\n    }\n    Common.defaults(evt, aux);\n    elem.dispatchEvent(evt);\n  },\n  bind: function bind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.addEventListener) {\n      elem.addEventListener(event, func, bool);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  unbind: function unbind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.removeEventListener) {\n      elem.removeEventListener(event, func, bool);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  addClass: function addClass(elem, className) {\n    if (elem.className === undefined) {\n      elem.className = className;\n    } else if (elem.className !== className) {\n      var classes = elem.className.split(/ +/);\n      if (classes.indexOf(className) === -1) {\n        classes.push(className);\n        elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n      }\n    }\n    return dom;\n  },\n  removeClass: function removeClass(elem, className) {\n    if (className) {\n      if (elem.className === className) {\n        elem.removeAttribute('class');\n      } else {\n        var classes = elem.className.split(/ +/);\n        var index = classes.indexOf(className);\n        if (index !== -1) {\n          classes.splice(index, 1);\n          elem.className = classes.join(' ');\n        }\n      }\n    } else {\n      elem.className = undefined;\n    }\n    return dom;\n  },\n  hasClass: function hasClass(elem, className) {\n    return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n  },\n  getWidth: function getWidth(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);\n  },\n  getHeight: function getHeight(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);\n  },\n  getOffset: function getOffset(el) {\n    var elem = el;\n    var offset = { left: 0, top: 0 };\n    if (elem.offsetParent) {\n      do {\n        offset.left += elem.offsetLeft;\n        offset.top += elem.offsetTop;\n        elem = elem.offsetParent;\n      } while (elem);\n    }\n    return offset;\n  },\n  isActive: function isActive(elem) {\n    return elem === document.activeElement && (elem.type || elem.href);\n  }\n};\n\nvar BooleanController = function (_Controller) {\n  inherits(BooleanController, _Controller);\n  function BooleanController(object, property) {\n    classCallCheck(this, BooleanController);\n    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__prev = _this2.getValue();\n    _this2.__checkbox = document.createElement('input');\n    _this2.__checkbox.setAttribute('type', 'checkbox');\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n    dom.bind(_this2.__checkbox, 'change', onChange, false);\n    _this2.domElement.appendChild(_this2.__checkbox);\n    _this2.updateDisplay();\n    return _this2;\n  }\n  createClass(BooleanController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      this.__prev = this.getValue();\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (this.getValue() === true) {\n        this.__checkbox.setAttribute('checked', 'checked');\n        this.__checkbox.checked = true;\n        this.__prev = true;\n      } else {\n        this.__checkbox.checked = false;\n        this.__prev = false;\n      }\n      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return BooleanController;\n}(Controller);\n\nvar OptionController = function (_Controller) {\n  inherits(OptionController, _Controller);\n  function OptionController(object, property, opts) {\n    classCallCheck(this, OptionController);\n    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));\n    var options = opts;\n    var _this = _this2;\n    _this2.__select = document.createElement('select');\n    if (Common.isArray(options)) {\n      var map = {};\n      Common.each(options, function (element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n    Common.each(options, function (value, key) {\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n    });\n    _this2.updateDisplay();\n    dom.bind(_this2.__select, 'change', function () {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n    _this2.domElement.appendChild(_this2.__select);\n    return _this2;\n  }\n  createClass(OptionController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (dom.isActive(this.__select)) return this;\n      this.__select.value = this.getValue();\n      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return OptionController;\n}(Controller);\n\nvar StringController = function (_Controller) {\n  inherits(StringController, _Controller);\n  function StringController(object, property) {\n    classCallCheck(this, StringController);\n    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));\n    var _this = _this2;\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'keyup', onChange);\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(StringController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (!dom.isActive(this.__input)) {\n        this.__input.value = this.getValue();\n      }\n      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return StringController;\n}(Controller);\n\nfunction numDecimals(x) {\n  var _x = x.toString();\n  if (_x.indexOf('.') > -1) {\n    return _x.length - _x.indexOf('.') - 1;\n  }\n  return 0;\n}\nvar NumberController = function (_Controller) {\n  inherits(NumberController, _Controller);\n  function NumberController(object, property, params) {\n    classCallCheck(this, NumberController);\n    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));\n    var _params = params || {};\n    _this.__min = _params.min;\n    _this.__max = _params.max;\n    _this.__step = _params.step;\n    if (Common.isUndefined(_this.__step)) {\n      if (_this.initialValue === 0) {\n        _this.__impliedStep = 1;\n      } else {\n        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;\n      }\n    } else {\n      _this.__impliedStep = _this.__step;\n    }\n    _this.__precision = numDecimals(_this.__impliedStep);\n    return _this;\n  }\n  createClass(NumberController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var _v = v;\n      if (this.__min !== undefined && _v < this.__min) {\n        _v = this.__min;\n      } else if (this.__max !== undefined && _v > this.__max) {\n        _v = this.__max;\n      }\n      if (this.__step !== undefined && _v % this.__step !== 0) {\n        _v = Math.round(_v / this.__step) * this.__step;\n      }\n      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);\n    }\n  }, {\n    key: 'min',\n    value: function min(minValue) {\n      this.__min = minValue;\n      return this;\n    }\n  }, {\n    key: 'max',\n    value: function max(maxValue) {\n      this.__max = maxValue;\n      return this;\n    }\n  }, {\n    key: 'step',\n    value: function step(stepValue) {\n      this.__step = stepValue;\n      this.__impliedStep = stepValue;\n      this.__precision = numDecimals(stepValue);\n      return this;\n    }\n  }]);\n  return NumberController;\n}(Controller);\n\nfunction roundToDecimal(value, decimals) {\n  var tenTo = Math.pow(10, decimals);\n  return Math.round(value * tenTo) / tenTo;\n}\nvar NumberControllerBox = function (_NumberController) {\n  inherits(NumberControllerBox, _NumberController);\n  function NumberControllerBox(object, property, params) {\n    classCallCheck(this, NumberControllerBox);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));\n    _this2.__truncationSuspended = false;\n    var _this = _this2;\n    var prevY = void 0;\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!Common.isNaN(attempted)) {\n        _this.setValue(attempted);\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onBlur() {\n      onFinish();\n    }\n    function onMouseDrag(e) {\n      var diff = prevY - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n      prevY = e.clientY;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      onFinish();\n    }\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prevY = e.clientY;\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'mousedown', onMouseDown);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n        onFinish();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(NumberControllerBox, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerBox;\n}(NumberController);\n\nfunction map(v, i1, i2, o1, o2) {\n  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n}\nvar NumberControllerSlider = function (_NumberController) {\n  inherits(NumberControllerSlider, _NumberController);\n  function NumberControllerSlider(object, property, min, max, step) {\n    classCallCheck(this, NumberControllerSlider);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));\n    var _this = _this2;\n    _this2.__background = document.createElement('div');\n    _this2.__foreground = document.createElement('div');\n    dom.bind(_this2.__background, 'mousedown', onMouseDown);\n    dom.bind(_this2.__background, 'touchstart', onTouchStart);\n    dom.addClass(_this2.__background, 'slider');\n    dom.addClass(_this2.__foreground, 'slider-fg');\n    function onMouseDown(e) {\n      document.activeElement.blur();\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      onMouseDrag(e);\n    }\n    function onMouseDrag(e) {\n      e.preventDefault();\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n      return false;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onTouchStart(e) {\n      if (e.touches.length !== 1) {\n        return;\n      }\n      dom.bind(window, 'touchmove', onTouchMove);\n      dom.bind(window, 'touchend', onTouchEnd);\n      onTouchMove(e);\n    }\n    function onTouchMove(e) {\n      var clientX = e.touches[0].clientX;\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n    }\n    function onTouchEnd() {\n      dom.unbind(window, 'touchmove', onTouchMove);\n      dom.unbind(window, 'touchend', onTouchEnd);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.updateDisplay();\n    _this2.__background.appendChild(_this2.__foreground);\n    _this2.domElement.appendChild(_this2.__background);\n    return _this2;\n  }\n  createClass(NumberControllerSlider, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);\n      this.__foreground.style.width = pct * 100 + '%';\n      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerSlider;\n}(NumberController);\n\nvar FunctionController = function (_Controller) {\n  inherits(FunctionController, _Controller);\n  function FunctionController(object, property, text) {\n    classCallCheck(this, FunctionController);\n    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__button = document.createElement('div');\n    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(_this2.__button, 'click', function (e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n    dom.addClass(_this2.__button, 'button');\n    _this2.domElement.appendChild(_this2.__button);\n    return _this2;\n  }\n  createClass(FunctionController, [{\n    key: 'fire',\n    value: function fire() {\n      if (this.__onChange) {\n        this.__onChange.call(this);\n      }\n      this.getValue().call(this.object);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n    }\n  }]);\n  return FunctionController;\n}(Controller);\n\nvar ColorController = function (_Controller) {\n  inherits(ColorController, _Controller);\n  function ColorController(object, property) {\n    classCallCheck(this, ColorController);\n    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));\n    _this2.__color = new Color(_this2.getValue());\n    _this2.__temp = new Color(0);\n    var _this = _this2;\n    _this2.domElement = document.createElement('div');\n    dom.makeSelectable(_this2.domElement, false);\n    _this2.__selector = document.createElement('div');\n    _this2.__selector.className = 'selector';\n    _this2.__saturation_field = document.createElement('div');\n    _this2.__saturation_field.className = 'saturation-field';\n    _this2.__field_knob = document.createElement('div');\n    _this2.__field_knob.className = 'field-knob';\n    _this2.__field_knob_border = '2px solid ';\n    _this2.__hue_knob = document.createElement('div');\n    _this2.__hue_knob.className = 'hue-knob';\n    _this2.__hue_field = document.createElement('div');\n    _this2.__hue_field.className = 'hue-field';\n    _this2.__input = document.createElement('input');\n    _this2.__input.type = 'text';\n    _this2.__input_textShadow = '0 1px 1px ';\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        onBlur.call(this);\n      }\n    });\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__selector, 'mousedown', function () {\n      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    dom.bind(_this2.__selector, 'touchstart', function () {\n      dom.addClass(this, 'drag').bind(window, 'touchend', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    var valueField = document.createElement('div');\n    Common.extend(_this2.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n    Common.extend(_this2.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    Common.extend(_this2.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n    Common.extend(_this2.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n    Common.extend(valueField.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');\n    Common.extend(_this2.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      border: '1px solid #555',\n      cursor: 'ns-resize',\n      position: 'absolute',\n      top: '3px',\n      right: '3px'\n    });\n    hueGradient(_this2.__hue_field);\n    Common.extend(_this2.__input.style, {\n      outline: 'none',\n      textAlign: 'center',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);\n    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);\n    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);\n    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);\n    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);\n    function fieldDown(e) {\n      setSV(e);\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'touchmove', setSV);\n      dom.bind(window, 'mouseup', fieldUpSV);\n      dom.bind(window, 'touchend', fieldUpSV);\n    }\n    function fieldDownH(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'touchmove', setH);\n      dom.bind(window, 'mouseup', fieldUpH);\n      dom.bind(window, 'touchend', fieldUpH);\n    }\n    function fieldUpSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'touchmove', setSV);\n      dom.unbind(window, 'mouseup', fieldUpSV);\n      dom.unbind(window, 'touchend', fieldUpSV);\n      onFinish();\n    }\n    function fieldUpH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'touchmove', setH);\n      dom.unbind(window, 'mouseup', fieldUpH);\n      dom.unbind(window, 'touchend', fieldUpH);\n      onFinish();\n    }\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.__color.toOriginal());\n      }\n    }\n    _this2.__saturation_field.appendChild(valueField);\n    _this2.__selector.appendChild(_this2.__field_knob);\n    _this2.__selector.appendChild(_this2.__saturation_field);\n    _this2.__selector.appendChild(_this2.__hue_field);\n    _this2.__hue_field.appendChild(_this2.__hue_knob);\n    _this2.domElement.appendChild(_this2.__input);\n    _this2.domElement.appendChild(_this2.__selector);\n    _this2.updateDisplay();\n    function setSV(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__saturation_field.getBoundingClientRect();\n      var _ref = e.touches && e.touches[0] || e,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);\n      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (v > 1) {\n        v = 1;\n      } else if (v < 0) {\n        v = 0;\n      }\n      if (s > 1) {\n        s = 1;\n      } else if (s < 0) {\n        s = 0;\n      }\n      _this.__color.v = v;\n      _this.__color.s = s;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    function setH(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__hue_field.getBoundingClientRect();\n      var _ref2 = e.touches && e.touches[0] || e,\n          clientY = _ref2.clientY;\n      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (h > 1) {\n        h = 1;\n      } else if (h < 0) {\n        h = 0;\n      }\n      _this.__color.h = h * 360;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    return _this2;\n  }\n  createClass(ColorController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var i = interpret(this.getValue());\n      if (i !== false) {\n        var mismatch = false;\n        Common.each(Color.COMPONENTS, function (component) {\n          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {\n            mismatch = true;\n            return {};\n          }\n        }, this);\n        if (mismatch) {\n          Common.extend(this.__color.__state, i);\n        }\n      }\n      Common.extend(this.__temp.__state, this.__color.__state);\n      this.__temp.a = 1;\n      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;\n      var _flip = 255 - flip;\n      Common.extend(this.__field_knob.style, {\n        marginLeft: 100 * this.__color.s - 7 + 'px',\n        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n        backgroundColor: this.__temp.toHexString(),\n        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'\n      });\n      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';\n      this.__temp.s = 1;\n      this.__temp.v = 1;\n      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());\n      this.__input.value = this.__color.toString();\n      Common.extend(this.__input.style, {\n        backgroundColor: this.__color.toHexString(),\n        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',\n        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'\n      });\n    }\n  }]);\n  return ColorController;\n}(Controller);\nvar vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];\nfunction linearGradient(elem, x, a, b) {\n  elem.style.background = '';\n  Common.each(vendors, function (vendor) {\n    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';\n  });\n}\nfunction hueGradient(elem) {\n  elem.style.background = '';\n  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';\n  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n}\n\nvar css = {\n  load: function load(url, indoc) {\n    var doc = indoc || document;\n    var link = doc.createElement('link');\n    link.type = 'text/css';\n    link.rel = 'stylesheet';\n    link.href = url;\n    doc.getElementsByTagName('head')[0].appendChild(link);\n  },\n  inject: function inject(cssContent, indoc) {\n    var doc = indoc || document;\n    var injected = document.createElement('style');\n    injected.type = 'text/css';\n    injected.innerHTML = cssContent;\n    var head = doc.getElementsByTagName('head')[0];\n    try {\n      head.appendChild(injected);\n    } catch (e) {\n    }\n  }\n};\n\nvar saveDialogContents = \"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n\\n    </div>\\n\\n  </div>\\n\\n</div>\";\n\nvar ControllerFactory = function ControllerFactory(object, property) {\n  var initialValue = object[property];\n  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {\n    return new OptionController(object, property, arguments[2]);\n  }\n  if (Common.isNumber(initialValue)) {\n    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {\n      if (Common.isNumber(arguments[4])) {\n        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);\n      }\n      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n    }\n    if (Common.isNumber(arguments[4])) {\n      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });\n    }\n    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n  }\n  if (Common.isString(initialValue)) {\n    return new StringController(object, property);\n  }\n  if (Common.isFunction(initialValue)) {\n    return new FunctionController(object, property, '');\n  }\n  if (Common.isBoolean(initialValue)) {\n    return new BooleanController(object, property);\n  }\n  return null;\n};\n\nfunction requestAnimationFrame(callback) {\n  setTimeout(callback, 1000 / 60);\n}\nvar requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;\n\nvar CenteredDiv = function () {\n  function CenteredDiv() {\n    classCallCheck(this, CenteredDiv);\n    this.backgroundElement = document.createElement('div');\n    Common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear',\n      transition: 'opacity 0.2s linear'\n    });\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n    this.domElement = document.createElement('div');\n    Common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',\n      transition: 'transform 0.2s ease-out, opacity 0.2s linear'\n    });\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function () {\n      _this.hide();\n    });\n  }\n  createClass(CenteredDiv, [{\n    key: 'show',\n    value: function show() {\n      var _this = this;\n      this.backgroundElement.style.display = 'block';\n      this.domElement.style.display = 'block';\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n      this.layout();\n      Common.defer(function () {\n        _this.backgroundElement.style.opacity = 1;\n        _this.domElement.style.opacity = 1;\n        _this.domElement.style.webkitTransform = 'scale(1)';\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      var _this = this;\n      var hide = function hide() {\n        _this.domElement.style.display = 'none';\n        _this.backgroundElement.style.display = 'none';\n        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n        dom.unbind(_this.domElement, 'transitionend', hide);\n        dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n      };\n      dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n      dom.bind(this.domElement, 'transitionend', hide);\n      dom.bind(this.domElement, 'oTransitionEnd', hide);\n      this.backgroundElement.style.opacity = 0;\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n    }\n  }, {\n    key: 'layout',\n    value: function layout() {\n      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';\n      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';\n    }\n  }]);\n  return CenteredDiv;\n}();\n\nvar styleSheet = ___$insertStyle(\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\");\n\ncss.inject(styleSheet);\nvar CSS_NAMESPACE = 'dg';\nvar HIDE_KEY_CODE = 72;\nvar CLOSE_BUTTON_HEIGHT = 20;\nvar DEFAULT_DEFAULT_PRESET_NAME = 'Default';\nvar SUPPORTS_LOCAL_STORAGE = function () {\n  try {\n    return !!window.localStorage;\n  } catch (e) {\n    return false;\n  }\n}();\nvar SAVE_DIALOGUE = void 0;\nvar autoPlaceVirgin = true;\nvar autoPlaceContainer = void 0;\nvar hide = false;\nvar hideableGuis = [];\nvar GUI = function GUI(pars) {\n  var _this = this;\n  var params = pars || {};\n  this.domElement = document.createElement('div');\n  this.__ul = document.createElement('ul');\n  this.domElement.appendChild(this.__ul);\n  dom.addClass(this.domElement, CSS_NAMESPACE);\n  this.__folders = {};\n  this.__controllers = [];\n  this.__rememberedObjects = [];\n  this.__rememberedObjectIndecesToControllers = [];\n  this.__listening = [];\n  params = Common.defaults(params, {\n    closeOnTop: false,\n    autoPlace: true,\n    width: GUI.DEFAULT_WIDTH\n  });\n  params = Common.defaults(params, {\n    resizable: params.autoPlace,\n    hideable: params.autoPlace\n  });\n  if (!Common.isUndefined(params.load)) {\n    if (params.preset) {\n      params.load.preset = params.preset;\n    }\n  } else {\n    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n  }\n  if (Common.isUndefined(params.parent) && params.hideable) {\n    hideableGuis.push(this);\n  }\n  params.resizable = Common.isUndefined(params.parent) && params.resizable;\n  if (params.autoPlace && Common.isUndefined(params.scrollable)) {\n    params.scrollable = true;\n  }\n  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n  var saveToLocalStorage = void 0;\n  var titleRow = void 0;\n  Object.defineProperties(this,\n  {\n    parent: {\n      get: function get$$1() {\n        return params.parent;\n      }\n    },\n    scrollable: {\n      get: function get$$1() {\n        return params.scrollable;\n      }\n    },\n    autoPlace: {\n      get: function get$$1() {\n        return params.autoPlace;\n      }\n    },\n    closeOnTop: {\n      get: function get$$1() {\n        return params.closeOnTop;\n      }\n    },\n    preset: {\n      get: function get$$1() {\n        if (_this.parent) {\n          return _this.getRoot().preset;\n        }\n        return params.load.preset;\n      },\n      set: function set$$1(v) {\n        if (_this.parent) {\n          _this.getRoot().preset = v;\n        } else {\n          params.load.preset = v;\n        }\n        setPresetSelectIndex(this);\n        _this.revert();\n      }\n    },\n    width: {\n      get: function get$$1() {\n        return params.width;\n      },\n      set: function set$$1(v) {\n        params.width = v;\n        setWidth(_this, v);\n      }\n    },\n    name: {\n      get: function get$$1() {\n        return params.name;\n      },\n      set: function set$$1(v) {\n        params.name = v;\n        if (titleRow) {\n          titleRow.innerHTML = params.name;\n        }\n      }\n    },\n    closed: {\n      get: function get$$1() {\n        return params.closed;\n      },\n      set: function set$$1(v) {\n        params.closed = v;\n        if (params.closed) {\n          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n        } else {\n          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n        }\n        this.onResize();\n        if (_this.__closeButton) {\n          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n        }\n      }\n    },\n    load: {\n      get: function get$$1() {\n        return params.load;\n      }\n    },\n    useLocalStorage: {\n      get: function get$$1() {\n        return useLocalStorage;\n      },\n      set: function set$$1(bool) {\n        if (SUPPORTS_LOCAL_STORAGE) {\n          useLocalStorage = bool;\n          if (bool) {\n            dom.bind(window, 'unload', saveToLocalStorage);\n          } else {\n            dom.unbind(window, 'unload', saveToLocalStorage);\n          }\n          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n        }\n      }\n    }\n  });\n  if (Common.isUndefined(params.parent)) {\n    this.closed = params.closed || false;\n    dom.addClass(this.domElement, GUI.CLASS_MAIN);\n    dom.makeSelectable(this.domElement, false);\n    if (SUPPORTS_LOCAL_STORAGE) {\n      if (useLocalStorage) {\n        _this.useLocalStorage = true;\n        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n        if (savedGui) {\n          params.load = JSON.parse(savedGui);\n        }\n      }\n    }\n    this.__closeButton = document.createElement('div');\n    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n    if (params.closeOnTop) {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);\n      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);\n    } else {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);\n      this.domElement.appendChild(this.__closeButton);\n    }\n    dom.bind(this.__closeButton, 'click', function () {\n      _this.closed = !_this.closed;\n    });\n  } else {\n    if (params.closed === undefined) {\n      params.closed = true;\n    }\n    var titleRowName = document.createTextNode(params.name);\n    dom.addClass(titleRowName, 'controller-name');\n    titleRow = addRow(_this, titleRowName);\n    var onClickTitle = function onClickTitle(e) {\n      e.preventDefault();\n      _this.closed = !_this.closed;\n      return false;\n    };\n    dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n    dom.addClass(titleRow, 'title');\n    dom.bind(titleRow, 'click', onClickTitle);\n    if (!params.closed) {\n      this.closed = false;\n    }\n  }\n  if (params.autoPlace) {\n    if (Common.isUndefined(params.parent)) {\n      if (autoPlaceVirgin) {\n        autoPlaceContainer = document.createElement('div');\n        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);\n        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);\n        document.body.appendChild(autoPlaceContainer);\n        autoPlaceVirgin = false;\n      }\n      autoPlaceContainer.appendChild(this.domElement);\n      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n    }\n    if (!this.parent) {\n      setWidth(_this, params.width);\n    }\n  }\n  this.__resizeHandler = function () {\n    _this.onResizeDebounced();\n  };\n  dom.bind(window, 'resize', this.__resizeHandler);\n  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);\n  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);\n  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);\n  this.onResize();\n  if (params.resizable) {\n    addResizeHandle(this);\n  }\n  saveToLocalStorage = function saveToLocalStorage() {\n    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n  };\n  this.saveToLocalStorageIfPossible = saveToLocalStorage;\n  function resetWidth() {\n    var root = _this.getRoot();\n    root.width += 1;\n    Common.defer(function () {\n      root.width -= 1;\n    });\n  }\n  if (!params.parent) {\n    resetWidth();\n  }\n};\nGUI.toggleHide = function () {\n  hide = !hide;\n  Common.each(hideableGuis, function (gui) {\n    gui.domElement.style.display = hide ? 'none' : '';\n  });\n};\nGUI.CLASS_AUTO_PLACE = 'a';\nGUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\nGUI.CLASS_MAIN = 'main';\nGUI.CLASS_CONTROLLER_ROW = 'cr';\nGUI.CLASS_TOO_TALL = 'taller-than-window';\nGUI.CLASS_CLOSED = 'closed';\nGUI.CLASS_CLOSE_BUTTON = 'close-button';\nGUI.CLASS_CLOSE_TOP = 'close-top';\nGUI.CLASS_CLOSE_BOTTOM = 'close-bottom';\nGUI.CLASS_DRAG = 'drag';\nGUI.DEFAULT_WIDTH = 245;\nGUI.TEXT_CLOSED = 'Close Controls';\nGUI.TEXT_OPEN = 'Open Controls';\nGUI._keydownHandler = function (e) {\n  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {\n    GUI.toggleHide();\n  }\n};\ndom.bind(window, 'keydown', GUI._keydownHandler, false);\nCommon.extend(GUI.prototype,\n{\n  add: function add(object, property) {\n    return _add(this, object, property, {\n      factoryArgs: Array.prototype.slice.call(arguments, 2)\n    });\n  },\n  addColor: function addColor(object, property) {\n    return _add(this, object, property, {\n      color: true\n    });\n  },\n  remove: function remove(controller) {\n    this.__ul.removeChild(controller.__li);\n    this.__controllers.splice(this.__controllers.indexOf(controller), 1);\n    var _this = this;\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  destroy: function destroy() {\n    if (this.parent) {\n      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');\n    }\n    if (this.autoPlace) {\n      autoPlaceContainer.removeChild(this.domElement);\n    }\n    var _this = this;\n    Common.each(this.__folders, function (subfolder) {\n      _this.removeFolder(subfolder);\n    });\n    dom.unbind(window, 'keydown', GUI._keydownHandler, false);\n    removeListeners(this);\n  },\n  addFolder: function addFolder(name) {\n    if (this.__folders[name] !== undefined) {\n      throw new Error('You already have a folder in this GUI by the' + ' name \"' + name + '\"');\n    }\n    var newGuiParams = { name: name, parent: this };\n    newGuiParams.autoPlace = this.autoPlace;\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[name]) {\n      newGuiParams.closed = this.load.folders[name].closed;\n      newGuiParams.load = this.load.folders[name];\n    }\n    var gui = new GUI(newGuiParams);\n    this.__folders[name] = gui;\n    var li = addRow(this, gui.domElement);\n    dom.addClass(li, 'folder');\n    return gui;\n  },\n  removeFolder: function removeFolder(folder) {\n    this.__ul.removeChild(folder.domElement.parentElement);\n    delete this.__folders[folder.name];\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[folder.name]) {\n      delete this.load.folders[folder.name];\n    }\n    removeListeners(folder);\n    var _this = this;\n    Common.each(folder.__folders, function (subfolder) {\n      folder.removeFolder(subfolder);\n    });\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  open: function open() {\n    this.closed = false;\n  },\n  close: function close() {\n    this.closed = true;\n  },\n  hide: function hide() {\n    this.domElement.style.display = 'none';\n  },\n  show: function show() {\n    this.domElement.style.display = '';\n  },\n  onResize: function onResize() {\n    var root = this.getRoot();\n    if (root.scrollable) {\n      var top = dom.getOffset(root.__ul).top;\n      var h = 0;\n      Common.each(root.__ul.childNodes, function (node) {\n        if (!(root.autoPlace && node === root.__save_row)) {\n          h += dom.getHeight(node);\n        }\n      });\n      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n      } else {\n        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = 'auto';\n      }\n    }\n    if (root.__resize_handle) {\n      Common.defer(function () {\n        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n      });\n    }\n    if (root.__closeButton) {\n      root.__closeButton.style.width = root.width + 'px';\n    }\n  },\n  onResizeDebounced: Common.debounce(function () {\n    this.onResize();\n  }, 50),\n  remember: function remember() {\n    if (Common.isUndefined(SAVE_DIALOGUE)) {\n      SAVE_DIALOGUE = new CenteredDiv();\n      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;\n    }\n    if (this.parent) {\n      throw new Error('You can only call remember on a top level GUI.');\n    }\n    var _this = this;\n    Common.each(Array.prototype.slice.call(arguments), function (object) {\n      if (_this.__rememberedObjects.length === 0) {\n        addSaveMenu(_this);\n      }\n      if (_this.__rememberedObjects.indexOf(object) === -1) {\n        _this.__rememberedObjects.push(object);\n      }\n    });\n    if (this.autoPlace) {\n      setWidth(this, this.width);\n    }\n  },\n  getRoot: function getRoot() {\n    var gui = this;\n    while (gui.parent) {\n      gui = gui.parent;\n    }\n    return gui;\n  },\n  getSaveObject: function getSaveObject() {\n    var toReturn = this.load;\n    toReturn.closed = this.closed;\n    if (this.__rememberedObjects.length > 0) {\n      toReturn.preset = this.preset;\n      if (!toReturn.remembered) {\n        toReturn.remembered = {};\n      }\n      toReturn.remembered[this.preset] = getCurrentPreset(this);\n    }\n    toReturn.folders = {};\n    Common.each(this.__folders, function (element, key) {\n      toReturn.folders[key] = element.getSaveObject();\n    });\n    return toReturn;\n  },\n  save: function save() {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n    }\n    this.load.remembered[this.preset] = getCurrentPreset(this);\n    markPresetModified(this, false);\n    this.saveToLocalStorageIfPossible();\n  },\n  saveAs: function saveAs(presetName) {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n    }\n    this.load.remembered[presetName] = getCurrentPreset(this);\n    this.preset = presetName;\n    addPresetOption(this, presetName, true);\n    this.saveToLocalStorageIfPossible();\n  },\n  revert: function revert(gui) {\n    Common.each(this.__controllers, function (controller) {\n      if (!this.getRoot().load.remembered) {\n        controller.setValue(controller.initialValue);\n      } else {\n        recallSavedValue(gui || this.getRoot(), controller);\n      }\n      if (controller.__onFinishChange) {\n        controller.__onFinishChange.call(controller, controller.getValue());\n      }\n    }, this);\n    Common.each(this.__folders, function (folder) {\n      folder.revert(folder);\n    });\n    if (!gui) {\n      markPresetModified(this.getRoot(), false);\n    }\n  },\n  listen: function listen(controller) {\n    var init = this.__listening.length === 0;\n    this.__listening.push(controller);\n    if (init) {\n      updateDisplays(this.__listening);\n    }\n  },\n  updateDisplay: function updateDisplay() {\n    Common.each(this.__controllers, function (controller) {\n      controller.updateDisplay();\n    });\n    Common.each(this.__folders, function (folder) {\n      folder.updateDisplay();\n    });\n  }\n});\nfunction addRow(gui, newDom, liBefore) {\n  var li = document.createElement('li');\n  if (newDom) {\n    li.appendChild(newDom);\n  }\n  if (liBefore) {\n    gui.__ul.insertBefore(li, liBefore);\n  } else {\n    gui.__ul.appendChild(li);\n  }\n  gui.onResize();\n  return li;\n}\nfunction removeListeners(gui) {\n  dom.unbind(window, 'resize', gui.__resizeHandler);\n  if (gui.saveToLocalStorageIfPossible) {\n    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);\n  }\n}\nfunction markPresetModified(gui, modified) {\n  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n  if (modified) {\n    opt.innerHTML = opt.value + '*';\n  } else {\n    opt.innerHTML = opt.value;\n  }\n}\nfunction augmentController(gui, li, controller) {\n  controller.__li = li;\n  controller.__gui = gui;\n  Common.extend(controller, {\n    options: function options(_options) {\n      if (arguments.length > 1) {\n        var nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: nextSibling,\n          factoryArgs: [Common.toArray(arguments)]\n        });\n      }\n      if (Common.isArray(_options) || Common.isObject(_options)) {\n        var _nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: _nextSibling,\n          factoryArgs: [_options]\n        });\n      }\n    },\n    name: function name(_name) {\n      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;\n      return controller;\n    },\n    listen: function listen() {\n      controller.__gui.listen(controller);\n      return controller;\n    },\n    remove: function remove() {\n      controller.__gui.remove(controller);\n      return controller;\n    }\n  });\n  if (controller instanceof NumberControllerSlider) {\n    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });\n    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {\n      var pc = controller[method];\n      var pb = box[method];\n      controller[method] = box[method] = function () {\n        var args = Array.prototype.slice.call(arguments);\n        pb.apply(box, args);\n        return pc.apply(controller, args);\n      };\n    });\n    dom.addClass(li, 'has-slider');\n    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n  } else if (controller instanceof NumberControllerBox) {\n    var r = function r(returned) {\n      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {\n        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;\n        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;\n        controller.remove();\n        var newController = _add(gui, controller.object, controller.property, {\n          before: controller.__li.nextElementSibling,\n          factoryArgs: [controller.__min, controller.__max, controller.__step]\n        });\n        newController.name(oldName);\n        if (wasListening) newController.listen();\n        return newController;\n      }\n      return returned;\n    };\n    controller.min = Common.compose(r, controller.min);\n    controller.max = Common.compose(r, controller.max);\n  } else if (controller instanceof BooleanController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__checkbox, 'click');\n    });\n    dom.bind(controller.__checkbox, 'click', function (e) {\n      e.stopPropagation();\n    });\n  } else if (controller instanceof FunctionController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__button, 'click');\n    });\n    dom.bind(li, 'mouseover', function () {\n      dom.addClass(controller.__button, 'hover');\n    });\n    dom.bind(li, 'mouseout', function () {\n      dom.removeClass(controller.__button, 'hover');\n    });\n  } else if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n    controller.updateDisplay = Common.compose(function (val) {\n      li.style.borderLeftColor = controller.__color.toString();\n      return val;\n    }, controller.updateDisplay);\n    controller.updateDisplay();\n  }\n  controller.setValue = Common.compose(function (val) {\n    if (gui.getRoot().__preset_select && controller.isModified()) {\n      markPresetModified(gui.getRoot(), true);\n    }\n    return val;\n  }, controller.setValue);\n}\nfunction recallSavedValue(gui, controller) {\n  var root = gui.getRoot();\n  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);\n  if (matchedIndex !== -1) {\n    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];\n    if (controllerMap === undefined) {\n      controllerMap = {};\n      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;\n    }\n    controllerMap[controller.property] = controller;\n    if (root.load && root.load.remembered) {\n      var presetMap = root.load.remembered;\n      var preset = void 0;\n      if (presetMap[gui.preset]) {\n        preset = presetMap[gui.preset];\n      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {\n        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];\n      } else {\n        return;\n      }\n      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {\n        var value = preset[matchedIndex][controller.property];\n        controller.initialValue = value;\n        controller.setValue(value);\n      }\n    }\n  }\n}\nfunction _add(gui, object, property, params) {\n  if (object[property] === undefined) {\n    throw new Error('Object \"' + object + '\" has no property \"' + property + '\"');\n  }\n  var controller = void 0;\n  if (params.color) {\n    controller = new ColorController(object, property);\n  } else {\n    var factoryArgs = [object, property].concat(params.factoryArgs);\n    controller = ControllerFactory.apply(gui, factoryArgs);\n  }\n  if (params.before instanceof Controller) {\n    params.before = params.before.__li;\n  }\n  recallSavedValue(gui, controller);\n  dom.addClass(controller.domElement, 'c');\n  var name = document.createElement('span');\n  dom.addClass(name, 'property-name');\n  name.innerHTML = controller.property;\n  var container = document.createElement('div');\n  container.appendChild(name);\n  container.appendChild(controller.domElement);\n  var li = addRow(gui, container, params.before);\n  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n  if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n  } else {\n    dom.addClass(li, _typeof(controller.getValue()));\n  }\n  augmentController(gui, li, controller);\n  gui.__controllers.push(controller);\n  return controller;\n}\nfunction getLocalStorageHash(gui, key) {\n  return document.location.href + '.' + key;\n}\nfunction addPresetOption(gui, name, setSelected) {\n  var opt = document.createElement('option');\n  opt.innerHTML = name;\n  opt.value = name;\n  gui.__preset_select.appendChild(opt);\n  if (setSelected) {\n    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n  }\n}\nfunction showHideExplain(gui, explain) {\n  explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n}\nfunction addSaveMenu(gui) {\n  var div = gui.__save_row = document.createElement('li');\n  dom.addClass(gui.domElement, 'has-save');\n  gui.__ul.insertBefore(div, gui.__ul.firstChild);\n  dom.addClass(div, 'save-row');\n  var gears = document.createElement('span');\n  gears.innerHTML = '&nbsp;';\n  dom.addClass(gears, 'button gears');\n  var button = document.createElement('span');\n  button.innerHTML = 'Save';\n  dom.addClass(button, 'button');\n  dom.addClass(button, 'save');\n  var button2 = document.createElement('span');\n  button2.innerHTML = 'New';\n  dom.addClass(button2, 'button');\n  dom.addClass(button2, 'save-as');\n  var button3 = document.createElement('span');\n  button3.innerHTML = 'Revert';\n  dom.addClass(button3, 'button');\n  dom.addClass(button3, 'revert');\n  var select = gui.__preset_select = document.createElement('select');\n  if (gui.load && gui.load.remembered) {\n    Common.each(gui.load.remembered, function (value, key) {\n      addPresetOption(gui, key, key === gui.preset);\n    });\n  } else {\n    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n  }\n  dom.bind(select, 'change', function () {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n    }\n    gui.preset = this.value;\n  });\n  div.appendChild(select);\n  div.appendChild(gears);\n  div.appendChild(button);\n  div.appendChild(button2);\n  div.appendChild(button3);\n  if (SUPPORTS_LOCAL_STORAGE) {\n    var explain = document.getElementById('dg-local-explain');\n    var localStorageCheckBox = document.getElementById('dg-local-storage');\n    var saveLocally = document.getElementById('dg-save-locally');\n    saveLocally.style.display = 'block';\n    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n      localStorageCheckBox.setAttribute('checked', 'checked');\n    }\n    showHideExplain(gui, explain);\n    dom.bind(localStorageCheckBox, 'change', function () {\n      gui.useLocalStorage = !gui.useLocalStorage;\n      showHideExplain(gui, explain);\n    });\n  }\n  var newConstructorTextArea = document.getElementById('dg-new-constructor');\n  dom.bind(newConstructorTextArea, 'keydown', function (e) {\n    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {\n      SAVE_DIALOGUE.hide();\n    }\n  });\n  dom.bind(gears, 'click', function () {\n    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n    SAVE_DIALOGUE.show();\n    newConstructorTextArea.focus();\n    newConstructorTextArea.select();\n  });\n  dom.bind(button, 'click', function () {\n    gui.save();\n  });\n  dom.bind(button2, 'click', function () {\n    var presetName = prompt('Enter a new preset name.');\n    if (presetName) {\n      gui.saveAs(presetName);\n    }\n  });\n  dom.bind(button3, 'click', function () {\n    gui.revert();\n  });\n}\nfunction addResizeHandle(gui) {\n  var pmouseX = void 0;\n  gui.__resize_handle = document.createElement('div');\n  Common.extend(gui.__resize_handle.style, {\n    width: '6px',\n    marginLeft: '-3px',\n    height: '200px',\n    cursor: 'ew-resize',\n    position: 'absolute'\n  });\n  function drag(e) {\n    e.preventDefault();\n    gui.width += pmouseX - e.clientX;\n    gui.onResize();\n    pmouseX = e.clientX;\n    return false;\n  }\n  function dragStop() {\n    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.unbind(window, 'mousemove', drag);\n    dom.unbind(window, 'mouseup', dragStop);\n  }\n  function dragStart(e) {\n    e.preventDefault();\n    pmouseX = e.clientX;\n    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.bind(window, 'mousemove', drag);\n    dom.bind(window, 'mouseup', dragStop);\n    return false;\n  }\n  dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n  dom.bind(gui.__closeButton, 'mousedown', dragStart);\n  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n}\nfunction setWidth(gui, w) {\n  gui.domElement.style.width = w + 'px';\n  if (gui.__save_row && gui.autoPlace) {\n    gui.__save_row.style.width = w + 'px';\n  }\n  if (gui.__closeButton) {\n    gui.__closeButton.style.width = w + 'px';\n  }\n}\nfunction getCurrentPreset(gui, useInitialValues) {\n  var toReturn = {};\n  Common.each(gui.__rememberedObjects, function (val, index) {\n    var savedValues = {};\n    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];\n    Common.each(controllerMap, function (controller, property) {\n      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();\n    });\n    toReturn[index] = savedValues;\n  });\n  return toReturn;\n}\nfunction setPresetSelectIndex(gui) {\n  for (var index = 0; index < gui.__preset_select.length; index++) {\n    if (gui.__preset_select[index].value === gui.preset) {\n      gui.__preset_select.selectedIndex = index;\n    }\n  }\n}\nfunction updateDisplays(controllerArray) {\n  if (controllerArray.length !== 0) {\n    requestAnimationFrame$1.call(window, function () {\n      updateDisplays(controllerArray);\n    });\n  }\n  Common.each(controllerArray, function (c) {\n    c.updateDisplay();\n  });\n}\n\nvar color = {\n  Color: Color,\n  math: ColorMath,\n  interpret: interpret\n};\nvar controllers = {\n  Controller: Controller,\n  BooleanController: BooleanController,\n  OptionController: OptionController,\n  StringController: StringController,\n  NumberController: NumberController,\n  NumberControllerBox: NumberControllerBox,\n  NumberControllerSlider: NumberControllerSlider,\n  FunctionController: FunctionController,\n  ColorController: ColorController\n};\nvar dom$1 = { dom: dom };\nvar gui = { GUI: GUI };\nvar GUI$1 = GUI;\nvar index = {\n  color: color,\n  controllers: controllers,\n  dom: dom$1,\n  gui: gui,\n  GUI: GUI$1\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceMappingURL=dat.gui.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLm1vZHVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lLXNhbmRib3gvLi9ub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLm1vZHVsZS5qcz84OTkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RhdGFhcnRzL2RhdC5ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBfX18kaW5zZXJ0U3R5bGUoY3NzKSB7XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgcmV0dXJuIGNzcztcbn1cblxuZnVuY3Rpb24gY29sb3JUb1N0cmluZyAoY29sb3IsIGZvcmNlQ1NTSGV4KSB7XG4gIHZhciBjb2xvckZvcm1hdCA9IGNvbG9yLl9fc3RhdGUuY29udmVyc2lvbk5hbWUudG9TdHJpbmcoKTtcbiAgdmFyIHIgPSBNYXRoLnJvdW5kKGNvbG9yLnIpO1xuICB2YXIgZyA9IE1hdGgucm91bmQoY29sb3IuZyk7XG4gIHZhciBiID0gTWF0aC5yb3VuZChjb2xvci5iKTtcbiAgdmFyIGEgPSBjb2xvci5hO1xuICB2YXIgaCA9IE1hdGgucm91bmQoY29sb3IuaCk7XG4gIHZhciBzID0gY29sb3Iucy50b0ZpeGVkKDEpO1xuICB2YXIgdiA9IGNvbG9yLnYudG9GaXhlZCgxKTtcbiAgaWYgKGZvcmNlQ1NTSGV4IHx8IGNvbG9yRm9ybWF0ID09PSAnVEhSRUVfQ0hBUl9IRVgnIHx8IGNvbG9yRm9ybWF0ID09PSAnU0lYX0NIQVJfSEVYJykge1xuICAgIHZhciBzdHIgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNikge1xuICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gJyMnICsgc3RyO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQicpIHtcbiAgICByZXR1cm4gJ3JnYignICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQkEnKSB7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSEVYJykge1xuICAgIHJldHVybiAnMHgnICsgY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICddJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfT0JKJykge1xuICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZBX09CSicpIHtcbiAgICByZXR1cm4gJ3toOicgKyBoICsgJyxzOicgKyBzICsgJyx2OicgKyB2ICsgJyxhOicgKyBhICsgJ30nO1xuICB9XG4gIHJldHVybiAndW5rbm93biBmb3JtYXQnO1xufVxuXG52YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgQ29tbW9uID0ge1xuICBCUkVBSzoge30sXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcbiAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLmlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGNvbXBvc2U6IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ciwgc2NvcGUpIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7XG4gICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7XG4gICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgdmFyIGwgPSB2b2lkIDA7XG4gICAgICBmb3IgKGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKykge1xuICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpbX2tleV0sIF9rZXkpID09PSB0aGlzLkJSRUFLKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoZm5jKSB7XG4gICAgc2V0VGltZW91dChmbmMsIDApO1xuICB9LFxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgdGhyZXNob2xkLCBjYWxsSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWNhbGxJbW1lZGlhdGVseSkgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbGxOb3cgPSBjYWxsSW1tZWRpYXRlbHkgfHwgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgfSxcbiAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbiBpc051bGwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOYU46IGZ1bmN0aW9uIChfaXNOYU4pIHtcbiAgICBmdW5jdGlvbiBpc05hTihfeCkge1xuICAgICAgcmV0dXJuIF9pc05hTi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpc05hTi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaXNOYU4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBpc05hTjtcbiAgfShmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIGlzTmFOKG9iaik7XG4gIH0pLFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9LFxuICBpc051bWJlcjogZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgMDtcbiAgfSxcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG9iaiArICcnO1xuICB9LFxuICBpc0Jvb2xlYW46IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gIH0sXG4gIGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9XG59O1xuXG52YXIgSU5URVJQUkVUQVRJT05TID0gW1xue1xuICBsaXRtdXM6IENvbW1vbi5pc1N0cmluZyxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBUSFJFRV9DSEFSX0hFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgU0lYX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccypcXCkvKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQkE6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzTnVtYmVyLFxuICBjb252ZXJzaW9uczoge1xuICAgIEhFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNBcnJheSxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JfQVJSQVk6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgUkdCQV9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc09iamVjdCxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWQV9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dO1xudmFyIHJlc3VsdCA9IHZvaWQgMDtcbnZhciB0b1JldHVybiA9IHZvaWQgMDtcbnZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQoKSB7XG4gIHRvUmV0dXJuID0gZmFsc2U7XG4gIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gQ29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcbiAgQ29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG4gICAgICBDb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uIChjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn07XG5cbnZhciB0bXBDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgQ29sb3JNYXRoID0ge1xuICBoc3ZfdG9fcmdiOiBmdW5jdGlvbiBoc3ZfdG9fcmdiKGgsIHMsIHYpIHtcbiAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICB2YXIgcSA9IHYgKiAoMS4wIC0gZiAqIHMpO1xuICAgIHZhciB0ID0gdiAqICgxLjAgLSAoMS4wIC0gZikgKiBzKTtcbiAgICB2YXIgYyA9IFtbdiwgdCwgcF0sIFtxLCB2LCBwXSwgW3AsIHYsIHRdLCBbcCwgcSwgdl0sIFt0LCBwLCB2XSwgW3YsIHAsIHFdXVtoaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgYjogY1syXSAqIDI1NVxuICAgIH07XG4gIH0sXG4gIHJnYl90b19oc3Y6IGZ1bmN0aW9uIHJnYl90b19oc3YociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgIHZhciBoID0gdm9pZCAwO1xuICAgIHZhciBzID0gdm9pZCAwO1xuICAgIGlmIChtYXggIT09IDApIHtcbiAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogTmFOLFxuICAgICAgICBzOiAwLFxuICAgICAgICB2OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAociA9PT0gbWF4KSB7XG4gICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IGggKiAzNjAsXG4gICAgICBzOiBzLFxuICAgICAgdjogbWF4IC8gMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hleDogZnVuY3Rpb24gcmdiX3RvX2hleChyLCBnLCBiKSB7XG4gICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICByZXR1cm4gaGV4O1xuICB9LFxuICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uIGNvbXBvbmVudF9mcm9tX2hleChoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgcmV0dXJuIGhleCA+PiBjb21wb25lbnRJbmRleCAqIDggJiAweEZGO1xuICB9LFxuICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uIGhleF93aXRoX2NvbXBvbmVudChoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IGhleCAmIH4oMHhGRiA8PCB0bXBDb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbG9yLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0hleFN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGNvbG9yVG9TdHJpbmcodGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9PcmlnaW5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3JpZ2luYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvcjtcbn0oKTtcbmZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgfVxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG4gICAgfVxuICB9KTtcbn1cbkNvbG9yLnJlY2FsY3VsYXRlUkdCID0gZnVuY3Rpb24gKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG4gIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IENvbG9yTWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgQ29sb3JNYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29ycnVwdGVkIGNvbG9yIHN0YXRlJyk7XG4gIH1cbn07XG5Db2xvci5yZWNhbGN1bGF0ZUhTViA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgcmVzdWx0ID0gQ29sb3JNYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwge1xuICAgIHM6IHJlc3VsdC5zLFxuICAgIHY6IHJlc3VsdC52XG4gIH0pO1xuICBpZiAoIUNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgfSBlbHNlIGlmIChDb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gIH1cbn07XG5Db2xvci5DT01QT05FTlRTID0gWydyJywgJ2cnLCAnYicsICdoJywgJ3MnLCAndicsICdoZXgnLCAnYSddO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IENvbG9yTWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG4gIH1cbn0pO1xuXG52YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbGxlcik7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnb25DaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRmluaXNoQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GaW5pc2hDaGFuZ2UoZm5jKSB7XG4gICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc01vZGlmaWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNb2RpZmllZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29udHJvbGxlcjtcbn0oKTtcblxudmFyIEVWRU5UX01BUCA9IHtcbiAgSFRNTEV2ZW50czogWydjaGFuZ2UnXSxcbiAgTW91c2VFdmVudHM6IFsnY2xpY2snLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICBLZXlib2FyZEV2ZW50czogWydrZXlkb3duJ11cbn07XG52YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuQ29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbiAodiwgaykge1xuICBDb21tb24uZWFjaCh2LCBmdW5jdGlvbiAoZSkge1xuICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICB9KTtcbn0pO1xudmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcbmZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG4gIGlmICh2YWwgPT09ICcwJyB8fCBDb21tb24uaXNVbmRlZmluZWQodmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcbiAgaWYgKCFDb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBkb20gPSB7XG4gIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbiBtYWtlU2VsZWN0YWJsZShlbGVtLCBzZWxlY3RhYmxlKSB7XG4gICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG4gIH0sXG4gIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbiBtYWtlRnVsbHNjcmVlbihlbGVtLCBob3IsIHZlcnQpIHtcbiAgICB2YXIgdmVydGljYWwgPSB2ZXJ0O1xuICAgIHZhciBob3Jpem9udGFsID0gaG9yO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIHtcbiAgICAgIGhvcml6b250YWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkge1xuICAgICAgdmVydGljYWwgPSB0cnVlO1xuICAgIH1cbiAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICB9XG4gIH0sXG4gIGZha2VFdmVudDogZnVuY3Rpb24gZmFrZUV2ZW50KGVsZW0sIGV2ZW50VHlwZSwgcGFycywgYXV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG4gICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50O1xuICAgICAgICAgIENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LCBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LCBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSxcbiAgYmluZDogZnVuY3Rpb24gYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uIGdldFdpZHRoKGVsZW0pIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLndpZHRoKTtcbiAgfSxcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUuaGVpZ2h0KTtcbiAgfSxcbiAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgICB2YXIgZWxlbSA9IGVsO1xuICAgIHZhciBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgZG8ge1xuICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudDtcbiAgICAgIH0gd2hpbGUgKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9LFxuICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIChlbGVtLnR5cGUgfHwgZWxlbS5ocmVmKTtcbiAgfVxufTtcblxudmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEJvb2xlYW5Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvb2xlYW5Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fcHJldiA9IF90aGlzMi5nZXRWYWx1ZSgpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cbiAgICBkb20uYmluZChfdGhpczIuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fY2hlY2tib3gpO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhCb29sZWFuQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciB0b1JldHVybiA9IGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoT3B0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIG9wdHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3B0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGlmIChDb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG4gICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhPcHRpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKGRvbS5pc0FjdGl2ZSh0aGlzLl9fc2VsZWN0KSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKFN0cmluZ0NvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmluZ0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhTdHJpbmdDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICB2YXIgX3ggPSB4LnRvU3RyaW5nKCk7XG4gIGlmIChfeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIHJldHVybiBfeC5sZW5ndGggLSBfeC5pbmRleE9mKCcuJykgLSAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF9wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgX3RoaXMuX19taW4gPSBfcGFyYW1zLm1pbjtcbiAgICBfdGhpcy5fX21heCA9IF9wYXJhbXMubWF4O1xuICAgIF90aGlzLl9fc3RlcCA9IF9wYXJhbXMuc3RlcDtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKF90aGlzLl9fc3RlcCkpIHtcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsVmFsdWUgPT09IDApIHtcbiAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoX3RoaXMuaW5pdGlhbFZhbHVlKSkgLyBNYXRoLkxOMTApKSAvIDEwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gX3RoaXMuX19zdGVwO1xuICAgIH1cbiAgICBfdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIF92ID0gdjtcbiAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgX3YgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21pbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIF92ID4gdGhpcy5fX21heCkge1xuICAgICAgICBfdiA9IHRoaXMuX19tYXg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiBfdiAlIHRoaXMuX19zdGVwICE9PSAwKSB7XG4gICAgICAgIF92ID0gTWF0aC5yb3VuZChfdiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBfdik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKG1pblZhbHVlKSB7XG4gICAgICB0aGlzLl9fbWluID0gbWluVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgobWF4VmFsdWUpIHtcbiAgICAgIHRoaXMuX19tYXggPSBtYXhWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0ZXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwKHN0ZXBWYWx1ZSkge1xuICAgICAgdGhpcy5fX3N0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoc3RlcFZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlckJveCwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJCb3gpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveCkpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSk7XG4gICAgX3RoaXMyLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICB2YXIgcHJldlkgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghQ29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIHtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICB2YXIgZGlmZiA9IHByZXZZIC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyQm94LCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcbn0oTnVtYmVyQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJTbGlkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChlLmNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICAgIG9uVG91Y2hNb3ZlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChjbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKF90aGlzMi5fX2ZvcmVncm91bmQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2JhY2tncm91bmQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikgLyAodGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QgKiAxMDAgKyAnJSc7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xufShOdW1iZXJDb250cm9sbGVyKTtcblxudmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhGdW5jdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGdW5jdGlvbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19idXR0b24sICdidXR0b24nKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19idXR0b24pO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2ZpcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQ29sb3JDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29sb3JDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgX3RoaXMyLl9fY29sb3IgPSBuZXcgQ29sb3IoX3RoaXMyLmdldFZhbHVlKCkpO1xuICAgIF90aGlzMi5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKF90aGlzMi5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG4gICAgX3RoaXMyLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHZhbHVlRmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX3NlbGVjdG9yLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEyMnB4JyxcbiAgICAgIGhlaWdodDogJzEwMnB4JyxcbiAgICAgIHBhZGRpbmc6ICczcHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTJweCcsXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICAgIGJvcmRlcjogX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgKyAoX3RoaXMyLl9fY29sb3IudiA8IDAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgI2ZmZicsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQodmFsdWVGaWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgfSk7XG4gICAgbGluZWFyR3JhZGllbnQodmFsdWVGaWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2h1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogJzNweCcsXG4gICAgICByaWdodDogJzNweCdcbiAgICB9KTtcbiAgICBodWVHcmFkaWVudChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgdGV4dFNoYWRvdzogX3RoaXMyLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKDAsMCwwLDAuNyknXG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2ZpZWxkX2tub2IsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2ZpZWxkX2tub2IsICd0b3VjaHN0YXJ0JywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19odWVfZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd25IKTtcbiAgICBkb20uYmluZChfdGhpczIuX19odWVfZmllbGQsICd0b3VjaHN0YXJ0JywgZmllbGREb3duSCk7XG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcbiAgICAgIHNldFNWKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBTVik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkRG93bkgoZSkge1xuICAgICAgc2V0SChlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwSCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBTVigpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwU1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBTVik7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZFVwSCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9fY29sb3IuX19zdGF0ZSA9IGk7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmluaXNoKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVGaWVsZCk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZmllbGRfa25vYik7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcbiAgICBfdGhpczIuX19odWVfZmllbGQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faHVlX2tub2IpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19zZWxlY3Rvcik7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBmdW5jdGlvbiBzZXRTVihlKSB7XG4gICAgICBpZiAoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IC0xKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZFJlY3QgPSBfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgX3JlZiA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXNbMF0gfHwgZSxcbiAgICAgICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG4gICAgICB2YXIgcyA9IChjbGllbnRYIC0gZmllbGRSZWN0LmxlZnQpIC8gKGZpZWxkUmVjdC5yaWdodCAtIGZpZWxkUmVjdC5sZWZ0KTtcbiAgICAgIHZhciB2ID0gMSAtIChjbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuICAgICAgaWYgKHYgPiAxKSB7XG4gICAgICAgIHYgPSAxO1xuICAgICAgfSBlbHNlIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzID4gMSkge1xuICAgICAgICBzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocyA8IDApIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9XG4gICAgICBfdGhpcy5fX2NvbG9yLnYgPSB2O1xuICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XG4gICAgICBpZiAoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IC0xKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZFJlY3QgPSBfdGhpcy5fX2h1ZV9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmMiA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXNbMF0gfHwgZSxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjIuY2xpZW50WTtcbiAgICAgIHZhciBoID0gMSAtIChjbGllbnRZIC0gZmllbGRSZWN0LnRvcCkgLyAoZmllbGRSZWN0LmJvdHRvbSAtIGZpZWxkUmVjdC50b3ApO1xuICAgICAgaWYgKGggPiAxKSB7XG4gICAgICAgIGggPSAxO1xuICAgICAgfSBlbHNlIGlmIChoIDwgMCkge1xuICAgICAgICBoID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IuaCA9IGggKiAzNjA7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3JDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgQ29tbW9uLmVhY2goQ29sb3IuQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIGlmICghQ29tbW9uLmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiYgIUNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSAmJiBpW2NvbXBvbmVudF0gIT09IHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19jb2xvci5fX3N0YXRlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fdGVtcC5fX3N0YXRlLCB0aGlzLl9fY29sb3IuX19zdGF0ZSk7XG4gICAgICB0aGlzLl9fdGVtcC5hID0gMTtcbiAgICAgIHZhciBmbGlwID0gdGhpcy5fX2NvbG9yLnYgPCAwLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAwLjUgPyAyNTUgOiAwO1xuICAgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgICAgbWFyZ2luTGVmdDogMTAwICogdGhpcy5fX2NvbG9yLnMgLSA3ICsgJ3B4JyxcbiAgICAgICAgbWFyZ2luVG9wOiAxMDAgKiAoMSAtIHRoaXMuX19jb2xvci52KSAtIDcgKyAncHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCksXG4gICAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCc7XG4gICAgICB0aGlzLl9fdGVtcC5zID0gMTtcbiAgICAgIHRoaXMuX190ZW1wLnYgPSAxO1xuICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b0hleFN0cmluZygpKTtcbiAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fY29sb3IudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgY29sb3I6ICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArICcpJyxcbiAgICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywuNyknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG52YXIgdmVuZG9ycyA9IFsnLW1vei0nLCAnLW8tJywgJy13ZWJraXQtJywgJy1tcy0nLCAnJ107XG5mdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XG4gIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICBDb21tb24uZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yKSB7XG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnICsgeCArICcsICcgKyBhICsgJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwgI2ZmMDBmZiAxNyUsICMwMDAwZmYgMzQlLCAjMDBmZmZmIDUwJSwgIzAwZmYwMCA2NyUsICNmZmZmMDAgODQlLCAjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xufVxuXG52YXIgY3NzID0ge1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCwgaW5kb2MpIHtcbiAgICB2YXIgZG9jID0gaW5kb2MgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID0gdXJsO1xuICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICB9LFxuICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChjc3NDb250ZW50LCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgaW5qZWN0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzc0NvbnRlbnQ7XG4gICAgdmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICB0cnkge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChpbmplY3RlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNhdmVEaWFsb2dDb250ZW50cyA9IFwiPGRpdiBpZD1cXFwiZGctc2F2ZVxcXCIgY2xhc3M9XFxcImRnIGRpYWxvZ3VlXFxcIj5cXG5cXG4gIEhlcmUncyB0aGUgbmV3IGxvYWQgcGFyYW1ldGVyIGZvciB5b3VyIDxjb2RlPkdVSTwvY29kZT4ncyBjb25zdHJ1Y3RvcjpcXG5cXG4gIDx0ZXh0YXJlYSBpZD1cXFwiZGctbmV3LWNvbnN0cnVjdG9yXFxcIj48L3RleHRhcmVhPlxcblxcbiAgPGRpdiBpZD1cXFwiZGctc2F2ZS1sb2NhbGx5XFxcIj5cXG5cXG4gICAgPGlucHV0IGlkPVxcXCJkZy1sb2NhbC1zdG9yYWdlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIvPiBBdXRvbWF0aWNhbGx5IHNhdmVcXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cXG5cXG4gICAgPGRpdiBpZD1cXFwiZGctbG9jYWwtZXhwbGFpblxcXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcXG4gICAgICBvdmVycmlkZSB0aG9zZSBwYXNzZWQgdG8gPGNvZGU+ZGF0LkdVSTwvY29kZT4ncyBjb25zdHJ1Y3Rvci4gVGhpcyBtYWtlcyBpdFxcbiAgICAgIGVhc2llciB0byB3b3JrIGluY3JlbWVudGFsbHksIGJ1dCA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlzIGZyYWdpbGUsXFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxcblxcbiAgICA8L2Rpdj5cXG5cXG4gIDwvZGl2PlxcblxcbjwvZGl2PlwiO1xuXG52YXIgQ29udHJvbGxlckZhY3RvcnkgPSBmdW5jdGlvbiBDb250cm9sbGVyRmFjdG9yeShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHZhciBpbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICBpZiAoQ29tbW9uLmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBDb21tb24uaXNPYmplY3QoYXJndW1lbnRzWzJdKSkge1xuICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xuICB9XG4gIGlmIChDb21tb24uaXNOdW1iZXIoaW5pdGlhbFZhbHVlKSkge1xuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuICAgICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdLCBzdGVwOiBhcmd1bWVudHNbNF0gfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbn1cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbnZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VudGVyZWREaXYoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VudGVyZWREaXYpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDEnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJyxcbiAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGRvbS5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVDbGFzcyhDZW50ZXJlZERpdiwgW3tcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgfTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsYXlvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIGRvbS5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2VudGVyZWREaXY7XG59KCk7XG5cbnZhciBzdHlsZVNoZWV0ID0gX19fJGluc2VydFN0eWxlKFwiLmRnIHVse2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7d2lkdGg6MTAwJTtjbGVhcjpib3RofS5kZy5hY3twb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MDt6LWluZGV4OjB9LmRnOm5vdCguYWMpIC5tYWlue292ZXJmbG93OmhpZGRlbn0uZGcubWFpbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXJ9LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93e292ZXJmbG93LXk6YXV0b30uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjE7bWFyZ2luLXRvcDotMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICMyYzJjMmN9LmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b257b3BhY2l0eToxICFpbXBvcnRhbnR9LmRnLm1haW46aG92ZXIgLmNsb3NlLWJ1dHRvbiwuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWd7b3BhY2l0eToxfS5kZy5tYWluIC5jbG9zZS1idXR0b257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO2JvcmRlcjowO2xpbmUtaGVpZ2h0OjE5cHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5kZy5tYWluIC5jbG9zZS1idXR0b24uY2xvc2UtdG9we3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy5tYWluIC5jbG9zZS1idXR0b24uY2xvc2UtYm90dG9te3Bvc2l0aW9uOmFic29sdXRlfS5kZy5tYWluIC5jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTExfS5kZy5he2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoxNXB4O292ZXJmbG93LXk6dmlzaWJsZX0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZS10b3B7bWFyZ2luLXRvcDowfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLWJvdHRvbXttYXJnaW4tdG9wOjI3cHh9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2Vke21hcmdpbi10b3A6MH0uZGcuYSAuc2F2ZS1yb3d7dG9wOjA7ei1pbmRleDoxMDAyfS5kZy5hIC5zYXZlLXJvdy5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLmEgLnNhdmUtcm93LmNsb3NlLWJvdHRvbXtwb3NpdGlvbjpmaXhlZH0uZGcgbGl7LXdlYmtpdC10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW8tdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy1tb3otdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0O3RyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstd2Via2l0LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyfS5kZyBsaTpub3QoLmZvbGRlcil7Y3Vyc29yOmF1dG87aGVpZ2h0OjI3cHg7bGluZS1oZWlnaHQ6MjdweDtwYWRkaW5nOjAgNHB4IDAgNXB4fS5kZyBsaS5mb2xkZXJ7cGFkZGluZzowO2JvcmRlci1sZWZ0OjRweCBzb2xpZCByZ2JhKDAsMCwwLDApfS5kZyBsaS50aXRsZXtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDotNHB4fS5kZyAuY2xvc2VkIGxpOm5vdCgudGl0bGUpLC5kZyAuY2xvc2VkIHVsIGxpLC5kZyAuY2xvc2VkIHVsIGxpPip7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjowfS5kZyAuY3J7Y2xlYXI6Ym90aDtwYWRkaW5nLWxlZnQ6M3B4O2hlaWdodDoyN3B4O292ZXJmbG93OmhpZGRlbn0uZGcgLnByb3BlcnR5LW5hbWV7Y3Vyc29yOmRlZmF1bHQ7ZmxvYXQ6bGVmdDtjbGVhcjpsZWZ0O3dpZHRoOjQwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1le3dpZHRoOjEwMCV9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo3cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLmNyLmNvbG9ye292ZXJmbG93OnZpc2libGV9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5jb2xvcntib3JkZXItbGVmdDozcHggc29saWR9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJGQTFENn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyRkExRDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyRkExRDY7bWF4LXdpZHRoOjEwMCV9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiKTtcblxuY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbnZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcbnZhciBISURFX0tFWV9DT0RFID0gNzI7XG52YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xudmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcbnZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0oKTtcbnZhciBTQVZFX0RJQUxPR1VFID0gdm9pZCAwO1xudmFyIGF1dG9QbGFjZVZpcmdpbiA9IHRydWU7XG52YXIgYXV0b1BsYWNlQ29udGFpbmVyID0gdm9pZCAwO1xudmFyIGhpZGUgPSBmYWxzZTtcbnZhciBoaWRlYWJsZUd1aXMgPSBbXTtcbnZhciBHVUkgPSBmdW5jdGlvbiBHVUkocGFycykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcbiAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcbiAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIGNsb3NlT25Ub3A6IGZhbHNlLFxuICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgfSk7XG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuICAgIGlmIChwYXJhbXMucHJlc2V0KSB7XG4gICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgIGhpZGVhYmxlR3Vpcy5wdXNoKHRoaXMpO1xuICB9XG4gIHBhcmFtcy5yZXNpemFibGUgPSBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgfVxuICB2YXIgdXNlTG9jYWxTdG9yYWdlID0gU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG4gIHZhciBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSB2b2lkIDA7XG4gIHZhciB0aXRsZVJvdyA9IHZvaWQgMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcbiAge1xuICAgIHBhcmVudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsYWJsZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9QbGFjZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VPblRvcDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VPblRvcDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXNldDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgaWYgKHRpdGxlUm93KSB7XG4gICAgICAgICAgdGl0bGVSb3cuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9hZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZUxvY2FsU3RvcmFnZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2U7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoYm9vbCkge1xuICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBwYXJhbXMuY2xvc2VkIHx8IGZhbHNlO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgIGlmICh1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNhdmVkR3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuICAgICAgICBpZiAoc2F2ZWRHdWkpIHtcbiAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRHdWkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgaWYgKHBhcmFtcy5jbG9zZU9uVG9wKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfVE9QKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fX2Nsb3NlQnV0dG9uLCB0aGlzLmRvbUVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CT1RUT00pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG4gICAgfVxuICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRpdGxlUm93TmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3dOYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG4gICAgdGl0bGVSb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlUm93TmFtZSk7XG4gICAgdmFyIG9uQ2xpY2tUaXRsZSA9IGZ1bmN0aW9uIG9uQ2xpY2tUaXRsZShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93LCAndGl0bGUnKTtcbiAgICBkb20uYmluZCh0aXRsZVJvdywgJ2NsaWNrJywgb25DbGlja1RpdGxlKTtcbiAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuICAgICAgaWYgKGF1dG9QbGFjZVZpcmdpbikge1xuICAgICAgICBhdXRvUGxhY2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvUGxhY2VDb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b1BsYWNlQ29udGFpbmVyKTtcbiAgICAgICAgYXV0b1BsYWNlVmlyZ2luID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBhdXRvUGxhY2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX19yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLm9uUmVzaXplRGVib3VuY2VkKCk7XG4gIH07XG4gIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIHRoaXMub25SZXNpemUoKTtcbiAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gIH1cbiAgc2F2ZVRvTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuICB9O1xuICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUgPSBzYXZlVG9Mb2NhbFN0b3JhZ2U7XG4gIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgcm9vdC53aWR0aCArPSAxO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICByb290LndpZHRoIC09IDE7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgcmVzZXRXaWR0aCgpO1xuICB9XG59O1xuR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGhpZGUgPSAhaGlkZTtcbiAgQ29tbW9uLmVhY2goaGlkZWFibGVHdWlzLCBmdW5jdGlvbiAoZ3VpKSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyAnbm9uZScgOiAnJztcbiAgfSk7XG59O1xuR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG5HVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG5HVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG5HVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG5HVUkuQ0xBU1NfQ0xPU0VfVE9QID0gJ2Nsb3NlLXRvcCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NID0gJ2Nsb3NlLWJvdHRvbSc7XG5HVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcbkdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbkdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5HVUkuX2tleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICB9XG59O1xuZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbkNvbW1vbi5leHRlbmQoR1VJLnByb3RvdHlwZSxcbntcbiAgYWRkOiBmdW5jdGlvbiBhZGQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgfSk7XG4gIH0sXG4gIGFkZENvbG9yOiBmdW5jdGlvbiBhZGRDb2xvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgY29sb3I6IHRydWVcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29udHJvbGxlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgIHRoaXMuX19jb250cm9sbGVycy5zcGxpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIHJvb3QgR1VJIHNob3VsZCBiZSByZW1vdmVkIHdpdGggLmRlc3Ryb3koKS4gJyArICdGb3Igc3ViZm9sZGVycywgdXNlIGd1aS5yZW1vdmVGb2xkZXIoZm9sZGVyKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBfdGhpcy5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRoaXMpO1xuICB9LFxuICBhZGRGb2xkZXI6IGZ1bmN0aW9uIGFkZEZvbGRlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICsgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIG5ld0d1aVBhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG4gICAgbmV3R3VpUGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7XG4gICAgICBuZXdHdWlQYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuICAgICAgbmV3R3VpUGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcbiAgICB9XG4gICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3R3VpUGFyYW1zKTtcbiAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcbiAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIHJlbW92ZUZvbGRlcjogZnVuY3Rpb24gcmVtb3ZlRm9sZGVyKGZvbGRlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChmb2xkZXIuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5fX2ZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKGZvbGRlcik7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaChmb2xkZXIuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBmb2xkZXIucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XG4gICAgfSk7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgfSxcbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9LFxuICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcbiAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG4gICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgIHZhciBoID0gMDtcbiAgICAgIENvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIShyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKSB7XG4gICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgIH1cbiAgfSxcbiAgb25SZXNpemVEZWJvdW5jZWQ6IENvbW1vbi5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9LCA1MCksXG4gIHJlbWVtYmVyOiBmdW5jdGlvbiByZW1lbWJlcigpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ0NvbnRlbnRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLicpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgfVxuICB9LFxuICBnZXRSb290OiBmdW5jdGlvbiBnZXRSb290KCkge1xuICAgIHZhciBndWkgPSB0aGlzO1xuICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICBndWkgPSBndWkucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZ3VpO1xuICB9LFxuICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbiBnZXRTYXZlT2JqZWN0KCkge1xuICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcbiAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcbiAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB9XG4gICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9SZXR1cm47XG4gIH0sXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICBzYXZlQXM6IGZ1bmN0aW9uIHNhdmVBcyhwcmVzZXROYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcbiAgfSxcbiAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoZ3VpKSB7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19vbkZpbmlzaENoYW5nZS5jYWxsKGNvbnRyb2xsZXIsIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICB9KTtcbiAgICBpZiAoIWd1aSkge1xuICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihjb250cm9sbGVyKSB7XG4gICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PT0gMDtcbiAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBhZGRSb3coZ3VpLCBuZXdEb20sIGxpQmVmb3JlKSB7XG4gIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGlmIChuZXdEb20pIHtcbiAgICBsaS5hcHBlbmRDaGlsZChuZXdEb20pO1xuICB9XG4gIGlmIChsaUJlZm9yZSkge1xuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgbGlCZWZvcmUpO1xuICB9IGVsc2Uge1xuICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgfVxuICBndWkub25SZXNpemUoKTtcbiAgcmV0dXJuIGxpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGd1aSkge1xuICBkb20udW5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGd1aS5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBpZiAoZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpIHtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIGd1aS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgaWYgKG1vZGlmaWVkKSB7XG4gICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArICcqJztcbiAgfSBlbHNlIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuICBDb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsIHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKF9vcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtDb21tb24udG9BcnJheShhcmd1bWVudHMpXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChDb21tb24uaXNBcnJheShfb3B0aW9ucykgfHwgQ29tbW9uLmlzT2JqZWN0KF9vcHRpb25zKSkge1xuICAgICAgICB2YXIgX25leHRTaWJsaW5nID0gY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogX25leHRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbX29wdGlvbnNdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZShfbmFtZSkge1xuICAgICAgY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9IF9uYW1lO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19ndWkucmVtb3ZlKGNvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKSB7XG4gICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcbiAgICBDb21tb24uZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnLCAnc3RlcCcsICdtaW4nLCAnbWF4J10sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHZhciBwYyA9IGNvbnRyb2xsZXJbbWV0aG9kXTtcbiAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuICAgICAgY29udHJvbGxlclttZXRob2RdID0gYm94W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcGIuYXBwbHkoYm94LCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHBjLmFwcGx5KGNvbnRyb2xsZXIsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBkb20uYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG4gICAgY29udHJvbGxlci5kb21FbGVtZW50Lmluc2VydEJlZm9yZShib3guZG9tRWxlbWVudCwgY29udHJvbGxlci5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xuICAgIHZhciByID0gZnVuY3Rpb24gcihyZXR1cm5lZCkge1xuICAgICAgaWYgKENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWluKSAmJiBDb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21heCkpIHtcbiAgICAgICAgdmFyIG9sZE5hbWUgPSBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgd2FzTGlzdGVuaW5nID0gY29udHJvbGxlci5fX2d1aS5fX2xpc3RlbmluZy5pbmRleE9mKGNvbnRyb2xsZXIpID4gLTE7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHZhciBuZXdDb250cm9sbGVyID0gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29udHJvbGxlci5fX21pbiwgY29udHJvbGxlci5fX21heCwgY29udHJvbGxlci5fX3N0ZXBdXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdDb250cm9sbGVyLm5hbWUob2xkTmFtZSk7XG4gICAgICAgIGlmICh3YXNMaXN0ZW5pbmcpIG5ld0NvbnRyb2xsZXIubGlzdGVuKCk7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgIH07XG4gICAgY29udHJvbGxlci5taW4gPSBDb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1pbik7XG4gICAgY29udHJvbGxlci5tYXggPSBDb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1heCk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XG4gICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChsaSwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICB9KTtcbiAgICBkb20uYmluZChsaSwgJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGxpLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNvbnRyb2xsZXIuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICB9XG4gIGNvbnRyb2xsZXIuc2V0VmFsdWUgPSBDb21tb24uY29tcG9zZShmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKGd1aS5nZXRSb290KCkuX19wcmVzZXRfc2VsZWN0ICYmIGNvbnRyb2xsZXIuaXNNb2RpZmllZCgpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xufVxuZnVuY3Rpb24gcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpIHtcbiAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xuICB2YXIgbWF0Y2hlZEluZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuICBpZiAobWF0Y2hlZEluZGV4ICE9PSAtMSkge1xuICAgIHZhciBjb250cm9sbGVyTWFwID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdO1xuICAgIGlmIChjb250cm9sbGVyTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRyb2xsZXJNYXAgPSB7fTtcbiAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XSA9IGNvbnRyb2xsZXJNYXA7XG4gICAgfVxuICAgIGNvbnRyb2xsZXJNYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHZhciBwcmVzZXRNYXAgPSByb290LmxvYWQucmVtZW1iZXJlZDtcbiAgICAgIHZhciBwcmVzZXQgPSB2b2lkIDA7XG4gICAgICBpZiAocHJlc2V0TWFwW2d1aS5wcmVzZXRdKSB7XG4gICAgICAgIHByZXNldCA9IHByZXNldE1hcFtndWkucHJlc2V0XTtcbiAgICAgIH0gZWxzZSBpZiAocHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0W21hdGNoZWRJbmRleF0gJiYgcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XTtcbiAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBcIicgKyBvYmplY3QgKyAnXCIgaGFzIG5vIHByb3BlcnR5IFwiJyArIHByb3BlcnR5ICsgJ1wiJyk7XG4gIH1cbiAgdmFyIGNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gIGlmIChwYXJhbXMuY29sb3IpIHtcbiAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmFjdG9yeUFyZ3MgPSBbb2JqZWN0LCBwcm9wZXJ0eV0uY29uY2F0KHBhcmFtcy5mYWN0b3J5QXJncyk7XG4gICAgY29udHJvbGxlciA9IENvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xuICB9XG4gIGlmIChwYXJhbXMuYmVmb3JlIGluc3RhbmNlb2YgQ29udHJvbGxlcikge1xuICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XG4gIH1cbiAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xuICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZG9tLmFkZENsYXNzKG5hbWUsICdwcm9wZXJ0eS1uYW1lJyk7XG4gIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xuICB2YXIgbGkgPSBhZGRSb3coZ3VpLCBjb250YWluZXIsIHBhcmFtcy5iZWZvcmUpO1xuICBkb20uYWRkQ2xhc3MobGksIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyk7XG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uYWRkQ2xhc3MobGksIF90eXBlb2YoY29udHJvbGxlci5nZXRWYWx1ZSgpKSk7XG4gIH1cbiAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG4gIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gIHJldHVybiBjb250cm9sbGVyO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xuICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcbn1cbmZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XG4gIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG4gIG9wdC52YWx1ZSA9IG5hbWU7XG4gIGd1aS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgaWYgKHNldFNlbGVjdGVkKSB7XG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xuICB9XG59XG5mdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKSB7XG4gIGV4cGxhaW4uc3R5bGUuZGlzcGxheSA9IGd1aS51c2VMb2NhbFN0b3JhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xufVxuZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XG4gIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGRvbS5hZGRDbGFzcyhndWkuZG9tRWxlbWVudCwgJ2hhcy1zYXZlJyk7XG4gIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xuICBkb20uYWRkQ2xhc3MoZGl2LCAnc2F2ZS1yb3cnKTtcbiAgdmFyIGdlYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgZG9tLmFkZENsYXNzKGdlYXJzLCAnYnV0dG9uIGdlYXJzJyk7XG4gIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcbiAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbjIuaW5uZXJIVE1MID0gJ05ldyc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xuICB2YXIgYnV0dG9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMy5pbm5lckhUTUwgPSAnUmV2ZXJ0JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdyZXZlcnQnKTtcbiAgdmFyIHNlbGVjdCA9IGd1aS5fX3ByZXNldF9zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICBDb21tb24uZWFjaChndWkubG9hZC5yZW1lbWJlcmVkLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT09IGd1aS5wcmVzZXQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuICB9XG4gIGRvbS5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xuICAgIH1cbiAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcbiAgfSk7XG4gIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICBkaXYuYXBwZW5kQ2hpbGQoZ2VhcnMpO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMyk7XG4gIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuICAgIHZhciBsb2NhbFN0b3JhZ2VDaGVja0JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1zdG9yYWdlJyk7XG4gICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xuICAgIHNhdmVMb2NhbGx5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICB9XG4gICAgc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbik7XG4gICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBndWkudXNlTG9jYWxTdG9yYWdlID0gIWd1aS51c2VMb2NhbFN0b3JhZ2U7XG4gICAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcbiAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PT0gNjcpKSB7XG4gICAgICBTQVZFX0RJQUxPR1VFLmhpZGUoKTtcbiAgICB9XG4gIH0pO1xuICBkb20uYmluZChnZWFycywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcbiAgICBTQVZFX0RJQUxPR1VFLnNob3coKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmZvY3VzKCk7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5zYXZlKCk7XG4gIH0pO1xuICBkb20uYmluZChidXR0b24yLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xuICAgIGlmIChwcmVzZXROYW1lKSB7XG4gICAgICBndWkuc2F2ZUFzKHByZXNldE5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBndWkucmV2ZXJ0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuICB2YXIgcG1vdXNlWCA9IHZvaWQgMDtcbiAgZ3VpLl9fcmVzaXplX2hhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBDb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcbiAgICB3aWR0aDogJzZweCcsXG4gICAgbWFyZ2luTGVmdDogJy0zcHgnLFxuICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH0pO1xuICBmdW5jdGlvbiBkcmFnKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG4gICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG4gICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gIH1cbiAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcbiAgICBkb20uYWRkQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgZG9tLmJpbmQoZ3VpLl9fY2xvc2VCdXR0b24sICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBndWkuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZ3VpLl9fcmVzaXplX2hhbmRsZSwgZ3VpLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xufVxuZnVuY3Rpb24gc2V0V2lkdGgoZ3VpLCB3KSB7XG4gIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG4gICAgZ3VpLl9fc2F2ZV9yb3cuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgfVxuICBpZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcbiAgICBndWkuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuICB2YXIgdG9SZXR1cm4gPSB7fTtcbiAgQ29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgdmFyIHNhdmVkVmFsdWVzID0ge307XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSBndWkuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbaW5kZXhdO1xuICAgIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJNYXAsIGZ1bmN0aW9uIChjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xuICAgICAgc2F2ZWRWYWx1ZXNbcHJvcGVydHldID0gdXNlSW5pdGlhbFZhbHVlcyA/IGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlIDogY29udHJvbGxlci5nZXRWYWx1ZSgpO1xuICAgIH0pO1xuICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkVmFsdWVzO1xuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufVxuZnVuY3Rpb24gc2V0UHJlc2V0U2VsZWN0SW5kZXgoZ3VpKSB7XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PT0gZ3VpLnByZXNldCkge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpIHtcbiAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT09IDApIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcbiAgICB9KTtcbiAgfVxuICBDb21tb24uZWFjaChjb250cm9sbGVyQXJyYXksIGZ1bmN0aW9uIChjKSB7XG4gICAgYy51cGRhdGVEaXNwbGF5KCk7XG4gIH0pO1xufVxuXG52YXIgY29sb3IgPSB7XG4gIENvbG9yOiBDb2xvcixcbiAgbWF0aDogQ29sb3JNYXRoLFxuICBpbnRlcnByZXQ6IGludGVycHJldFxufTtcbnZhciBjb250cm9sbGVycyA9IHtcbiAgQ29udHJvbGxlcjogQ29udHJvbGxlcixcbiAgQm9vbGVhbkNvbnRyb2xsZXI6IEJvb2xlYW5Db250cm9sbGVyLFxuICBPcHRpb25Db250cm9sbGVyOiBPcHRpb25Db250cm9sbGVyLFxuICBTdHJpbmdDb250cm9sbGVyOiBTdHJpbmdDb250cm9sbGVyLFxuICBOdW1iZXJDb250cm9sbGVyOiBOdW1iZXJDb250cm9sbGVyLFxuICBOdW1iZXJDb250cm9sbGVyQm94OiBOdW1iZXJDb250cm9sbGVyQm94LFxuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyOiBOdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuICBGdW5jdGlvbkNvbnRyb2xsZXI6IEZ1bmN0aW9uQ29udHJvbGxlcixcbiAgQ29sb3JDb250cm9sbGVyOiBDb2xvckNvbnRyb2xsZXJcbn07XG52YXIgZG9tJDEgPSB7IGRvbTogZG9tIH07XG52YXIgZ3VpID0geyBHVUk6IEdVSSB9O1xudmFyIEdVSSQxID0gR1VJO1xudmFyIGluZGV4ID0ge1xuICBjb2xvcjogY29sb3IsXG4gIGNvbnRyb2xsZXJzOiBjb250cm9sbGVycyxcbiAgZG9tOiBkb20kMSxcbiAgZ3VpOiBndWksXG4gIEdVSTogR1VJJDFcbn07XG5cbmV4cG9ydCB7IGNvbG9yLCBjb250cm9sbGVycywgZG9tJDEgYXMgZG9tLCBndWksIEdVSSQxIGFzIEdVSSB9O1xuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXQuZ3VpLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/dat.gui/build/dat.gui.module.js\n");

/***/ }),

/***/ "./node_modules/pixi-spine/dist/pixi-spine.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi-spine/dist/pixi-spine.js ***!
  \****************************************************/
/***/ (function() {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Animation = (function () {\r\n            function Animation(name, timelines, duration) {\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                if (timelines == null)\r\n                    throw new Error(\"timelines cannot be null.\");\r\n                this.name = name;\r\n                this.timelines = timelines;\r\n                this.timelineIds = [];\r\n                for (var i = 0; i < timelines.length; i++)\r\n                    this.timelineIds[timelines[i].getPropertyId()] = true;\r\n                this.duration = duration;\r\n            }\r\n            Animation.prototype.hasTimeline = function (id) {\r\n                return this.timelineIds[id] == true;\r\n            };\r\n            Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                if (loop && this.duration != 0) {\r\n                    time %= this.duration;\r\n                    if (lastTime > 0)\r\n                        lastTime %= this.duration;\r\n                }\r\n                var timelines = this.timelines;\r\n                for (var i = 0, n = timelines.length; i < n; i++)\r\n                    timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n            };\r\n            Animation.binarySearch = function (values, target, step) {\r\n                if (step === void 0) { step = 1; }\r\n                var low = 0;\r\n                var high = values.length / step - 2;\r\n                if (high == 0)\r\n                    return step;\r\n                var current = high >>> 1;\r\n                while (true) {\r\n                    if (values[(current + 1) * step] <= target)\r\n                        low = current + 1;\r\n                    else\r\n                        high = current;\r\n                    if (low == high)\r\n                        return (low + 1) * step;\r\n                    current = (low + high) >>> 1;\r\n                }\r\n            };\r\n            Animation.linearSearch = function (values, target, step) {\r\n                for (var i = 0, last = values.length - step; i <= last; i += step)\r\n                    if (values[i] > target)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            return Animation;\r\n        }());\r\n        core.Animation = Animation;\r\n        var MixBlend;\r\n        (function (MixBlend) {\r\n            MixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\r\n            MixBlend[MixBlend[\"first\"] = 1] = \"first\";\r\n            MixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\r\n            MixBlend[MixBlend[\"add\"] = 3] = \"add\";\r\n        })(MixBlend = core.MixBlend || (core.MixBlend = {}));\r\n        var MixDirection;\r\n        (function (MixDirection) {\r\n            MixDirection[MixDirection[\"mixIn\"] = 0] = \"mixIn\";\r\n            MixDirection[MixDirection[\"mixOut\"] = 1] = \"mixOut\";\r\n        })(MixDirection = core.MixDirection || (core.MixDirection = {}));\r\n        var TimelineType;\r\n        (function (TimelineType) {\r\n            TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n            TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n            TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n            TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n            TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n            TimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n            TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n            TimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n            TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n            TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n            TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n            TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n            TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n            TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n            TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n        })(TimelineType = core.TimelineType || (core.TimelineType = {}));\r\n        var CurveTimeline = (function () {\r\n            function CurveTimeline(frameCount) {\r\n                if (frameCount <= 0)\r\n                    throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n            }\r\n            CurveTimeline.prototype.getFrameCount = function () {\r\n                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n            };\r\n            CurveTimeline.prototype.setLinear = function (frameIndex) {\r\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n            };\r\n            CurveTimeline.prototype.setStepped = function (frameIndex) {\r\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n            };\r\n            CurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n                var index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                if (index == this.curves.length)\r\n                    return CurveTimeline.LINEAR;\r\n                var type = this.curves[index];\r\n                if (type == CurveTimeline.LINEAR)\r\n                    return CurveTimeline.LINEAR;\r\n                if (type == CurveTimeline.STEPPED)\r\n                    return CurveTimeline.STEPPED;\r\n                return CurveTimeline.BEZIER;\r\n            };\r\n            CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n                var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n                var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                var curves = this.curves;\r\n                curves[i++] = CurveTimeline.BEZIER;\r\n                var x = dfx, y = dfy;\r\n                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                    curves[i] = x;\r\n                    curves[i + 1] = y;\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    x += dfx;\r\n                    y += dfy;\r\n                }\r\n            };\r\n            CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n                percent = core.MathUtils.clamp(percent, 0, 1);\r\n                var curves = this.curves;\r\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                var type = curves[i];\r\n                if (type == CurveTimeline.LINEAR)\r\n                    return percent;\r\n                if (type == CurveTimeline.STEPPED)\r\n                    return 0;\r\n                i++;\r\n                var x = 0;\r\n                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                    x = curves[i];\r\n                    if (x >= percent) {\r\n                        var prevX = void 0, prevY = void 0;\r\n                        if (i == start) {\r\n                            prevX = 0;\r\n                            prevY = 0;\r\n                        }\r\n                        else {\r\n                            prevX = curves[i - 2];\r\n                            prevY = curves[i - 1];\r\n                        }\r\n                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n                    }\r\n                }\r\n                var y = curves[i - 1];\r\n                return y + (1 - y) * (percent - x) / (1 - x);\r\n            };\r\n            CurveTimeline.LINEAR = 0;\r\n            CurveTimeline.STEPPED = 1;\r\n            CurveTimeline.BEZIER = 2;\r\n            CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n            return CurveTimeline;\r\n        }());\r\n        core.CurveTimeline = CurveTimeline;\r\n        var RotateTimeline = (function (_super) {\r\n            __extends(RotateTimeline, _super);\r\n            function RotateTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount << 1);\r\n                return _this;\r\n            }\r\n            RotateTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.rotate << 24) + this.boneIndex;\r\n            };\r\n            RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n                frameIndex <<= 1;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n            };\r\n            RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var r_1 = bone.data.rotation - bone.rotation;\r\n                            bone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n                    var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation + r_2 * alpha;\r\n                            break;\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            r_2 += bone.data.rotation - bone.rotation;\r\n                            r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n                        case MixBlend.add:\r\n                            bone.rotation += r_2 * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n                r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        r += bone.data.rotation - bone.rotation;\r\n                    case MixBlend.add:\r\n                        bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                }\r\n            };\r\n            RotateTimeline.ENTRIES = 2;\r\n            RotateTimeline.PREV_TIME = -2;\r\n            RotateTimeline.PREV_ROTATION = -1;\r\n            RotateTimeline.ROTATION = 1;\r\n            return RotateTimeline;\r\n        }(CurveTimeline));\r\n        core.RotateTimeline = RotateTimeline;\r\n        var TranslateTimeline = (function (_super) {\r\n            __extends(TranslateTimeline, _super);\r\n            function TranslateTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TranslateTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.translate << 24) + this.boneIndex;\r\n            };\r\n            TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n                frameIndex *= TranslateTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TranslateTimeline.X] = x;\r\n                this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n            };\r\n            TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.x = bone.data.x;\r\n                            bone.y = bone.data.y;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.x += (bone.data.x - bone.x) * alpha;\r\n                            bone.y += (bone.data.y - bone.y) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + TranslateTimeline.PREV_X];\r\n                    y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n                    x = frames[frame + TranslateTimeline.PREV_X];\r\n                    y = frames[frame + TranslateTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n                    x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n                }\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.x = bone.data.x + x * alpha;\r\n                        bone.y = bone.data.y + y * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                        bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.x += x * alpha;\r\n                        bone.y += y * alpha;\r\n                }\r\n            };\r\n            TranslateTimeline.ENTRIES = 3;\r\n            TranslateTimeline.PREV_TIME = -3;\r\n            TranslateTimeline.PREV_X = -2;\r\n            TranslateTimeline.PREV_Y = -1;\r\n            TranslateTimeline.X = 1;\r\n            TranslateTimeline.Y = 2;\r\n            return TranslateTimeline;\r\n        }(CurveTimeline));\r\n        core.TranslateTimeline = TranslateTimeline;\r\n        var ScaleTimeline = (function (_super) {\r\n            __extends(ScaleTimeline, _super);\r\n            function ScaleTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            ScaleTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.scale << 24) + this.boneIndex;\r\n            };\r\n            ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.scaleX = bone.data.scaleX;\r\n                            bone.scaleY = bone.data.scaleY;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n                    x = frames[frame + ScaleTimeline.PREV_X];\r\n                    y = frames[frame + ScaleTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n                }\r\n                if (alpha == 1) {\r\n                    if (blend == MixBlend.add) {\r\n                        bone.scaleX += x - bone.data.scaleX;\r\n                        bone.scaleY += y - bone.data.scaleY;\r\n                    }\r\n                    else {\r\n                        bone.scaleX = x;\r\n                        bone.scaleY = y;\r\n                    }\r\n                }\r\n                else {\r\n                    var bx = 0, by = 0;\r\n                    if (direction == MixDirection.mixOut) {\r\n                        switch (blend) {\r\n                            case MixBlend.setup:\r\n                                bx = bone.data.scaleX;\r\n                                by = bone.data.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\r\n                                break;\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                bx = bone.scaleX;\r\n                                by = bone.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                bx = bone.scaleX;\r\n                                by = bone.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (blend) {\r\n                            case MixBlend.setup:\r\n                                bx = Math.abs(bone.data.scaleX) * core.MathUtils.signum(x);\r\n                                by = Math.abs(bone.data.scaleY) * core.MathUtils.signum(y);\r\n                                bone.scaleX = bx + (x - bx) * alpha;\r\n                                bone.scaleY = by + (y - by) * alpha;\r\n                                break;\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                bx = Math.abs(bone.scaleX) * core.MathUtils.signum(x);\r\n                                by = Math.abs(bone.scaleY) * core.MathUtils.signum(y);\r\n                                bone.scaleX = bx + (x - bx) * alpha;\r\n                                bone.scaleY = by + (y - by) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                bx = core.MathUtils.signum(x);\r\n                                by = core.MathUtils.signum(y);\r\n                                bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                                bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            return ScaleTimeline;\r\n        }(TranslateTimeline));\r\n        core.ScaleTimeline = ScaleTimeline;\r\n        var ShearTimeline = (function (_super) {\r\n            __extends(ShearTimeline, _super);\r\n            function ShearTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            ShearTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.shear << 24) + this.boneIndex;\r\n            };\r\n            ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.shearX = bone.data.shearX;\r\n                            bone.shearY = bone.data.shearY;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + ShearTimeline.PREV_X];\r\n                    y = frames[frames.length + ShearTimeline.PREV_Y];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n                    x = frames[frame + ShearTimeline.PREV_X];\r\n                    y = frames[frame + ShearTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n                }\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.shearX = bone.data.shearX + x * alpha;\r\n                        bone.shearY = bone.data.shearY + y * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.shearX += x * alpha;\r\n                        bone.shearY += y * alpha;\r\n                }\r\n            };\r\n            return ShearTimeline;\r\n        }(TranslateTimeline));\r\n        core.ShearTimeline = ShearTimeline;\r\n        var ColorTimeline = (function (_super) {\r\n            __extends(ColorTimeline, _super);\r\n            function ColorTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            ColorTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.color << 24) + this.slotIndex;\r\n            };\r\n            ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n                frameIndex *= ColorTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + ColorTimeline.R] = r;\r\n                this.frames[frameIndex + ColorTimeline.G] = g;\r\n                this.frames[frameIndex + ColorTimeline.B] = b;\r\n                this.frames[frameIndex + ColorTimeline.A] = a;\r\n            };\r\n            ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            slot.color.setFromColor(slot.data.color);\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var color = slot.color, setup = slot.data.color;\r\n                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n                    }\r\n                    return;\r\n                }\r\n                var r = 0, g = 0, b = 0, a = 0;\r\n                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    r = frames[i + ColorTimeline.PREV_R];\r\n                    g = frames[i + ColorTimeline.PREV_G];\r\n                    b = frames[i + ColorTimeline.PREV_B];\r\n                    a = frames[i + ColorTimeline.PREV_A];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n                    r = frames[frame + ColorTimeline.PREV_R];\r\n                    g = frames[frame + ColorTimeline.PREV_G];\r\n                    b = frames[frame + ColorTimeline.PREV_B];\r\n                    a = frames[frame + ColorTimeline.PREV_A];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n                    r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n                    g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n                    b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n                    a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n                }\r\n                if (alpha == 1)\r\n                    slot.color.set(r, g, b, a);\r\n                else {\r\n                    var color = slot.color;\r\n                    if (blend == MixBlend.setup)\r\n                        color.setFromColor(slot.data.color);\r\n                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n                }\r\n            };\r\n            ColorTimeline.ENTRIES = 5;\r\n            ColorTimeline.PREV_TIME = -5;\r\n            ColorTimeline.PREV_R = -4;\r\n            ColorTimeline.PREV_G = -3;\r\n            ColorTimeline.PREV_B = -2;\r\n            ColorTimeline.PREV_A = -1;\r\n            ColorTimeline.R = 1;\r\n            ColorTimeline.G = 2;\r\n            ColorTimeline.B = 3;\r\n            ColorTimeline.A = 4;\r\n            return ColorTimeline;\r\n        }(CurveTimeline));\r\n        core.ColorTimeline = ColorTimeline;\r\n        var TwoColorTimeline = (function (_super) {\r\n            __extends(TwoColorTimeline, _super);\r\n            function TwoColorTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TwoColorTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.twoColor << 24) + this.slotIndex;\r\n            };\r\n            TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n                frameIndex *= TwoColorTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n                this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n                this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n                this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n                this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n                this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n                this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n            };\r\n            TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            slot.color.setFromColor(slot.data.color);\r\n                            slot.darkColor.setFromColor(slot.data.darkColor);\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n                    }\r\n                    return;\r\n                }\r\n                var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    r = frames[i + TwoColorTimeline.PREV_R];\r\n                    g = frames[i + TwoColorTimeline.PREV_G];\r\n                    b = frames[i + TwoColorTimeline.PREV_B];\r\n                    a = frames[i + TwoColorTimeline.PREV_A];\r\n                    r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n                    g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n                    b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n                    r = frames[frame + TwoColorTimeline.PREV_R];\r\n                    g = frames[frame + TwoColorTimeline.PREV_G];\r\n                    b = frames[frame + TwoColorTimeline.PREV_B];\r\n                    a = frames[frame + TwoColorTimeline.PREV_A];\r\n                    r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n                    g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n                    b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n                }\r\n                if (alpha == 1) {\r\n                    slot.color.set(r, g, b, a);\r\n                    slot.darkColor.set(r2, g2, b2, 1);\r\n                }\r\n                else {\r\n                    var light = slot.color, dark = slot.darkColor;\r\n                    if (blend == MixBlend.setup) {\r\n                        light.setFromColor(slot.data.color);\r\n                        dark.setFromColor(slot.data.darkColor);\r\n                    }\r\n                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n                }\r\n            };\r\n            TwoColorTimeline.ENTRIES = 8;\r\n            TwoColorTimeline.PREV_TIME = -8;\r\n            TwoColorTimeline.PREV_R = -7;\r\n            TwoColorTimeline.PREV_G = -6;\r\n            TwoColorTimeline.PREV_B = -5;\r\n            TwoColorTimeline.PREV_A = -4;\r\n            TwoColorTimeline.PREV_R2 = -3;\r\n            TwoColorTimeline.PREV_G2 = -2;\r\n            TwoColorTimeline.PREV_B2 = -1;\r\n            TwoColorTimeline.R = 1;\r\n            TwoColorTimeline.G = 2;\r\n            TwoColorTimeline.B = 3;\r\n            TwoColorTimeline.A = 4;\r\n            TwoColorTimeline.R2 = 5;\r\n            TwoColorTimeline.G2 = 6;\r\n            TwoColorTimeline.B2 = 7;\r\n            return TwoColorTimeline;\r\n        }(CurveTimeline));\r\n        core.TwoColorTimeline = TwoColorTimeline;\r\n        var AttachmentTimeline = (function () {\r\n            function AttachmentTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.attachmentNames = new Array(frameCount);\r\n            }\r\n            AttachmentTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.attachment << 24) + this.slotIndex;\r\n            };\r\n            AttachmentTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n                this.frames[frameIndex] = time;\r\n                this.attachmentNames[frameIndex] = attachmentName;\r\n            };\r\n            AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                if (direction == MixDirection.mixOut) {\r\n                    if (blend == MixBlend.setup)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n                    return;\r\n                }\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n                    return;\r\n                }\r\n                var frameIndex = 0;\r\n                if (time >= frames[frames.length - 1])\r\n                    frameIndex = frames.length - 1;\r\n                else\r\n                    frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n                var attachmentName = this.attachmentNames[frameIndex];\r\n                skeleton.slots[this.slotIndex]\r\n                    .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n            };\r\n            AttachmentTimeline.prototype.setAttachment = function (skeleton, slot, attachmentName) {\r\n                slot.attachment = attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName);\r\n            };\r\n            return AttachmentTimeline;\r\n        }());\r\n        core.AttachmentTimeline = AttachmentTimeline;\r\n        var zeros = null;\r\n        var DeformTimeline = (function (_super) {\r\n            __extends(DeformTimeline, _super);\r\n            function DeformTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount);\r\n                _this.frameVertices = new Array(frameCount);\r\n                if (zeros == null)\r\n                    zeros = core.Utils.newFloatArray(64);\r\n                return _this;\r\n            }\r\n            DeformTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n            };\r\n            DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n                this.frames[frameIndex] = time;\r\n                this.frameVertices[frameIndex] = vertices;\r\n            };\r\n            DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var slotAttachment = slot.getAttachment();\r\n                if (!(slotAttachment instanceof core.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\r\n                    return;\r\n                var deformArray = slot.deform;\r\n                if (deformArray.length == 0)\r\n                    blend = MixBlend.setup;\r\n                var frameVertices = this.frameVertices;\r\n                var vertexCount = frameVertices[0].length;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    var vertexAttachment = slotAttachment;\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            deformArray.length = 0;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            if (alpha == 1) {\r\n                                deformArray.length = 0;\r\n                                break;\r\n                            }\r\n                            var deform_1 = core.Utils.setArraySize(deformArray, vertexCount);\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i = 0; i < vertexCount; i++)\r\n                                    deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;\r\n                            }\r\n                            else {\r\n                                alpha = 1 - alpha;\r\n                                for (var i = 0; i < vertexCount; i++)\r\n                                    deform_1[i] *= alpha;\r\n                            }\r\n                    }\r\n                    return;\r\n                }\r\n                var deform = core.Utils.setArraySize(deformArray, vertexCount);\r\n                if (time >= frames[frames.length - 1]) {\r\n                    var lastVertices = frameVertices[frames.length - 1];\r\n                    if (alpha == 1) {\r\n                        if (blend == MixBlend.add) {\r\n                            var vertexAttachment = slotAttachment;\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n                                    deform[i_1] += lastVertices[i_1] - setupVertices[i_1];\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n                                    deform[i_2] += lastVertices[i_2];\r\n                            }\r\n                        }\r\n                        else {\r\n                            core.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (blend) {\r\n                            case MixBlend.setup: {\r\n                                var vertexAttachment_1 = slotAttachment;\r\n                                if (vertexAttachment_1.bones == null) {\r\n                                    var setupVertices = vertexAttachment_1.vertices;\r\n                                    for (var i_3 = 0; i_3 < vertexCount; i_3++) {\r\n                                        var setup = setupVertices[i_3];\r\n                                        deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var i_4 = 0; i_4 < vertexCount; i_4++)\r\n                                        deform[i_4] = lastVertices[i_4] * alpha;\r\n                                }\r\n                                break;\r\n                            }\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                for (var i_5 = 0; i_5 < vertexCount; i_5++)\r\n                                    deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                var vertexAttachment = slotAttachment;\r\n                                if (vertexAttachment.bones == null) {\r\n                                    var setupVertices = vertexAttachment.vertices;\r\n                                    for (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n                                        deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var i_7 = 0; i_7 < vertexCount; i_7++)\r\n                                        deform[i_7] += lastVertices[i_7] * alpha;\r\n                                }\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time);\r\n                var prevVertices = frameVertices[frame - 1];\r\n                var nextVertices = frameVertices[frame];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n                if (alpha == 1) {\r\n                    if (blend == MixBlend.add) {\r\n                        var vertexAttachment = slotAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            var setupVertices = vertexAttachment.vertices;\r\n                            for (var i_8 = 0; i_8 < vertexCount; i_8++) {\r\n                                var prev = prevVertices[i_8];\r\n                                deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i_9 = 0; i_9 < vertexCount; i_9++) {\r\n                                var prev = prevVertices[i_9];\r\n                                deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i_10 = 0; i_10 < vertexCount; i_10++) {\r\n                            var prev = prevVertices[i_10];\r\n                            deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    switch (blend) {\r\n                        case MixBlend.setup: {\r\n                            var vertexAttachment_2 = slotAttachment;\r\n                            if (vertexAttachment_2.bones == null) {\r\n                                var setupVertices = vertexAttachment_2.vertices;\r\n                                for (var i_11 = 0; i_11 < vertexCount; i_11++) {\r\n                                    var prev = prevVertices[i_11], setup = setupVertices[i_11];\r\n                                    deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_12 = 0; i_12 < vertexCount; i_12++) {\r\n                                    var prev = prevVertices[i_12];\r\n                                    deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            for (var i_13 = 0; i_13 < vertexCount; i_13++) {\r\n                                var prev = prevVertices[i_13];\r\n                                deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;\r\n                            }\r\n                            break;\r\n                        case MixBlend.add:\r\n                            var vertexAttachment = slotAttachment;\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i_14 = 0; i_14 < vertexCount; i_14++) {\r\n                                    var prev = prevVertices[i_14];\r\n                                    deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_15 = 0; i_15 < vertexCount; i_15++) {\r\n                                    var prev = prevVertices[i_15];\r\n                                    deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\r\n                                }\r\n                            }\r\n                    }\r\n                }\r\n            };\r\n            return DeformTimeline;\r\n        }(CurveTimeline));\r\n        core.DeformTimeline = DeformTimeline;\r\n        var EventTimeline = (function () {\r\n            function EventTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.events = new Array(frameCount);\r\n            }\r\n            EventTimeline.prototype.getPropertyId = function () {\r\n                return TimelineType.event << 24;\r\n            };\r\n            EventTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            EventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n                this.frames[frameIndex] = event.time;\r\n                this.events[frameIndex] = event;\r\n            };\r\n            EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                if (firedEvents == null)\r\n                    return;\r\n                var frames = this.frames;\r\n                var frameCount = this.frames.length;\r\n                if (lastTime > time) {\r\n                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n                    lastTime = -1;\r\n                }\r\n                else if (lastTime >= frames[frameCount - 1])\r\n                    return;\r\n                if (time < frames[0])\r\n                    return;\r\n                var frame = 0;\r\n                if (lastTime < frames[0])\r\n                    frame = 0;\r\n                else {\r\n                    frame = Animation.binarySearch(frames, lastTime);\r\n                    var frameTime = frames[frame];\r\n                    while (frame > 0) {\r\n                        if (frames[frame - 1] != frameTime)\r\n                            break;\r\n                        frame--;\r\n                    }\r\n                }\r\n                for (; frame < frameCount && time >= frames[frame]; frame++)\r\n                    firedEvents.push(this.events[frame]);\r\n            };\r\n            return EventTimeline;\r\n        }());\r\n        core.EventTimeline = EventTimeline;\r\n        var DrawOrderTimeline = (function () {\r\n            function DrawOrderTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.drawOrders = new Array(frameCount);\r\n            }\r\n            DrawOrderTimeline.prototype.getPropertyId = function () {\r\n                return TimelineType.drawOrder << 24;\r\n            };\r\n            DrawOrderTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n                this.frames[frameIndex] = time;\r\n                this.drawOrders[frameIndex] = drawOrder;\r\n            };\r\n            DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var drawOrder = skeleton.drawOrder;\r\n                var slots = skeleton.slots;\r\n                if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                    return;\r\n                }\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                        core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                    return;\r\n                }\r\n                var frame = 0;\r\n                if (time >= frames[frames.length - 1])\r\n                    frame = frames.length - 1;\r\n                else\r\n                    frame = Animation.binarySearch(frames, time) - 1;\r\n                var drawOrderToSetupIndex = this.drawOrders[frame];\r\n                if (drawOrderToSetupIndex == null)\r\n                    core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n                else {\r\n                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n                }\r\n            };\r\n            return DrawOrderTimeline;\r\n        }());\r\n        core.DrawOrderTimeline = DrawOrderTimeline;\r\n        var IkConstraintTimeline = (function (_super) {\r\n            __extends(IkConstraintTimeline, _super);\r\n            function IkConstraintTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            IkConstraintTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n            };\r\n            IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {\r\n                frameIndex *= IkConstraintTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n                this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n                this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n                this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n            };\r\n            IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.mix = constraint.data.mix;\r\n                            constraint.softness = constraint.data.softness;\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                    }\r\n                    return;\r\n                }\r\n                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n                    if (blend == MixBlend.setup) {\r\n                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                        constraint.softness = constraint.data.softness\r\n                            + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                        if (direction == MixDirection.mixOut) {\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                        }\r\n                        else {\r\n                            constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                            constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                            constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                        constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                        if (direction == MixDirection.mixIn) {\r\n                            constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                            constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                            constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n                var softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n                if (blend == MixBlend.setup) {\r\n                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n                    constraint.softness = constraint.data.softness\r\n                        + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n                    if (direction == MixDirection.mixOut) {\r\n                        constraint.bendDirection = constraint.data.bendDirection;\r\n                        constraint.compress = constraint.data.compress;\r\n                        constraint.stretch = constraint.data.stretch;\r\n                    }\r\n                    else {\r\n                        constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n                else {\r\n                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n                    constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n                    if (direction == MixDirection.mixIn) {\r\n                        constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n            };\r\n            IkConstraintTimeline.ENTRIES = 6;\r\n            IkConstraintTimeline.PREV_TIME = -6;\r\n            IkConstraintTimeline.PREV_MIX = -5;\r\n            IkConstraintTimeline.PREV_SOFTNESS = -4;\r\n            IkConstraintTimeline.PREV_BEND_DIRECTION = -3;\r\n            IkConstraintTimeline.PREV_COMPRESS = -2;\r\n            IkConstraintTimeline.PREV_STRETCH = -1;\r\n            IkConstraintTimeline.MIX = 1;\r\n            IkConstraintTimeline.SOFTNESS = 2;\r\n            IkConstraintTimeline.BEND_DIRECTION = 3;\r\n            IkConstraintTimeline.COMPRESS = 4;\r\n            IkConstraintTimeline.STRETCH = 5;\r\n            return IkConstraintTimeline;\r\n        }(CurveTimeline));\r\n        core.IkConstraintTimeline = IkConstraintTimeline;\r\n        var TransformConstraintTimeline = (function (_super) {\r\n            __extends(TransformConstraintTimeline, _super);\r\n            function TransformConstraintTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TransformConstraintTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n            };\r\n            TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n                frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n            };\r\n            TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    var data = constraint.data;\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.rotateMix = data.rotateMix;\r\n                            constraint.translateMix = data.translateMix;\r\n                            constraint.scaleMix = data.scaleMix;\r\n                            constraint.shearMix = data.shearMix;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var rotate = 0, translate = 0, scale = 0, shear = 0;\r\n                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n                }\r\n                if (blend == MixBlend.setup) {\r\n                    var data = constraint.data;\r\n                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n                }\r\n                else {\r\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n                }\r\n            };\r\n            TransformConstraintTimeline.ENTRIES = 5;\r\n            TransformConstraintTimeline.PREV_TIME = -5;\r\n            TransformConstraintTimeline.PREV_ROTATE = -4;\r\n            TransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n            TransformConstraintTimeline.PREV_SCALE = -2;\r\n            TransformConstraintTimeline.PREV_SHEAR = -1;\r\n            TransformConstraintTimeline.ROTATE = 1;\r\n            TransformConstraintTimeline.TRANSLATE = 2;\r\n            TransformConstraintTimeline.SCALE = 3;\r\n            TransformConstraintTimeline.SHEAR = 4;\r\n            return TransformConstraintTimeline;\r\n        }(CurveTimeline));\r\n        core.TransformConstraintTimeline = TransformConstraintTimeline;\r\n        var PathConstraintPositionTimeline = (function (_super) {\r\n            __extends(PathConstraintPositionTimeline, _super);\r\n            function PathConstraintPositionTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            PathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n                frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n            };\r\n            PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.position = constraint.data.position;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var position = 0;\r\n                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n                    position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n                }\r\n                if (blend == MixBlend.setup)\r\n                    constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n                else\r\n                    constraint.position += (position - constraint.position) * alpha;\r\n            };\r\n            PathConstraintPositionTimeline.ENTRIES = 2;\r\n            PathConstraintPositionTimeline.PREV_TIME = -2;\r\n            PathConstraintPositionTimeline.PREV_VALUE = -1;\r\n            PathConstraintPositionTimeline.VALUE = 1;\r\n            return PathConstraintPositionTimeline;\r\n        }(CurveTimeline));\r\n        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n        var PathConstraintSpacingTimeline = (function (_super) {\r\n            __extends(PathConstraintSpacingTimeline, _super);\r\n            function PathConstraintSpacingTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.spacing = constraint.data.spacing;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var spacing = 0;\r\n                if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n                    spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n                }\r\n                if (blend == MixBlend.setup)\r\n                    constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n                else\r\n                    constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n            };\r\n            return PathConstraintSpacingTimeline;\r\n        }(PathConstraintPositionTimeline));\r\n        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n        var PathConstraintMixTimeline = (function (_super) {\r\n            __extends(PathConstraintMixTimeline, _super);\r\n            function PathConstraintMixTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            PathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n                frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n            };\r\n            PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.rotateMix = constraint.data.rotateMix;\r\n                            constraint.translateMix = constraint.data.translateMix;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var rotate = 0, translate = 0;\r\n                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n                }\r\n                if (blend == MixBlend.setup) {\r\n                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n                }\r\n                else {\r\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n                }\r\n            };\r\n            PathConstraintMixTimeline.ENTRIES = 3;\r\n            PathConstraintMixTimeline.PREV_TIME = -3;\r\n            PathConstraintMixTimeline.PREV_ROTATE = -2;\r\n            PathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n            PathConstraintMixTimeline.ROTATE = 1;\r\n            PathConstraintMixTimeline.TRANSLATE = 2;\r\n            return PathConstraintMixTimeline;\r\n        }(CurveTimeline));\r\n        core.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AnimationState = (function () {\r\n            function AnimationState(data) {\r\n                this.tracks = new Array();\r\n                this.timeScale = 1;\r\n                this.unkeyedState = 0;\r\n                this.events = new Array();\r\n                this.listeners = new Array();\r\n                this.queue = new EventQueue(this);\r\n                this.propertyIDs = new core.IntSet();\r\n                this.animationsChanged = false;\r\n                this.trackEntryPool = new core.Pool(function () { return new TrackEntry(); });\r\n                this.data = data;\r\n            }\r\n            AnimationState.prototype.update = function (delta) {\r\n                delta *= this.timeScale;\r\n                var tracks = this.tracks;\r\n                for (var i = 0, n = tracks.length; i < n; i++) {\r\n                    var current = tracks[i];\r\n                    if (current == null)\r\n                        continue;\r\n                    current.animationLast = current.nextAnimationLast;\r\n                    current.trackLast = current.nextTrackLast;\r\n                    var currentDelta = delta * current.timeScale;\r\n                    if (current.delay > 0) {\r\n                        current.delay -= currentDelta;\r\n                        if (current.delay > 0)\r\n                            continue;\r\n                        currentDelta = -current.delay;\r\n                        current.delay = 0;\r\n                    }\r\n                    var next = current.next;\r\n                    if (next != null) {\r\n                        var nextTime = current.trackLast - next.delay;\r\n                        if (nextTime >= 0) {\r\n                            next.delay = 0;\r\n                            next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                            current.trackTime += currentDelta;\r\n                            this.setCurrent(i, next, true);\r\n                            while (next.mixingFrom != null) {\r\n                                next.mixTime += delta;\r\n                                next = next.mixingFrom;\r\n                            }\r\n                            continue;\r\n                        }\r\n                    }\r\n                    else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                        tracks[i] = null;\r\n                        this.queue.end(current);\r\n                        this.disposeNext(current);\r\n                        continue;\r\n                    }\r\n                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                        var from = current.mixingFrom;\r\n                        current.mixingFrom = null;\r\n                        if (from != null)\r\n                            from.mixingTo = null;\r\n                        while (from != null) {\r\n                            this.queue.end(from);\r\n                            from = from.mixingFrom;\r\n                        }\r\n                    }\r\n                    current.trackTime += currentDelta;\r\n                }\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n                var from = to.mixingFrom;\r\n                if (from == null)\r\n                    return true;\r\n                var finished = this.updateMixingFrom(from, delta);\r\n                from.animationLast = from.nextAnimationLast;\r\n                from.trackLast = from.nextTrackLast;\r\n                if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n                    if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                        to.mixingFrom = from.mixingFrom;\r\n                        if (from.mixingFrom != null)\r\n                            from.mixingFrom.mixingTo = to;\r\n                        to.interruptAlpha = from.interruptAlpha;\r\n                        this.queue.end(from);\r\n                    }\r\n                    return finished;\r\n                }\r\n                from.trackTime += delta * from.timeScale;\r\n                to.mixTime += delta;\r\n                return false;\r\n            };\r\n            AnimationState.prototype.apply = function (skeleton) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                if (this.animationsChanged)\r\n                    this._animationsChanged();\r\n                var events = this.events;\r\n                var tracks = this.tracks;\r\n                var applied = false;\r\n                for (var i_16 = 0, n_1 = tracks.length; i_16 < n_1; i_16++) {\r\n                    var current = tracks[i_16];\r\n                    if (current == null || current.delay > 0)\r\n                        continue;\r\n                    applied = true;\r\n                    var blend = i_16 == 0 ? core.MixBlend.first : current.mixBlend;\r\n                    var mix = current.alpha;\r\n                    if (current.mixingFrom != null)\r\n                        mix *= this.applyMixingFrom(current, skeleton, blend);\r\n                    else if (current.trackTime >= current.trackEnd && current.next == null)\r\n                        mix = 0;\r\n                    var animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n                    var timelineCount = current.animation.timelines.length;\r\n                    var timelines = current.animation.timelines;\r\n                    if ((i_16 == 0 && mix == 1) || blend == core.MixBlend.add) {\r\n                        for (var ii = 0; ii < timelineCount; ii++) {\r\n                            core.Utils.webkit602BugfixHelper(mix, blend);\r\n                            var timeline = timelines[ii];\r\n                            if (timeline instanceof core.AttachmentTimeline)\r\n                                this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                            else\r\n                                timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, core.MixDirection.mixIn);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var timelineMode = current.timelineMode;\r\n                        var firstFrame = current.timelinesRotation.length == 0;\r\n                        if (firstFrame)\r\n                            core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                        var timelinesRotation = current.timelinesRotation;\r\n                        for (var ii = 0; ii < timelineCount; ii++) {\r\n                            var timeline_1 = timelines[ii];\r\n                            var timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : core.MixBlend.setup;\r\n                            if (timeline_1 instanceof core.RotateTimeline) {\r\n                                this.applyRotateTimeline(timeline_1, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                            }\r\n                            else if (timeline_1 instanceof core.AttachmentTimeline) {\r\n                                this.applyAttachmentTimeline(timeline_1, skeleton, animationTime, blend, true);\r\n                            }\r\n                            else {\r\n                                core.Utils.webkit602BugfixHelper(mix, blend);\r\n                                timeline_1.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, core.MixDirection.mixIn);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.queueEvents(current, animationTime);\r\n                    events.length = 0;\r\n                    current.nextAnimationLast = animationTime;\r\n                    current.nextTrackLast = current.trackTime;\r\n                }\r\n                var setupState = this.unkeyedState + AnimationState.SETUP;\r\n                var slots = skeleton.slots;\r\n                for (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.attachmentState == setupState) {\r\n                        var attachmentName = slot.data.attachmentName;\r\n                        slot.attachment = (attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n                    }\r\n                }\r\n                this.unkeyedState += 2;\r\n                this.queue.drain();\r\n                return applied;\r\n            };\r\n            AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\r\n                var from = to.mixingFrom;\r\n                if (from.mixingFrom != null)\r\n                    this.applyMixingFrom(from, skeleton, blend);\r\n                var mix = 0;\r\n                if (to.mixDuration == 0) {\r\n                    mix = 1;\r\n                    if (blend == core.MixBlend.first)\r\n                        blend = core.MixBlend.setup;\r\n                }\r\n                else {\r\n                    mix = to.mixTime / to.mixDuration;\r\n                    if (mix > 1)\r\n                        mix = 1;\r\n                    if (blend != core.MixBlend.first)\r\n                        blend = from.mixBlend;\r\n                }\r\n                var events = mix < from.eventThreshold ? this.events : null;\r\n                var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n                var animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n                var timelineCount = from.animation.timelines.length;\r\n                var timelines = from.animation.timelines;\r\n                var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n                if (blend == core.MixBlend.add) {\r\n                    for (var i = 0; i < timelineCount; i++)\r\n                        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, core.MixDirection.mixOut);\r\n                }\r\n                else {\r\n                    var timelineMode = from.timelineMode;\r\n                    var timelineHoldMix = from.timelineHoldMix;\r\n                    var firstFrame = from.timelinesRotation.length == 0;\r\n                    if (firstFrame)\r\n                        core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n                    var timelinesRotation = from.timelinesRotation;\r\n                    from.totalAlpha = 0;\r\n                    for (var i = 0; i < timelineCount; i++) {\r\n                        var timeline = timelines[i];\r\n                        var direction = core.MixDirection.mixOut;\r\n                        var timelineBlend = void 0;\r\n                        var alpha = 0;\r\n                        switch (timelineMode[i]) {\r\n                            case AnimationState.SUBSEQUENT:\r\n                                if (!drawOrder && timeline instanceof core.DrawOrderTimeline)\r\n                                    continue;\r\n                                timelineBlend = blend;\r\n                                alpha = alphaMix;\r\n                                break;\r\n                            case AnimationState.FIRST:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                alpha = alphaMix;\r\n                                break;\r\n                            case AnimationState.HOLD_SUBSEQUENT:\r\n                                timelineBlend = blend;\r\n                                alpha = alphaHold;\r\n                                break;\r\n                            case AnimationState.HOLD_FIRST:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                alpha = alphaHold;\r\n                                break;\r\n                            default:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                var holdMix = timelineHoldMix[i];\r\n                                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                                break;\r\n                        }\r\n                        from.totalAlpha += alpha;\r\n                        if (timeline instanceof core.RotateTimeline)\r\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                        else if (timeline instanceof core.AttachmentTimeline)\r\n                            this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\r\n                        else {\r\n                            core.Utils.webkit602BugfixHelper(alpha, blend);\r\n                            if (drawOrder && timeline instanceof core.DrawOrderTimeline && timelineBlend == core.MixBlend.setup)\r\n                                direction = core.MixDirection.mixIn;\r\n                            timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                        }\r\n                    }\r\n                }\r\n                if (to.mixDuration > 0)\r\n                    this.queueEvents(from, animationTime);\r\n                this.events.length = 0;\r\n                from.nextAnimationLast = animationTime;\r\n                from.nextTrackLast = from.trackTime;\r\n                return mix;\r\n            };\r\n            AnimationState.prototype.applyAttachmentTimeline = function (timeline, skeleton, time, blend, attachments) {\r\n                var slot = skeleton.slots[timeline.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = timeline.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == core.MixBlend.setup || blend == core.MixBlend.first)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n                }\r\n                else {\r\n                    var frameIndex;\r\n                    if (time >= frames[frames.length - 1])\r\n                        frameIndex = frames.length - 1;\r\n                    else\r\n                        frameIndex = core.Animation.binarySearch(frames, time) - 1;\r\n                    this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\r\n                }\r\n                if (slot.attachmentState <= this.unkeyedState)\r\n                    slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\r\n            };\r\n            AnimationState.prototype.setAttachment = function (skeleton, slot, attachmentName, attachments) {\r\n                slot.attachment = attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName);\r\n                if (attachments)\r\n                    slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\r\n            };\r\n            AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\r\n                if (firstFrame)\r\n                    timelinesRotation[i] = 0;\r\n                if (alpha == 1) {\r\n                    timeline.apply(skeleton, 0, time, null, 1, blend, core.MixDirection.mixIn);\r\n                    return;\r\n                }\r\n                var rotateTimeline = timeline;\r\n                var frames = rotateTimeline.frames;\r\n                var bone = skeleton.bones[rotateTimeline.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                var r1 = 0, r2 = 0;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case core.MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation;\r\n                        default:\r\n                            return;\r\n                        case core.MixBlend.first:\r\n                            r1 = bone.rotation;\r\n                            r2 = bone.data.rotation;\r\n                    }\r\n                }\r\n                else {\r\n                    r1 = blend == core.MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n                    if (time >= frames[frames.length - core.RotateTimeline.ENTRIES])\r\n                        r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];\r\n                    else {\r\n                        var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);\r\n                        var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];\r\n                        var frameTime = frames[frame];\r\n                        var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));\r\n                        r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;\r\n                        r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                        r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                        r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                    }\r\n                }\r\n                var total = 0, diff = r2 - r1;\r\n                diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n                if (diff == 0) {\r\n                    total = timelinesRotation[i];\r\n                }\r\n                else {\r\n                    var lastTotal = 0, lastDiff = 0;\r\n                    if (firstFrame) {\r\n                        lastTotal = 0;\r\n                        lastDiff = diff;\r\n                    }\r\n                    else {\r\n                        lastTotal = timelinesRotation[i];\r\n                        lastDiff = timelinesRotation[i + 1];\r\n                    }\r\n                    var current = diff > 0, dir = lastTotal >= 0;\r\n                    if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                        if (Math.abs(lastTotal) > 180)\r\n                            lastTotal += 360 * core.MathUtils.signum(lastTotal);\r\n                        dir = current;\r\n                    }\r\n                    total = diff + lastTotal - lastTotal % 360;\r\n                    if (dir != current)\r\n                        total += 360 * core.MathUtils.signum(lastTotal);\r\n                    timelinesRotation[i] = total;\r\n                }\r\n                timelinesRotation[i + 1] = diff;\r\n                r1 += total * alpha;\r\n                bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n            };\r\n            AnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n                var duration = animationEnd - animationStart;\r\n                var trackLastWrapped = entry.trackLast % duration;\r\n                var events = this.events;\r\n                var i = 0, n = events.length;\r\n                for (; i < n; i++) {\r\n                    var event_1 = events[i];\r\n                    if (event_1.time < trackLastWrapped)\r\n                        break;\r\n                    if (event_1.time > animationEnd)\r\n                        continue;\r\n                    this.queue.event(entry, event_1);\r\n                }\r\n                var complete = false;\r\n                if (entry.loop)\r\n                    complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n                else\r\n                    complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n                if (complete)\r\n                    this.queue.complete(entry);\r\n                for (; i < n; i++) {\r\n                    var event_2 = events[i];\r\n                    if (event_2.time < animationStart)\r\n                        continue;\r\n                    this.queue.event(entry, events[i]);\r\n                }\r\n            };\r\n            AnimationState.prototype.clearTracks = function () {\r\n                var oldDrainDisabled = this.queue.drainDisabled;\r\n                this.queue.drainDisabled = true;\r\n                for (var i = 0, n = this.tracks.length; i < n; i++)\r\n                    this.clearTrack(i);\r\n                this.tracks.length = 0;\r\n                this.queue.drainDisabled = oldDrainDisabled;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.clearTrack = function (trackIndex) {\r\n                if (trackIndex >= this.tracks.length)\r\n                    return;\r\n                var current = this.tracks[trackIndex];\r\n                if (current == null)\r\n                    return;\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                var entry = current;\r\n                while (true) {\r\n                    var from = entry.mixingFrom;\r\n                    if (from == null)\r\n                        break;\r\n                    this.queue.end(from);\r\n                    entry.mixingFrom = null;\r\n                    entry.mixingTo = null;\r\n                    entry = from;\r\n                }\r\n                this.tracks[current.trackIndex] = null;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n                var from = this.expandToIndex(index);\r\n                this.tracks[index] = current;\r\n                if (from != null) {\r\n                    if (interrupt)\r\n                        this.queue.interrupt(from);\r\n                    current.mixingFrom = from;\r\n                    from.mixingTo = current;\r\n                    current.mixTime = 0;\r\n                    if (from.mixingFrom != null && from.mixDuration > 0)\r\n                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n                    from.timelinesRotation.length = 0;\r\n                }\r\n                this.queue.start(current);\r\n            };\r\n            AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                if (animation == null)\r\n                    throw new Error(\"Animation not found: \" + animationName);\r\n                return this.setAnimationWith(trackIndex, animation, loop);\r\n            };\r\n            AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n                if (animation == null)\r\n                    throw new Error(\"animation cannot be null.\");\r\n                var interrupt = true;\r\n                var current = this.expandToIndex(trackIndex);\r\n                if (current != null) {\r\n                    if (current.nextTrackLast == -1) {\r\n                        this.tracks[trackIndex] = current.mixingFrom;\r\n                        this.queue.interrupt(current);\r\n                        this.queue.end(current);\r\n                        this.disposeNext(current);\r\n                        current = current.mixingFrom;\r\n                        interrupt = false;\r\n                    }\r\n                    else\r\n                        this.disposeNext(current);\r\n                }\r\n                var entry = this.trackEntry(trackIndex, animation, loop, current);\r\n                this.setCurrent(trackIndex, entry, interrupt);\r\n                this.queue.drain();\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                if (animation == null)\r\n                    throw new Error(\"Animation not found: \" + animationName);\r\n                return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n            };\r\n            AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n                if (animation == null)\r\n                    throw new Error(\"animation cannot be null.\");\r\n                var last = this.expandToIndex(trackIndex);\r\n                if (last != null) {\r\n                    while (last.next != null)\r\n                        last = last.next;\r\n                }\r\n                var entry = this.trackEntry(trackIndex, animation, loop, last);\r\n                if (last == null) {\r\n                    this.setCurrent(trackIndex, entry, true);\r\n                    this.queue.drain();\r\n                }\r\n                else {\r\n                    last.next = entry;\r\n                    if (delay <= 0) {\r\n                        var duration = last.animationEnd - last.animationStart;\r\n                        if (duration != 0) {\r\n                            if (last.loop)\r\n                                delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                            else\r\n                                delay += Math.max(duration, last.trackTime);\r\n                            delay -= this.data.getMix(last.animation, animation);\r\n                        }\r\n                        else\r\n                            delay = last.trackTime;\r\n                    }\r\n                }\r\n                entry.delay = delay;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n                entry.mixDuration = mixDuration;\r\n                entry.trackEnd = mixDuration;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n                if (delay <= 0)\r\n                    delay -= mixDuration;\r\n                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n                entry.mixDuration = mixDuration;\r\n                entry.trackEnd = mixDuration;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n                var oldDrainDisabled = this.queue.drainDisabled;\r\n                this.queue.drainDisabled = true;\r\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                    var current = this.tracks[i];\r\n                    if (current != null)\r\n                        this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n                }\r\n                this.queue.drainDisabled = oldDrainDisabled;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.expandToIndex = function (index) {\r\n                if (index < this.tracks.length)\r\n                    return this.tracks[index];\r\n                core.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n                this.tracks.length = index + 1;\r\n                return null;\r\n            };\r\n            AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n                var entry = this.trackEntryPool.obtain();\r\n                entry.trackIndex = trackIndex;\r\n                entry.animation = animation;\r\n                entry.loop = loop;\r\n                entry.holdPrevious = false;\r\n                entry.eventThreshold = 0;\r\n                entry.attachmentThreshold = 0;\r\n                entry.drawOrderThreshold = 0;\r\n                entry.animationStart = 0;\r\n                entry.animationEnd = animation.duration;\r\n                entry.animationLast = -1;\r\n                entry.nextAnimationLast = -1;\r\n                entry.delay = 0;\r\n                entry.trackTime = 0;\r\n                entry.trackLast = -1;\r\n                entry.nextTrackLast = -1;\r\n                entry.trackEnd = Number.MAX_VALUE;\r\n                entry.timeScale = 1;\r\n                entry.alpha = 1;\r\n                entry.interruptAlpha = 1;\r\n                entry.mixTime = 0;\r\n                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n                entry.mixBlend = core.MixBlend.replace;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.disposeNext = function (entry) {\r\n                var next = entry.next;\r\n                while (next != null) {\r\n                    this.queue.dispose(next);\r\n                    next = next.next;\r\n                }\r\n                entry.next = null;\r\n            };\r\n            AnimationState.prototype._animationsChanged = function () {\r\n                this.animationsChanged = false;\r\n                this.propertyIDs.clear();\r\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                    var entry = this.tracks[i];\r\n                    if (entry == null)\r\n                        continue;\r\n                    while (entry.mixingFrom != null)\r\n                        entry = entry.mixingFrom;\r\n                    do {\r\n                        if (entry.mixingFrom == null || entry.mixBlend != core.MixBlend.add)\r\n                            this.computeHold(entry);\r\n                        entry = entry.mixingTo;\r\n                    } while (entry != null);\r\n                }\r\n            };\r\n            AnimationState.prototype.computeHold = function (entry) {\r\n                var to = entry.mixingTo;\r\n                var timelines = entry.animation.timelines;\r\n                var timelinesCount = entry.animation.timelines.length;\r\n                var timelineMode = core.Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n                entry.timelineHoldMix.length = 0;\r\n                var timelineDipMix = core.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n                var propertyIDs = this.propertyIDs;\r\n                if (to != null && to.holdPrevious) {\r\n                    for (var i = 0; i < timelinesCount; i++) {\r\n                        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\r\n                    }\r\n                    return;\r\n                }\r\n                outer: for (var i = 0; i < timelinesCount; i++) {\r\n                    var timeline = timelines[i];\r\n                    var id = timeline.getPropertyId();\r\n                    if (!propertyIDs.add(id))\r\n                        timelineMode[i] = AnimationState.SUBSEQUENT;\r\n                    else if (to == null || timeline instanceof core.AttachmentTimeline || timeline instanceof core.DrawOrderTimeline\r\n                        || timeline instanceof core.EventTimeline || !to.animation.hasTimeline(id)) {\r\n                        timelineMode[i] = AnimationState.FIRST;\r\n                    }\r\n                    else {\r\n                        for (var next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                            if (next.animation.hasTimeline(id))\r\n                                continue;\r\n                            if (entry.mixDuration > 0) {\r\n                                timelineMode[i] = AnimationState.HOLD_MIX;\r\n                                timelineDipMix[i] = next;\r\n                                continue outer;\r\n                            }\r\n                            break;\r\n                        }\r\n                        timelineMode[i] = AnimationState.HOLD_FIRST;\r\n                    }\r\n                }\r\n            };\r\n            AnimationState.prototype.getCurrent = function (trackIndex) {\r\n                if (trackIndex >= this.tracks.length)\r\n                    return null;\r\n                return this.tracks[trackIndex];\r\n            };\r\n            AnimationState.prototype.addListener = function (listener) {\r\n                if (listener == null)\r\n                    throw new Error(\"listener cannot be null.\");\r\n                this.listeners.push(listener);\r\n            };\r\n            AnimationState.prototype.removeListener = function (listener) {\r\n                var index = this.listeners.indexOf(listener);\r\n                if (index >= 0)\r\n                    this.listeners.splice(index, 1);\r\n            };\r\n            AnimationState.prototype.clearListeners = function () {\r\n                this.listeners.length = 0;\r\n            };\r\n            AnimationState.prototype.clearListenerNotifications = function () {\r\n                this.queue.clear();\r\n            };\r\n            AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {\r\n                if (!AnimationState.deprecatedWarning1) {\r\n                    AnimationState.deprecatedWarning1 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n                }\r\n                this.setAnimation(trackIndex, animationName, loop);\r\n            };\r\n            AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {\r\n                if (!AnimationState.deprecatedWarning2) {\r\n                    AnimationState.deprecatedWarning2 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n                }\r\n                this.addAnimation(trackIndex, animationName, loop, delay);\r\n            };\r\n            AnimationState.prototype.hasAnimation = function (animationName) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                return animation !== null;\r\n            };\r\n            AnimationState.prototype.hasAnimationByName = function (animationName) {\r\n                if (!AnimationState.deprecatedWarning3) {\r\n                    AnimationState.deprecatedWarning3 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n                }\r\n                return this.hasAnimation(animationName);\r\n            };\r\n            AnimationState.emptyAnimation = new core.Animation(\"<empty>\", [], 0);\r\n            AnimationState.SUBSEQUENT = 0;\r\n            AnimationState.FIRST = 1;\r\n            AnimationState.HOLD_SUBSEQUENT = 2;\r\n            AnimationState.HOLD_FIRST = 3;\r\n            AnimationState.HOLD_MIX = 4;\r\n            AnimationState.SETUP = 1;\r\n            AnimationState.CURRENT = 2;\r\n            AnimationState.deprecatedWarning1 = false;\r\n            AnimationState.deprecatedWarning2 = false;\r\n            AnimationState.deprecatedWarning3 = false;\r\n            return AnimationState;\r\n        }());\r\n        core.AnimationState = AnimationState;\r\n        var TrackEntry = (function () {\r\n            function TrackEntry() {\r\n                this.mixBlend = core.MixBlend.replace;\r\n                this.timelineMode = new Array();\r\n                this.timelineHoldMix = new Array();\r\n                this.timelinesRotation = new Array();\r\n            }\r\n            TrackEntry.prototype.reset = function () {\r\n                this.next = null;\r\n                this.mixingFrom = null;\r\n                this.mixingTo = null;\r\n                this.animation = null;\r\n                this.listener = null;\r\n                this.timelineMode.length = 0;\r\n                this.timelineHoldMix.length = 0;\r\n                this.timelinesRotation.length = 0;\r\n            };\r\n            TrackEntry.prototype.getAnimationTime = function () {\r\n                if (this.loop) {\r\n                    var duration = this.animationEnd - this.animationStart;\r\n                    if (duration == 0)\r\n                        return this.animationStart;\r\n                    return (this.trackTime % duration) + this.animationStart;\r\n                }\r\n                return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n            };\r\n            TrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n                this.animationLast = animationLast;\r\n                this.nextAnimationLast = animationLast;\r\n            };\r\n            TrackEntry.prototype.isComplete = function () {\r\n                return this.trackTime >= this.animationEnd - this.animationStart;\r\n            };\r\n            TrackEntry.prototype.resetRotationDirections = function () {\r\n                this.timelinesRotation.length = 0;\r\n            };\r\n            Object.defineProperty(TrackEntry.prototype, \"time\", {\r\n                get: function () {\r\n                    if (!TrackEntry.deprecatedWarning1) {\r\n                        TrackEntry.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n                    }\r\n                    return this.trackTime;\r\n                },\r\n                set: function (value) {\r\n                    if (!TrackEntry.deprecatedWarning1) {\r\n                        TrackEntry.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n                    }\r\n                    this.trackTime = value;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TrackEntry.prototype, \"endTime\", {\r\n                get: function () {\r\n                    if (!TrackEntry.deprecatedWarning2) {\r\n                        TrackEntry.deprecatedWarning2 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n                    }\r\n                    return this.trackTime;\r\n                },\r\n                set: function (value) {\r\n                    if (!TrackEntry.deprecatedWarning2) {\r\n                        TrackEntry.deprecatedWarning2 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n                    }\r\n                    this.trackTime = value;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            TrackEntry.prototype.loopsCount = function () {\r\n                return Math.floor(this.trackTime / this.trackEnd);\r\n            };\r\n            TrackEntry.deprecatedWarning1 = false;\r\n            TrackEntry.deprecatedWarning2 = false;\r\n            return TrackEntry;\r\n        }());\r\n        core.TrackEntry = TrackEntry;\r\n        var EventQueue = (function () {\r\n            function EventQueue(animState) {\r\n                this.objects = [];\r\n                this.drainDisabled = false;\r\n                this.animState = animState;\r\n            }\r\n            EventQueue.prototype.start = function (entry) {\r\n                this.objects.push(EventType.start);\r\n                this.objects.push(entry);\r\n                this.animState.animationsChanged = true;\r\n            };\r\n            EventQueue.prototype.interrupt = function (entry) {\r\n                this.objects.push(EventType.interrupt);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.end = function (entry) {\r\n                this.objects.push(EventType.end);\r\n                this.objects.push(entry);\r\n                this.animState.animationsChanged = true;\r\n            };\r\n            EventQueue.prototype.dispose = function (entry) {\r\n                this.objects.push(EventType.dispose);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.complete = function (entry) {\r\n                this.objects.push(EventType.complete);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.event = function (entry, event) {\r\n                this.objects.push(EventType.event);\r\n                this.objects.push(entry);\r\n                this.objects.push(event);\r\n            };\r\n            EventQueue.prototype.deprecateStuff = function () {\r\n                if (!EventQueue.deprecatedWarning1) {\r\n                    EventQueue.deprecatedWarning1 = true;\r\n                    console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\r\n                }\r\n                return true;\r\n            };\r\n            EventQueue.prototype.drain = function () {\r\n                if (this.drainDisabled)\r\n                    return;\r\n                this.drainDisabled = true;\r\n                var objects = this.objects;\r\n                var listeners = this.animState.listeners;\r\n                for (var i = 0; i < objects.length; i += 2) {\r\n                    var type = objects[i];\r\n                    var entry = objects[i + 1];\r\n                    switch (type) {\r\n                        case EventType.start:\r\n                            if (entry.listener != null && entry.listener.start)\r\n                                entry.listener.start(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].start)\r\n                                    listeners[ii].start(entry);\r\n                            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\r\n                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\r\n                            break;\r\n                        case EventType.interrupt:\r\n                            if (entry.listener != null && entry.listener.interrupt)\r\n                                entry.listener.interrupt(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].interrupt)\r\n                                    listeners[ii].interrupt(entry);\r\n                            break;\r\n                        case EventType.end:\r\n                            if (entry.listener != null && entry.listener.end)\r\n                                entry.listener.end(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].end)\r\n                                    listeners[ii].end(entry);\r\n                            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\r\n                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\r\n                        case EventType.dispose:\r\n                            if (entry.listener != null && entry.listener.dispose)\r\n                                entry.listener.dispose(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].dispose)\r\n                                    listeners[ii].dispose(entry);\r\n                            this.animState.trackEntryPool.free(entry);\r\n                            break;\r\n                        case EventType.complete:\r\n                            if (entry.listener != null && entry.listener.complete)\r\n                                entry.listener.complete(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].complete)\r\n                                    listeners[ii].complete(entry);\r\n                            var count = core.MathUtils.toInt(entry.loopsCount());\r\n                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\r\n                            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\r\n                            break;\r\n                        case EventType.event:\r\n                            var event_3 = objects[i++ + 2];\r\n                            if (entry.listener != null && entry.listener.event)\r\n                                entry.listener.event(entry, event_3);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].event)\r\n                                    listeners[ii].event(entry, event_3);\r\n                            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);\r\n                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);\r\n                            break;\r\n                    }\r\n                }\r\n                this.clear();\r\n                this.drainDisabled = false;\r\n            };\r\n            EventQueue.prototype.clear = function () {\r\n                this.objects.length = 0;\r\n            };\r\n            EventQueue.deprecatedWarning1 = false;\r\n            return EventQueue;\r\n        }());\r\n        core.EventQueue = EventQueue;\r\n        var EventType;\r\n        (function (EventType) {\r\n            EventType[EventType[\"start\"] = 0] = \"start\";\r\n            EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n            EventType[EventType[\"end\"] = 2] = \"end\";\r\n            EventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n            EventType[EventType[\"complete\"] = 4] = \"complete\";\r\n            EventType[EventType[\"event\"] = 5] = \"event\";\r\n        })(EventType = core.EventType || (core.EventType = {}));\r\n        var AnimationStateAdapter = (function () {\r\n            function AnimationStateAdapter() {\r\n            }\r\n            AnimationStateAdapter.prototype.start = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.interrupt = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.end = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.dispose = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.complete = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.event = function (entry, event) {\r\n            };\r\n            return AnimationStateAdapter;\r\n        }());\r\n        core.AnimationStateAdapter = AnimationStateAdapter;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AnimationStateData = (function () {\r\n            function AnimationStateData(skeletonData) {\r\n                this.animationToMixTime = {};\r\n                this.defaultMix = 0;\r\n                if (skeletonData == null)\r\n                    throw new Error(\"skeletonData cannot be null.\");\r\n                this.skeletonData = skeletonData;\r\n            }\r\n            AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n                var from = this.skeletonData.findAnimation(fromName);\r\n                if (from == null)\r\n                    throw new Error(\"Animation not found: \" + fromName);\r\n                var to = this.skeletonData.findAnimation(toName);\r\n                if (to == null)\r\n                    throw new Error(\"Animation not found: \" + toName);\r\n                this.setMixWith(from, to, duration);\r\n            };\r\n            AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {\r\n                if (!AnimationStateData.deprecatedWarning1) {\r\n                    AnimationStateData.deprecatedWarning1 = true;\r\n                    console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\r\n                }\r\n                this.setMix(fromName, toName, duration);\r\n            };\r\n            AnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n                if (from == null)\r\n                    throw new Error(\"from cannot be null.\");\r\n                if (to == null)\r\n                    throw new Error(\"to cannot be null.\");\r\n                var key = from.name + \".\" + to.name;\r\n                this.animationToMixTime[key] = duration;\r\n            };\r\n            AnimationStateData.prototype.getMix = function (from, to) {\r\n                var key = from.name + \".\" + to.name;\r\n                var value = this.animationToMixTime[key];\r\n                return value === undefined ? this.defaultMix : value;\r\n            };\r\n            AnimationStateData.deprecatedWarning1 = false;\r\n            return AnimationStateData;\r\n        }());\r\n        core.AnimationStateData = AnimationStateData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AtlasAttachmentLoader = (function () {\r\n            function AtlasAttachmentLoader(atlas) {\r\n                this.atlas = atlas;\r\n            }\r\n            AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n                var region = this.atlas.findRegion(path);\r\n                if (region == null)\r\n                    throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n                var attachment = new core.RegionAttachment(name);\r\n                attachment.region = region;\r\n                return attachment;\r\n            };\r\n            AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n                var region = this.atlas.findRegion(path);\r\n                if (region == null)\r\n                    throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n                var attachment = new core.MeshAttachment(name);\r\n                attachment.region = region;\r\n                return attachment;\r\n            };\r\n            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n                return new core.BoundingBoxAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n                return new core.PathAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n                return new core.PointAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n                return new core.ClippingAttachment(name);\r\n            };\r\n            return AtlasAttachmentLoader;\r\n        }());\r\n        core.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BlendMode;\r\n        (function (BlendMode) {\r\n            BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n            BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n            BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n            BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n        })(BlendMode = core.BlendMode || (core.BlendMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Bone = (function () {\r\n            function Bone(data, skeleton, parent) {\r\n                this.matrix = new PIXI.Matrix();\r\n                this.children = new Array();\r\n                this.x = 0;\r\n                this.y = 0;\r\n                this.rotation = 0;\r\n                this.scaleX = 0;\r\n                this.scaleY = 0;\r\n                this.shearX = 0;\r\n                this.shearY = 0;\r\n                this.ax = 0;\r\n                this.ay = 0;\r\n                this.arotation = 0;\r\n                this.ascaleX = 0;\r\n                this.ascaleY = 0;\r\n                this.ashearX = 0;\r\n                this.ashearY = 0;\r\n                this.appliedValid = false;\r\n                this.sorted = false;\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.skeleton = skeleton;\r\n                this.parent = parent;\r\n                this.setToSetupPose();\r\n            }\r\n            Object.defineProperty(Bone.prototype, \"worldX\", {\r\n                get: function () {\r\n                    return this.matrix.tx;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(Bone.prototype, \"worldY\", {\r\n                get: function () {\r\n                    return this.matrix.ty;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Bone.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            Bone.prototype.update = function () {\r\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n            };\r\n            Bone.prototype.updateWorldTransform = function () {\r\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n            };\r\n            Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n                this.ax = x;\r\n                this.ay = y;\r\n                this.arotation = rotation;\r\n                this.ascaleX = scaleX;\r\n                this.ascaleY = scaleY;\r\n                this.ashearX = shearX;\r\n                this.ashearY = shearY;\r\n                this.appliedValid = true;\r\n                var parent = this.parent;\r\n                var m = this.matrix;\r\n                var sx = this.skeleton.scaleX;\r\n                var sy = Bone.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n                if (parent == null) {\r\n                    var skeleton = this.skeleton;\r\n                    var rotationY = rotation + 90 + shearY;\r\n                    m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n                    m.c = core.MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n                    m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n                    m.d = core.MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n                    m.tx = x * sx + skeleton.x;\r\n                    m.ty = y * sy + skeleton.y;\r\n                    return;\r\n                }\r\n                var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n                m.tx = pa * x + pb * y + parent.matrix.tx;\r\n                m.ty = pc * x + pd * y + parent.matrix.ty;\r\n                switch (this.data.transformMode) {\r\n                    case core.TransformMode.Normal: {\r\n                        var rotationY = rotation + 90 + shearY;\r\n                        var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\r\n                        m.a = pa * la + pb * lc;\r\n                        m.c = pa * lb + pb * ld;\r\n                        m.b = pc * la + pd * lc;\r\n                        m.d = pc * lb + pd * ld;\r\n                        return;\r\n                    }\r\n                    case core.TransformMode.OnlyTranslation: {\r\n                        var rotationY = rotation + 90 + shearY;\r\n                        m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                        m.c = core.MathUtils.cosDeg(rotationY) * scaleY;\r\n                        m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                        m.d = core.MathUtils.sinDeg(rotationY) * scaleY;\r\n                        break;\r\n                    }\r\n                    case core.TransformMode.NoRotationOrReflection: {\r\n                        var s = pa * pa + pc * pc;\r\n                        var prx = 0;\r\n                        if (s > 0.0001) {\r\n                            s = Math.abs(pa * pd - pb * pc) / s;\r\n                            pa /= this.skeleton.scaleX;\r\n                            pc /= this.skeleton.scaleY;\r\n                            pb = pc * s;\r\n                            pd = pa * s;\r\n                            prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;\r\n                        }\r\n                        else {\r\n                            pa = 0;\r\n                            pc = 0;\r\n                            prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;\r\n                        }\r\n                        var rx = rotation + shearX - prx;\r\n                        var ry = rotation + shearY - prx + 90;\r\n                        var la = core.MathUtils.cosDeg(rx) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(ry) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(rx) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(ry) * scaleY;\r\n                        m.a = pa * la - pb * lc;\r\n                        m.c = pa * lb - pb * ld;\r\n                        m.b = pc * la + pd * lc;\r\n                        m.d = pc * lb + pd * ld;\r\n                        break;\r\n                    }\r\n                    case core.TransformMode.NoScale:\r\n                    case core.TransformMode.NoScaleOrReflection: {\r\n                        var cos = core.MathUtils.cosDeg(rotation);\r\n                        var sin = core.MathUtils.sinDeg(rotation);\r\n                        var za = (pa * cos + pb * sin) / sx;\r\n                        var zc = (pc * cos + pd * sin) / sy;\r\n                        var s = Math.sqrt(za * za + zc * zc);\r\n                        if (s > 0.00001)\r\n                            s = 1 / s;\r\n                        za *= s;\r\n                        zc *= s;\r\n                        s = Math.sqrt(za * za + zc * zc);\r\n                        if (this.data.transformMode == core.TransformMode.NoScale\r\n                            && (pa * pd - pb * pc < 0) != (Bone.yDown ?\r\n                                (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\r\n                                (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)))\r\n                            s = -s;\r\n                        var r = Math.PI / 2 + Math.atan2(zc, za);\r\n                        var zb = Math.cos(r) * s;\r\n                        var zd = Math.sin(r) * s;\r\n                        var la = core.MathUtils.cosDeg(shearX) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(shearX) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                        m.a = za * la + zb * lc;\r\n                        m.c = za * lb + zb * ld;\r\n                        m.b = zc * la + zd * lc;\r\n                        m.d = zc * lb + zd * ld;\r\n                        break;\r\n                    }\r\n                }\r\n                m.a *= sx;\r\n                m.c *= sx;\r\n                m.b *= sy;\r\n                m.d *= sy;\r\n            };\r\n            Bone.prototype.setToSetupPose = function () {\r\n                var data = this.data;\r\n                this.x = data.x;\r\n                this.y = data.y;\r\n                this.rotation = data.rotation;\r\n                this.scaleX = data.scaleX;\r\n                this.scaleY = data.scaleY;\r\n                this.shearX = data.shearX;\r\n                this.shearY = data.shearY;\r\n            };\r\n            Bone.prototype.getWorldRotationX = function () {\r\n                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.getWorldRotationY = function () {\r\n                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.getWorldScaleX = function () {\r\n                var m = this.matrix;\r\n                return Math.sqrt(m.a * m.a + m.c * m.c);\r\n            };\r\n            Bone.prototype.getWorldScaleY = function () {\r\n                var m = this.matrix;\r\n                return Math.sqrt(m.b * m.b + m.d * m.d);\r\n            };\r\n            Bone.prototype.updateAppliedTransform = function () {\r\n                this.appliedValid = true;\r\n                var parent = this.parent;\r\n                var m = this.matrix;\r\n                if (parent == null) {\r\n                    this.ax = m.tx;\r\n                    this.ay = m.ty;\r\n                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;\r\n                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n                    this.ashearX = 0;\r\n                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;\r\n                    return;\r\n                }\r\n                var pm = parent.matrix;\r\n                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n                var dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n                this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n                this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n                var ia = pid * pm.d;\r\n                var id = pid * pm.a;\r\n                var ib = pid * pm.c;\r\n                var ic = pid * pm.b;\r\n                var ra = ia * m.a - ib * m.b;\r\n                var rb = ia * m.c - ib * m.d;\r\n                var rc = id * m.b - ic * m.a;\r\n                var rd = id * m.d - ic * m.c;\r\n                this.ashearX = 0;\r\n                this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n                if (this.ascaleX > 0.0001) {\r\n                    var det = ra * rd - rb * rc;\r\n                    this.ascaleY = det / this.ascaleX;\r\n                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;\r\n                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;\r\n                }\r\n                else {\r\n                    this.ascaleX = 0;\r\n                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n                    this.ashearY = 0;\r\n                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;\r\n                }\r\n            };\r\n            Bone.prototype.worldToLocal = function (world) {\r\n                var m = this.matrix;\r\n                var a = m.a, b = m.c, c = m.b, d = m.d;\r\n                var invDet = 1 / (a * d - b * c);\r\n                var x = world.x - m.tx, y = world.y - m.ty;\r\n                world.x = (x * d * invDet - y * b * invDet);\r\n                world.y = (y * a * invDet - x * c * invDet);\r\n                return world;\r\n            };\r\n            Bone.prototype.localToWorld = function (local) {\r\n                var m = this.matrix;\r\n                var x = local.x, y = local.y;\r\n                local.x = x * m.a + y * m.c + m.tx;\r\n                local.y = x * m.b + y * m.d + m.ty;\r\n                return local;\r\n            };\r\n            Bone.prototype.worldToLocalRotation = function (worldRotation) {\r\n                var sin = core.MathUtils.sinDeg(worldRotation), cos = core.MathUtils.cosDeg(worldRotation);\r\n                var mat = this.matrix;\r\n                return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.localToWorldRotation = function (localRotation) {\r\n                var sin = core.MathUtils.sinDeg(localRotation), cos = core.MathUtils.cosDeg(localRotation);\r\n                var mat = this.matrix;\r\n                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.rotateWorld = function (degrees) {\r\n                var mat = this.matrix;\r\n                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                var cos = core.MathUtils.cosDeg(degrees), sin = core.MathUtils.sinDeg(degrees);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                this.appliedValid = false;\r\n            };\r\n            Bone.yDown = false;\r\n            return Bone;\r\n        }());\r\n        core.Bone = Bone;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BoneData = (function () {\r\n            function BoneData(index, name, parent) {\r\n                this.x = 0;\r\n                this.y = 0;\r\n                this.rotation = 0;\r\n                this.scaleX = 1;\r\n                this.scaleY = 1;\r\n                this.shearX = 0;\r\n                this.shearY = 0;\r\n                this.transformMode = TransformMode.Normal;\r\n                this.skinRequired = false;\r\n                this.color = new core.Color();\r\n                if (index < 0)\r\n                    throw new Error(\"index must be >= 0.\");\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.index = index;\r\n                this.name = name;\r\n                this.parent = parent;\r\n            }\r\n            return BoneData;\r\n        }());\r\n        core.BoneData = BoneData;\r\n        var TransformMode;\r\n        (function (TransformMode) {\r\n            TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n            TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n            TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n            TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n            TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n        })(TransformMode = core.TransformMode || (core.TransformMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var ConstraintData = (function () {\r\n            function ConstraintData(name, order, skinRequired) {\r\n                this.name = name;\r\n                this.order = order;\r\n                this.skinRequired = skinRequired;\r\n            }\r\n            return ConstraintData;\r\n        }());\r\n        core.ConstraintData = ConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Event = (function () {\r\n            function Event(time, data) {\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                this.time = time;\r\n                this.data = data;\r\n            }\r\n            return Event;\r\n        }());\r\n        core.Event = Event;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var EventData = (function () {\r\n            function EventData(name) {\r\n                this.name = name;\r\n            }\r\n            return EventData;\r\n        }());\r\n        core.EventData = EventData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IkConstraint = (function () {\r\n            function IkConstraint(data, skeleton) {\r\n                this.bendDirection = 0;\r\n                this.compress = false;\r\n                this.stretch = false;\r\n                this.mix = 1;\r\n                this.softness = 0;\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.mix = data.mix;\r\n                this.softness = data.softness;\r\n                this.bendDirection = data.bendDirection;\r\n                this.compress = data.compress;\r\n                this.stretch = data.stretch;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findBone(data.target.name);\r\n            }\r\n            IkConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            IkConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            IkConstraint.prototype.update = function () {\r\n                var target = this.target;\r\n                var bones = this.bones;\r\n                switch (bones.length) {\r\n                    case 1:\r\n                        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                        break;\r\n                    case 2:\r\n                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n                        break;\r\n                }\r\n            };\r\n            IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\r\n                if (!bone.appliedValid)\r\n                    bone.updateAppliedTransform();\r\n                var p = bone.parent.matrix;\r\n                var pa = p.a, pb = p.c, pc = p.b, pd = p.d;\r\n                var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n                switch (bone.data.transformMode) {\r\n                    case core.TransformMode.OnlyTranslation:\r\n                        tx = targetX - bone.worldX;\r\n                        ty = targetY - bone.worldY;\r\n                        break;\r\n                    case core.TransformMode.NoRotationOrReflection:\r\n                        var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                        var sa = pa / bone.skeleton.scaleX;\r\n                        var sc = pc / bone.skeleton.scaleY;\r\n                        pb = -sc * s * bone.skeleton.scaleX;\r\n                        pd = sa * s * bone.skeleton.scaleY;\r\n                        rotationIK += Math.atan2(sc, sa) * core.MathUtils.radDeg;\r\n                    default:\r\n                        var x = targetX - p.tx, y = targetY - p.ty;\r\n                        var d = pa * pd - pb * pc;\r\n                        tx = (x * pd - y * pb) / d - bone.ax;\r\n                        ty = (y * pa - x * pc) / d - bone.ay;\r\n                }\r\n                rotationIK += Math.atan2(ty, tx) * core.MathUtils.radDeg;\r\n                if (bone.ascaleX < 0)\r\n                    rotationIK += 180;\r\n                if (rotationIK > 180)\r\n                    rotationIK -= 360;\r\n                else if (rotationIK < -180)\r\n                    rotationIK += 360;\r\n                var sx = bone.ascaleX, sy = bone.ascaleY;\r\n                if (compress || stretch) {\r\n                    switch (bone.data.transformMode) {\r\n                        case core.TransformMode.NoScale:\r\n                        case core.TransformMode.NoScaleOrReflection:\r\n                            tx = targetX - bone.worldX;\r\n                            ty = targetY - bone.worldY;\r\n                    }\r\n                    var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n                    if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                        var s = (dd / b - 1) * alpha + 1;\r\n                        sx *= s;\r\n                        if (uniform)\r\n                            sy *= s;\r\n                    }\r\n                }\r\n                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n            };\r\n            IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\r\n                if (alpha == 0) {\r\n                    child.updateWorldTransform();\r\n                    return;\r\n                }\r\n                if (!parent.appliedValid)\r\n                    parent.updateAppliedTransform();\r\n                if (!child.appliedValid)\r\n                    child.updateAppliedTransform();\r\n                var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n                var pmat = parent.matrix;\r\n                var os1 = 0, os2 = 0, s2 = 0;\r\n                if (psx < 0) {\r\n                    psx = -psx;\r\n                    os1 = 180;\r\n                    s2 = -1;\r\n                }\r\n                else {\r\n                    os1 = 0;\r\n                    s2 = 1;\r\n                }\r\n                if (psy < 0) {\r\n                    psy = -psy;\r\n                    s2 = -s2;\r\n                }\r\n                if (csx < 0) {\r\n                    csx = -csx;\r\n                    os2 = 180;\r\n                }\r\n                else\r\n                    os2 = 0;\r\n                var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n                var u = Math.abs(psx - psy) <= 0.0001;\r\n                if (!u) {\r\n                    cy = 0;\r\n                    cwx = a * cx + pmat.tx;\r\n                    cwy = c * cx + pmat.ty;\r\n                }\r\n                else {\r\n                    cy = child.ay;\r\n                    cwx = a * cx + b * cy + pmat.tx;\r\n                    cwy = c * cx + d * cy + pmat.ty;\r\n                }\r\n                var pp = parent.parent.matrix;\r\n                a = pp.a;\r\n                b = pp.c;\r\n                c = pp.b;\r\n                d = pp.d;\r\n                var id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\r\n                var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n                var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n                if (l1 < 0.0001) {\r\n                    this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n                    child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n                    return;\r\n                }\r\n                x = targetX - pp.tx;\r\n                y = targetY - pp.ty;\r\n                var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n                var dd = tx * tx + ty * ty;\r\n                if (softness != 0) {\r\n                    softness *= psx * (csx + 1) / 2;\r\n                    var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n                    if (sd > 0) {\r\n                        var p = Math.min(1, sd / (softness * 2)) - 1;\r\n                        p = (sd - softness * (1 - p * p)) / td;\r\n                        tx -= p * tx;\r\n                        ty -= p * ty;\r\n                        dd = tx * tx + ty * ty;\r\n                    }\r\n                }\r\n                outer: if (u) {\r\n                    l2 *= psx;\r\n                    var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                    if (cos < -1)\r\n                        cos = -1;\r\n                    else if (cos > 1) {\r\n                        cos = 1;\r\n                        if (stretch)\r\n                            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                    }\r\n                    a2 = Math.acos(cos) * bendDir;\r\n                    a = l1 + l2 * cos;\r\n                    b = l2 * Math.sin(a2);\r\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n                }\r\n                else {\r\n                    a = psx * l2;\r\n                    b = psy * l2;\r\n                    var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                    var c1 = -2 * bb * l1, c2 = bb - aa;\r\n                    d = c1 * c1 - 4 * c2 * c;\r\n                    if (d >= 0) {\r\n                        var q = Math.sqrt(d);\r\n                        if (c1 < 0)\r\n                            q = -q;\r\n                        q = -(c1 + q) / 2;\r\n                        var r0 = q / c2, r1 = c / q;\r\n                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                        if (r * r <= dd) {\r\n                            y = Math.sqrt(dd - r * r) * bendDir;\r\n                            a1 = ta - Math.atan2(y, r);\r\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                            break outer;\r\n                        }\r\n                    }\r\n                    var minAngle = core.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                    var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                    c = -a * l1 / (aa - bb);\r\n                    if (c >= -1 && c <= 1) {\r\n                        c = Math.acos(c);\r\n                        x = a * Math.cos(c) + l1;\r\n                        y = b * Math.sin(c);\r\n                        d = x * x + y * y;\r\n                        if (d < minDist) {\r\n                            minAngle = c;\r\n                            minDist = d;\r\n                            minX = x;\r\n                            minY = y;\r\n                        }\r\n                        if (d > maxDist) {\r\n                            maxAngle = c;\r\n                            maxDist = d;\r\n                            maxX = x;\r\n                            maxY = y;\r\n                        }\r\n                    }\r\n                    if (dd <= (minDist + maxDist) / 2) {\r\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                        a2 = minAngle * bendDir;\r\n                    }\r\n                    else {\r\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                        a2 = maxAngle * bendDir;\r\n                    }\r\n                }\r\n                var os = Math.atan2(cy, cx) * s2;\r\n                var rotation = parent.arotation;\r\n                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;\r\n                if (a1 > 180)\r\n                    a1 -= 360;\r\n                else if (a1 < -180)\r\n                    a1 += 360;\r\n                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n                rotation = child.arotation;\r\n                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n                if (a2 > 180)\r\n                    a2 -= 360;\r\n                else if (a2 < -180)\r\n                    a2 += 360;\r\n                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n            };\r\n            return IkConstraint;\r\n        }());\r\n        core.IkConstraint = IkConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IkConstraintData = (function (_super) {\r\n            __extends(IkConstraintData, _super);\r\n            function IkConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                _this.bendDirection = 1;\r\n                _this.compress = false;\r\n                _this.stretch = false;\r\n                _this.uniform = false;\r\n                _this.mix = 1;\r\n                _this.softness = 0;\r\n                return _this;\r\n            }\r\n            return IkConstraintData;\r\n        }(core.ConstraintData));\r\n        core.IkConstraintData = IkConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathConstraint = (function () {\r\n            function PathConstraint(data, skeleton) {\r\n                this.position = 0;\r\n                this.spacing = 0;\r\n                this.rotateMix = 0;\r\n                this.translateMix = 0;\r\n                this.spaces = new Array();\r\n                this.positions = new Array();\r\n                this.world = new Array();\r\n                this.curves = new Array();\r\n                this.lengths = new Array();\r\n                this.segments = new Array();\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.bones = new Array();\r\n                for (var i = 0, n = data.bones.length; i < n; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findSlot(data.target.name);\r\n                this.position = data.position;\r\n                this.spacing = data.spacing;\r\n                this.rotateMix = data.rotateMix;\r\n                this.translateMix = data.translateMix;\r\n            }\r\n            PathConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            PathConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            PathConstraint.prototype.update = function () {\r\n                var attachment = this.target.getAttachment();\r\n                if (!(attachment instanceof core.PathAttachment))\r\n                    return;\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n                var translate = translateMix > 0, rotate = rotateMix > 0;\r\n                if (!translate && !rotate)\r\n                    return;\r\n                var data = this.data;\r\n                var spacingMode = data.spacingMode;\r\n                var lengthSpacing = spacingMode == core.SpacingMode.Length;\r\n                var rotateMode = data.rotateMode;\r\n                var tangents = rotateMode == core.RotateMode.Tangent, scale = rotateMode == core.RotateMode.ChainScale;\r\n                var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n                var bones = this.bones;\r\n                var spaces = core.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n                var spacing = this.spacing;\r\n                if (scale || lengthSpacing) {\r\n                    if (scale)\r\n                        lengths = core.Utils.setArraySize(this.lengths, boneCount);\r\n                    for (var i = 0, n = spacesCount - 1; i < n;) {\r\n                        var bone = bones[i];\r\n                        var setupLength = bone.data.length;\r\n                        if (setupLength < PathConstraint.epsilon) {\r\n                            if (scale)\r\n                                lengths[i] = 0;\r\n                            spaces[++i] = 0;\r\n                        }\r\n                        else {\r\n                            var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                            var length_1 = Math.sqrt(x * x + y * y);\r\n                            if (scale)\r\n                                lengths[i] = length_1;\r\n                            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 1; i < spacesCount; i++)\r\n                        spaces[i] = spacing;\r\n                }\r\n                var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);\r\n                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n                var tip = false;\r\n                if (offsetRotation == 0)\r\n                    tip = rotateMode == core.RotateMode.Chain;\r\n                else {\r\n                    tip = false;\r\n                    var p = this.target.bone.matrix;\r\n                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                }\r\n                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n                    var bone = bones[i];\r\n                    var mat = bone.matrix;\r\n                    mat.tx += (boneX - mat.tx) * translateMix;\r\n                    mat.ty += (boneY - mat.ty) * translateMix;\r\n                    var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n                    if (scale) {\r\n                        var length_2 = lengths[i];\r\n                        if (length_2 != 0) {\r\n                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\r\n                            mat.a *= s;\r\n                            mat.b *= s;\r\n                        }\r\n                    }\r\n                    boneX = x;\r\n                    boneY = y;\r\n                    if (rotate) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                        if (tangents)\r\n                            r = positions[p - 1];\r\n                        else if (spaces[i + 1] == 0)\r\n                            r = positions[p + 2];\r\n                        else\r\n                            r = Math.atan2(dy, dx);\r\n                        r -= Math.atan2(c, a);\r\n                        if (tip) {\r\n                            cos = Math.cos(r);\r\n                            sin = Math.sin(r);\r\n                            var length_3 = bone.data.length;\r\n                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\r\n                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\r\n                        }\r\n                        else {\r\n                            r += offsetRotation;\r\n                        }\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        cos = Math.cos(r);\r\n                        sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                    }\r\n                    bone.appliedValid = false;\r\n                }\r\n            };\r\n            PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n                var target = this.target;\r\n                var position = this.position;\r\n                var spaces = this.spaces, out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n                var closed = path.closed;\r\n                var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n                if (!path.constantSpeed) {\r\n                    var lengths = path.lengths;\r\n                    curveCount -= closed ? 1 : 2;\r\n                    var pathLength_1 = lengths[curveCount];\r\n                    if (percentPosition)\r\n                        position *= pathLength_1;\r\n                    if (percentSpacing) {\r\n                        for (var i = 0; i < spacesCount; i++)\r\n                            spaces[i] *= pathLength_1;\r\n                    }\r\n                    world = core.Utils.setArraySize(this.world, 8);\r\n                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                        var space = spaces[i];\r\n                        position += space;\r\n                        var p = position;\r\n                        if (closed) {\r\n                            p %= pathLength_1;\r\n                            if (p < 0)\r\n                                p += pathLength_1;\r\n                            curve = 0;\r\n                        }\r\n                        else if (p < 0) {\r\n                            if (prevCurve != PathConstraint.BEFORE) {\r\n                                prevCurve = PathConstraint.BEFORE;\r\n                                path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                            }\r\n                            this.addBeforePosition(p, world, 0, out, o);\r\n                            continue;\r\n                        }\r\n                        else if (p > pathLength_1) {\r\n                            if (prevCurve != PathConstraint.AFTER) {\r\n                                prevCurve = PathConstraint.AFTER;\r\n                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                            }\r\n                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n                            continue;\r\n                        }\r\n                        for (;; curve++) {\r\n                            var length_4 = lengths[curve];\r\n                            if (p > length_4)\r\n                                continue;\r\n                            if (curve == 0)\r\n                                p /= length_4;\r\n                            else {\r\n                                var prev = lengths[curve - 1];\r\n                                p = (p - prev) / (length_4 - prev);\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (curve != prevCurve) {\r\n                            prevCurve = curve;\r\n                            if (closed && curve == curveCount) {\r\n                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                                path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                            }\r\n                            else\r\n                                path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                        }\r\n                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n                    }\r\n                    return out;\r\n                }\r\n                if (closed) {\r\n                    verticesLength += 2;\r\n                    world = core.Utils.setArraySize(this.world, verticesLength);\r\n                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n                    world[verticesLength - 2] = world[0];\r\n                    world[verticesLength - 1] = world[1];\r\n                }\r\n                else {\r\n                    curveCount--;\r\n                    verticesLength -= 4;\r\n                    world = core.Utils.setArraySize(this.world, verticesLength);\r\n                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n                }\r\n                var curves = core.Utils.setArraySize(this.curves, curveCount);\r\n                var pathLength = 0;\r\n                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n                var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n                    cx1 = world[w];\r\n                    cy1 = world[w + 1];\r\n                    cx2 = world[w + 2];\r\n                    cy2 = world[w + 3];\r\n                    x2 = world[w + 4];\r\n                    y2 = world[w + 5];\r\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n                    ddfx = tmpx * 2 + dddfx;\r\n                    ddfy = tmpy * 2 + dddfy;\r\n                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx + dddfx;\r\n                    dfy += ddfy + dddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    curves[i] = pathLength;\r\n                    x1 = x2;\r\n                    y1 = y2;\r\n                }\r\n                if (percentPosition)\r\n                    position *= pathLength;\r\n                if (percentSpacing) {\r\n                    for (var i = 0; i < spacesCount; i++)\r\n                        spaces[i] *= pathLength;\r\n                }\r\n                var segments = this.segments;\r\n                var curveLength = 0;\r\n                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n                    var space = spaces[i];\r\n                    position += space;\r\n                    var p = position;\r\n                    if (closed) {\r\n                        p %= pathLength;\r\n                        if (p < 0)\r\n                            p += pathLength;\r\n                        curve = 0;\r\n                    }\r\n                    else if (p < 0) {\r\n                        this.addBeforePosition(p, world, 0, out, o);\r\n                        continue;\r\n                    }\r\n                    else if (p > pathLength) {\r\n                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                        continue;\r\n                    }\r\n                    for (;; curve++) {\r\n                        var length_5 = curves[curve];\r\n                        if (p > length_5)\r\n                            continue;\r\n                        if (curve == 0)\r\n                            p /= length_5;\r\n                        else {\r\n                            var prev = curves[curve - 1];\r\n                            p = (p - prev) / (length_5 - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (curve != prevCurve) {\r\n                        prevCurve = curve;\r\n                        var ii = curve * 6;\r\n                        x1 = world[ii];\r\n                        y1 = world[ii + 1];\r\n                        cx1 = world[ii + 2];\r\n                        cy1 = world[ii + 3];\r\n                        cx2 = world[ii + 4];\r\n                        cy2 = world[ii + 5];\r\n                        x2 = world[ii + 6];\r\n                        y2 = world[ii + 7];\r\n                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                        ddfx = tmpx * 2 + dddfx;\r\n                        ddfy = tmpy * 2 + dddfy;\r\n                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[0] = curveLength;\r\n                        for (ii = 1; ii < 8; ii++) {\r\n                            dfx += ddfx;\r\n                            dfy += ddfy;\r\n                            ddfx += dddfx;\r\n                            ddfy += dddfy;\r\n                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                            segments[ii] = curveLength;\r\n                        }\r\n                        dfx += ddfx;\r\n                        dfy += ddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[8] = curveLength;\r\n                        dfx += ddfx + dddfx;\r\n                        dfy += ddfy + dddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[9] = curveLength;\r\n                        segment = 0;\r\n                    }\r\n                    p *= curveLength;\r\n                    for (;; segment++) {\r\n                        var length_6 = segments[segment];\r\n                        if (p > length_6)\r\n                            continue;\r\n                        if (segment == 0)\r\n                            p /= length_6;\r\n                        else {\r\n                            var prev = segments[segment - 1];\r\n                            p = segment + (p - prev) / (length_6 - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n                }\r\n                return out;\r\n            };\r\n            PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n                var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n                out[o] = x1 + p * Math.cos(r);\r\n                out[o + 1] = y1 + p * Math.sin(r);\r\n                out[o + 2] = r;\r\n            };\r\n            PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n                var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n                out[o] = x1 + p * Math.cos(r);\r\n                out[o + 1] = y1 + p * Math.sin(r);\r\n                out[o + 2] = r;\r\n            };\r\n            PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n                if (p == 0 || isNaN(p))\r\n                    p = 0.0001;\r\n                var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n                var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n                out[o] = x;\r\n                out[o + 1] = y;\r\n                if (tangents)\r\n                    out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n            };\r\n            PathConstraint.NONE = -1;\r\n            PathConstraint.BEFORE = -2;\r\n            PathConstraint.AFTER = -3;\r\n            PathConstraint.epsilon = 0.00001;\r\n            return PathConstraint;\r\n        }());\r\n        core.PathConstraint = PathConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathConstraintData = (function (_super) {\r\n            __extends(PathConstraintData, _super);\r\n            function PathConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                return _this;\r\n            }\r\n            return PathConstraintData;\r\n        }(core.ConstraintData));\r\n        core.PathConstraintData = PathConstraintData;\r\n        var PositionMode;\r\n        (function (PositionMode) {\r\n            PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n            PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n        })(PositionMode = core.PositionMode || (core.PositionMode = {}));\r\n        var SpacingMode;\r\n        (function (SpacingMode) {\r\n            SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n            SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n            SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));\r\n        var RotateMode;\r\n        (function (RotateMode) {\r\n            RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n            RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n            RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n        })(RotateMode = core.RotateMode || (core.RotateMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Skeleton = (function () {\r\n            function Skeleton(data) {\r\n                this._updateCache = new Array();\r\n                this.updateCacheReset = new Array();\r\n                this.time = 0;\r\n                this.scaleX = 1;\r\n                this.scaleY = 1;\r\n                this.x = 0;\r\n                this.y = 0;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                this.data = data;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++) {\r\n                    var boneData = data.bones[i];\r\n                    var bone = void 0;\r\n                    if (boneData.parent == null)\r\n                        bone = new core.Bone(boneData, this, null);\r\n                    else {\r\n                        var parent_1 = this.bones[boneData.parent.index];\r\n                        bone = new core.Bone(boneData, this, parent_1);\r\n                        parent_1.children.push(bone);\r\n                    }\r\n                    this.bones.push(bone);\r\n                }\r\n                this.slots = new Array();\r\n                this.drawOrder = new Array();\r\n                for (var i = 0; i < data.slots.length; i++) {\r\n                    var slotData = data.slots[i];\r\n                    var bone = this.bones[slotData.boneData.index];\r\n                    var slot = new core.Slot(slotData, bone);\r\n                    this.slots.push(slot);\r\n                    this.drawOrder.push(slot);\r\n                }\r\n                this.ikConstraints = new Array();\r\n                for (var i = 0; i < data.ikConstraints.length; i++) {\r\n                    var ikConstraintData = data.ikConstraints[i];\r\n                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));\r\n                }\r\n                this.transformConstraints = new Array();\r\n                for (var i = 0; i < data.transformConstraints.length; i++) {\r\n                    var transformConstraintData = data.transformConstraints[i];\r\n                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));\r\n                }\r\n                this.pathConstraints = new Array();\r\n                for (var i = 0; i < data.pathConstraints.length; i++) {\r\n                    var pathConstraintData = data.pathConstraints[i];\r\n                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));\r\n                }\r\n                this.color = new core.Color(1, 1, 1, 1);\r\n                this.updateCache();\r\n            }\r\n            Skeleton.prototype.updateCache = function () {\r\n                var updateCache = this._updateCache;\r\n                updateCache.length = 0;\r\n                this.updateCacheReset.length = 0;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    bone.sorted = bone.data.skinRequired;\r\n                    bone.active = !bone.sorted;\r\n                }\r\n                if (this.skin != null) {\r\n                    var skinBones = this.skin.bones;\r\n                    for (var i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                        var bone = this.bones[skinBones[i].index];\r\n                        do {\r\n                            bone.sorted = false;\r\n                            bone.active = true;\r\n                            bone = bone.parent;\r\n                        } while (bone != null);\r\n                    }\r\n                }\r\n                var ikConstraints = this.ikConstraints;\r\n                var transformConstraints = this.transformConstraints;\r\n                var pathConstraints = this.pathConstraints;\r\n                var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n                var constraintCount = ikCount + transformCount + pathCount;\r\n                outer: for (var i = 0; i < constraintCount; i++) {\r\n                    for (var ii = 0; ii < ikCount; ii++) {\r\n                        var constraint = ikConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortIkConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (var ii = 0; ii < transformCount; ii++) {\r\n                        var constraint = transformConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortTransformConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (var ii = 0; ii < pathCount; ii++) {\r\n                        var constraint = pathConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortPathConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    this.sortBone(bones[i]);\r\n            };\r\n            Skeleton.prototype.sortIkConstraint = function (constraint) {\r\n                constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                var target = constraint.target;\r\n                this.sortBone(target);\r\n                var constrained = constraint.bones;\r\n                var parent = constrained[0];\r\n                this.sortBone(parent);\r\n                if (constrained.length > 1) {\r\n                    var child = constrained[constrained.length - 1];\r\n                    if (!(this._updateCache.indexOf(child) > -1))\r\n                        this.updateCacheReset.push(child);\r\n                }\r\n                this._updateCache.push(constraint);\r\n                this.sortReset(parent.children);\r\n                constrained[constrained.length - 1].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortPathConstraint = function (constraint) {\r\n                constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                var slot = constraint.target;\r\n                var slotIndex = slot.data.index;\r\n                var slotBone = slot.bone;\r\n                if (this.skin != null)\r\n                    this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n                    this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n                for (var i = 0, n = this.data.skins.length; i < n; i++)\r\n                    this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n                var attachment = slot.getAttachment();\r\n                if (attachment instanceof core.PathAttachment)\r\n                    this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n                var constrained = constraint.bones;\r\n                var boneCount = constrained.length;\r\n                for (var i = 0; i < boneCount; i++)\r\n                    this.sortBone(constrained[i]);\r\n                this._updateCache.push(constraint);\r\n                for (var i = 0; i < boneCount; i++)\r\n                    this.sortReset(constrained[i].children);\r\n                for (var i = 0; i < boneCount; i++)\r\n                    constrained[i].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortTransformConstraint = function (constraint) {\r\n                constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                this.sortBone(constraint.target);\r\n                var constrained = constraint.bones;\r\n                var boneCount = constrained.length;\r\n                if (constraint.data.local) {\r\n                    for (var i = 0; i < boneCount; i++) {\r\n                        var child = constrained[i];\r\n                        this.sortBone(child.parent);\r\n                        if (!(this._updateCache.indexOf(child) > -1))\r\n                            this.updateCacheReset.push(child);\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 0; i < boneCount; i++) {\r\n                        this.sortBone(constrained[i]);\r\n                    }\r\n                }\r\n                this._updateCache.push(constraint);\r\n                for (var ii = 0; ii < boneCount; ii++)\r\n                    this.sortReset(constrained[ii].children);\r\n                for (var ii = 0; ii < boneCount; ii++)\r\n                    constrained[ii].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n                var attachments = skin.attachments[slotIndex];\r\n                if (!attachments)\r\n                    return;\r\n                for (var key in attachments) {\r\n                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n                }\r\n            };\r\n            Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n                if (!(attachment instanceof core.PathAttachment))\r\n                    return;\r\n                var pathBones = attachment.bones;\r\n                if (pathBones == null)\r\n                    this.sortBone(slotBone);\r\n                else {\r\n                    var bones = this.bones;\r\n                    var i = 0;\r\n                    while (i < pathBones.length) {\r\n                        var boneCount = pathBones[i++];\r\n                        for (var n = i + boneCount; i < n; i++) {\r\n                            var boneIndex = pathBones[i];\r\n                            this.sortBone(bones[boneIndex]);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            Skeleton.prototype.sortBone = function (bone) {\r\n                if (bone.sorted)\r\n                    return;\r\n                var parent = bone.parent;\r\n                if (parent != null)\r\n                    this.sortBone(parent);\r\n                bone.sorted = true;\r\n                this._updateCache.push(bone);\r\n            };\r\n            Skeleton.prototype.sortReset = function (bones) {\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.active)\r\n                        continue;\r\n                    if (bone.sorted)\r\n                        this.sortReset(bone.children);\r\n                    bone.sorted = false;\r\n                }\r\n            };\r\n            Skeleton.prototype.updateWorldTransform = function () {\r\n                var updateCacheReset = this.updateCacheReset;\r\n                for (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n                    var bone = updateCacheReset[i];\r\n                    bone.ax = bone.x;\r\n                    bone.ay = bone.y;\r\n                    bone.arotation = bone.rotation;\r\n                    bone.ascaleX = bone.scaleX;\r\n                    bone.ascaleY = bone.scaleY;\r\n                    bone.ashearX = bone.shearX;\r\n                    bone.ashearY = bone.shearY;\r\n                    bone.appliedValid = true;\r\n                }\r\n                var updateCache = this._updateCache;\r\n                for (var i = 0, n = updateCache.length; i < n; i++)\r\n                    updateCache[i].update();\r\n            };\r\n            Skeleton.prototype.setToSetupPose = function () {\r\n                this.setBonesToSetupPose();\r\n                this.setSlotsToSetupPose();\r\n            };\r\n            Skeleton.prototype.setBonesToSetupPose = function () {\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    bones[i].setToSetupPose();\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var constraint = ikConstraints[i];\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                }\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    var data = constraint.data;\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n                }\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    var data = constraint.data;\r\n                    constraint.position = data.position;\r\n                    constraint.spacing = data.spacing;\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                }\r\n            };\r\n            Skeleton.prototype.setSlotsToSetupPose = function () {\r\n                var slots = this.slots;\r\n                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    slots[i].setToSetupPose();\r\n            };\r\n            Skeleton.prototype.getRootBone = function () {\r\n                if (this.bones.length == 0)\r\n                    return null;\r\n                return this.bones[0];\r\n            };\r\n            Skeleton.prototype.findBone = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (bone.data.name == boneName)\r\n                        return bone;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findBoneIndex = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    if (bones[i].data.name == boneName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            Skeleton.prototype.findSlot = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.data.name == slotName)\r\n                        return slot;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findSlotIndex = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    if (slots[i].data.name == slotName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            Skeleton.prototype.setSkinByName = function (skinName) {\r\n                var skin = this.data.findSkin(skinName);\r\n                if (skin == null)\r\n                    throw new Error(\"Skin not found: \" + skinName);\r\n                this.setSkin(skin);\r\n            };\r\n            Skeleton.prototype.setSkin = function (newSkin) {\r\n                if (newSkin == this.skin)\r\n                    return;\r\n                if (newSkin != null) {\r\n                    if (this.skin != null)\r\n                        newSkin.attachAll(this, this.skin);\r\n                    else {\r\n                        var slots = this.slots;\r\n                        for (var i = 0, n = slots.length; i < n; i++) {\r\n                            var slot = slots[i];\r\n                            var name_1 = slot.data.attachmentName;\r\n                            if (name_1 != null) {\r\n                                var attachment = newSkin.getAttachment(i, name_1);\r\n                                if (attachment != null)\r\n                                    slot.setAttachment(attachment);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.skin = newSkin;\r\n                this.updateCache();\r\n            };\r\n            Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n            };\r\n            Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n                if (attachmentName == null)\r\n                    throw new Error(\"attachmentName cannot be null.\");\r\n                if (this.skin != null) {\r\n                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n                    if (attachment != null)\r\n                        return attachment;\r\n                }\r\n                if (this.data.defaultSkin != null)\r\n                    return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n                return null;\r\n            };\r\n            Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.data.name == slotName) {\r\n                        var attachment = null;\r\n                        if (attachmentName != null) {\r\n                            attachment = this.getAttachment(i, attachmentName);\r\n                            if (attachment == null)\r\n                                throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                        }\r\n                        slot.setAttachment(attachment);\r\n                        return;\r\n                    }\r\n                }\r\n                throw new Error(\"Slot not found: \" + slotName);\r\n            };\r\n            Skeleton.prototype.findIkConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var ikConstraint = ikConstraints[i];\r\n                    if (ikConstraint.data.name == constraintName)\r\n                        return ikConstraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findTransformConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    if (constraint.data.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findPathConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    if (constraint.data.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.getBounds = function (offset, size, temp) {\r\n                if (temp === void 0) { temp = new Array(2); }\r\n                if (offset == null)\r\n                    throw new Error(\"offset cannot be null.\");\r\n                if (size == null)\r\n                    throw new Error(\"size cannot be null.\");\r\n                var drawOrder = this.drawOrder;\r\n                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                    var slot = drawOrder[i];\r\n                    if (!slot.bone.active)\r\n                        continue;\r\n                    var verticesLength = 0;\r\n                    var vertices = null;\r\n                    var attachment = slot.getAttachment();\r\n                    if (attachment instanceof core.RegionAttachment) {\r\n                        verticesLength = 8;\r\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\r\n                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n                    }\r\n                    else if (attachment instanceof core.MeshAttachment) {\r\n                        var mesh = attachment;\r\n                        verticesLength = mesh.worldVerticesLength;\r\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\r\n                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n                    }\r\n                    if (vertices != null) {\r\n                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                            var x = vertices[ii], y = vertices[ii + 1];\r\n                            minX = Math.min(minX, x);\r\n                            minY = Math.min(minY, y);\r\n                            maxX = Math.max(maxX, x);\r\n                            maxY = Math.max(maxY, y);\r\n                        }\r\n                    }\r\n                }\r\n                offset.set(minX, minY);\r\n                size.set(maxX - minX, maxY - minY);\r\n            };\r\n            Skeleton.prototype.update = function (delta) {\r\n                this.time += delta;\r\n            };\r\n            Object.defineProperty(Skeleton.prototype, \"flipX\", {\r\n                get: function () {\r\n                    return this.scaleX == -1;\r\n                },\r\n                set: function (value) {\r\n                    if (!Skeleton.deprecatedWarning1) {\r\n                        Skeleton.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n                    }\r\n                    this.scaleX = value ? 1.0 : -1.0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(Skeleton.prototype, \"flipY\", {\r\n                get: function () {\r\n                    return this.scaleY == -1;\r\n                },\r\n                set: function (value) {\r\n                    if (!Skeleton.deprecatedWarning1) {\r\n                        Skeleton.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n                    }\r\n                    this.scaleY = value ? 1.0 : -1.0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Skeleton.deprecatedWarning1 = false;\r\n            return Skeleton;\r\n        }());\r\n        core.Skeleton = Skeleton;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonBinary = (function () {\r\n            function SkeletonBinary(attachmentLoader) {\r\n                this.scale = 1;\r\n                this.linkedMeshes = new Array();\r\n                this.attachmentLoader = attachmentLoader;\r\n            }\r\n            SkeletonBinary.prototype.readSkeletonData = function (binary) {\r\n                var scale = this.scale;\r\n                var skeletonData = new core.SkeletonData();\r\n                skeletonData.name = \"\";\r\n                var input = new BinaryInput(binary);\r\n                skeletonData.hash = input.readString();\r\n                skeletonData.version = input.readString();\r\n                if (skeletonData.version === '3.8.75') {\r\n                    var error = \"Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.\";\r\n                    console.error(error);\r\n                }\r\n                skeletonData.x = input.readFloat();\r\n                skeletonData.y = input.readFloat();\r\n                skeletonData.width = input.readFloat();\r\n                skeletonData.height = input.readFloat();\r\n                var nonessential = input.readBoolean();\r\n                if (nonessential) {\r\n                    skeletonData.fps = input.readFloat();\r\n                    skeletonData.imagesPath = input.readString();\r\n                    skeletonData.audioPath = input.readString();\r\n                }\r\n                var n = 0;\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++)\r\n                    input.strings.push(input.readString());\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var name_2 = input.readString();\r\n                    var parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n                    var data = new core.BoneData(i, name_2, parent_2);\r\n                    data.rotation = input.readFloat();\r\n                    data.x = input.readFloat() * scale;\r\n                    data.y = input.readFloat() * scale;\r\n                    data.scaleX = input.readFloat();\r\n                    data.scaleY = input.readFloat();\r\n                    data.shearX = input.readFloat();\r\n                    data.shearY = input.readFloat();\r\n                    data.length = input.readFloat() * scale;\r\n                    data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n                    data.skinRequired = input.readBoolean();\r\n                    if (nonessential)\r\n                        core.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                    skeletonData.bones.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var slotName = input.readString();\r\n                    var boneData = skeletonData.bones[input.readInt(true)];\r\n                    var data = new core.SlotData(i, slotName, boneData);\r\n                    core.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                    var darkColor = input.readInt32();\r\n                    if (darkColor != -1)\r\n                        core.Color.rgb888ToColor(data.darkColor = new core.Color(), darkColor);\r\n                    data.attachmentName = input.readStringRef();\r\n                    data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n                    skeletonData.slots.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.IkConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.bones[input.readInt(true)];\r\n                    data.mix = input.readFloat();\r\n                    data.softness = input.readFloat() * scale;\r\n                    data.bendDirection = input.readByte();\r\n                    data.compress = input.readBoolean();\r\n                    data.stretch = input.readBoolean();\r\n                    data.uniform = input.readBoolean();\r\n                    skeletonData.ikConstraints.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.TransformConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.bones[input.readInt(true)];\r\n                    data.local = input.readBoolean();\r\n                    data.relative = input.readBoolean();\r\n                    data.offsetRotation = input.readFloat();\r\n                    data.offsetX = input.readFloat() * scale;\r\n                    data.offsetY = input.readFloat() * scale;\r\n                    data.offsetScaleX = input.readFloat();\r\n                    data.offsetScaleY = input.readFloat();\r\n                    data.offsetShearY = input.readFloat();\r\n                    data.rotateMix = input.readFloat();\r\n                    data.translateMix = input.readFloat();\r\n                    data.scaleMix = input.readFloat();\r\n                    data.shearMix = input.readFloat();\r\n                    skeletonData.transformConstraints.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.PathConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.slots[input.readInt(true)];\r\n                    data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n                    data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n                    data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n                    data.offsetRotation = input.readFloat();\r\n                    data.position = input.readFloat();\r\n                    if (data.positionMode == core.PositionMode.Fixed)\r\n                        data.position *= scale;\r\n                    data.spacing = input.readFloat();\r\n                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                        data.spacing *= scale;\r\n                    data.rotateMix = input.readFloat();\r\n                    data.translateMix = input.readFloat();\r\n                    skeletonData.pathConstraints.push(data);\r\n                }\r\n                var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n                if (defaultSkin != null) {\r\n                    skeletonData.defaultSkin = defaultSkin;\r\n                    skeletonData.skins.push(defaultSkin);\r\n                }\r\n                {\r\n                    var i = skeletonData.skins.length;\r\n                    core.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n                    for (; i < n; i++)\r\n                        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n                }\r\n                n = this.linkedMeshes.length;\r\n                for (var i = 0; i < n; i++) {\r\n                    var linkedMesh = this.linkedMeshes[i];\r\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                    if (skin == null)\r\n                        throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                    if (parent_3 == null)\r\n                        throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;\r\n                    linkedMesh.mesh.setParentMesh(parent_3);\r\n                }\r\n                this.linkedMeshes.length = 0;\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var data = new core.EventData(input.readStringRef());\r\n                    data.intValue = input.readInt(false);\r\n                    data.floatValue = input.readFloat();\r\n                    data.stringValue = input.readString();\r\n                    data.audioPath = input.readString();\r\n                    if (data.audioPath != null) {\r\n                        data.volume = input.readFloat();\r\n                        data.balance = input.readFloat();\r\n                    }\r\n                    skeletonData.events.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++)\r\n                    skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n                return skeletonData;\r\n            };\r\n            SkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {\r\n                var skin = null;\r\n                var slotCount = 0;\r\n                if (defaultSkin) {\r\n                    slotCount = input.readInt(true);\r\n                    if (slotCount == 0)\r\n                        return null;\r\n                    skin = new core.Skin(\"default\");\r\n                }\r\n                else {\r\n                    skin = new core.Skin(input.readStringRef());\r\n                    skin.bones.length = input.readInt(true);\r\n                    for (var i = 0, n = skin.bones.length; i < n; i++)\r\n                        skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n                    slotCount = input.readInt(true);\r\n                }\r\n                for (var i = 0; i < slotCount; i++) {\r\n                    var slotIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var name_3 = input.readStringRef();\r\n                        var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);\r\n                        if (attachment != null)\r\n                            skin.setAttachment(slotIndex, name_3, attachment);\r\n                    }\r\n                }\r\n                return skin;\r\n            };\r\n            SkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\r\n                var scale = this.scale;\r\n                var name = input.readStringRef();\r\n                if (name == null)\r\n                    name = attachmentName;\r\n                var typeIndex = input.readByte();\r\n                var type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n                switch (type) {\r\n                    case core.AttachmentType.Region: {\r\n                        var path = input.readStringRef();\r\n                        var rotation = input.readFloat();\r\n                        var x = input.readFloat();\r\n                        var y = input.readFloat();\r\n                        var scaleX = input.readFloat();\r\n                        var scaleY = input.readFloat();\r\n                        var width = input.readFloat();\r\n                        var height = input.readFloat();\r\n                        var color = input.readInt32();\r\n                        if (path == null)\r\n                            path = name;\r\n                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                        if (region == null)\r\n                            return null;\r\n                        region.path = path;\r\n                        region.x = x * scale;\r\n                        region.y = y * scale;\r\n                        region.scaleX = scaleX;\r\n                        region.scaleY = scaleY;\r\n                        region.rotation = rotation;\r\n                        region.width = width * scale;\r\n                        region.height = height * scale;\r\n                        core.Color.rgba8888ToColor(region.color, color);\r\n                        return region;\r\n                    }\r\n                    case core.AttachmentType.BoundingBox: {\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                        if (box == null)\r\n                            return null;\r\n                        box.worldVerticesLength = vertexCount << 1;\r\n                        box.vertices = vertices.vertices;\r\n                        box.bones = vertices.bones;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(box.color, color);\r\n                        return box;\r\n                    }\r\n                    case core.AttachmentType.Mesh: {\r\n                        var path = input.readStringRef();\r\n                        var color = input.readInt32();\r\n                        var vertexCount = input.readInt(true);\r\n                        var uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                        var triangles = this.readShortArray(input);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var hullLength = input.readInt(true);\r\n                        var edges = null;\r\n                        var width = 0, height = 0;\r\n                        if (nonessential) {\r\n                            edges = this.readShortArray(input);\r\n                            width = input.readFloat();\r\n                            height = input.readFloat();\r\n                        }\r\n                        if (path == null)\r\n                            path = name;\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        core.Color.rgba8888ToColor(mesh.color, color);\r\n                        mesh.bones = vertices.bones;\r\n                        mesh.vertices = vertices.vertices;\r\n                        mesh.worldVerticesLength = vertexCount << 1;\r\n                        mesh.triangles = triangles;\r\n                        mesh.regionUVs = new Float32Array(uvs);\r\n                        mesh.hullLength = hullLength << 1;\r\n                        if (nonessential) {\r\n                            mesh.edges = edges;\r\n                            mesh.width = width * scale;\r\n                            mesh.height = height * scale;\r\n                        }\r\n                        return mesh;\r\n                    }\r\n                    case core.AttachmentType.LinkedMesh: {\r\n                        var path = input.readStringRef();\r\n                        var color = input.readInt32();\r\n                        var skinName = input.readStringRef();\r\n                        var parent_4 = input.readStringRef();\r\n                        var inheritDeform = input.readBoolean();\r\n                        var width = 0, height = 0;\r\n                        if (nonessential) {\r\n                            width = input.readFloat();\r\n                            height = input.readFloat();\r\n                        }\r\n                        if (path == null)\r\n                            path = name;\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        core.Color.rgba8888ToColor(mesh.color, color);\r\n                        if (nonessential) {\r\n                            mesh.width = width * scale;\r\n                            mesh.height = height * scale;\r\n                        }\r\n                        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));\r\n                        return mesh;\r\n                    }\r\n                    case core.AttachmentType.Path: {\r\n                        var closed_1 = input.readBoolean();\r\n                        var constantSpeed = input.readBoolean();\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var lengths = core.Utils.newArray(vertexCount / 3, 0);\r\n                        for (var i = 0, n = lengths.length; i < n; i++)\r\n                            lengths[i] = input.readFloat() * scale;\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                        if (path == null)\r\n                            return null;\r\n                        path.closed = closed_1;\r\n                        path.constantSpeed = constantSpeed;\r\n                        path.worldVerticesLength = vertexCount << 1;\r\n                        path.vertices = vertices.vertices;\r\n                        path.bones = vertices.bones;\r\n                        path.lengths = lengths;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(path.color, color);\r\n                        return path;\r\n                    }\r\n                    case core.AttachmentType.Point: {\r\n                        var rotation = input.readFloat();\r\n                        var x = input.readFloat();\r\n                        var y = input.readFloat();\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                        if (point == null)\r\n                            return null;\r\n                        point.x = x * scale;\r\n                        point.y = y * scale;\r\n                        point.rotation = rotation;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(point.color, color);\r\n                        return point;\r\n                    }\r\n                    case core.AttachmentType.Clipping: {\r\n                        var endSlotIndex = input.readInt(true);\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                        if (clip == null)\r\n                            return null;\r\n                        clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                        clip.worldVerticesLength = vertexCount << 1;\r\n                        clip.vertices = vertices.vertices;\r\n                        clip.bones = vertices.bones;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(clip.color, color);\r\n                        return clip;\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonBinary.prototype.readVertices = function (input, vertexCount) {\r\n                var verticesLength = vertexCount << 1;\r\n                var vertices = new Vertices();\r\n                var scale = this.scale;\r\n                if (!input.readBoolean()) {\r\n                    vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n                    return vertices;\r\n                }\r\n                var weights = new Array();\r\n                var bonesArray = new Array();\r\n                for (var i = 0; i < vertexCount; i++) {\r\n                    var boneCount = input.readInt(true);\r\n                    bonesArray.push(boneCount);\r\n                    for (var ii = 0; ii < boneCount; ii++) {\r\n                        bonesArray.push(input.readInt(true));\r\n                        weights.push(input.readFloat() * scale);\r\n                        weights.push(input.readFloat() * scale);\r\n                        weights.push(input.readFloat());\r\n                    }\r\n                }\r\n                vertices.vertices = core.Utils.toFloatArray(weights);\r\n                vertices.bones = bonesArray;\r\n                return vertices;\r\n            };\r\n            SkeletonBinary.prototype.readFloatArray = function (input, n, scale) {\r\n                var array = new Array(n);\r\n                if (scale == 1) {\r\n                    for (var i = 0; i < n; i++)\r\n                        array[i] = input.readFloat();\r\n                }\r\n                else {\r\n                    for (var i = 0; i < n; i++)\r\n                        array[i] = input.readFloat() * scale;\r\n                }\r\n                return array;\r\n            };\r\n            SkeletonBinary.prototype.readShortArray = function (input) {\r\n                var n = input.readInt(true);\r\n                var array = new Array(n);\r\n                for (var i = 0; i < n; i++)\r\n                    array[i] = input.readShort();\r\n                return array;\r\n            };\r\n            SkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {\r\n                var timelines = new Array();\r\n                var scale = this.scale;\r\n                var duration = 0;\r\n                var tempColor1 = new core.Color();\r\n                var tempColor2 = new core.Color();\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var slotIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                                var timeline = new core.AttachmentTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.SLOT_COLOR: {\r\n                                var timeline = new core.ColorTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    var time = input.readFloat();\r\n                                    core.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                    timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.ColorTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.SLOT_TWO_COLOR: {\r\n                                var timeline = new core.TwoColorTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    var time = input.readFloat();\r\n                                    core.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                    core.Color.rgb888ToColor(tempColor2, input.readInt32());\r\n                                    timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TwoColorTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var boneIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.BONE_ROTATE: {\r\n                                var timeline = new core.RotateTimeline(frameCount);\r\n                                timeline.boneIndex = boneIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.RotateTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.BONE_TRANSLATE:\r\n                            case SkeletonBinary.BONE_SCALE:\r\n                            case SkeletonBinary.BONE_SHEAR: {\r\n                                var timeline = void 0;\r\n                                var timelineScale = 1;\r\n                                if (timelineType == SkeletonBinary.BONE_SCALE)\r\n                                    timeline = new core.ScaleTimeline(frameCount);\r\n                                else if (timelineType == SkeletonBinary.BONE_SHEAR)\r\n                                    timeline = new core.ShearTimeline(frameCount);\r\n                                else {\r\n                                    timeline = new core.TranslateTimeline(frameCount);\r\n                                    timelineScale = scale;\r\n                                }\r\n                                timeline.boneIndex = boneIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TranslateTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var frameCount = input.readInt(true);\r\n                    var timeline = new core.IkConstraintTimeline(frameCount);\r\n                    timeline.ikConstraintIndex = index;\r\n                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                        if (frameIndex < frameCount - 1)\r\n                            this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.IkConstraintTimeline.ENTRIES]);\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var frameCount = input.readInt(true);\r\n                    var timeline = new core.TransformConstraintTimeline(frameCount);\r\n                    timeline.transformConstraintIndex = index;\r\n                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                        if (frameIndex < frameCount - 1)\r\n                            this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TransformConstraintTimeline.ENTRIES]);\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var data = skeletonData.pathConstraints[index];\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.PATH_POSITION:\r\n                            case SkeletonBinary.PATH_SPACING: {\r\n                                var timeline = void 0;\r\n                                var timelineScale = 1;\r\n                                if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                                    timeline = new core.PathConstraintSpacingTimeline(frameCount);\r\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                else {\r\n                                    timeline = new core.PathConstraintPositionTimeline(frameCount);\r\n                                    if (data.positionMode == core.PositionMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                timeline.pathConstraintIndex = index;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.PATH_MIX: {\r\n                                var timeline = new core.PathConstraintMixTimeline(frameCount);\r\n                                timeline.pathConstraintIndex = index;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.PathConstraintMixTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var skin = skeletonData.skins[input.readInt(true)];\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var slotIndex = input.readInt(true);\r\n                        for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                            var attachment = skin.getAttachment(slotIndex, input.readStringRef());\r\n                            var weighted = attachment.bones != null;\r\n                            var vertices = attachment.vertices;\r\n                            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                            var frameCount = input.readInt(true);\r\n                            var timeline = new core.DeformTimeline(frameCount);\r\n                            timeline.slotIndex = slotIndex;\r\n                            timeline.attachment = attachment;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                var time = input.readFloat();\r\n                                var deform = void 0;\r\n                                var end = input.readInt(true);\r\n                                if (end == 0)\r\n                                    deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = core.Utils.newFloatArray(deformLength);\r\n                                    var start = input.readInt(true);\r\n                                    end += start;\r\n                                    if (scale == 1) {\r\n                                        for (var v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat();\r\n                                    }\r\n                                    else {\r\n                                        for (var v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat() * scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (var v = 0, vn = deform.length; v < vn; v++)\r\n                                            deform[v] += vertices[v];\r\n                                    }\r\n                                }\r\n                                timeline.setFrame(frameIndex, time, deform);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                        }\r\n                    }\r\n                }\r\n                var drawOrderCount = input.readInt(true);\r\n                if (drawOrderCount > 0) {\r\n                    var timeline = new core.DrawOrderTimeline(drawOrderCount);\r\n                    var slotCount = skeletonData.slots.length;\r\n                    for (var i = 0; i < drawOrderCount; i++) {\r\n                        var time = input.readFloat();\r\n                        var offsetCount = input.readInt(true);\r\n                        var drawOrder = core.Utils.newArray(slotCount, 0);\r\n                        for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                            drawOrder[ii] = -1;\r\n                        var unchanged = core.Utils.newArray(slotCount - offsetCount, 0);\r\n                        var originalIndex = 0, unchangedIndex = 0;\r\n                        for (var ii = 0; ii < offsetCount; ii++) {\r\n                            var slotIndex = input.readInt(true);\r\n                            while (originalIndex != slotIndex)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                        }\r\n                        while (originalIndex < slotCount)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                            if (drawOrder[ii] == -1)\r\n                                drawOrder[ii] = unchanged[--unchangedIndex];\r\n                        timeline.setFrame(i, time, drawOrder);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n                }\r\n                var eventCount = input.readInt(true);\r\n                if (eventCount > 0) {\r\n                    var timeline = new core.EventTimeline(eventCount);\r\n                    for (var i = 0; i < eventCount; i++) {\r\n                        var time = input.readFloat();\r\n                        var eventData = skeletonData.events[input.readInt(true)];\r\n                        var event_4 = new core.Event(time, eventData);\r\n                        event_4.intValue = input.readInt(false);\r\n                        event_4.floatValue = input.readFloat();\r\n                        event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                        if (event_4.data.audioPath != null) {\r\n                            event_4.volume = input.readFloat();\r\n                            event_4.balance = input.readFloat();\r\n                        }\r\n                        timeline.setFrame(i, event_4);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n                }\r\n                return new core.Animation(name, timelines, duration);\r\n            };\r\n            SkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {\r\n                switch (input.readByte()) {\r\n                    case SkeletonBinary.CURVE_STEPPED:\r\n                        timeline.setStepped(frameIndex);\r\n                        break;\r\n                    case SkeletonBinary.CURVE_BEZIER:\r\n                        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                        break;\r\n                }\r\n            };\r\n            SkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {\r\n                timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n            };\r\n            SkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];\r\n            SkeletonBinary.TransformModeValues = [core.TransformMode.Normal, core.TransformMode.OnlyTranslation, core.TransformMode.NoRotationOrReflection, core.TransformMode.NoScale, core.TransformMode.NoScaleOrReflection];\r\n            SkeletonBinary.PositionModeValues = [core.PositionMode.Fixed, core.PositionMode.Percent];\r\n            SkeletonBinary.SpacingModeValues = [core.SpacingMode.Length, core.SpacingMode.Fixed, core.SpacingMode.Percent];\r\n            SkeletonBinary.RotateModeValues = [core.RotateMode.Tangent, core.RotateMode.Chain, core.RotateMode.ChainScale];\r\n            SkeletonBinary.BlendModeValues = [core.BlendMode.Normal, core.BlendMode.Additive, core.BlendMode.Multiply, core.BlendMode.Screen];\r\n            SkeletonBinary.BONE_ROTATE = 0;\r\n            SkeletonBinary.BONE_TRANSLATE = 1;\r\n            SkeletonBinary.BONE_SCALE = 2;\r\n            SkeletonBinary.BONE_SHEAR = 3;\r\n            SkeletonBinary.SLOT_ATTACHMENT = 0;\r\n            SkeletonBinary.SLOT_COLOR = 1;\r\n            SkeletonBinary.SLOT_TWO_COLOR = 2;\r\n            SkeletonBinary.PATH_POSITION = 0;\r\n            SkeletonBinary.PATH_SPACING = 1;\r\n            SkeletonBinary.PATH_MIX = 2;\r\n            SkeletonBinary.CURVE_LINEAR = 0;\r\n            SkeletonBinary.CURVE_STEPPED = 1;\r\n            SkeletonBinary.CURVE_BEZIER = 2;\r\n            return SkeletonBinary;\r\n        }());\r\n        core.SkeletonBinary = SkeletonBinary;\r\n        var BinaryInput = (function () {\r\n            function BinaryInput(data, strings, index, buffer) {\r\n                if (strings === void 0) { strings = new Array(); }\r\n                if (index === void 0) { index = 0; }\r\n                if (buffer === void 0) { buffer = new DataView(data.buffer); }\r\n                this.strings = strings;\r\n                this.index = index;\r\n                this.buffer = buffer;\r\n            }\r\n            BinaryInput.prototype.readByte = function () {\r\n                return this.buffer.getInt8(this.index++);\r\n            };\r\n            BinaryInput.prototype.readShort = function () {\r\n                var value = this.buffer.getInt16(this.index);\r\n                this.index += 2;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readInt32 = function () {\r\n                var value = this.buffer.getInt32(this.index);\r\n                this.index += 4;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readInt = function (optimizePositive) {\r\n                var b = this.readByte();\r\n                var result = b & 0x7F;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 7;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 14;\r\n                        if ((b & 0x80) != 0) {\r\n                            b = this.readByte();\r\n                            result |= (b & 0x7F) << 21;\r\n                            if ((b & 0x80) != 0) {\r\n                                b = this.readByte();\r\n                                result |= (b & 0x7F) << 28;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n            };\r\n            BinaryInput.prototype.readStringRef = function () {\r\n                var index = this.readInt(true);\r\n                return index == 0 ? null : this.strings[index - 1];\r\n            };\r\n            BinaryInput.prototype.readString = function () {\r\n                var byteCount = this.readInt(true);\r\n                switch (byteCount) {\r\n                    case 0:\r\n                        return null;\r\n                    case 1:\r\n                        return \"\";\r\n                }\r\n                byteCount--;\r\n                var chars = \"\";\r\n                var charCount = 0;\r\n                for (var i = 0; i < byteCount;) {\r\n                    var b = this.readByte();\r\n                    switch (b >> 4) {\r\n                        case 12:\r\n                        case 13:\r\n                            chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                            i += 2;\r\n                            break;\r\n                        case 14:\r\n                            chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                            i += 3;\r\n                            break;\r\n                        default:\r\n                            chars += String.fromCharCode(b);\r\n                            i++;\r\n                    }\r\n                }\r\n                return chars;\r\n            };\r\n            BinaryInput.prototype.readFloat = function () {\r\n                var value = this.buffer.getFloat32(this.index);\r\n                this.index += 4;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readBoolean = function () {\r\n                return this.readByte() != 0;\r\n            };\r\n            return BinaryInput;\r\n        }());\r\n        var LinkedMesh = (function () {\r\n            function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n                this.mesh = mesh;\r\n                this.skin = skin;\r\n                this.slotIndex = slotIndex;\r\n                this.parent = parent;\r\n                this.inheritDeform = inheritDeform;\r\n            }\r\n            return LinkedMesh;\r\n        }());\r\n        var Vertices = (function () {\r\n            function Vertices(bones, vertices) {\r\n                if (bones === void 0) { bones = null; }\r\n                if (vertices === void 0) { vertices = null; }\r\n                this.bones = bones;\r\n                this.vertices = vertices;\r\n            }\r\n            return Vertices;\r\n        }());\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonBounds = (function () {\r\n            function SkeletonBounds() {\r\n                this.minX = 0;\r\n                this.minY = 0;\r\n                this.maxX = 0;\r\n                this.maxY = 0;\r\n                this.boundingBoxes = new Array();\r\n                this.polygons = new Array();\r\n                this.polygonPool = new core.Pool(function () {\r\n                    return core.Utils.newFloatArray(16);\r\n                });\r\n            }\r\n            SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                var boundingBoxes = this.boundingBoxes;\r\n                var polygons = this.polygons;\r\n                var polygonPool = this.polygonPool;\r\n                var slots = skeleton.slots;\r\n                var slotCount = slots.length;\r\n                boundingBoxes.length = 0;\r\n                polygonPool.freeAll(polygons);\r\n                polygons.length = 0;\r\n                for (var i = 0; i < slotCount; i++) {\r\n                    var slot = slots[i];\r\n                    if (!slot.bone.active)\r\n                        continue;\r\n                    var attachment = slot.getAttachment();\r\n                    if (attachment instanceof core.BoundingBoxAttachment) {\r\n                        var boundingBox = attachment;\r\n                        boundingBoxes.push(boundingBox);\r\n                        var polygon = polygonPool.obtain();\r\n                        if (polygon.length != boundingBox.worldVerticesLength) {\r\n                            polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                        }\r\n                        polygons.push(polygon);\r\n                        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n                    }\r\n                }\r\n                if (updateAabb) {\r\n                    this.aabbCompute();\r\n                }\r\n                else {\r\n                    this.minX = Number.POSITIVE_INFINITY;\r\n                    this.minY = Number.POSITIVE_INFINITY;\r\n                    this.maxX = Number.NEGATIVE_INFINITY;\r\n                    this.maxY = Number.NEGATIVE_INFINITY;\r\n                }\r\n            };\r\n            SkeletonBounds.prototype.aabbCompute = function () {\r\n                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++) {\r\n                    var polygon = polygons[i];\r\n                    var vertices = polygon;\r\n                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                        var x = vertices[ii];\r\n                        var y = vertices[ii + 1];\r\n                        minX = Math.min(minX, x);\r\n                        minY = Math.min(minY, y);\r\n                        maxX = Math.max(maxX, x);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                }\r\n                this.minX = minX;\r\n                this.minY = minY;\r\n                this.maxX = maxX;\r\n                this.maxY = maxY;\r\n            };\r\n            SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n            };\r\n            SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n                var minX = this.minX;\r\n                var minY = this.minY;\r\n                var maxX = this.maxX;\r\n                var maxY = this.maxY;\r\n                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n                    return false;\r\n                var m = (y2 - y1) / (x2 - x1);\r\n                var y = m * (minX - x1) + y1;\r\n                if (y > minY && y < maxY)\r\n                    return true;\r\n                y = m * (maxX - x1) + y1;\r\n                if (y > minY && y < maxY)\r\n                    return true;\r\n                var x = (minY - y1) / m + x1;\r\n                if (x > minX && x < maxX)\r\n                    return true;\r\n                x = (maxY - y1) / m + x1;\r\n                if (x > minX && x < maxX)\r\n                    return true;\r\n                return false;\r\n            };\r\n            SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n            };\r\n            SkeletonBounds.prototype.containsPoint = function (x, y) {\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++)\r\n                    if (this.containsPointPolygon(polygons[i], x, y))\r\n                        return this.boundingBoxes[i];\r\n                return null;\r\n            };\r\n            SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n                var vertices = polygon;\r\n                var nn = polygon.length;\r\n                var prevIndex = nn - 2;\r\n                var inside = false;\r\n                for (var ii = 0; ii < nn; ii += 2) {\r\n                    var vertexY = vertices[ii + 1];\r\n                    var prevY = vertices[prevIndex + 1];\r\n                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                        var vertexX = vertices[ii];\r\n                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n                            inside = !inside;\r\n                    }\r\n                    prevIndex = ii;\r\n                }\r\n                return inside;\r\n            };\r\n            SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++)\r\n                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n                        return this.boundingBoxes[i];\r\n                return null;\r\n            };\r\n            SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n                var vertices = polygon;\r\n                var nn = polygon.length;\r\n                var width12 = x1 - x2, height12 = y1 - y2;\r\n                var det1 = x1 * y2 - y1 * x2;\r\n                var x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n                for (var ii = 0; ii < nn; ii += 2) {\r\n                    var x4 = vertices[ii], y4 = vertices[ii + 1];\r\n                    var det2 = x3 * y4 - y3 * x4;\r\n                    var width34 = x3 - x4, height34 = y3 - y4;\r\n                    var det3 = width12 * height34 - height12 * width34;\r\n                    var x = (det1 * width34 - width12 * det2) / det3;\r\n                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                        var y = (det1 * height34 - height12 * det2) / det3;\r\n                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n                            return true;\r\n                    }\r\n                    x3 = x4;\r\n                    y3 = y4;\r\n                }\r\n                return false;\r\n            };\r\n            SkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n                if (boundingBox == null)\r\n                    throw new Error(\"boundingBox cannot be null.\");\r\n                var index = this.boundingBoxes.indexOf(boundingBox);\r\n                return index == -1 ? null : this.polygons[index];\r\n            };\r\n            SkeletonBounds.prototype.getWidth = function () {\r\n                return this.maxX - this.minX;\r\n            };\r\n            SkeletonBounds.prototype.getHeight = function () {\r\n                return this.maxY - this.minY;\r\n            };\r\n            return SkeletonBounds;\r\n        }());\r\n        core.SkeletonBounds = SkeletonBounds;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonClipping = (function () {\r\n            function SkeletonClipping() {\r\n                this.triangulator = new core.Triangulator();\r\n                this.clippingPolygon = new Array();\r\n                this.clipOutput = new Array();\r\n                this.clippedVertices = new Array();\r\n                this.clippedTriangles = new Array();\r\n                this.scratch = new Array();\r\n            }\r\n            SkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n                if (this.clipAttachment != null)\r\n                    return 0;\r\n                this.clipAttachment = clip;\r\n                var n = clip.worldVerticesLength;\r\n                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);\r\n                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n                var clippingPolygon = this.clippingPolygon;\r\n                SkeletonClipping.makeClockwise(clippingPolygon);\r\n                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n                for (var i = 0, n_2 = clippingPolygons.length; i < n_2; i++) {\r\n                    var polygon = clippingPolygons[i];\r\n                    SkeletonClipping.makeClockwise(polygon);\r\n                    polygon.push(polygon[0]);\r\n                    polygon.push(polygon[1]);\r\n                }\r\n                return clippingPolygons.length;\r\n            };\r\n            SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n                if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n                    this.clipEnd();\r\n            };\r\n            SkeletonClipping.prototype.clipEnd = function () {\r\n                if (this.clipAttachment == null)\r\n                    return;\r\n                this.clipAttachment = null;\r\n                this.clippingPolygons = null;\r\n                this.clippedVertices.length = 0;\r\n                this.clippedTriangles.length = 0;\r\n                this.clippingPolygon.length = 0;\r\n            };\r\n            SkeletonClipping.prototype.isClipping = function () {\r\n                return this.clipAttachment != null;\r\n            };\r\n            SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n                var clippedTriangles = this.clippedTriangles;\r\n                var polygons = this.clippingPolygons;\r\n                var polygonsCount = this.clippingPolygons.length;\r\n                var vertexSize = twoColor ? 12 : 8;\r\n                var index = 0;\r\n                clippedVertices.length = 0;\r\n                clippedTriangles.length = 0;\r\n                outer: for (var i = 0; i < trianglesLength; i += 3) {\r\n                    var vertexOffset = triangles[i] << 1;\r\n                    var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n                    var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n                    vertexOffset = triangles[i + 1] << 1;\r\n                    var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n                    var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n                    vertexOffset = triangles[i + 2] << 1;\r\n                    var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n                    var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n                    for (var p = 0; p < polygonsCount; p++) {\r\n                        var s = clippedVertices.length;\r\n                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n                            var clipOutputLength = clipOutput.length;\r\n                            if (clipOutputLength == 0)\r\n                                continue;\r\n                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n                            var clipOutputCount = clipOutputLength >> 1;\r\n                            var clipOutputItems = this.clipOutput;\r\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n                            for (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n                                var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n                                clippedVerticesItems[s] = x;\r\n                                clippedVerticesItems[s + 1] = y;\r\n                                clippedVerticesItems[s + 2] = light.r;\r\n                                clippedVerticesItems[s + 3] = light.g;\r\n                                clippedVerticesItems[s + 4] = light.b;\r\n                                clippedVerticesItems[s + 5] = light.a;\r\n                                var c0 = x - x3, c1 = y - y3;\r\n                                var a = (d0 * c0 + d1 * c1) * d;\r\n                                var b = (d4 * c0 + d2 * c1) * d;\r\n                                var c = 1 - a - b;\r\n                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n                                if (twoColor) {\r\n                                    clippedVerticesItems[s + 8] = dark.r;\r\n                                    clippedVerticesItems[s + 9] = dark.g;\r\n                                    clippedVerticesItems[s + 10] = dark.b;\r\n                                    clippedVerticesItems[s + 11] = dark.a;\r\n                                }\r\n                                s += vertexSize;\r\n                            }\r\n                            s = clippedTriangles.length;\r\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n                            clipOutputCount--;\r\n                            for (var ii = 1; ii < clipOutputCount; ii++) {\r\n                                clippedTrianglesItems[s] = index;\r\n                                clippedTrianglesItems[s + 1] = (index + ii);\r\n                                clippedTrianglesItems[s + 2] = (index + ii + 1);\r\n                                s += 3;\r\n                            }\r\n                            index += clipOutputCount + 1;\r\n                        }\r\n                        else {\r\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n                            clippedVerticesItems[s] = x1;\r\n                            clippedVerticesItems[s + 1] = y1;\r\n                            clippedVerticesItems[s + 2] = light.r;\r\n                            clippedVerticesItems[s + 3] = light.g;\r\n                            clippedVerticesItems[s + 4] = light.b;\r\n                            clippedVerticesItems[s + 5] = light.a;\r\n                            if (!twoColor) {\r\n                                clippedVerticesItems[s + 6] = u1;\r\n                                clippedVerticesItems[s + 7] = v1;\r\n                                clippedVerticesItems[s + 8] = x2;\r\n                                clippedVerticesItems[s + 9] = y2;\r\n                                clippedVerticesItems[s + 10] = light.r;\r\n                                clippedVerticesItems[s + 11] = light.g;\r\n                                clippedVerticesItems[s + 12] = light.b;\r\n                                clippedVerticesItems[s + 13] = light.a;\r\n                                clippedVerticesItems[s + 14] = u2;\r\n                                clippedVerticesItems[s + 15] = v2;\r\n                                clippedVerticesItems[s + 16] = x3;\r\n                                clippedVerticesItems[s + 17] = y3;\r\n                                clippedVerticesItems[s + 18] = light.r;\r\n                                clippedVerticesItems[s + 19] = light.g;\r\n                                clippedVerticesItems[s + 20] = light.b;\r\n                                clippedVerticesItems[s + 21] = light.a;\r\n                                clippedVerticesItems[s + 22] = u3;\r\n                                clippedVerticesItems[s + 23] = v3;\r\n                            }\r\n                            else {\r\n                                clippedVerticesItems[s + 6] = u1;\r\n                                clippedVerticesItems[s + 7] = v1;\r\n                                clippedVerticesItems[s + 8] = dark.r;\r\n                                clippedVerticesItems[s + 9] = dark.g;\r\n                                clippedVerticesItems[s + 10] = dark.b;\r\n                                clippedVerticesItems[s + 11] = dark.a;\r\n                                clippedVerticesItems[s + 12] = x2;\r\n                                clippedVerticesItems[s + 13] = y2;\r\n                                clippedVerticesItems[s + 14] = light.r;\r\n                                clippedVerticesItems[s + 15] = light.g;\r\n                                clippedVerticesItems[s + 16] = light.b;\r\n                                clippedVerticesItems[s + 17] = light.a;\r\n                                clippedVerticesItems[s + 18] = u2;\r\n                                clippedVerticesItems[s + 19] = v2;\r\n                                clippedVerticesItems[s + 20] = dark.r;\r\n                                clippedVerticesItems[s + 21] = dark.g;\r\n                                clippedVerticesItems[s + 22] = dark.b;\r\n                                clippedVerticesItems[s + 23] = dark.a;\r\n                                clippedVerticesItems[s + 24] = x3;\r\n                                clippedVerticesItems[s + 25] = y3;\r\n                                clippedVerticesItems[s + 26] = light.r;\r\n                                clippedVerticesItems[s + 27] = light.g;\r\n                                clippedVerticesItems[s + 28] = light.b;\r\n                                clippedVerticesItems[s + 29] = light.a;\r\n                                clippedVerticesItems[s + 30] = u3;\r\n                                clippedVerticesItems[s + 31] = v3;\r\n                                clippedVerticesItems[s + 32] = dark.r;\r\n                                clippedVerticesItems[s + 33] = dark.g;\r\n                                clippedVerticesItems[s + 34] = dark.b;\r\n                                clippedVerticesItems[s + 35] = dark.a;\r\n                            }\r\n                            s = clippedTriangles.length;\r\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);\r\n                            clippedTrianglesItems[s] = index;\r\n                            clippedTrianglesItems[s + 1] = (index + 1);\r\n                            clippedTrianglesItems[s + 2] = (index + 2);\r\n                            index += 3;\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n                var originalOutput = output;\r\n                var clipped = false;\r\n                var input = null;\r\n                if (clippingArea.length % 4 >= 2) {\r\n                    input = output;\r\n                    output = this.scratch;\r\n                }\r\n                else\r\n                    input = this.scratch;\r\n                input.length = 0;\r\n                input.push(x1);\r\n                input.push(y1);\r\n                input.push(x2);\r\n                input.push(y2);\r\n                input.push(x3);\r\n                input.push(y3);\r\n                input.push(x1);\r\n                input.push(y1);\r\n                output.length = 0;\r\n                var clippingVertices = clippingArea;\r\n                var clippingVerticesLast = clippingArea.length - 4;\r\n                for (var i = 0;; i += 2) {\r\n                    var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n                    var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n                    var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n                    var inputVertices = input;\r\n                    var inputVerticesLength = input.length - 2, outputStart = output.length;\r\n                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n                        var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n                        var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n                            if (side2) {\r\n                                output.push(inputX2);\r\n                                output.push(inputY2);\r\n                                continue;\r\n                            }\r\n                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                        }\r\n                        else if (side2) {\r\n                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                            output.push(inputX2);\r\n                            output.push(inputY2);\r\n                        }\r\n                        clipped = true;\r\n                    }\r\n                    if (outputStart == output.length) {\r\n                        originalOutput.length = 0;\r\n                        return true;\r\n                    }\r\n                    output.push(output[0]);\r\n                    output.push(output[1]);\r\n                    if (i == clippingVerticesLast)\r\n                        break;\r\n                    var temp = output;\r\n                    output = input;\r\n                    output.length = 0;\r\n                    input = temp;\r\n                }\r\n                if (originalOutput != output) {\r\n                    originalOutput.length = 0;\r\n                    for (var i = 0, n = output.length - 2; i < n; i++)\r\n                        originalOutput[i] = output[i];\r\n                }\r\n                else\r\n                    originalOutput.length = originalOutput.length - 2;\r\n                return clipped;\r\n            };\r\n            SkeletonClipping.makeClockwise = function (polygon) {\r\n                var vertices = polygon;\r\n                var verticeslength = polygon.length;\r\n                var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n                for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n                    p1x = vertices[i];\r\n                    p1y = vertices[i + 1];\r\n                    p2x = vertices[i + 2];\r\n                    p2y = vertices[i + 3];\r\n                    area += p1x * p2y - p2x * p1y;\r\n                }\r\n                if (area < 0)\r\n                    return;\r\n                for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n                    var x = vertices[i], y = vertices[i + 1];\r\n                    var other = lastX - i;\r\n                    vertices[i] = vertices[other];\r\n                    vertices[i + 1] = vertices[other + 1];\r\n                    vertices[other] = x;\r\n                    vertices[other + 1] = y;\r\n                }\r\n            };\r\n            return SkeletonClipping;\r\n        }());\r\n        core.SkeletonClipping = SkeletonClipping;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonData = (function () {\r\n            function SkeletonData() {\r\n                this.bones = new Array();\r\n                this.slots = new Array();\r\n                this.skins = new Array();\r\n                this.events = new Array();\r\n                this.animations = new Array();\r\n                this.ikConstraints = new Array();\r\n                this.transformConstraints = new Array();\r\n                this.pathConstraints = new Array();\r\n                this.fps = 0;\r\n            }\r\n            SkeletonData.prototype.findBone = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (bone.name == boneName)\r\n                        return bone;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findBoneIndex = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    if (bones[i].name == boneName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            SkeletonData.prototype.findSlot = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.name == slotName)\r\n                        return slot;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findSlotIndex = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    if (slots[i].name == slotName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            SkeletonData.prototype.findSkin = function (skinName) {\r\n                if (skinName == null)\r\n                    throw new Error(\"skinName cannot be null.\");\r\n                var skins = this.skins;\r\n                for (var i = 0, n = skins.length; i < n; i++) {\r\n                    var skin = skins[i];\r\n                    if (skin.name == skinName)\r\n                        return skin;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findEvent = function (eventDataName) {\r\n                if (eventDataName == null)\r\n                    throw new Error(\"eventDataName cannot be null.\");\r\n                var events = this.events;\r\n                for (var i = 0, n = events.length; i < n; i++) {\r\n                    var event_5 = events[i];\r\n                    if (event_5.name == eventDataName)\r\n                        return event_5;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findAnimation = function (animationName) {\r\n                if (animationName == null)\r\n                    throw new Error(\"animationName cannot be null.\");\r\n                var animations = this.animations;\r\n                for (var i = 0, n = animations.length; i < n; i++) {\r\n                    var animation = animations[i];\r\n                    if (animation.name == animationName)\r\n                        return animation;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var constraint = ikConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n                if (pathConstraintName == null)\r\n                    throw new Error(\"pathConstraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++)\r\n                    if (pathConstraints[i].name == pathConstraintName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            return SkeletonData;\r\n        }());\r\n        core.SkeletonData = SkeletonData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        core.FAIL_ON_NON_EXISTING_SKIN = false;\r\n        var SkeletonJson = (function () {\r\n            function SkeletonJson(attachmentLoader) {\r\n                this.scale = 1;\r\n                this.linkedMeshes = new Array();\r\n                this.attachmentLoader = attachmentLoader;\r\n            }\r\n            SkeletonJson.prototype.readSkeletonData = function (json) {\r\n                var scale = this.scale;\r\n                var skeletonData = new core.SkeletonData();\r\n                var root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n                var skeletonMap = root.skeleton;\r\n                if (skeletonMap != null) {\r\n                    skeletonData.hash = skeletonMap.hash;\r\n                    skeletonData.version = skeletonMap.spine;\r\n                    if (skeletonData.version.substr(0, 3) !== '3.8') {\r\n                        var error = \"PixiJS Spine plugin supports only format for Spine 3.8. Your model has version \" + skeletonMap.spine + \". Please look in pixi-spine repository README for another branch.\";\r\n                        console.error(error);\r\n                    }\r\n                    if (skeletonData.version === '3.8.75') {\r\n                        var error = \"Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.\";\r\n                        console.error(error);\r\n                    }\r\n                    skeletonData.x = skeletonMap.x;\r\n                    skeletonData.y = skeletonMap.y;\r\n                    skeletonData.width = skeletonMap.width;\r\n                    skeletonData.height = skeletonMap.height;\r\n                    skeletonData.fps = skeletonMap.fps;\r\n                    skeletonData.imagesPath = skeletonMap.images;\r\n                }\r\n                if (root.bones) {\r\n                    for (var i = 0; i < root.bones.length; i++) {\r\n                        var boneMap = root.bones[i];\r\n                        var parent_5 = null;\r\n                        var parentName = this.getValue(boneMap, \"parent\", null);\r\n                        if (parentName != null) {\r\n                            parent_5 = skeletonData.findBone(parentName);\r\n                            if (parent_5 == null)\r\n                                throw new Error(\"Parent bone not found: \" + parentName);\r\n                        }\r\n                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_5);\r\n                        data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                        data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                        data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                        data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                        data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                        data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n                        data.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n                        skeletonData.bones.push(data);\r\n                    }\r\n                }\r\n                if (root.slots) {\r\n                    for (var i = 0; i < root.slots.length; i++) {\r\n                        var slotMap = root.slots[i];\r\n                        var slotName = slotMap.name;\r\n                        var boneName = slotMap.bone;\r\n                        var boneData = skeletonData.findBone(boneName);\r\n                        if (boneData == null)\r\n                            throw new Error(\"Slot bone not found: \" + boneName);\r\n                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);\r\n                        var color = this.getValue(slotMap, \"color\", null);\r\n                        if (color != null)\r\n                            data.color.setFromString(color);\r\n                        var dark = this.getValue(slotMap, \"dark\", null);\r\n                        if (dark != null) {\r\n                            data.darkColor = new core.Color(1, 1, 1, 1);\r\n                            data.darkColor.setFromString(dark);\r\n                        }\r\n                        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                        skeletonData.slots.push(data);\r\n                    }\r\n                }\r\n                if (root.ik) {\r\n                    for (var i = 0; i < root.ik.length; i++) {\r\n                        var constraintMap = root.ik[i];\r\n                        var data = new core.IkConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"IK bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findBone(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"IK target bone not found: \" + targetName);\r\n                        data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n                        data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n                        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                        data.compress = this.getValue(constraintMap, \"compress\", false);\r\n                        data.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n                        data.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n                        skeletonData.ikConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.transform) {\r\n                    for (var i = 0; i < root.transform.length; i++) {\r\n                        var constraintMap = root.transform[i];\r\n                        var data = new core.TransformConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findBone(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n                        data.local = this.getValue(constraintMap, \"local\", false);\r\n                        data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n                        skeletonData.transformConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.path) {\r\n                    for (var i = 0; i < root.path.length; i++) {\r\n                        var constraintMap = root.path[i];\r\n                        var data = new core.PathConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findSlot(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"Path target slot not found: \" + targetName);\r\n                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                        data.position = this.getValue(constraintMap, \"position\", 0);\r\n                        if (data.positionMode == core.PositionMode.Fixed)\r\n                            data.position *= scale;\r\n                        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                            data.spacing *= scale;\r\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                        skeletonData.pathConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.skins) {\r\n                    for (var i = 0; i < root.skins.length; i++) {\r\n                        var skinMap = root.skins[i];\r\n                        var skin = new core.Skin(skinMap.name);\r\n                        if (skinMap.bones) {\r\n                            for (var ii = 0; ii < skinMap.bones.length; ii++) {\r\n                                var bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                                if (bone == null)\r\n                                    throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                                skin.bones.push(bone);\r\n                            }\r\n                        }\r\n                        if (skinMap.ik) {\r\n                            for (var ii = 0; ii < skinMap.ik.length; ii++) {\r\n                                var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        if (skinMap.transform) {\r\n                            for (var ii = 0; ii < skinMap.transform.length; ii++) {\r\n                                var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        if (skinMap.path) {\r\n                            for (var ii = 0; ii < skinMap.path.length; ii++) {\r\n                                var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        for (var slotName in skinMap.attachments) {\r\n                            var slot = skeletonData.findSlot(slotName);\r\n                            if (slot == null)\r\n                                throw new Error(\"Slot not found: \" + slotName);\r\n                            var slotMap = skinMap.attachments[slotName];\r\n                            for (var entryName in slotMap) {\r\n                                var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                                if (attachment != null)\r\n                                    skin.setAttachment(slot.index, entryName, attachment);\r\n                            }\r\n                        }\r\n                        skeletonData.skins.push(skin);\r\n                        if (skin.name == \"default\")\r\n                            skeletonData.defaultSkin = skin;\r\n                    }\r\n                }\r\n                for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n                    var linkedMesh = this.linkedMeshes[i];\r\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                    if (skin == null)\r\n                        throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                    var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                    if (parent_6 == null)\r\n                        throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;\r\n                    linkedMesh.mesh.setParentMesh(parent_6);\r\n                }\r\n                this.linkedMeshes.length = 0;\r\n                if (root.events) {\r\n                    for (var eventName in root.events) {\r\n                        var eventMap = root.events[eventName];\r\n                        var data = new core.EventData(eventName);\r\n                        data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                        data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                        data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                        data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                        if (data.audioPath != null) {\r\n                            data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                            data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                        }\r\n                        skeletonData.events.push(data);\r\n                    }\r\n                }\r\n                if (root.animations) {\r\n                    for (var animationName in root.animations) {\r\n                        var animationMap = root.animations[animationName];\r\n                        this.readAnimation(animationMap, animationName, skeletonData);\r\n                    }\r\n                }\r\n                return skeletonData;\r\n            };\r\n            SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n                var scale = this.scale;\r\n                name = this.getValue(map, \"name\", name);\r\n                var type = this.getValue(map, \"type\", \"region\");\r\n                switch (type) {\r\n                    case \"region\": {\r\n                        var path = this.getValue(map, \"path\", name);\r\n                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                        if (region == null)\r\n                            return null;\r\n                        region.path = path;\r\n                        region.x = this.getValue(map, \"x\", 0) * scale;\r\n                        region.y = this.getValue(map, \"y\", 0) * scale;\r\n                        region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                        region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                        region.rotation = this.getValue(map, \"rotation\", 0);\r\n                        region.width = map.width * scale;\r\n                        region.height = map.height * scale;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            region.color.setFromString(color);\r\n                        return region;\r\n                    }\r\n                    case \"boundingbox\": {\r\n                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                        if (box == null)\r\n                            return null;\r\n                        this.readVertices(map, box, map.vertexCount << 1);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            box.color.setFromString(color);\r\n                        return box;\r\n                    }\r\n                    case \"mesh\":\r\n                    case \"linkedmesh\": {\r\n                        var path = this.getValue(map, \"path\", name);\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            mesh.color.setFromString(color);\r\n                        mesh.width = this.getValue(map, \"width\", 0) * scale;\r\n                        mesh.height = this.getValue(map, \"height\", 0) * scale;\r\n                        var parent_7 = this.getValue(map, \"parent\", null);\r\n                        if (parent_7 != null) {\r\n                            this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_7, this.getValue(map, \"deform\", true)));\r\n                            return mesh;\r\n                        }\r\n                        var uvs = map.uvs;\r\n                        this.readVertices(map, mesh, uvs.length);\r\n                        mesh.triangles = map.triangles;\r\n                        mesh.regionUVs = new Float32Array(uvs);\r\n                        mesh.edges = this.getValue(map, \"edges\", null);\r\n                        mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                        return mesh;\r\n                    }\r\n                    case \"path\": {\r\n                        var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                        if (path == null)\r\n                            return null;\r\n                        path.closed = this.getValue(map, \"closed\", false);\r\n                        path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n                        var vertexCount = map.vertexCount;\r\n                        this.readVertices(map, path, vertexCount << 1);\r\n                        var lengths = core.Utils.newArray(vertexCount / 3, 0);\r\n                        for (var i = 0; i < map.lengths.length; i++)\r\n                            lengths[i] = map.lengths[i] * scale;\r\n                        path.lengths = lengths;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            path.color.setFromString(color);\r\n                        return path;\r\n                    }\r\n                    case \"point\": {\r\n                        var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                        if (point == null)\r\n                            return null;\r\n                        point.x = this.getValue(map, \"x\", 0) * scale;\r\n                        point.y = this.getValue(map, \"y\", 0) * scale;\r\n                        point.rotation = this.getValue(map, \"rotation\", 0);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            point.color.setFromString(color);\r\n                        return point;\r\n                    }\r\n                    case \"clipping\": {\r\n                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                        if (clip == null)\r\n                            return null;\r\n                        var end = this.getValue(map, \"end\", null);\r\n                        if (end != null) {\r\n                            var slot = skeletonData.findSlot(end);\r\n                            if (slot == null)\r\n                                throw new Error(\"Clipping end slot not found: \" + end);\r\n                            clip.endSlot = slot;\r\n                        }\r\n                        var vertexCount = map.vertexCount;\r\n                        this.readVertices(map, clip, vertexCount << 1);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            clip.color.setFromString(color);\r\n                        return clip;\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n                var scale = this.scale;\r\n                attachment.worldVerticesLength = verticesLength;\r\n                var vertices = map.vertices;\r\n                if (verticesLength == vertices.length) {\r\n                    var scaledVertices = core.Utils.toFloatArray(vertices);\r\n                    if (scale != 1) {\r\n                        for (var i = 0, n = vertices.length; i < n; i++)\r\n                            scaledVertices[i] *= scale;\r\n                    }\r\n                    attachment.vertices = scaledVertices;\r\n                    return;\r\n                }\r\n                var weights = new Array();\r\n                var bones = new Array();\r\n                for (var i = 0, n = vertices.length; i < n;) {\r\n                    var boneCount = vertices[i++];\r\n                    bones.push(boneCount);\r\n                    for (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n                        bones.push(vertices[i]);\r\n                        weights.push(vertices[i + 1] * scale);\r\n                        weights.push(vertices[i + 2] * scale);\r\n                        weights.push(vertices[i + 3]);\r\n                    }\r\n                }\r\n                attachment.bones = bones;\r\n                attachment.vertices = core.Utils.toFloatArray(weights);\r\n            };\r\n            SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n                var scale = this.scale;\r\n                var timelines = new Array();\r\n                var duration = 0;\r\n                if (map.slots) {\r\n                    for (var slotName in map.slots) {\r\n                        var slotMap = map.slots[slotName];\r\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                        if (slotIndex == -1)\r\n                            throw new Error(\"Slot not found: \" + slotName);\r\n                        for (var timelineName in slotMap) {\r\n                            var timelineMap = slotMap[timelineName];\r\n                            if (timelineName == \"attachment\") {\r\n                                var timeline = new core.AttachmentTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                            }\r\n                            else if (timelineName == \"color\") {\r\n                                var timeline = new core.ColorTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var color = new core.Color();\r\n                                    color.setFromString(valueMap.color || \"ffffffff\");\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName == \"twoColor\") {\r\n                                var timeline = new core.TwoColorTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var light = new core.Color();\r\n                                    var dark = new core.Color();\r\n                                    light.setFromString(valueMap.light);\r\n                                    dark.setFromString(valueMap.dark);\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);\r\n                            }\r\n                            else\r\n                                throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                        }\r\n                    }\r\n                }\r\n                if (map.bones) {\r\n                    for (var boneName in map.bones) {\r\n                        var boneMap = map.bones[boneName];\r\n                        var boneIndex = skeletonData.findBoneIndex(boneName);\r\n                        if (boneIndex == -1)\r\n                            throw new Error(\"Bone not found: \" + boneName);\r\n                        for (var timelineName in boneMap) {\r\n                            var timelineMap = boneMap[timelineName];\r\n                            if (timelineName === \"rotate\") {\r\n                                var timeline = new core.RotateTimeline(timelineMap.length);\r\n                                timeline.boneIndex = boneIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                                var timeline = null;\r\n                                var timelineScale = 1, defaultValue = 0;\r\n                                if (timelineName === \"scale\") {\r\n                                    timeline = new core.ScaleTimeline(timelineMap.length);\r\n                                    defaultValue = 1;\r\n                                }\r\n                                else if (timelineName === \"shear\")\r\n                                    timeline = new core.ShearTimeline(timelineMap.length);\r\n                                else {\r\n                                    timeline = new core.TranslateTimeline(timelineMap.length);\r\n                                    timelineScale = scale;\r\n                                }\r\n                                timeline.boneIndex = boneIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);\r\n                            }\r\n                            else\r\n                                throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                        }\r\n                    }\r\n                }\r\n                if (map.ik) {\r\n                    for (var constraintName in map.ik) {\r\n                        var constraintMap = map.ik[constraintName];\r\n                        var constraint = skeletonData.findIkConstraint(constraintName);\r\n                        var timeline = new core.IkConstraintTimeline(constraintMap.length);\r\n                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                        var frameIndex = 0;\r\n                        for (var i = 0; i < constraintMap.length; i++) {\r\n                            var valueMap = constraintMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale, this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n                if (map.transform) {\r\n                    for (var constraintName in map.transform) {\r\n                        var constraintMap = map.transform[constraintName];\r\n                        var constraint = skeletonData.findTransformConstraint(constraintName);\r\n                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);\r\n                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                        var frameIndex = 0;\r\n                        for (var i = 0; i < constraintMap.length; i++) {\r\n                            var valueMap = constraintMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n                if (map.path) {\r\n                    for (var constraintName in map.path) {\r\n                        var constraintMap = map.path[constraintName];\r\n                        var index = skeletonData.findPathConstraintIndex(constraintName);\r\n                        if (index == -1)\r\n                            throw new Error(\"Path constraint not found: \" + constraintName);\r\n                        var data = skeletonData.pathConstraints[index];\r\n                        for (var timelineName in constraintMap) {\r\n                            var timelineMap = constraintMap[timelineName];\r\n                            if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                                var timeline = null;\r\n                                var timelineScale = 1;\r\n                                if (timelineName === \"spacing\") {\r\n                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);\r\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                else {\r\n                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);\r\n                                    if (data.positionMode == core.PositionMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                timeline.pathConstraintIndex = index;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName === \"mix\") {\r\n                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);\r\n                                timeline.pathConstraintIndex = index;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (map.deform) {\r\n                    for (var deformName in map.deform) {\r\n                        var deformMap = map.deform[deformName];\r\n                        var skin = skeletonData.findSkin(deformName);\r\n                        if (skin == null) {\r\n                            if (core.FAIL_ON_NON_EXISTING_SKIN) {\r\n                                throw new Error(\"Skin not found: \" + deformName);\r\n                            }\r\n                            else {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        for (var slotName in deformMap) {\r\n                            var slotMap = deformMap[slotName];\r\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                            if (slotIndex == -1)\r\n                                throw new Error(\"Slot not found: \" + slotMap.name);\r\n                            for (var timelineName in slotMap) {\r\n                                var timelineMap = slotMap[timelineName];\r\n                                var attachment = skin.getAttachment(slotIndex, timelineName);\r\n                                if (attachment == null)\r\n                                    throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                                var weighted = attachment.bones != null;\r\n                                var vertices = attachment.vertices;\r\n                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                                var timeline = new core.DeformTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                timeline.attachment = attachment;\r\n                                var frameIndex = 0;\r\n                                for (var j = 0; j < timelineMap.length; j++) {\r\n                                    var valueMap = timelineMap[j];\r\n                                    var deform = void 0;\r\n                                    var verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n                                    if (verticesValue == null)\r\n                                        deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;\r\n                                    else {\r\n                                        deform = core.Utils.newFloatArray(deformLength);\r\n                                        var start = this.getValue(valueMap, \"offset\", 0);\r\n                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                        if (scale != 1) {\r\n                                            for (var i = start, n = i + verticesValue.length; i < n; i++)\r\n                                                deform[i] *= scale;\r\n                                        }\r\n                                        if (!weighted) {\r\n                                            for (var i = 0; i < deformLength; i++)\r\n                                                deform[i] += vertices[i];\r\n                                        }\r\n                                    }\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var drawOrderNode = map.drawOrder;\r\n                if (drawOrderNode == null)\r\n                    drawOrderNode = map.draworder;\r\n                if (drawOrderNode != null) {\r\n                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);\r\n                    var slotCount = skeletonData.slots.length;\r\n                    var frameIndex = 0;\r\n                    for (var j = 0; j < drawOrderNode.length; j++) {\r\n                        var drawOrderMap = drawOrderNode[j];\r\n                        var drawOrder = null;\r\n                        var offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                        if (offsets != null) {\r\n                            drawOrder = core.Utils.newArray(slotCount, -1);\r\n                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);\r\n                            var originalIndex = 0, unchangedIndex = 0;\r\n                            for (var i = 0; i < offsets.length; i++) {\r\n                                var offsetMap = offsets[i];\r\n                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                                if (slotIndex == -1)\r\n                                    throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                                while (originalIndex != slotIndex)\r\n                                    unchanged[unchangedIndex++] = originalIndex++;\r\n                                drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                            }\r\n                            while (originalIndex < slotCount)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            for (var i = slotCount - 1; i >= 0; i--)\r\n                                if (drawOrder[i] == -1)\r\n                                    drawOrder[i] = unchanged[--unchangedIndex];\r\n                        }\r\n                        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n                if (map.events) {\r\n                    var timeline = new core.EventTimeline(map.events.length);\r\n                    var frameIndex = 0;\r\n                    for (var i = 0; i < map.events.length; i++) {\r\n                        var eventMap = map.events[i];\r\n                        var eventData = skeletonData.findEvent(eventMap.name);\r\n                        if (eventData == null)\r\n                            throw new Error(\"Event not found: \" + eventMap.name);\r\n                        var event_6 = new core.Event(core.Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n                        event_6.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                        event_6.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                        event_6.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                        if (event_6.data.audioPath != null) {\r\n                            event_6.volume = this.getValue(eventMap, \"volume\", 1);\r\n                            event_6.balance = this.getValue(eventMap, \"balance\", 0);\r\n                        }\r\n                        timeline.setFrame(frameIndex++, event_6);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n                if (isNaN(duration)) {\r\n                    throw new Error(\"Error while parsing animation, duration is NaN\");\r\n                }\r\n                skeletonData.animations.push(new core.Animation(name, timelines, duration));\r\n            };\r\n            SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n                if (!map.hasOwnProperty(\"curve\"))\r\n                    return;\r\n                if (map.curve === \"stepped\")\r\n                    timeline.setStepped(frameIndex);\r\n                else {\r\n                    var curve = map.curve;\r\n                    timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n                }\r\n            };\r\n            SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n                return map[prop] !== undefined ? map[prop] : defaultValue;\r\n            };\r\n            SkeletonJson.blendModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"normal\")\r\n                    return core.BlendMode.Normal;\r\n                if (str == \"additive\")\r\n                    return core.BlendMode.Additive;\r\n                if (str == \"multiply\")\r\n                    return core.BlendMode.Multiply;\r\n                if (str == \"screen\")\r\n                    return core.BlendMode.Screen;\r\n                throw new Error(\"Unknown blend mode: \" + str);\r\n            };\r\n            SkeletonJson.positionModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"fixed\")\r\n                    return core.PositionMode.Fixed;\r\n                if (str == \"percent\")\r\n                    return core.PositionMode.Percent;\r\n                throw new Error(\"Unknown position mode: \" + str);\r\n            };\r\n            SkeletonJson.spacingModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"length\")\r\n                    return core.SpacingMode.Length;\r\n                if (str == \"fixed\")\r\n                    return core.SpacingMode.Fixed;\r\n                if (str == \"percent\")\r\n                    return core.SpacingMode.Percent;\r\n                throw new Error(\"Unknown position mode: \" + str);\r\n            };\r\n            SkeletonJson.rotateModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"tangent\")\r\n                    return core.RotateMode.Tangent;\r\n                if (str == \"chain\")\r\n                    return core.RotateMode.Chain;\r\n                if (str == \"chainscale\")\r\n                    return core.RotateMode.ChainScale;\r\n                throw new Error(\"Unknown rotate mode: \" + str);\r\n            };\r\n            SkeletonJson.transformModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"normal\")\r\n                    return core.TransformMode.Normal;\r\n                if (str == \"onlytranslation\")\r\n                    return core.TransformMode.OnlyTranslation;\r\n                if (str == \"norotationorreflection\")\r\n                    return core.TransformMode.NoRotationOrReflection;\r\n                if (str == \"noscale\")\r\n                    return core.TransformMode.NoScale;\r\n                if (str == \"noscaleorreflection\")\r\n                    return core.TransformMode.NoScaleOrReflection;\r\n                throw new Error(\"Unknown transform mode: \" + str);\r\n            };\r\n            return SkeletonJson;\r\n        }());\r\n        core.SkeletonJson = SkeletonJson;\r\n        var LinkedMesh = (function () {\r\n            function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n                this.mesh = mesh;\r\n                this.skin = skin;\r\n                this.slotIndex = slotIndex;\r\n                this.parent = parent;\r\n                this.inheritDeform = inheritDeform;\r\n            }\r\n            return LinkedMesh;\r\n        }());\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkinEntry = (function () {\r\n            function SkinEntry(slotIndex, name, attachment) {\r\n                this.slotIndex = slotIndex;\r\n                this.name = name;\r\n                this.attachment = attachment;\r\n            }\r\n            return SkinEntry;\r\n        }());\r\n        core.SkinEntry = SkinEntry;\r\n        var Skin = (function () {\r\n            function Skin(name) {\r\n                this.attachments = new Array();\r\n                this.bones = Array();\r\n                this.constraints = new Array();\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.name = name;\r\n            }\r\n            Skin.prototype.setAttachment = function (slotIndex, name, attachment) {\r\n                if (attachment == null)\r\n                    throw new Error(\"attachment cannot be null.\");\r\n                var attachments = this.attachments;\r\n                if (slotIndex >= attachments.length)\r\n                    attachments.length = slotIndex + 1;\r\n                if (!attachments[slotIndex])\r\n                    attachments[slotIndex] = {};\r\n                attachments[slotIndex][name] = attachment;\r\n            };\r\n            Skin.prototype.addSkin = function (skin) {\r\n                for (var i = 0; i < skin.bones.length; i++) {\r\n                    var bone = skin.bones[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.bones.length; j++) {\r\n                        if (this.bones[j] == bone) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.bones.push(bone);\r\n                }\r\n                for (var i = 0; i < skin.constraints.length; i++) {\r\n                    var constraint = skin.constraints[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.constraints.length; j++) {\r\n                        if (this.constraints[j] == constraint) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.constraints.push(constraint);\r\n                }\r\n                var attachments = skin.getAttachments();\r\n                for (var i = 0; i < attachments.length; i++) {\r\n                    var attachment = attachments[i];\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                }\r\n            };\r\n            Skin.prototype.copySkin = function (skin) {\r\n                for (var i = 0; i < skin.bones.length; i++) {\r\n                    var bone = skin.bones[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.bones.length; j++) {\r\n                        if (this.bones[j] == bone) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.bones.push(bone);\r\n                }\r\n                for (var i = 0; i < skin.constraints.length; i++) {\r\n                    var constraint = skin.constraints[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.constraints.length; j++) {\r\n                        if (this.constraints[j] == constraint) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.constraints.push(constraint);\r\n                }\r\n                var attachments = skin.getAttachments();\r\n                for (var i = 0; i < attachments.length; i++) {\r\n                    var attachment = attachments[i];\r\n                    if (attachment.attachment == null)\r\n                        continue;\r\n                    if (attachment.attachment instanceof core.MeshAttachment) {\r\n                        attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                    }\r\n                    else {\r\n                        attachment.attachment = attachment.attachment.copy();\r\n                        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                    }\r\n                }\r\n            };\r\n            Skin.prototype.getAttachment = function (slotIndex, name) {\r\n                var dictionary = this.attachments[slotIndex];\r\n                return dictionary ? dictionary[name] : null;\r\n            };\r\n            Skin.prototype.removeAttachment = function (slotIndex, name) {\r\n                var dictionary = this.attachments[slotIndex];\r\n                if (dictionary)\r\n                    dictionary[name] = null;\r\n            };\r\n            Skin.prototype.getAttachments = function () {\r\n                var entries = new Array();\r\n                for (var i = 0; i < this.attachments.length; i++) {\r\n                    var slotAttachments = this.attachments[i];\r\n                    if (slotAttachments) {\r\n                        for (var name_4 in slotAttachments) {\r\n                            var attachment = slotAttachments[name_4];\r\n                            if (attachment)\r\n                                entries.push(new SkinEntry(i, name_4, attachment));\r\n                        }\r\n                    }\r\n                }\r\n                return entries;\r\n            };\r\n            Skin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {\r\n                var slotAttachments = this.attachments[slotIndex];\r\n                if (slotAttachments) {\r\n                    for (var name_5 in slotAttachments) {\r\n                        var attachment = slotAttachments[name_5];\r\n                        if (attachment)\r\n                            attachments.push(new SkinEntry(slotIndex, name_5, attachment));\r\n                    }\r\n                }\r\n            };\r\n            Skin.prototype.clear = function () {\r\n                this.attachments.length = 0;\r\n                this.bones.length = 0;\r\n                this.constraints.length = 0;\r\n            };\r\n            Skin.prototype.attachAll = function (skeleton, oldSkin) {\r\n                var slotIndex = 0;\r\n                for (var i = 0; i < skeleton.slots.length; i++) {\r\n                    var slot = skeleton.slots[i];\r\n                    var slotAttachment = slot.getAttachment();\r\n                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                        var dictionary = oldSkin.attachments[slotIndex];\r\n                        for (var key in dictionary) {\r\n                            var skinAttachment = dictionary[key];\r\n                            if (slotAttachment == skinAttachment) {\r\n                                var attachment = this.getAttachment(slotIndex, key);\r\n                                if (attachment != null)\r\n                                    slot.setAttachment(attachment);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    slotIndex++;\r\n                }\r\n            };\r\n            return Skin;\r\n        }());\r\n        core.Skin = Skin;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Slot = (function () {\r\n            function Slot(data, bone) {\r\n                this.deform = new Array();\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (bone == null)\r\n                    throw new Error(\"bone cannot be null.\");\r\n                this.data = data;\r\n                this.bone = bone;\r\n                this.color = new core.Color();\r\n                this.darkColor = data.darkColor == null ? null : new core.Color();\r\n                this.setToSetupPose();\r\n                this.blendMode = this.data.blendMode;\r\n            }\r\n            Slot.prototype.getAttachment = function () {\r\n                return this.attachment;\r\n            };\r\n            Slot.prototype.setAttachment = function (attachment) {\r\n                if (this.attachment == attachment)\r\n                    return;\r\n                this.attachment = attachment;\r\n                this.attachmentTime = this.bone.skeleton.time;\r\n                this.deform.length = 0;\r\n            };\r\n            Slot.prototype.setAttachmentTime = function (time) {\r\n                this.attachmentTime = this.bone.skeleton.time - time;\r\n            };\r\n            Slot.prototype.getAttachmentTime = function () {\r\n                return this.bone.skeleton.time - this.attachmentTime;\r\n            };\r\n            Slot.prototype.setToSetupPose = function () {\r\n                this.color.setFromColor(this.data.color);\r\n                if (this.darkColor != null)\r\n                    this.darkColor.setFromColor(this.data.darkColor);\r\n                if (this.data.attachmentName == null)\r\n                    this.attachment = null;\r\n                else {\r\n                    this.attachment = null;\r\n                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n                }\r\n            };\r\n            return Slot;\r\n        }());\r\n        core.Slot = Slot;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SlotData = (function () {\r\n            function SlotData(index, name, boneData) {\r\n                this.color = new core.Color(1, 1, 1, 1);\r\n                if (index < 0)\r\n                    throw new Error(\"index must be >= 0.\");\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                if (boneData == null)\r\n                    throw new Error(\"boneData cannot be null.\");\r\n                this.index = index;\r\n                this.name = name;\r\n                this.boneData = boneData;\r\n            }\r\n            return SlotData;\r\n        }());\r\n        core.SlotData = SlotData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Texture = (function () {\r\n            function Texture(image) {\r\n                this._image = image;\r\n            }\r\n            Texture.prototype.getImage = function () {\r\n                return this._image;\r\n            };\r\n            Texture.filterFromString = function (text) {\r\n                switch (text.toLowerCase()) {\r\n                    case \"nearest\": return TextureFilter.Nearest;\r\n                    case \"linear\": return TextureFilter.Linear;\r\n                    case \"mipmap\": return TextureFilter.MipMap;\r\n                    case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n                    case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n                    case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n                    case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n                    default: throw new Error(\"Unknown texture filter \" + text);\r\n                }\r\n            };\r\n            Texture.wrapFromString = function (text) {\r\n                switch (text.toLowerCase()) {\r\n                    case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n                    case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n                    case \"repeat\": return TextureWrap.Repeat;\r\n                    default: throw new Error(\"Unknown texture wrap \" + text);\r\n                }\r\n            };\r\n            return Texture;\r\n        }());\r\n        core.Texture = Texture;\r\n        var TextureFilter;\r\n        (function (TextureFilter) {\r\n            TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n            TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n            TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n            TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n            TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n            TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n            TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n        })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));\r\n        var TextureWrap;\r\n        (function (TextureWrap) {\r\n            TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n            TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n            TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));\r\n        var TextureRegion = (function () {\r\n            function TextureRegion() {\r\n                this.size = null;\r\n            }\r\n            Object.defineProperty(TextureRegion.prototype, \"width\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        return tex.crop.width;\r\n                    }\r\n                    if (tex.trim) {\r\n                        return tex.trim.width;\r\n                    }\r\n                    return tex.orig.width;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"height\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        return tex.crop.height;\r\n                    }\r\n                    if (tex.trim) {\r\n                        return tex.trim.height;\r\n                    }\r\n                    return tex.orig.height;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"u\", {\r\n                get: function () {\r\n                    return this.texture._uvs.x0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"v\", {\r\n                get: function () {\r\n                    return this.texture._uvs.y0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"u2\", {\r\n                get: function () {\r\n                    return this.texture._uvs.x2;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"v2\", {\r\n                get: function () {\r\n                    return this.texture._uvs.y2;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"offsetX\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return tex.trim ? tex.trim.x : 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"offsetY\", {\r\n                get: function () {\r\n                    console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n                    return this.spineOffsetY;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"pixiOffsetY\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return tex.trim ? tex.trim.y : 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"spineOffsetY\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"originalWidth\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        if (tex.trim) {\r\n                            return tex.trim.width;\r\n                        }\r\n                        return tex.crop.width;\r\n                    }\r\n                    return tex.orig.width;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"originalHeight\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        if (tex.trim) {\r\n                            return tex.trim.height;\r\n                        }\r\n                        return tex.crop.height;\r\n                    }\r\n                    return tex.orig.height;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"x\", {\r\n                get: function () {\r\n                    return this.texture.frame.x;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"y\", {\r\n                get: function () {\r\n                    return this.texture.frame.y;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"rotate\", {\r\n                get: function () {\r\n                    return this.texture.rotate !== 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            return TextureRegion;\r\n        }());\r\n        core.TextureRegion = TextureRegion;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TextureAtlas = (function () {\r\n            function TextureAtlas(atlasText, textureLoader, callback) {\r\n                this.pages = new Array();\r\n                this.regions = new Array();\r\n                if (atlasText) {\r\n                    this.addSpineAtlas(atlasText, textureLoader, callback);\r\n                }\r\n            }\r\n            TextureAtlas.prototype.addTexture = function (name, texture) {\r\n                var pages = this.pages;\r\n                var page = null;\r\n                for (var i = 0; i < pages.length; i++) {\r\n                    if (pages[i].baseTexture === texture.baseTexture) {\r\n                        page = pages[i];\r\n                        break;\r\n                    }\r\n                }\r\n                if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = 'texturePage';\r\n                    var baseTexture = texture.baseTexture;\r\n                    page.width = baseTexture.realWidth;\r\n                    page.height = baseTexture.realHeight;\r\n                    page.baseTexture = baseTexture;\r\n                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;\r\n                    page.uWrap = core.TextureWrap.ClampToEdge;\r\n                    page.vWrap = core.TextureWrap.ClampToEdge;\r\n                    pages.push(page);\r\n                }\r\n                var region = new TextureAtlasRegion();\r\n                region.name = name;\r\n                region.page = page;\r\n                region.texture = texture;\r\n                region.index = -1;\r\n                this.regions.push(region);\r\n                return region;\r\n            };\r\n            TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {\r\n                for (var key in textures) {\r\n                    if (textures.hasOwnProperty(key)) {\r\n                        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n                    }\r\n                }\r\n            };\r\n            TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {\r\n                return this.load(atlasText, textureLoader, callback);\r\n            };\r\n            TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {\r\n                var _this = this;\r\n                if (textureLoader == null)\r\n                    throw new Error(\"textureLoader cannot be null.\");\r\n                var reader = new TextureAtlasReader(atlasText);\r\n                var tuple = new Array(4);\r\n                var page = null;\r\n                var iterateParser = function () {\r\n                    while (true) {\r\n                        var line = reader.readLine();\r\n                        if (line == null) {\r\n                            return callback && callback(_this);\r\n                        }\r\n                        line = line.trim();\r\n                        if (line.length == 0)\r\n                            page = null;\r\n                        else if (!page) {\r\n                            page = new TextureAtlasPage();\r\n                            page.name = line;\r\n                            if (reader.readTuple(tuple) == 2) {\r\n                                page.width = parseInt(tuple[0]);\r\n                                page.height = parseInt(tuple[1]);\r\n                                reader.readTuple(tuple);\r\n                            }\r\n                            reader.readTuple(tuple);\r\n                            page.minFilter = core.Texture.filterFromString(tuple[0]);\r\n                            page.magFilter = core.Texture.filterFromString(tuple[1]);\r\n                            var direction = reader.readValue();\r\n                            page.uWrap = core.TextureWrap.ClampToEdge;\r\n                            page.vWrap = core.TextureWrap.ClampToEdge;\r\n                            if (direction == \"x\")\r\n                                page.uWrap = core.TextureWrap.Repeat;\r\n                            else if (direction == \"y\")\r\n                                page.vWrap = core.TextureWrap.Repeat;\r\n                            else if (direction == \"xy\")\r\n                                page.uWrap = page.vWrap = core.TextureWrap.Repeat;\r\n                            textureLoader(line, function (texture) {\r\n                                if (texture === null) {\r\n                                    _this.pages.splice(_this.pages.indexOf(page), 1);\r\n                                    return callback && callback(null);\r\n                                }\r\n                                page.baseTexture = texture;\r\n                                if (!texture.valid) {\r\n                                    texture.setSize(page.width, page.height);\r\n                                }\r\n                                _this.pages.push(page);\r\n                                page.setFilters();\r\n                                if (!page.width || !page.height) {\r\n                                    page.width = texture.realWidth;\r\n                                    page.height = texture.realHeight;\r\n                                    if (!page.width || !page.height) {\r\n                                        console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                                    }\r\n                                }\r\n                                iterateParser();\r\n                            });\r\n                            _this.pages.push(page);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            var region = new TextureAtlasRegion();\r\n                            region.name = line;\r\n                            region.page = page;\r\n                            var rotateValue = reader.readValue();\r\n                            var rotate = 0;\r\n                            if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                                rotate = 6;\r\n                            }\r\n                            else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                                rotate = 0;\r\n                            }\r\n                            else {\r\n                                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n                            }\r\n                            reader.readTuple(tuple);\r\n                            var x = parseInt(tuple[0]);\r\n                            var y = parseInt(tuple[1]);\r\n                            reader.readTuple(tuple);\r\n                            var width = parseInt(tuple[0]);\r\n                            var height = parseInt(tuple[1]);\r\n                            var resolution = page.baseTexture.resolution;\r\n                            x /= resolution;\r\n                            y /= resolution;\r\n                            width /= resolution;\r\n                            height /= resolution;\r\n                            var swapWH = rotate % 4 != 0;\r\n                            var frame = new PIXI.Rectangle(x, y, swapWH ? height : width, swapWH ? width : height);\r\n                            if (reader.readTuple(tuple) == 4) {\r\n                                if (reader.readTuple(tuple) == 4) {\r\n                                    reader.readTuple(tuple);\r\n                                }\r\n                            }\r\n                            var originalWidth = parseInt(tuple[0]) / resolution;\r\n                            var originalHeight = parseInt(tuple[1]) / resolution;\r\n                            reader.readTuple(tuple);\r\n                            var offsetX = parseInt(tuple[0]) / resolution;\r\n                            var offsetY = parseInt(tuple[1]) / resolution;\r\n                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                            var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n                            if (PIXI.VERSION[0] != '3') {\r\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\r\n                            }\r\n                            else {\r\n                                var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                                var crop = frame2.clone();\r\n                                trim.width = originalWidth;\r\n                                trim.height = originalHeight;\r\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\r\n                            }\r\n                            region.index = parseInt(reader.readValue());\r\n                            region.texture.updateUvs();\r\n                            _this.regions.push(region);\r\n                        }\r\n                    }\r\n                };\r\n                iterateParser();\r\n            };\r\n            TextureAtlas.prototype.findRegion = function (name) {\r\n                for (var i = 0; i < this.regions.length; i++) {\r\n                    if (this.regions[i].name == name) {\r\n                        return this.regions[i];\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            TextureAtlas.prototype.dispose = function () {\r\n                for (var i = 0; i < this.pages.length; i++) {\r\n                    this.pages[i].baseTexture.dispose();\r\n                }\r\n            };\r\n            return TextureAtlas;\r\n        }());\r\n        core.TextureAtlas = TextureAtlas;\r\n        var TextureAtlasReader = (function () {\r\n            function TextureAtlasReader(text) {\r\n                this.index = 0;\r\n                this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n            }\r\n            TextureAtlasReader.prototype.readLine = function () {\r\n                if (this.index >= this.lines.length)\r\n                    return null;\r\n                return this.lines[this.index++];\r\n            };\r\n            TextureAtlasReader.prototype.readValue = function () {\r\n                var line = this.readLine();\r\n                var colon = line.indexOf(\":\");\r\n                if (colon == -1)\r\n                    throw new Error(\"Invalid line: \" + line);\r\n                return line.substring(colon + 1).trim();\r\n            };\r\n            TextureAtlasReader.prototype.readTuple = function (tuple) {\r\n                var line = this.readLine();\r\n                var colon = line.indexOf(\":\");\r\n                if (colon == -1)\r\n                    throw new Error(\"Invalid line: \" + line);\r\n                var i = 0, lastMatch = colon + 1;\r\n                for (; i < 3; i++) {\r\n                    var comma = line.indexOf(\",\", lastMatch);\r\n                    if (comma == -1)\r\n                        break;\r\n                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n                    lastMatch = comma + 1;\r\n                }\r\n                tuple[i] = line.substring(lastMatch).trim();\r\n                return i + 1;\r\n            };\r\n            return TextureAtlasReader;\r\n        }());\r\n        var TextureAtlasPage = (function () {\r\n            function TextureAtlasPage() {\r\n            }\r\n            TextureAtlasPage.prototype.setFilters = function () {\r\n                var tex = this.baseTexture;\r\n                var filter = this.minFilter;\r\n                if (filter == core.TextureFilter.Linear) {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n                }\r\n                else if (this.minFilter == core.TextureFilter.Nearest) {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n                }\r\n                else {\r\n                    tex.mipmap = PIXI.MIPMAP_MODES.POW2;\r\n                    if (filter == core.TextureFilter.MipMapNearestNearest) {\r\n                        tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n                    }\r\n                    else {\r\n                        tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n                    }\r\n                }\r\n            };\r\n            return TextureAtlasPage;\r\n        }());\r\n        core.TextureAtlasPage = TextureAtlasPage;\r\n        var TextureAtlasRegion = (function (_super) {\r\n            __extends(TextureAtlasRegion, _super);\r\n            function TextureAtlasRegion() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            return TextureAtlasRegion;\r\n        }(core.TextureRegion));\r\n        core.TextureAtlasRegion = TextureAtlasRegion;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TransformConstraint = (function () {\r\n            function TransformConstraint(data, skeleton) {\r\n                this.rotateMix = 0;\r\n                this.translateMix = 0;\r\n                this.scaleMix = 0;\r\n                this.shearMix = 0;\r\n                this.temp = new core.Vector2();\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.rotateMix = data.rotateMix;\r\n                this.translateMix = data.translateMix;\r\n                this.scaleMix = data.scaleMix;\r\n                this.shearMix = data.shearMix;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findBone(data.target.name);\r\n            }\r\n            TransformConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            TransformConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            TransformConstraint.prototype.update = function () {\r\n                if (this.data.local) {\r\n                    if (this.data.relative)\r\n                        this.applyRelativeLocal();\r\n                    else\r\n                        this.applyAbsoluteLocal();\r\n                }\r\n                else {\r\n                    if (this.data.relative)\r\n                        this.applyRelativeWorld();\r\n                    else\r\n                        this.applyAbsoluteWorld();\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                var targetMat = target.matrix;\r\n                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                var offsetRotation = this.data.offsetRotation * degRadReflect;\r\n                var offsetShearY = this.data.offsetShearY * degRadReflect;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    var modified = false;\r\n                    var mat = bone.matrix;\r\n                    if (rotateMix != 0) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        var cos = Math.cos(r), sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                        modified = true;\r\n                    }\r\n                    if (translateMix != 0) {\r\n                        var temp = this.temp;\r\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                        mat.tx += (temp.x - mat.tx) * translateMix;\r\n                        mat.ty += (temp.y - mat.ty) * translateMix;\r\n                        modified = true;\r\n                    }\r\n                    if (scaleMix > 0) {\r\n                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                        var ts = Math.sqrt(ta * ta + tc * tc);\r\n                        if (s > 0.00001)\r\n                            s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                        mat.a *= s;\r\n                        mat.b *= s;\r\n                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                        ts = Math.sqrt(tb * tb + td * td);\r\n                        if (s > 0.00001)\r\n                            s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                        mat.c *= s;\r\n                        mat.d *= s;\r\n                        modified = true;\r\n                    }\r\n                    if (shearMix > 0) {\r\n                        var b = mat.c, d = mat.d;\r\n                        var by = Math.atan2(d, b);\r\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r = by + (r + offsetShearY) * shearMix;\r\n                        var s = Math.sqrt(b * b + d * d);\r\n                        mat.c = Math.cos(r) * s;\r\n                        mat.d = Math.sin(r) * s;\r\n                        modified = true;\r\n                    }\r\n                    if (modified)\r\n                        bone.appliedValid = false;\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyRelativeWorld = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                var targetMat = target.matrix;\r\n                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    var modified = false;\r\n                    var mat = bone.matrix;\r\n                    if (rotateMix != 0) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                        var r = Math.atan2(tc, ta) + offsetRotation;\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        var cos = Math.cos(r), sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                        modified = true;\r\n                    }\r\n                    if (translateMix != 0) {\r\n                        var temp = this.temp;\r\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                        mat.tx += temp.x * translateMix;\r\n                        mat.ty += temp.y * translateMix;\r\n                        modified = true;\r\n                    }\r\n                    if (scaleMix > 0) {\r\n                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                        mat.a *= s;\r\n                        mat.b *= s;\r\n                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                        mat.c *= s;\r\n                        mat.d *= s;\r\n                        modified = true;\r\n                    }\r\n                    if (shearMix > 0) {\r\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        var b = mat.c, d = mat.d;\r\n                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                        var s = Math.sqrt(b * b + d * d);\r\n                        mat.c = Math.cos(r) * s;\r\n                        mat.d = Math.sin(r) * s;\r\n                        modified = true;\r\n                    }\r\n                    if (modified)\r\n                        bone.appliedValid = false;\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                if (!target.appliedValid)\r\n                    target.updateAppliedTransform();\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.appliedValid)\r\n                        bone.updateAppliedTransform();\r\n                    var rotation = bone.arotation;\r\n                    if (rotateMix != 0) {\r\n                        var r = target.arotation - rotation + this.data.offsetRotation;\r\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                        rotation += r * rotateMix;\r\n                    }\r\n                    var x = bone.ax, y = bone.ay;\r\n                    if (translateMix != 0) {\r\n                        x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                        y += (target.ay - y + this.data.offsetY) * translateMix;\r\n                    }\r\n                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                    if (scaleMix > 0) {\r\n                        if (scaleX > 0.00001)\r\n                            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                        if (scaleY > 0.00001)\r\n                            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n                    }\r\n                    var shearY = bone.ashearY;\r\n                    if (shearMix > 0) {\r\n                        var r = target.ashearY - shearY + this.data.offsetShearY;\r\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                        bone.shearY += r * shearMix;\r\n                    }\r\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyRelativeLocal = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                if (!target.appliedValid)\r\n                    target.updateAppliedTransform();\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.appliedValid)\r\n                        bone.updateAppliedTransform();\r\n                    var rotation = bone.arotation;\r\n                    if (rotateMix != 0)\r\n                        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n                    var x = bone.ax, y = bone.ay;\r\n                    if (translateMix != 0) {\r\n                        x += (target.ax + this.data.offsetX) * translateMix;\r\n                        y += (target.ay + this.data.offsetY) * translateMix;\r\n                    }\r\n                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                    if (scaleMix > 0) {\r\n                        if (scaleX > 0.00001)\r\n                            scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                        if (scaleY > 0.00001)\r\n                            scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n                    }\r\n                    var shearY = bone.ashearY;\r\n                    if (shearMix > 0)\r\n                        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n                }\r\n            };\r\n            return TransformConstraint;\r\n        }());\r\n        core.TransformConstraint = TransformConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TransformConstraintData = (function (_super) {\r\n            __extends(TransformConstraintData, _super);\r\n            function TransformConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                _this.rotateMix = 0;\r\n                _this.translateMix = 0;\r\n                _this.scaleMix = 0;\r\n                _this.shearMix = 0;\r\n                _this.offsetRotation = 0;\r\n                _this.offsetX = 0;\r\n                _this.offsetY = 0;\r\n                _this.offsetScaleX = 0;\r\n                _this.offsetScaleY = 0;\r\n                _this.offsetShearY = 0;\r\n                _this.relative = false;\r\n                _this.local = false;\r\n                return _this;\r\n            }\r\n            return TransformConstraintData;\r\n        }(core.ConstraintData));\r\n        core.TransformConstraintData = TransformConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Triangulator = (function () {\r\n            function Triangulator() {\r\n                this.convexPolygons = new Array();\r\n                this.convexPolygonsIndices = new Array();\r\n                this.indicesArray = new Array();\r\n                this.isConcaveArray = new Array();\r\n                this.triangles = new Array();\r\n                this.polygonPool = new core.Pool(function () {\r\n                    return new Array();\r\n                });\r\n                this.polygonIndicesPool = new core.Pool(function () {\r\n                    return new Array();\r\n                });\r\n            }\r\n            Triangulator.prototype.triangulate = function (verticesArray) {\r\n                var vertices = verticesArray;\r\n                var vertexCount = verticesArray.length >> 1;\r\n                var indices = this.indicesArray;\r\n                indices.length = 0;\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    indices[i] = i;\r\n                var isConcave = this.isConcaveArray;\r\n                isConcave.length = 0;\r\n                for (var i = 0, n = vertexCount; i < n; ++i)\r\n                    isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n                var triangles = this.triangles;\r\n                triangles.length = 0;\r\n                while (vertexCount > 3) {\r\n                    var previous = vertexCount - 1, i = 0, next = 1;\r\n                    while (true) {\r\n                        outer: if (!isConcave[i]) {\r\n                            var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n                            var p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n                            var p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n                            var p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n                                if (!isConcave[ii])\r\n                                    continue;\r\n                                var v = indices[ii] << 1;\r\n                                var vx = vertices[v], vy = vertices[v + 1];\r\n                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n                                            break outer;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (next == 0) {\r\n                            do {\r\n                                if (!isConcave[i])\r\n                                    break;\r\n                                i--;\r\n                            } while (i > 0);\r\n                            break;\r\n                        }\r\n                        previous = i;\r\n                        i = next;\r\n                        next = (next + 1) % vertexCount;\r\n                    }\r\n                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n                    triangles.push(indices[i]);\r\n                    triangles.push(indices[(i + 1) % vertexCount]);\r\n                    indices.splice(i, 1);\r\n                    isConcave.splice(i, 1);\r\n                    vertexCount--;\r\n                    var previousIndex = (vertexCount + i - 1) % vertexCount;\r\n                    var nextIndex = i == vertexCount ? 0 : i;\r\n                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n                }\r\n                if (vertexCount == 3) {\r\n                    triangles.push(indices[2]);\r\n                    triangles.push(indices[0]);\r\n                    triangles.push(indices[1]);\r\n                }\r\n                return triangles;\r\n            };\r\n            Triangulator.prototype.decompose = function (verticesArray, triangles) {\r\n                var vertices = verticesArray;\r\n                var convexPolygons = this.convexPolygons;\r\n                this.polygonPool.freeAll(convexPolygons);\r\n                convexPolygons.length = 0;\r\n                var convexPolygonsIndices = this.convexPolygonsIndices;\r\n                this.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n                convexPolygonsIndices.length = 0;\r\n                var polygonIndices = this.polygonIndicesPool.obtain();\r\n                polygonIndices.length = 0;\r\n                var polygon = this.polygonPool.obtain();\r\n                polygon.length = 0;\r\n                var fanBaseIndex = -1, lastWinding = 0;\r\n                for (var i = 0, n = triangles.length; i < n; i += 3) {\r\n                    var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n                    var x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n                    var x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n                    var x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n                    var merged = false;\r\n                    if (fanBaseIndex == t1) {\r\n                        var o = polygon.length - 4;\r\n                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n                        if (winding1 == lastWinding && winding2 == lastWinding) {\r\n                            polygon.push(x3);\r\n                            polygon.push(y3);\r\n                            polygonIndices.push(t3);\r\n                            merged = true;\r\n                        }\r\n                    }\r\n                    if (!merged) {\r\n                        if (polygon.length > 0) {\r\n                            convexPolygons.push(polygon);\r\n                            convexPolygonsIndices.push(polygonIndices);\r\n                        }\r\n                        else {\r\n                            this.polygonPool.free(polygon);\r\n                            this.polygonIndicesPool.free(polygonIndices);\r\n                        }\r\n                        polygon = this.polygonPool.obtain();\r\n                        polygon.length = 0;\r\n                        polygon.push(x1);\r\n                        polygon.push(y1);\r\n                        polygon.push(x2);\r\n                        polygon.push(y2);\r\n                        polygon.push(x3);\r\n                        polygon.push(y3);\r\n                        polygonIndices = this.polygonIndicesPool.obtain();\r\n                        polygonIndices.length = 0;\r\n                        polygonIndices.push(t1);\r\n                        polygonIndices.push(t2);\r\n                        polygonIndices.push(t3);\r\n                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n                        fanBaseIndex = t1;\r\n                    }\r\n                }\r\n                if (polygon.length > 0) {\r\n                    convexPolygons.push(polygon);\r\n                    convexPolygonsIndices.push(polygonIndices);\r\n                }\r\n                for (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n                    polygonIndices = convexPolygonsIndices[i];\r\n                    if (polygonIndices.length == 0)\r\n                        continue;\r\n                    var firstIndex = polygonIndices[0];\r\n                    var lastIndex = polygonIndices[polygonIndices.length - 1];\r\n                    polygon = convexPolygons[i];\r\n                    var o = polygon.length - 4;\r\n                    var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n                    var prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n                    var firstX = polygon[0], firstY = polygon[1];\r\n                    var secondX = polygon[2], secondY = polygon[3];\r\n                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n                    for (var ii = 0; ii < n; ii++) {\r\n                        if (ii == i)\r\n                            continue;\r\n                        var otherIndices = convexPolygonsIndices[ii];\r\n                        if (otherIndices.length != 3)\r\n                            continue;\r\n                        var otherFirstIndex = otherIndices[0];\r\n                        var otherSecondIndex = otherIndices[1];\r\n                        var otherLastIndex = otherIndices[2];\r\n                        var otherPoly = convexPolygons[ii];\r\n                        var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n                            continue;\r\n                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n                        if (winding1 == winding && winding2 == winding) {\r\n                            otherPoly.length = 0;\r\n                            otherIndices.length = 0;\r\n                            polygon.push(x3);\r\n                            polygon.push(y3);\r\n                            polygonIndices.push(otherLastIndex);\r\n                            prevPrevX = prevX;\r\n                            prevPrevY = prevY;\r\n                            prevX = x3;\r\n                            prevY = y3;\r\n                            ii = 0;\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n                    polygon = convexPolygons[i];\r\n                    if (polygon.length == 0) {\r\n                        convexPolygons.splice(i, 1);\r\n                        this.polygonPool.free(polygon);\r\n                        polygonIndices = convexPolygonsIndices[i];\r\n                        convexPolygonsIndices.splice(i, 1);\r\n                        this.polygonIndicesPool.free(polygonIndices);\r\n                    }\r\n                }\r\n                return convexPolygons;\r\n            };\r\n            Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n                var current = indices[index] << 1;\r\n                var next = indices[(index + 1) % vertexCount] << 1;\r\n                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n            };\r\n            Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n            };\r\n            Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n                var px = p2x - p1x, py = p2y - p1y;\r\n                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n            };\r\n            return Triangulator;\r\n        }());\r\n        core.Triangulator = Triangulator;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IntSet = (function () {\r\n            function IntSet() {\r\n                this.array = new Array();\r\n            }\r\n            IntSet.prototype.add = function (value) {\r\n                var contains = this.contains(value);\r\n                this.array[value | 0] = value | 0;\r\n                return !contains;\r\n            };\r\n            IntSet.prototype.contains = function (value) {\r\n                return this.array[value | 0] != undefined;\r\n            };\r\n            IntSet.prototype.remove = function (value) {\r\n                this.array[value | 0] = undefined;\r\n            };\r\n            IntSet.prototype.clear = function () {\r\n                this.array.length = 0;\r\n            };\r\n            return IntSet;\r\n        }());\r\n        core.IntSet = IntSet;\r\n        var Color = (function () {\r\n            function Color(r, g, b, a) {\r\n                if (r === void 0) { r = 0; }\r\n                if (g === void 0) { g = 0; }\r\n                if (b === void 0) { b = 0; }\r\n                if (a === void 0) { a = 0; }\r\n                this.r = r;\r\n                this.g = g;\r\n                this.b = b;\r\n                this.a = a;\r\n            }\r\n            Color.prototype.set = function (r, g, b, a) {\r\n                this.r = r;\r\n                this.g = g;\r\n                this.b = b;\r\n                this.a = a;\r\n                this.clamp();\r\n                return this;\r\n            };\r\n            Color.prototype.setFromColor = function (c) {\r\n                this.r = c.r;\r\n                this.g = c.g;\r\n                this.b = c.b;\r\n                this.a = c.a;\r\n                return this;\r\n            };\r\n            Color.prototype.setFromString = function (hex) {\r\n                hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n                this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n                this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n                this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n                return this;\r\n            };\r\n            Color.prototype.add = function (r, g, b, a) {\r\n                this.r += r;\r\n                this.g += g;\r\n                this.b += b;\r\n                this.a += a;\r\n                this.clamp();\r\n                return this;\r\n            };\r\n            Color.prototype.clamp = function () {\r\n                if (this.r < 0)\r\n                    this.r = 0;\r\n                else if (this.r > 1)\r\n                    this.r = 1;\r\n                if (this.g < 0)\r\n                    this.g = 0;\r\n                else if (this.g > 1)\r\n                    this.g = 1;\r\n                if (this.b < 0)\r\n                    this.b = 0;\r\n                else if (this.b > 1)\r\n                    this.b = 1;\r\n                if (this.a < 0)\r\n                    this.a = 0;\r\n                else if (this.a > 1)\r\n                    this.a = 1;\r\n                return this;\r\n            };\r\n            Color.rgba8888ToColor = function (color, value) {\r\n                color.r = ((value & 0xff000000) >>> 24) / 255;\r\n                color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n                color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n                color.a = ((value & 0x000000ff)) / 255;\r\n            };\r\n            Color.rgb888ToColor = function (color, value) {\r\n                color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n                color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n                color.b = ((value & 0x000000ff)) / 255;\r\n            };\r\n            Color.WHITE = new Color(1, 1, 1, 1);\r\n            Color.RED = new Color(1, 0, 0, 1);\r\n            Color.GREEN = new Color(0, 1, 0, 1);\r\n            Color.BLUE = new Color(0, 0, 1, 1);\r\n            Color.MAGENTA = new Color(1, 0, 1, 1);\r\n            return Color;\r\n        }());\r\n        core.Color = Color;\r\n        var MathUtils = (function () {\r\n            function MathUtils() {\r\n            }\r\n            MathUtils.clamp = function (value, min, max) {\r\n                if (value < min)\r\n                    return min;\r\n                if (value > max)\r\n                    return max;\r\n                return value;\r\n            };\r\n            MathUtils.cosDeg = function (degrees) {\r\n                return Math.cos(degrees * MathUtils.degRad);\r\n            };\r\n            MathUtils.sinDeg = function (degrees) {\r\n                return Math.sin(degrees * MathUtils.degRad);\r\n            };\r\n            MathUtils.signum = function (value) {\r\n                return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n            };\r\n            MathUtils.toInt = function (x) {\r\n                return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n            };\r\n            MathUtils.cbrt = function (x) {\r\n                var y = Math.pow(Math.abs(x), 1 / 3);\r\n                return x < 0 ? -y : y;\r\n            };\r\n            MathUtils.randomTriangular = function (min, max) {\r\n                return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n            };\r\n            MathUtils.randomTriangularWith = function (min, max, mode) {\r\n                var u = Math.random();\r\n                var d = max - min;\r\n                if (u <= (mode - min) / d)\r\n                    return min + Math.sqrt(u * d * (mode - min));\r\n                return max - Math.sqrt((1 - u) * d * (max - mode));\r\n            };\r\n            MathUtils.PI = 3.1415927;\r\n            MathUtils.PI2 = MathUtils.PI * 2;\r\n            MathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n            MathUtils.radDeg = MathUtils.radiansToDegrees;\r\n            MathUtils.degreesToRadians = MathUtils.PI / 180;\r\n            MathUtils.degRad = MathUtils.degreesToRadians;\r\n            return MathUtils;\r\n        }());\r\n        core.MathUtils = MathUtils;\r\n        var Interpolation = (function () {\r\n            function Interpolation() {\r\n            }\r\n            Interpolation.prototype.apply = function (start, end, a) {\r\n                return start + (end - start) * this.applyInternal(a);\r\n            };\r\n            return Interpolation;\r\n        }());\r\n        core.Interpolation = Interpolation;\r\n        var Pow = (function (_super) {\r\n            __extends(Pow, _super);\r\n            function Pow(power) {\r\n                var _this = _super.call(this) || this;\r\n                _this.power = 2;\r\n                _this.power = power;\r\n                return _this;\r\n            }\r\n            Pow.prototype.applyInternal = function (a) {\r\n                if (a <= 0.5)\r\n                    return Math.pow(a * 2, this.power) / 2;\r\n                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n            };\r\n            return Pow;\r\n        }(Interpolation));\r\n        core.Pow = Pow;\r\n        var PowOut = (function (_super) {\r\n            __extends(PowOut, _super);\r\n            function PowOut(power) {\r\n                return _super.call(this, power) || this;\r\n            }\r\n            PowOut.prototype.applyInternal = function (a) {\r\n                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n            };\r\n            return PowOut;\r\n        }(Pow));\r\n        core.PowOut = PowOut;\r\n        var Utils = (function () {\r\n            function Utils() {\r\n            }\r\n            Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n                for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n                    dest[j] = source[i];\r\n                }\r\n            };\r\n            Utils.setArraySize = function (array, size, value) {\r\n                if (value === void 0) { value = 0; }\r\n                var oldSize = array.length;\r\n                if (oldSize == size)\r\n                    return array;\r\n                array.length = size;\r\n                if (oldSize < size) {\r\n                    for (var i = oldSize; i < size; i++)\r\n                        array[i] = value;\r\n                }\r\n                return array;\r\n            };\r\n            Utils.ensureArrayCapacity = function (array, size, value) {\r\n                if (value === void 0) { value = 0; }\r\n                if (array.length >= size)\r\n                    return array;\r\n                return Utils.setArraySize(array, size, value);\r\n            };\r\n            Utils.newArray = function (size, defaultValue) {\r\n                var array = new Array(size);\r\n                for (var i = 0; i < size; i++)\r\n                    array[i] = defaultValue;\r\n                return array;\r\n            };\r\n            Utils.newFloatArray = function (size) {\r\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                    return new Float32Array(size);\r\n                }\r\n                else {\r\n                    var array = new Array(size);\r\n                    for (var i = 0; i < array.length; i++)\r\n                        array[i] = 0;\r\n                    return array;\r\n                }\r\n            };\r\n            Utils.newShortArray = function (size) {\r\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                    return new Int16Array(size);\r\n                }\r\n                else {\r\n                    var array = new Array(size);\r\n                    for (var i = 0; i < array.length; i++)\r\n                        array[i] = 0;\r\n                    return array;\r\n                }\r\n            };\r\n            Utils.toFloatArray = function (array) {\r\n                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n            };\r\n            Utils.toSinglePrecision = function (value) {\r\n                return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n            };\r\n            Utils.webkit602BugfixHelper = function (alpha, blend) {\r\n            };\r\n            Utils.contains = function (array, element, identity) {\r\n                if (identity === void 0) { identity = true; }\r\n                for (var i = 0; i < array.length; i++) {\r\n                    if (array[i] == element)\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n            return Utils;\r\n        }());\r\n        core.Utils = Utils;\r\n        var DebugUtils = (function () {\r\n            function DebugUtils() {\r\n            }\r\n            DebugUtils.logBones = function (skeleton) {\r\n                for (var i = 0; i < skeleton.bones.length; i++) {\r\n                    var bone = skeleton.bones[i];\r\n                    var mat = bone.matrix;\r\n                    console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\r\n                }\r\n            };\r\n            return DebugUtils;\r\n        }());\r\n        core.DebugUtils = DebugUtils;\r\n        var Pool = (function () {\r\n            function Pool(instantiator) {\r\n                this.items = new Array();\r\n                this.instantiator = instantiator;\r\n            }\r\n            Pool.prototype.obtain = function () {\r\n                return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n            };\r\n            Pool.prototype.free = function (item) {\r\n                if (item.reset)\r\n                    item.reset();\r\n                this.items.push(item);\r\n            };\r\n            Pool.prototype.freeAll = function (items) {\r\n                for (var i = 0; i < items.length; i++) {\r\n                    this.free(items[i]);\r\n                }\r\n            };\r\n            Pool.prototype.clear = function () {\r\n                this.items.length = 0;\r\n            };\r\n            return Pool;\r\n        }());\r\n        core.Pool = Pool;\r\n        var Vector2 = (function () {\r\n            function Vector2(x, y) {\r\n                if (x === void 0) { x = 0; }\r\n                if (y === void 0) { y = 0; }\r\n                this.x = x;\r\n                this.y = y;\r\n            }\r\n            Vector2.prototype.set = function (x, y) {\r\n                this.x = x;\r\n                this.y = y;\r\n                return this;\r\n            };\r\n            Vector2.prototype.length = function () {\r\n                var x = this.x;\r\n                var y = this.y;\r\n                return Math.sqrt(x * x + y * y);\r\n            };\r\n            Vector2.prototype.normalize = function () {\r\n                var len = this.length();\r\n                if (len != 0) {\r\n                    this.x /= len;\r\n                    this.y /= len;\r\n                }\r\n                return this;\r\n            };\r\n            return Vector2;\r\n        }());\r\n        core.Vector2 = Vector2;\r\n        var TimeKeeper = (function () {\r\n            function TimeKeeper() {\r\n                this.maxDelta = 0.064;\r\n                this.framesPerSecond = 0;\r\n                this.delta = 0;\r\n                this.totalTime = 0;\r\n                this.lastTime = Date.now() / 1000;\r\n                this.frameCount = 0;\r\n                this.frameTime = 0;\r\n            }\r\n            TimeKeeper.prototype.update = function () {\r\n                var now = Date.now() / 1000;\r\n                this.delta = now - this.lastTime;\r\n                this.frameTime += this.delta;\r\n                this.totalTime += this.delta;\r\n                if (this.delta > this.maxDelta)\r\n                    this.delta = this.maxDelta;\r\n                this.lastTime = now;\r\n                this.frameCount++;\r\n                if (this.frameTime > 1) {\r\n                    this.framesPerSecond = this.frameCount / this.frameTime;\r\n                    this.frameTime = 0;\r\n                    this.frameCount = 0;\r\n                }\r\n            };\r\n            return TimeKeeper;\r\n        }());\r\n        core.TimeKeeper = TimeKeeper;\r\n        var WindowedMean = (function () {\r\n            function WindowedMean(windowSize) {\r\n                if (windowSize === void 0) { windowSize = 32; }\r\n                this.addedValues = 0;\r\n                this.lastValue = 0;\r\n                this.mean = 0;\r\n                this.dirty = true;\r\n                this.values = new Array(windowSize);\r\n            }\r\n            WindowedMean.prototype.hasEnoughData = function () {\r\n                return this.addedValues >= this.values.length;\r\n            };\r\n            WindowedMean.prototype.addValue = function (value) {\r\n                if (this.addedValues < this.values.length)\r\n                    this.addedValues++;\r\n                this.values[this.lastValue++] = value;\r\n                if (this.lastValue > this.values.length - 1)\r\n                    this.lastValue = 0;\r\n                this.dirty = true;\r\n            };\r\n            WindowedMean.prototype.getMean = function () {\r\n                if (this.hasEnoughData()) {\r\n                    if (this.dirty) {\r\n                        var mean = 0;\r\n                        for (var i = 0; i < this.values.length; i++) {\r\n                            mean += this.values[i];\r\n                        }\r\n                        this.mean = mean / this.values.length;\r\n                        this.dirty = false;\r\n                    }\r\n                    return this.mean;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n            };\r\n            return WindowedMean;\r\n        }());\r\n        core.WindowedMean = WindowedMean;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Attachment = (function () {\r\n            function Attachment(name) {\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.name = name;\r\n            }\r\n            return Attachment;\r\n        }());\r\n        core.Attachment = Attachment;\r\n        var VertexAttachment = (function (_super) {\r\n            __extends(VertexAttachment, _super);\r\n            function VertexAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n                _this.worldVerticesLength = 0;\r\n                _this.deformAttachment = _this;\r\n                return _this;\r\n            }\r\n            VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {\r\n                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n            };\r\n            VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n                count = offset + (count >> 1) * stride;\r\n                var skeleton = slot.bone.skeleton;\r\n                var deformArray = slot.deform;\r\n                var vertices = this.vertices;\r\n                var bones = this.bones;\r\n                if (bones == null) {\r\n                    if (deformArray.length > 0)\r\n                        vertices = deformArray;\r\n                    var mat = slot.bone.matrix;\r\n                    var x = mat.tx;\r\n                    var y = mat.ty;\r\n                    var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n                        var vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n                        worldVertices[w] = vx * a + vy * b + x;\r\n                        worldVertices[w + 1] = vx * c + vy * d + y;\r\n                    }\r\n                    return;\r\n                }\r\n                var v = 0, skip = 0;\r\n                for (var i = 0; i < start; i += 2) {\r\n                    var n = bones[v];\r\n                    v += n + 1;\r\n                    skip += n;\r\n                }\r\n                var skeletonBones = skeleton.bones;\r\n                if (deformArray.length == 0) {\r\n                    for (var w = offset, b = skip * 3; w < count; w += stride) {\r\n                        var wx = 0, wy = 0;\r\n                        var n = bones[v++];\r\n                        n += v;\r\n                        for (; v < n; v++, b += 3) {\r\n                            var mat = skeletonBones[bones[v]].matrix;\r\n                            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                        }\r\n                        worldVertices[w] = wx;\r\n                        worldVertices[w + 1] = wy;\r\n                    }\r\n                }\r\n                else {\r\n                    var deform = deformArray;\r\n                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                        var wx = 0, wy = 0;\r\n                        var n = bones[v++];\r\n                        n += v;\r\n                        for (; v < n; v++, b += 3, f += 2) {\r\n                            var mat = skeletonBones[bones[v]].matrix;\r\n                            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                        }\r\n                        worldVertices[w] = wx;\r\n                        worldVertices[w + 1] = wy;\r\n                    }\r\n                }\r\n            };\r\n            VertexAttachment.prototype.copyTo = function (attachment) {\r\n                if (this.bones != null) {\r\n                    attachment.bones = new Array(this.bones.length);\r\n                    core.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n                }\r\n                else\r\n                    attachment.bones = null;\r\n                if (this.vertices != null) {\r\n                    attachment.vertices = core.Utils.newFloatArray(this.vertices.length);\r\n                    core.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n                }\r\n                else\r\n                    attachment.vertices = null;\r\n                attachment.worldVerticesLength = this.worldVerticesLength;\r\n                attachment.deformAttachment = this.deformAttachment;\r\n            };\r\n            VertexAttachment.nextID = 0;\r\n            return VertexAttachment;\r\n        }(Attachment));\r\n        core.VertexAttachment = VertexAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AttachmentType;\r\n        (function (AttachmentType) {\r\n            AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n            AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n            AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n            AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n            AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n            AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n            AttachmentType[AttachmentType[\"Clipping\"] = 6] = \"Clipping\";\r\n        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BoundingBoxAttachment = (function (_super) {\r\n            __extends(BoundingBoxAttachment, _super);\r\n            function BoundingBoxAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            BoundingBoxAttachment.prototype.copy = function () {\r\n                var copy = new BoundingBoxAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return BoundingBoxAttachment;\r\n        }(core.VertexAttachment));\r\n        core.BoundingBoxAttachment = BoundingBoxAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var ClippingAttachment = (function (_super) {\r\n            __extends(ClippingAttachment, _super);\r\n            function ClippingAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);\r\n                return _this;\r\n            }\r\n            ClippingAttachment.prototype.copy = function () {\r\n                var copy = new ClippingAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.endSlot = this.endSlot;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return ClippingAttachment;\r\n        }(core.VertexAttachment));\r\n        core.ClippingAttachment = ClippingAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var MeshAttachment = (function (_super) {\r\n            __extends(MeshAttachment, _super);\r\n            function MeshAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                _this.tempColor = new core.Color(0, 0, 0, 0);\r\n                return _this;\r\n            }\r\n            MeshAttachment.prototype.getParentMesh = function () {\r\n                return this.parentMesh;\r\n            };\r\n            MeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n                this.parentMesh = parentMesh;\r\n                if (parentMesh != null) {\r\n                    this.bones = parentMesh.bones;\r\n                    this.vertices = parentMesh.vertices;\r\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                    this.regionUVs = parentMesh.regionUVs;\r\n                    this.triangles = parentMesh.triangles;\r\n                    this.hullLength = parentMesh.hullLength;\r\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                }\r\n            };\r\n            MeshAttachment.prototype.copy = function () {\r\n                if (this.parentMesh != null)\r\n                    return this.newLinkedMesh();\r\n                var copy = new MeshAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.path = this.path;\r\n                copy.color.setFromColor(this.color);\r\n                this.copyTo(copy);\r\n                copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n                core.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n                copy.uvs = new Array(this.uvs.length);\r\n                core.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\r\n                copy.triangles = new Array(this.triangles.length);\r\n                core.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n                copy.hullLength = this.hullLength;\r\n                if (this.edges != null) {\r\n                    copy.edges = new Array(this.edges.length);\r\n                    core.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n                }\r\n                copy.width = this.width;\r\n                copy.height = this.height;\r\n                return copy;\r\n            };\r\n            MeshAttachment.prototype.newLinkedMesh = function () {\r\n                var copy = new MeshAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.path = this.path;\r\n                copy.color.setFromColor(this.color);\r\n                copy.deformAttachment = this.deformAttachment;\r\n                copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n                return copy;\r\n            };\r\n            return MeshAttachment;\r\n        }(core.VertexAttachment));\r\n        core.MeshAttachment = MeshAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathAttachment = (function (_super) {\r\n            __extends(PathAttachment, _super);\r\n            function PathAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.closed = false;\r\n                _this.constantSpeed = false;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            PathAttachment.prototype.copy = function () {\r\n                var copy = new PathAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.lengths = new Array(this.lengths.length);\r\n                core.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n                copy.closed = closed;\r\n                copy.constantSpeed = this.constantSpeed;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return PathAttachment;\r\n        }(core.VertexAttachment));\r\n        core.PathAttachment = PathAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PointAttachment = (function (_super) {\r\n            __extends(PointAttachment, _super);\r\n            function PointAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(0.38, 0.94, 0, 1);\r\n                return _this;\r\n            }\r\n            PointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n                var mat = bone.matrix;\r\n                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n                return point;\r\n            };\r\n            PointAttachment.prototype.computeWorldRotation = function (bone) {\r\n                var mat = bone.matrix;\r\n                var cos = core.MathUtils.cosDeg(this.rotation), sin = core.MathUtils.sinDeg(this.rotation);\r\n                var x = cos * mat.a + sin * mat.c;\r\n                var y = cos * mat.b + sin * mat.d;\r\n                return Math.atan2(y, x) * core.MathUtils.radDeg;\r\n            };\r\n            PointAttachment.prototype.copy = function () {\r\n                var copy = new PointAttachment(this.name);\r\n                copy.x = this.x;\r\n                copy.y = this.y;\r\n                copy.rotation = this.rotation;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return PointAttachment;\r\n        }(core.VertexAttachment));\r\n        core.PointAttachment = PointAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var RegionAttachment = (function (_super) {\r\n            __extends(RegionAttachment, _super);\r\n            function RegionAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.x = 0;\r\n                _this.y = 0;\r\n                _this.scaleX = 1;\r\n                _this.scaleY = 1;\r\n                _this.rotation = 0;\r\n                _this.width = 0;\r\n                _this.height = 0;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                _this.offset = core.Utils.newFloatArray(8);\r\n                _this.uvs = core.Utils.newFloatArray(8);\r\n                _this.tempColor = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            RegionAttachment.prototype.updateOffset = function () {\r\n                var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n                var localX2 = localX + this.region.width * regionScaleX;\r\n                var localY2 = localY + this.region.height * regionScaleY;\r\n                var radians = this.rotation * Math.PI / 180;\r\n                var cos = Math.cos(radians);\r\n                var sin = Math.sin(radians);\r\n                var localXCos = localX * cos + this.x;\r\n                var localXSin = localX * sin;\r\n                var localYCos = localY * cos + this.y;\r\n                var localYSin = localY * sin;\r\n                var localX2Cos = localX2 * cos + this.x;\r\n                var localX2Sin = localX2 * sin;\r\n                var localY2Cos = localY2 * cos + this.y;\r\n                var localY2Sin = localY2 * sin;\r\n                var offset = this.offset;\r\n                offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n                offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n                offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n                offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n                offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n                offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n            };\r\n            RegionAttachment.prototype.setRegion = function (region) {\r\n                this.region = region;\r\n                var uvs = this.uvs;\r\n                if (region.rotate) {\r\n                    uvs[2] = region.u;\r\n                    uvs[3] = region.v2;\r\n                    uvs[4] = region.u;\r\n                    uvs[5] = region.v;\r\n                    uvs[6] = region.u2;\r\n                    uvs[7] = region.v;\r\n                    uvs[0] = region.u2;\r\n                    uvs[1] = region.v2;\r\n                }\r\n                else {\r\n                    uvs[0] = region.u;\r\n                    uvs[1] = region.v2;\r\n                    uvs[2] = region.u;\r\n                    uvs[3] = region.v;\r\n                    uvs[4] = region.u2;\r\n                    uvs[5] = region.v;\r\n                    uvs[6] = region.u2;\r\n                    uvs[7] = region.v2;\r\n                }\r\n            };\r\n            RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n                var vertexOffset = this.offset;\r\n                var mat = bone.matrix;\r\n                var x = mat.tx, y = mat.ty;\r\n                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                var offsetX = 0, offsetY = 0;\r\n                offsetX = vertexOffset[RegionAttachment.OX1];\r\n                offsetY = vertexOffset[RegionAttachment.OY1];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX2];\r\n                offsetY = vertexOffset[RegionAttachment.OY2];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX3];\r\n                offsetY = vertexOffset[RegionAttachment.OY3];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX4];\r\n                offsetY = vertexOffset[RegionAttachment.OY4];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n            };\r\n            RegionAttachment.prototype.copy = function () {\r\n                var copy = new RegionAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.rendererObject = this.rendererObject;\r\n                copy.path = this.path;\r\n                copy.x = this.x;\r\n                copy.y = this.y;\r\n                copy.scaleX = this.scaleX;\r\n                copy.scaleY = this.scaleY;\r\n                copy.rotation = this.rotation;\r\n                copy.width = this.width;\r\n                copy.height = this.height;\r\n                core.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n                core.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            RegionAttachment.OX1 = 0;\r\n            RegionAttachment.OY1 = 1;\r\n            RegionAttachment.OX2 = 2;\r\n            RegionAttachment.OY2 = 3;\r\n            RegionAttachment.OX3 = 4;\r\n            RegionAttachment.OY3 = 5;\r\n            RegionAttachment.OX4 = 6;\r\n            RegionAttachment.OY4 = 7;\r\n            RegionAttachment.X1 = 0;\r\n            RegionAttachment.Y1 = 1;\r\n            RegionAttachment.C1R = 2;\r\n            RegionAttachment.C1G = 3;\r\n            RegionAttachment.C1B = 4;\r\n            RegionAttachment.C1A = 5;\r\n            RegionAttachment.U1 = 6;\r\n            RegionAttachment.V1 = 7;\r\n            RegionAttachment.X2 = 8;\r\n            RegionAttachment.Y2 = 9;\r\n            RegionAttachment.C2R = 10;\r\n            RegionAttachment.C2G = 11;\r\n            RegionAttachment.C2B = 12;\r\n            RegionAttachment.C2A = 13;\r\n            RegionAttachment.U2 = 14;\r\n            RegionAttachment.V2 = 15;\r\n            RegionAttachment.X3 = 16;\r\n            RegionAttachment.Y3 = 17;\r\n            RegionAttachment.C3R = 18;\r\n            RegionAttachment.C3G = 19;\r\n            RegionAttachment.C3B = 20;\r\n            RegionAttachment.C3A = 21;\r\n            RegionAttachment.U3 = 22;\r\n            RegionAttachment.V3 = 23;\r\n            RegionAttachment.X4 = 24;\r\n            RegionAttachment.Y4 = 25;\r\n            RegionAttachment.C4R = 26;\r\n            RegionAttachment.C4G = 27;\r\n            RegionAttachment.C4B = 28;\r\n            RegionAttachment.C4A = 29;\r\n            RegionAttachment.U4 = 30;\r\n            RegionAttachment.V4 = 31;\r\n            return RegionAttachment;\r\n        }(core.Attachment));\r\n        core.RegionAttachment = RegionAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var JitterEffect = (function () {\r\n            function JitterEffect(jitterX, jitterY) {\r\n                this.jitterX = 0;\r\n                this.jitterY = 0;\r\n                this.jitterX = jitterX;\r\n                this.jitterY = jitterY;\r\n            }\r\n            JitterEffect.prototype.begin = function (skeleton) {\r\n            };\r\n            JitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n            };\r\n            JitterEffect.prototype.end = function () {\r\n            };\r\n            return JitterEffect;\r\n        }());\r\n        core.JitterEffect = JitterEffect;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SwirlEffect = (function () {\r\n            function SwirlEffect(radius) {\r\n                this.centerX = 0;\r\n                this.centerY = 0;\r\n                this.radius = 0;\r\n                this.angle = 0;\r\n                this.worldX = 0;\r\n                this.worldY = 0;\r\n                this.radius = radius;\r\n            }\r\n            SwirlEffect.prototype.begin = function (skeleton) {\r\n                this.worldX = skeleton.x + this.centerX;\r\n                this.worldY = skeleton.y + this.centerY;\r\n            };\r\n            SwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n                var radAngle = this.angle * core.MathUtils.degreesToRadians;\r\n                var x = position.x - this.worldX;\r\n                var y = position.y - this.worldY;\r\n                var dist = Math.sqrt(x * x + y * y);\r\n                if (dist < this.radius) {\r\n                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n                    var cos = Math.cos(theta);\r\n                    var sin = Math.sin(theta);\r\n                    position.x = cos * x - sin * y + this.worldX;\r\n                    position.y = sin * x + cos * y + this.worldY;\r\n                }\r\n            };\r\n            SwirlEffect.prototype.end = function () {\r\n            };\r\n            SwirlEffect.interpolation = new core.PowOut(2);\r\n            return SwirlEffect;\r\n        }());\r\n        core.SwirlEffect = SwirlEffect;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\n(function () {\r\n    if (!Math.fround) {\r\n        Math.fround = Math.fround = (function (array) {\r\n            return function (x) {\r\n                return array[0] = x, array[0];\r\n            };\r\n        })(new Float32Array(1));\r\n    }\r\n})();\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    pixi_spine.core.Bone.yDown = true;\r\n    var tempRgb = [0, 0, 0];\r\n    var SpineSprite = (function (_super) {\r\n        __extends(SpineSprite, _super);\r\n        function SpineSprite() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this.region = null;\r\n            _this.attachment = null;\r\n            return _this;\r\n        }\r\n        return SpineSprite;\r\n    }(PIXI.Sprite));\r\n    pixi_spine.SpineSprite = SpineSprite;\r\n    var gp = PIXI.GraphicsGeometry.prototype;\r\n    if (!gp.invalidate) {\r\n        var tmp_1 = [];\r\n        gp.invalidate = function () {\r\n            var t = this.graphicsData;\r\n            tmp_1.push(0);\r\n            this.graphicsData = tmp_1;\r\n            this.clear();\r\n            this.graphicsData = t;\r\n        };\r\n    }\r\n    var SpineMesh = (function (_super) {\r\n        __extends(SpineMesh, _super);\r\n        function SpineMesh(texture, vertices, uvs, indices, drawMode) {\r\n            var _this = _super.call(this, texture, vertices, uvs, indices, drawMode) || this;\r\n            _this.region = null;\r\n            _this.attachment = null;\r\n            return _this;\r\n        }\r\n        return SpineMesh;\r\n    }(PIXI.SimpleMesh));\r\n    pixi_spine.SpineMesh = SpineMesh;\r\n    var Spine = (function (_super) {\r\n        __extends(Spine, _super);\r\n        function Spine(spineData) {\r\n            var _this = _super.call(this) || this;\r\n            if (!spineData) {\r\n                throw new Error('The spineData param is required.');\r\n            }\r\n            if ((typeof spineData) === \"string\") {\r\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n            }\r\n            _this.spineData = spineData;\r\n            _this.skeleton = new pixi_spine.core.Skeleton(spineData);\r\n            _this.skeleton.updateWorldTransform();\r\n            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);\r\n            _this.state = new pixi_spine.core.AnimationState(_this.stateData);\r\n            _this.slotContainers = [];\r\n            _this.tempClipContainers = [];\r\n            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {\r\n                var slot = _this.skeleton.slots[i];\r\n                var attachment = slot.getAttachment();\r\n                var slotContainer = _this.newContainer();\r\n                _this.slotContainers.push(slotContainer);\r\n                _this.addChild(slotContainer);\r\n                _this.tempClipContainers.push(null);\r\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\r\n                    var spriteName = attachment.region.name;\r\n                    var sprite = _this.createSprite(slot, attachment, spriteName);\r\n                    slot.currentSprite = sprite;\r\n                    slot.currentSpriteName = spriteName;\r\n                    slotContainer.addChild(sprite);\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.MeshAttachment) {\r\n                    var mesh = _this.createMesh(slot, attachment);\r\n                    slot.currentMesh = mesh;\r\n                    slot.currentMeshId = attachment.id;\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\r\n                    _this.createGraphics(slot, attachment);\r\n                    slotContainer.addChild(slot.clippingContainer);\r\n                    slotContainer.addChild(slot.currentGraphics);\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            _this.tintRgb = new Float32Array([1, 1, 1]);\r\n            _this.autoUpdate = true;\r\n            _this.visible = true;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Spine.prototype, \"autoUpdate\", {\r\n            get: function () {\r\n                return this._autoUpdate;\r\n            },\r\n            set: function (value) {\r\n                if (value !== this._autoUpdate) {\r\n                    this._autoUpdate = value;\r\n                    this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n                }\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"visible\", {\r\n            get: function () {\r\n                return this._visible;\r\n            },\r\n            set: function (value) {\r\n                if (value !== this._visible) {\r\n                    this._visible = value;\r\n                    if (value) {\r\n                        this.lastTime = 0;\r\n                    }\r\n                }\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"tint\", {\r\n            get: function () {\r\n                return PIXI.utils.rgb2hex(this.tintRgb);\r\n            },\r\n            set: function (value) {\r\n                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"delayLimit\", {\r\n            get: function () {\r\n                var limit = typeof this.localDelayLimit !== \"undefined\" ?\r\n                    this.localDelayLimit : Spine.globalDelayLimit;\r\n                return limit || Number.MAX_VALUE;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Spine.prototype.update = function (dt) {\r\n            var delayLimit = this.delayLimit;\r\n            if (dt > delayLimit)\r\n                dt = delayLimit;\r\n            this.state.update(dt);\r\n            this.state.apply(this.skeleton);\r\n            if (!this.skeleton)\r\n                return;\r\n            this.skeleton.updateWorldTransform();\r\n            var slots = this.skeleton.slots;\r\n            var globalClr = this.color;\r\n            var light = null, dark = null;\r\n            if (globalClr) {\r\n                light = globalClr.light;\r\n                dark = globalClr.dark;\r\n            }\r\n            else {\r\n                light = this.tintRgb;\r\n            }\r\n            var thack = false;\r\n            for (var i = 0, n = slots.length; i < n; i++) {\r\n                var slot = slots[i];\r\n                var attachment = slot.getAttachment();\r\n                var slotContainer = this.slotContainers[i];\r\n                if (!attachment) {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n                var spriteColor = null;\r\n                var attColor = attachment.color;\r\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\r\n                    var region = attachment.region;\r\n                    if (region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                            slot.currentMesh = null;\r\n                            slot.currentMeshId = undefined;\r\n                            slot.currentMeshName = undefined;\r\n                        }\r\n                        var ar = region;\r\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\r\n                            var spriteName = ar.name;\r\n                            if (slot.currentSprite) {\r\n                                slot.currentSprite.visible = false;\r\n                            }\r\n                            slot.sprites = slot.sprites || {};\r\n                            if (slot.sprites[spriteName] !== undefined) {\r\n                                slot.sprites[spriteName].visible = true;\r\n                            }\r\n                            else {\r\n                                var sprite = this.createSprite(slot, attachment, spriteName);\r\n                                slotContainer.addChild(sprite);\r\n                            }\r\n                            slot.currentSprite = slot.sprites[spriteName];\r\n                            slot.currentSpriteName = spriteName;\r\n                        }\r\n                        else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\r\n                            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                        }\r\n                    }\r\n                    var transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n                    if (slot.currentSprite.color) {\r\n                        spriteColor = slot.currentSprite.color;\r\n                    }\r\n                    else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.MeshAttachment) {\r\n                    if (slot.currentSprite) {\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n                        var transform = new PIXI.Transform();\r\n                        transform._parentID = -1;\r\n                        transform._worldID = slotContainer.transform._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!slot.currentMeshId || slot.currentMeshId !== attachment.id) {\r\n                        var meshId = attachment.id;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n                        slot.meshes = slot.meshes || {};\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        }\r\n                        else {\r\n                            var mesh = this.createMesh(slot, attachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        spriteColor = slot.currentMesh.color;\r\n                    }\r\n                    else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                }\r\n                else {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n                slotContainer.visible = true;\r\n                if (spriteColor) {\r\n                    var r0 = slot.color.r * attColor.r;\r\n                    var g0 = slot.color.g * attColor.g;\r\n                    var b0 = slot.color.b * attColor.b;\r\n                    spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\r\n                    if (slot.darkColor) {\r\n                        r0 = slot.darkColor.r;\r\n                        g0 = slot.darkColor.g;\r\n                        b0 = slot.darkColor.b;\r\n                    }\r\n                    else {\r\n                        r0 = 0.0;\r\n                        g0 = 0.0;\r\n                        b0 = 0.0;\r\n                    }\r\n                    spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\r\n                }\r\n                slotContainer.alpha = slot.color.a;\r\n            }\r\n            var drawOrder = this.skeleton.drawOrder;\r\n            var clippingAttachment = null;\r\n            var clippingContainer = null;\r\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                var slot = slots[drawOrder[i].data.index];\r\n                var slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n                if (!clippingContainer) {\r\n                    if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                        slotContainer.parent.removeChild(slotContainer);\r\n                        slotContainer.parent = this;\r\n                    }\r\n                }\r\n                if (slot.currentGraphics && slot.getAttachment()) {\r\n                    clippingContainer = slot.clippingContainer;\r\n                    clippingAttachment = slot.getAttachment();\r\n                    clippingContainer.children.length = 0;\r\n                    this.children[i] = slotContainer;\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingAttachment.endSlot = null;\r\n                    }\r\n                }\r\n                else {\r\n                    if (clippingContainer) {\r\n                        var c = this.tempClipContainers[i];\r\n                        if (!c) {\r\n                            c = this.tempClipContainers[i] = this.newContainer();\r\n                            c.visible = false;\r\n                        }\r\n                        this.children[i] = c;\r\n                        slotContainer.parent = null;\r\n                        clippingContainer.addChild(slotContainer);\r\n                        if (clippingAttachment.endSlot == slot.data) {\r\n                            clippingContainer.renderable = true;\r\n                            clippingContainer = null;\r\n                            clippingAttachment = null;\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.children[i] = slotContainer;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {\r\n            if (sprite.attachment === attachment && sprite.region === region) {\r\n                return;\r\n            }\r\n            sprite.region = region;\r\n            sprite.attachment = attachment;\r\n            sprite.texture = region.texture;\r\n            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;\r\n            sprite.position.x = attachment.x;\r\n            sprite.position.y = attachment.y;\r\n            sprite.alpha = attachment.color.a;\r\n            if (!region.size) {\r\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n            }\r\n            else {\r\n                sprite.scale.x = region.size.width / region.originalWidth;\r\n                sprite.scale.y = -region.size.height / region.originalHeight;\r\n            }\r\n        };\r\n        Spine.prototype.setMeshRegion = function (attachment, mesh, region) {\r\n            if (mesh.attachment === attachment && mesh.region === region) {\r\n                return;\r\n            }\r\n            mesh.region = region;\r\n            mesh.attachment = attachment;\r\n            mesh.texture = region.texture;\r\n            region.texture.updateUvs();\r\n            mesh.uvBuffer.update(attachment.regionUVs);\r\n        };\r\n        Spine.prototype.autoUpdateTransform = function () {\r\n            if (Spine.globalAutoUpdate) {\r\n                this.lastTime = this.lastTime || Date.now();\r\n                var timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n                this.lastTime = Date.now();\r\n                this.update(timeDelta);\r\n            }\r\n            else {\r\n                this.lastTime = 0;\r\n            }\r\n            PIXI.Container.prototype.updateTransform.call(this);\r\n        };\r\n        ;\r\n        Spine.prototype.createSprite = function (slot, attachment, defName) {\r\n            var region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n            }\r\n            var texture = region.texture;\r\n            var sprite = this.newSprite(texture);\r\n            sprite.anchor.set(0.5);\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n            slot.sprites = slot.sprites || {};\r\n            slot.sprites[defName] = sprite;\r\n            return sprite;\r\n        };\r\n        ;\r\n        Spine.prototype.createMesh = function (slot, attachment) {\r\n            var region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n                slot.hackAttachment = null;\r\n                slot.hackRegion = null;\r\n            }\r\n            var strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), PIXI.DRAW_MODES.TRIANGLES);\r\n            if (typeof strip._canvasPadding !== \"undefined\") {\r\n                strip._canvasPadding = 1.5;\r\n            }\r\n            strip.alpha = attachment.color.a;\r\n            strip.region = attachment.region;\r\n            this.setMeshRegion(attachment, strip, region);\r\n            slot.meshes = slot.meshes || {};\r\n            slot.meshes[attachment.id] = strip;\r\n            return strip;\r\n        };\r\n        ;\r\n        Spine.prototype.createGraphics = function (slot, clip) {\r\n            var graphics = this.newGraphics();\r\n            var poly = new PIXI.Polygon([]);\r\n            graphics.clear();\r\n            graphics.beginFill(0xffffff, 1);\r\n            graphics.drawPolygon(poly);\r\n            graphics.renderable = false;\r\n            slot.currentGraphics = graphics;\r\n            slot.clippingContainer = this.newContainer();\r\n            slot.clippingContainer.mask = slot.currentGraphics;\r\n            return graphics;\r\n        };\r\n        Spine.prototype.updateGraphics = function (slot, clip) {\r\n            var geom = slot.currentGraphics.geometry;\r\n            var vertices = geom.graphicsData[0].shape.points;\r\n            var n = clip.worldVerticesLength;\r\n            vertices.length = n;\r\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n            geom.invalidate();\r\n        };\r\n        Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {\r\n            if (texture === void 0) { texture = null; }\r\n            if (size === void 0) { size = null; }\r\n            var slot = this.skeleton.slots[slotIndex];\r\n            if (!slot) {\r\n                return false;\r\n            }\r\n            var attachment = slot.getAttachment();\r\n            var region = attachment.region;\r\n            if (texture) {\r\n                region = new pixi_spine.core.TextureRegion();\r\n                region.texture = texture;\r\n                region.size = size;\r\n                slot.hackRegion = region;\r\n                slot.hackAttachment = attachment;\r\n            }\r\n            else {\r\n                slot.hackRegion = null;\r\n                slot.hackAttachment = null;\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                slot.currentSprite.region = region;\r\n            }\r\n            else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(attachment, slot.currentMesh, region);\r\n            }\r\n            return true;\r\n        };\r\n        Spine.prototype.hackTextureBySlotName = function (slotName, texture, size) {\r\n            if (texture === void 0) { texture = null; }\r\n            if (size === void 0) { size = null; }\r\n            var index = this.skeleton.findSlotIndex(slotName);\r\n            if (index == -1) {\r\n                return false;\r\n            }\r\n            return this.hackTextureBySlotIndex(index, texture, size);\r\n        };\r\n        Spine.prototype.hackTextureAttachment = function (slotName, attachmentName, texture, size) {\r\n            if (size === void 0) { size = null; }\r\n            var slotIndex = this.skeleton.findSlotIndex(slotName);\r\n            var attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n            attachment.region.texture = texture;\r\n            var slot = this.skeleton.slots[slotIndex];\r\n            if (!slot) {\r\n                return false;\r\n            }\r\n            var currentAttachment = slot.getAttachment();\r\n            if (attachmentName === currentAttachment.name) {\r\n                var region = attachment.region;\r\n                if (texture) {\r\n                    region = new pixi_spine.core.TextureRegion();\r\n                    region.texture = texture;\r\n                    region.size = size;\r\n                    slot.hackRegion = region;\r\n                    slot.hackAttachment = currentAttachment;\r\n                }\r\n                else {\r\n                    slot.hackRegion = null;\r\n                    slot.hackAttachment = null;\r\n                }\r\n                if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                    this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\r\n                    slot.currentSprite.region = region;\r\n                }\r\n                else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                    this.setMeshRegion(currentAttachment, slot.currentMesh, region);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        Spine.prototype.newContainer = function () {\r\n            return new PIXI.Container();\r\n        };\r\n        Spine.prototype.newSprite = function (tex) {\r\n            return new SpineSprite(tex);\r\n        };\r\n        Spine.prototype.newGraphics = function () {\r\n            return new PIXI.Graphics();\r\n        };\r\n        Spine.prototype.newMesh = function (texture, vertices, uvs, indices, drawMode) {\r\n            return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n        };\r\n        Spine.prototype.transformHack = function () {\r\n            return 1;\r\n        };\r\n        Spine.prototype.hackAttachmentGroups = function (nameSuffix, group, outGroup) {\r\n            if (!nameSuffix) {\r\n                return;\r\n            }\r\n            var list_d = [], list_n = [];\r\n            for (var i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n                var slot = this.skeleton.slots[i];\r\n                var name_6 = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n                var target = slot.currentSprite || slot.currentMesh;\r\n                if (name_6.endsWith(nameSuffix)) {\r\n                    target.parentGroup = group;\r\n                    list_n.push(target);\r\n                }\r\n                else if (outGroup && target) {\r\n                    target.parentGroup = outGroup;\r\n                    list_d.push(target);\r\n                }\r\n            }\r\n            return [list_d, list_n];\r\n        };\r\n        ;\r\n        Spine.prototype.destroy = function (options) {\r\n            for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n                var slot = this.skeleton.slots[i];\r\n                for (var name_7 in slot.meshes) {\r\n                    slot.meshes[name_7].destroy(options);\r\n                }\r\n                slot.meshes = null;\r\n                for (var name_8 in slot.sprites) {\r\n                    slot.sprites[name_8].destroy(options);\r\n                }\r\n                slot.sprites = null;\r\n            }\r\n            for (var i = 0, n = this.slotContainers.length; i < n; i++) {\r\n                this.slotContainers[i].destroy(options);\r\n            }\r\n            this.spineData = null;\r\n            this.skeleton = null;\r\n            this.slotContainers = null;\r\n            this.stateData = null;\r\n            this.state = null;\r\n            this.tempClipContainers = null;\r\n            _super.prototype.destroy.call(this, options);\r\n        };\r\n        Spine.globalAutoUpdate = true;\r\n        Spine.globalDelayLimit = 0;\r\n        Spine.clippingPolygon = [];\r\n        return Spine;\r\n    }(PIXI.Container));\r\n    pixi_spine.Spine = Spine;\r\n    function SlotContainerUpdateTransformV3() {\r\n        var pt = this.parent.worldTransform;\r\n        var wt = this.worldTransform;\r\n        var lt = this.localTransform;\r\n        wt.a = lt.a * pt.a + lt.b * pt.c;\r\n        wt.b = lt.a * pt.b + lt.b * pt.d;\r\n        wt.c = lt.c * pt.a + lt.d * pt.c;\r\n        wt.d = lt.c * pt.b + lt.d * pt.d;\r\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\r\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\r\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\r\n        this._currentBounds = null;\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    PIXI.spine = pixi_spine;\r\n    var TextureProto = PIXI.Texture.prototype;\r\n    if (!TextureProto._updateUvs) {\r\n        TextureProto._updateUvs = TextureProto.updateUvs;\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    function isJson(resource) {\r\n        return resource.type === PIXI.LoaderResource.TYPE.JSON;\r\n    }\r\n    function isBuffer(resource) {\r\n        return resource.xhrType === PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER;\r\n    }\r\n    PIXI.LoaderResource.setExtensionXhrType('skel', PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n    var AtlasParser = (function () {\r\n        function AtlasParser() {\r\n        }\r\n        AtlasParser.use = function (resource, next) {\r\n            if (!resource.data) {\r\n                return next();\r\n            }\r\n            var isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n            var isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata.spineMetadata);\r\n            if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                return next();\r\n            }\r\n            var parser = null;\r\n            var dataToParse = resource.data;\r\n            if (isJsonSpineModel) {\r\n                parser = new pixi_spine.core.SkeletonJson(null);\r\n            }\r\n            else {\r\n                parser = new pixi_spine.core.SkeletonBinary(null);\r\n                if (resource.data instanceof ArrayBuffer) {\r\n                    dataToParse = new Uint8Array(resource.data);\r\n                }\r\n            }\r\n            var metadata = resource.metadata || {};\r\n            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\r\n            if (metadataSkeletonScale) {\r\n                parser.scale = metadataSkeletonScale;\r\n            }\r\n            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\r\n            if (metadataAtlas === false) {\r\n                return next();\r\n            }\r\n            if (metadataAtlas && metadataAtlas.pages) {\r\n                parser.attachmentLoader = new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas);\r\n                resource.spineData = parser.readSkeletonData(dataToParse);\r\n                resource.spineAtlas = metadataAtlas;\r\n                return next();\r\n            }\r\n            var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n            var atlasPath = resource.url;\r\n            var queryStringPos = atlasPath.indexOf('?');\r\n            if (queryStringPos > 0) {\r\n                atlasPath = atlasPath.substr(0, queryStringPos);\r\n            }\r\n            atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n            if (resource.metadata && resource.metadata.spineAtlasFile) {\r\n                atlasPath = resource.metadata.spineAtlasFile;\r\n            }\r\n            atlasPath = atlasPath.replace(this.baseUrl, '');\r\n            var atlasOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                metadata: metadata.spineMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            var imageOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                metadata: metadata.imageMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n            baseUrl = baseUrl.replace(this.baseUrl, '');\r\n            var namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n            var adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                : metadata.image ? staticImageLoader({ 'default': metadata.image })\r\n                    : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                        : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n            var createSkeletonWithRawAtlas = function (rawData) {\r\n                new pixi_spine.core.TextureAtlas(rawData, adapter, function (spineAtlas) {\r\n                    if (spineAtlas) {\r\n                        parser.attachmentLoader = new pixi_spine.core.AtlasAttachmentLoader(spineAtlas);\r\n                        resource.spineData = parser.readSkeletonData(dataToParse);\r\n                        resource.spineAtlas = spineAtlas;\r\n                    }\r\n                    next();\r\n                });\r\n            };\r\n            if (resource.metadata && resource.metadata.atlasRawData) {\r\n                createSkeletonWithRawAtlas(resource.metadata.atlasRawData);\r\n            }\r\n            else {\r\n                this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\r\n                    if (!atlasResource.error) {\r\n                        createSkeletonWithRawAtlas(atlasResource.data);\r\n                    }\r\n                    else {\r\n                        next();\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        return AtlasParser;\r\n    }());\r\n    pixi_spine.AtlasParser = AtlasParser;\r\n    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line, callback) {\r\n            var name = namePrefix + line;\r\n            var url = baseUrl + line;\r\n            var cachedResource = loader.resources[name];\r\n            if (cachedResource) {\r\n                var done = function () {\r\n                    callback(cachedResource.texture.baseTexture);\r\n                };\r\n                if (cachedResource.texture) {\r\n                    done();\r\n                }\r\n                else {\r\n                    cachedResource.onAfterMiddleware.add(done);\r\n                }\r\n            }\r\n            else {\r\n                loader.add(name, url, imageOptions, function (resource) {\r\n                    if (!resource.error) {\r\n                        callback(resource.texture.baseTexture);\r\n                    }\r\n                    else {\r\n                        callback(null);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;\r\n    function syncImageLoaderAdapter(baseUrl, crossOrigin) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line, callback) {\r\n            callback(PIXI.BaseTexture.from(line, crossOrigin));\r\n        };\r\n    }\r\n    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;\r\n    function staticImageLoader(pages) {\r\n        return function (line, callback) {\r\n            var page = pages[line] || pages['default'];\r\n            if (page && page.baseTexture)\r\n                callback(page.baseTexture);\r\n            else\r\n                callback(page);\r\n        };\r\n    }\r\n    pixi_spine.staticImageLoader = staticImageLoader;\r\n    if (PIXI.Loader) {\r\n        PIXI.Loader.registerPlugin(AtlasParser);\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\n//# sourceMappingURL=pixi-spine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGl4aS1zcGluZS9kaXN0L3BpeGktc3BpbmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZS1zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL3BpeGktc3BpbmUvZGlzdC9waXhpLXNwaW5lLmpzPzMyZjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRpbWVsaW5lcyBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZXMgPSB0aW1lbGluZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lSWRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lSWRzW3RpbWVsaW5lc1tpXS5nZXRQcm9wZXJ0eUlkKCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmhhc1RpbWVsaW5lID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lbGluZUlkc1tpZF0gPT0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGxvb3AsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb29wICYmIHRoaXMuZHVyYXRpb24gIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWUgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lcyA9IHRoaXMudGltZWxpbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lc1tpXS5hcHBseShza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb24uYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24gKHZhbHVlcywgdGFyZ2V0LCBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAxOyB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBoaWdoID0gdmFsdWVzLmxlbmd0aCAvIHN0ZXAgLSAyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpZ2ggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaGlnaCA+Pj4gMTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1soY3VycmVudCArIDEpICogc3RlcF0gPD0gdGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3cgPSBjdXJyZW50ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3cgPT0gaGlnaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsb3cgKyAxKSAqIHN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uLmxpbmVhclNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldCwgc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSB2YWx1ZXMubGVuZ3RoIC0gc3RlcDsgaSA8PSBsYXN0OyBpICs9IHN0ZXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSA+IHRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBBbmltYXRpb247XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcclxuICAgICAgICB2YXIgTWl4QmxlbmQ7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChNaXhCbGVuZCkge1xyXG4gICAgICAgICAgICBNaXhCbGVuZFtNaXhCbGVuZFtcInNldHVwXCJdID0gMF0gPSBcInNldHVwXCI7XHJcbiAgICAgICAgICAgIE1peEJsZW5kW01peEJsZW5kW1wiZmlyc3RcIl0gPSAxXSA9IFwiZmlyc3RcIjtcclxuICAgICAgICAgICAgTWl4QmxlbmRbTWl4QmxlbmRbXCJyZXBsYWNlXCJdID0gMl0gPSBcInJlcGxhY2VcIjtcclxuICAgICAgICAgICAgTWl4QmxlbmRbTWl4QmxlbmRbXCJhZGRcIl0gPSAzXSA9IFwiYWRkXCI7XHJcbiAgICAgICAgfSkoTWl4QmxlbmQgPSBjb3JlLk1peEJsZW5kIHx8IChjb3JlLk1peEJsZW5kID0ge30pKTtcclxuICAgICAgICB2YXIgTWl4RGlyZWN0aW9uO1xyXG4gICAgICAgIChmdW5jdGlvbiAoTWl4RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIE1peERpcmVjdGlvbltNaXhEaXJlY3Rpb25bXCJtaXhJblwiXSA9IDBdID0gXCJtaXhJblwiO1xyXG4gICAgICAgICAgICBNaXhEaXJlY3Rpb25bTWl4RGlyZWN0aW9uW1wibWl4T3V0XCJdID0gMV0gPSBcIm1peE91dFwiO1xyXG4gICAgICAgIH0pKE1peERpcmVjdGlvbiA9IGNvcmUuTWl4RGlyZWN0aW9uIHx8IChjb3JlLk1peERpcmVjdGlvbiA9IHt9KSk7XHJcbiAgICAgICAgdmFyIFRpbWVsaW5lVHlwZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFRpbWVsaW5lVHlwZSkge1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wicm90YXRlXCJdID0gMF0gPSBcInJvdGF0ZVwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1widHJhbnNsYXRlXCJdID0gMV0gPSBcInRyYW5zbGF0ZVwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wic2NhbGVcIl0gPSAyXSA9IFwic2NhbGVcIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcInNoZWFyXCJdID0gM10gPSBcInNoZWFyXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJhdHRhY2htZW50XCJdID0gNF0gPSBcImF0dGFjaG1lbnRcIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImNvbG9yXCJdID0gNV0gPSBcImNvbG9yXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJkZWZvcm1cIl0gPSA2XSA9IFwiZGVmb3JtXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJldmVudFwiXSA9IDddID0gXCJldmVudFwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiZHJhd09yZGVyXCJdID0gOF0gPSBcImRyYXdPcmRlclwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiaWtDb25zdHJhaW50XCJdID0gOV0gPSBcImlrQ29uc3RyYWludFwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1widHJhbnNmb3JtQ29uc3RyYWludFwiXSA9IDEwXSA9IFwidHJhbnNmb3JtQ29uc3RyYWludFwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wicGF0aENvbnN0cmFpbnRQb3NpdGlvblwiXSA9IDExXSA9IFwicGF0aENvbnN0cmFpbnRQb3NpdGlvblwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wicGF0aENvbnN0cmFpbnRTcGFjaW5nXCJdID0gMTJdID0gXCJwYXRoQ29uc3RyYWludFNwYWNpbmdcIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcInBhdGhDb25zdHJhaW50TWl4XCJdID0gMTNdID0gXCJwYXRoQ29uc3RyYWludE1peFwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1widHdvQ29sb3JcIl0gPSAxNF0gPSBcInR3b0NvbG9yXCI7XHJcbiAgICAgICAgfSkoVGltZWxpbmVUeXBlID0gY29yZS5UaW1lbGluZVR5cGUgfHwgKGNvcmUuVGltZWxpbmVUeXBlID0ge30pKTtcclxuICAgICAgICB2YXIgQ3VydmVUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEN1cnZlVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lQ291bnQgPD0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmcmFtZUNvdW50IG11c3QgYmUgPiAwOiBcIiArIGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJ2ZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoKGZyYW1lQ291bnQgLSAxKSAqIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUucHJvdG90eXBlLmdldEZyYW1lQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJ2ZXMubGVuZ3RoIC8gQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSArIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUucHJvdG90eXBlLnNldExpbmVhciA9IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnZlc1tmcmFtZUluZGV4ICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRV0gPSBDdXJ2ZVRpbWVsaW5lLkxJTkVBUjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuc2V0U3RlcHBlZCA9IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnZlc1tmcmFtZUluZGV4ICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRV0gPSBDdXJ2ZVRpbWVsaW5lLlNURVBQRUQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUucHJvdG90eXBlLmdldEN1cnZlVHlwZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBmcmFtZUluZGV4ICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmN1cnZlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEN1cnZlVGltZWxpbmUuTElORUFSO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmN1cnZlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBDdXJ2ZVRpbWVsaW5lLkxJTkVBUilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3VydmVUaW1lbGluZS5MSU5FQVI7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBDdXJ2ZVRpbWVsaW5lLlNURVBQRUQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEN1cnZlVGltZWxpbmUuU1RFUFBFRDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDdXJ2ZVRpbWVsaW5lLkJFWklFUjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuc2V0Q3VydmUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgY3gxLCBjeTEsIGN4MiwgY3kyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1weCA9ICgtY3gxICogMiArIGN4MikgKiAwLjAzLCB0bXB5ID0gKC1jeTEgKiAyICsgY3kyKSAqIDAuMDM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGRkZnggPSAoKGN4MSAtIGN4MikgKiAzICsgMSkgKiAwLjAwNiwgZGRkZnkgPSAoKGN5MSAtIGN5MikgKiAzICsgMSkgKiAwLjAwNjtcclxuICAgICAgICAgICAgICAgIHZhciBkZGZ4ID0gdG1weCAqIDIgKyBkZGRmeCwgZGRmeSA9IHRtcHkgKiAyICsgZGRkZnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGZ4ID0gY3gxICogMC4zICsgdG1weCArIGRkZGZ4ICogMC4xNjY2NjY2NywgZGZ5ID0gY3kxICogMC4zICsgdG1weSArIGRkZGZ5ICogMC4xNjY2NjY2NztcclxuICAgICAgICAgICAgICAgIHZhciBpID0gZnJhbWVJbmRleCAqIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkU7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XHJcbiAgICAgICAgICAgICAgICBjdXJ2ZXNbaSsrXSA9IEN1cnZlVGltZWxpbmUuQkVaSUVSO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBkZngsIHkgPSBkZnk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gaSArIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkUgLSAxOyBpIDwgbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmVzW2ldID0geDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZXNbaSArIDFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICBkZnggKz0gZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICBkZnkgKz0gZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICBkZGZ4ICs9IGRkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRkZnkgKz0gZGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCArPSBkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSBkZnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUucHJvdG90eXBlLmdldEN1cnZlUGVyY2VudCA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCBwZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gY29yZS5NYXRoVXRpbHMuY2xhbXAocGVyY2VudCwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjdXJ2ZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBDdXJ2ZVRpbWVsaW5lLkxJTkVBUilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuU1RFUFBFRClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHN0YXJ0ID0gaSwgbiA9IGkgKyBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFIC0gMTsgaSA8IG47IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBjdXJ2ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gcGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlggPSB2b2lkIDAsIHByZXZZID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlggPSBjdXJ2ZXNbaSAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlkgPSBjdXJ2ZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2WSArIChjdXJ2ZXNbaSArIDFdIC0gcHJldlkpICogKHBlcmNlbnQgLSBwcmV2WCkgLyAoeCAtIHByZXZYKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGN1cnZlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geSArICgxIC0geSkgKiAocGVyY2VudCAtIHgpIC8gKDEgLSB4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5MSU5FQVIgPSAwO1xyXG4gICAgICAgICAgICBDdXJ2ZVRpbWVsaW5lLlNURVBQRUQgPSAxO1xyXG4gICAgICAgICAgICBDdXJ2ZVRpbWVsaW5lLkJFWklFUiA9IDI7XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkUgPSAxMCAqIDIgLSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gQ3VydmVUaW1lbGluZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQ3VydmVUaW1lbGluZSA9IEN1cnZlVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFJvdGF0ZVRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFJvdGF0ZVRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBSb3RhdGVUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgPDwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUm90YXRlVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5yb3RhdGUgPDwgMjQpICsgdGhpcy5ib25lSW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdGF0ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBkZWdyZWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4IDw8PSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFJvdGF0ZVRpbWVsaW5lLlJPVEFUSU9OXSA9IGRlZ3JlZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdGF0ZVRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUucm90YXRpb24gPSBib25lLmRhdGEucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcl8xID0gYm9uZS5kYXRhLnJvdGF0aW9uIC0gYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUucm90YXRpb24gKz0gKHJfMSAtICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gcl8xIC8gMzYwKSB8IDApKSAqIDM2MCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBSb3RhdGVUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByXzIgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUucm90YXRpb24gPSBib25lLmRhdGEucm90YXRpb24gKyByXzIgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnJlcGxhY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByXzIgKz0gYm9uZS5kYXRhLnJvdGF0aW9uIC0gYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJfMiAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHJfMiAvIDM2MCkgfCAwKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuYWRkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiArPSByXzIgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFJvdGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZSb3RhdGlvbiA9IGZyYW1lc1tmcmFtZSArIFJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KChmcmFtZSA+PiAxKSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgUm90YXRlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBmcmFtZXNbZnJhbWUgKyBSb3RhdGVUaW1lbGluZS5ST1RBVElPTl0gLSBwcmV2Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICByID0gcHJldlJvdGF0aW9uICsgKHIgLSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIgLyAzNjApIHwgMCkpICogMzYwKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIChyIC0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnJlcGxhY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gYm9uZS5kYXRhLnJvdGF0aW9uIC0gYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiArPSAociAtICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gciAvIDM2MCkgfCAwKSkgKiAzNjApICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdGF0ZVRpbWVsaW5lLkVOVFJJRVMgPSAyO1xyXG4gICAgICAgICAgICBSb3RhdGVUaW1lbGluZS5QUkVWX1RJTUUgPSAtMjtcclxuICAgICAgICAgICAgUm90YXRlVGltZWxpbmUuUFJFVl9ST1RBVElPTiA9IC0xO1xyXG4gICAgICAgICAgICBSb3RhdGVUaW1lbGluZS5ST1RBVElPTiA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBSb3RhdGVUaW1lbGluZTtcclxuICAgICAgICB9KEN1cnZlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLlJvdGF0ZVRpbWVsaW5lID0gUm90YXRlVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFRyYW5zbGF0ZVRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYW5zbGF0ZVRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2xhdGVUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnRyYW5zbGF0ZSA8PCAyNCkgKyB0aGlzLmJvbmVJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNsYXRlVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHgsIHkpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggKj0gVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2xhdGVUaW1lbGluZS5YXSA9IHg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHJhbnNsYXRlVGltZWxpbmUuWV0gPSB5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnggPSBib25lLmRhdGEueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUueSA9IGJvbmUuZGF0YS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS54ICs9IChib25lLmRhdGEueCAtIGJvbmUueCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUueSArPSAoYm9uZS5kYXRhLnkgLSBib25lLnkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gMCwgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgVHJhbnNsYXRlVGltZWxpbmUuUFJFVl9YXTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1hdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNsYXRlVGltZWxpbmUuWF0gLSB4KSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNsYXRlVGltZWxpbmUuWV0gLSB5KSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS54ID0gYm9uZS5kYXRhLnggKyB4ICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUueSA9IGJvbmUuZGF0YS55ICsgeSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS54ICs9IChib25lLmRhdGEueCArIHggLSBib25lLngpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUueSArPSAoYm9uZS5kYXRhLnkgKyB5IC0gYm9uZS55KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS54ICs9IHggKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS55ICs9IHkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFUyA9IDM7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfVElNRSA9IC0zO1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1ggPSAtMjtcclxuICAgICAgICAgICAgVHJhbnNsYXRlVGltZWxpbmUuUFJFVl9ZID0gLTE7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLlggPSAxO1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5ZID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zbGF0ZVRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuVHJhbnNsYXRlVGltZWxpbmUgPSBUcmFuc2xhdGVUaW1lbGluZTtcclxuICAgICAgICB2YXIgU2NhbGVUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTY2FsZVRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTY2FsZVRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNjYWxlVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5zY2FsZSA8PCAyNCkgKyB0aGlzLmJvbmVJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2NhbGVUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCA9IGJvbmUuZGF0YS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IGJvbmUuZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCArPSAoYm9uZS5kYXRhLnNjYWxlWCAtIGJvbmUuc2NhbGVYKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVkgKz0gKGJvbmUuZGF0YS5zY2FsZVkgLSBib25lLnNjYWxlWSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwLCB5ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gU2NhbGVUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFNjYWxlVGltZWxpbmUuUFJFVl9YXSAqIGJvbmUuZGF0YS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgU2NhbGVUaW1lbGluZS5QUkVWX1ldICogYm9uZS5kYXRhLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBTY2FsZVRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlBSRVZfWF07XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGZyYW1lc1tmcmFtZSArIFNjYWxlVGltZWxpbmUuUFJFVl9ZXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gU2NhbGVUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKHggKyAoZnJhbWVzW2ZyYW1lICsgU2NhbGVUaW1lbGluZS5YXSAtIHgpICogcGVyY2VudCkgKiBib25lLmRhdGEuc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAoeSArIChmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlldIC0geSkgKiBwZXJjZW50KSAqIGJvbmUuZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggKz0geCAtIGJvbmUuZGF0YS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZICs9IHkgLSBib25lLmRhdGEuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ4ID0gMCwgYnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm1peE91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gYm9uZS5kYXRhLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGJvbmUuZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSBieCArIChNYXRoLmFicyh4KSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bShieCkgLSBieCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IGJ5ICsgKE1hdGguYWJzKHkpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGJ5KSAtIGJ5KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieCA9IGJvbmUuc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYm9uZS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSBieCArIChNYXRoLmFicyh4KSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bShieCkgLSBieCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IGJ5ICsgKE1hdGguYWJzKHkpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGJ5KSAtIGJ5KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnggPSBib25lLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IGJvbmUuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYID0gYnggKyAoTWF0aC5hYnMoeCkgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0oYngpIC0gYm9uZS5kYXRhLnNjYWxlWCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IGJ5ICsgKE1hdGguYWJzKHkpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGJ5KSAtIGJvbmUuZGF0YS5zY2FsZVkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnggPSBNYXRoLmFicyhib25lLmRhdGEuc2NhbGVYKSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bSh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IE1hdGguYWJzKGJvbmUuZGF0YS5zY2FsZVkpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYID0gYnggKyAoeCAtIGJ4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYnkgKyAoeSAtIGJ5KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieCA9IE1hdGguYWJzKGJvbmUuc2NhbGVYKSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bSh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSA9IE1hdGguYWJzKGJvbmUuc2NhbGVZKSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bSh5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCA9IGJ4ICsgKHggLSBieCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IGJ5ICsgKHkgLSBieSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuYWRkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gY29yZS5NYXRoVXRpbHMuc2lnbnVtKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gY29yZS5NYXRoVXRpbHMuc2lnbnVtKHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYID0gTWF0aC5hYnMoYm9uZS5zY2FsZVgpICogYnggKyAoeCAtIE1hdGguYWJzKGJvbmUuZGF0YS5zY2FsZVgpICogYngpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVkgPSBNYXRoLmFicyhib25lLnNjYWxlWSkgKiBieSArICh5IC0gTWF0aC5hYnMoYm9uZS5kYXRhLnNjYWxlWSkgKiBieSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNjYWxlVGltZWxpbmU7XHJcbiAgICAgICAgfShUcmFuc2xhdGVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuU2NhbGVUaW1lbGluZSA9IFNjYWxlVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFNoZWFyVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU2hlYXJUaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2hlYXJUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTaGVhclRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUuc2hlYXIgPDwgMjQpICsgdGhpcy5ib25lSW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNoZWFyVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1t0aGlzLmJvbmVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvbmUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclggPSBib25lLmRhdGEuc2hlYXJYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclkgPSBib25lLmRhdGEuc2hlYXJZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclggKz0gKGJvbmUuZGF0YS5zaGVhclggLSBib25lLnNoZWFyWCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJZICs9IChib25lLmRhdGEuc2hlYXJZIC0gYm9uZS5zaGVhclkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gMCwgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFNoZWFyVGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTaGVhclRpbWVsaW5lLlBSRVZfWF07XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgU2hlYXJUaW1lbGluZS5QUkVWX1ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFNoZWFyVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuUFJFVl9YXTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZnJhbWVzW2ZyYW1lICsgU2hlYXJUaW1lbGluZS5QUkVWX1ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBTaGVhclRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4ICsgKGZyYW1lc1tmcmFtZSArIFNoZWFyVGltZWxpbmUuWF0gLSB4KSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkgKyAoZnJhbWVzW2ZyYW1lICsgU2hlYXJUaW1lbGluZS5ZXSAtIHkpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWCA9IGJvbmUuZGF0YS5zaGVhclggKyB4ICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJZID0gYm9uZS5kYXRhLnNoZWFyWSArIHkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnJlcGxhY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJYICs9IChib25lLmRhdGEuc2hlYXJYICsgeCAtIGJvbmUuc2hlYXJYKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWSArPSAoYm9uZS5kYXRhLnNoZWFyWSArIHkgLSBib25lLnNoZWFyWSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJYICs9IHggKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclkgKz0geSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2hlYXJUaW1lbGluZTtcclxuICAgICAgICB9KFRyYW5zbGF0ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5TaGVhclRpbWVsaW5lID0gU2hlYXJUaW1lbGluZTtcclxuICAgICAgICB2YXIgQ29sb3JUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDb2xvclRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb2xvclRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIENvbG9yVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLmNvbG9yIDw8IDI0KSArIHRoaXMuc2xvdEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDb2xvclRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IENvbG9yVGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBDb2xvclRpbWVsaW5lLlJdID0gcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBDb2xvclRpbWVsaW5lLkddID0gZztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBDb2xvclRpbWVsaW5lLkJdID0gYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBDb2xvclRpbWVsaW5lLkFdID0gYTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBzbG90LmNvbG9yLCBzZXR1cCA9IHNsb3QuZGF0YS5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLmFkZCgoc2V0dXAuciAtIGNvbG9yLnIpICogYWxwaGEsIChzZXR1cC5nIC0gY29sb3IuZykgKiBhbHBoYSwgKHNldHVwLmIgLSBjb2xvci5iKSAqIGFscGhhLCAoc2V0dXAuYSAtIGNvbG9yLmEpICogYWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIENvbG9yVGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGZyYW1lc1tpICsgQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBmcmFtZXNbaSArIENvbG9yVGltZWxpbmUuUFJFVl9HXTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gZnJhbWVzW2kgKyBDb2xvclRpbWVsaW5lLlBSRVZfQl07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZyYW1lc1tpICsgQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIENvbG9yVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUFJFVl9SXTtcclxuICAgICAgICAgICAgICAgICAgICBnID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLlBSRVZfQl07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUFJFVl9BXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gQ29sb3JUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByICs9IChmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLlJdIC0gcikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGcgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuR10gLSBnKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYiArPSAoZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5CXSAtIGIpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBhICs9IChmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLkFdIC0gYSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jb2xvci5zZXQociwgZywgYiwgYSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBzbG90LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5zZXR1cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IuYWRkKChyIC0gY29sb3IucikgKiBhbHBoYSwgKGcgLSBjb2xvci5nKSAqIGFscGhhLCAoYiAtIGNvbG9yLmIpICogYWxwaGEsIChhIC0gY29sb3IuYSkgKiBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuRU5UUklFUyA9IDU7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUFJFVl9USU1FID0gLTU7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUFJFVl9SID0gLTQ7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUFJFVl9HID0gLTM7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUFJFVl9CID0gLTI7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUFJFVl9BID0gLTE7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuUiA9IDE7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuRyA9IDI7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuQiA9IDM7XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUuQSA9IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvclRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuQ29sb3JUaW1lbGluZSA9IENvbG9yVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFR3b0NvbG9yVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHdvQ29sb3JUaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHdvQ29sb3JUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS50d29Db2xvciA8PCAyNCkgKyB0aGlzLnNsb3RJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgciwgZywgYiwgYSwgcjIsIGcyLCBiMikge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCAqPSBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5SXSA9IHI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5HXSA9IGc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5CXSA9IGI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5BXSA9IGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5SMl0gPSByMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkcyXSA9IGcyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFR3b0NvbG9yVGltZWxpbmUuQjJdID0gYjI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNsb3QuYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmNvbG9yLnNldEZyb21Db2xvcihzbG90LmRhdGEuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5kYXJrQ29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5kYXJrQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpZ2h0ID0gc2xvdC5jb2xvciwgZGFyayA9IHNsb3QuZGFya0NvbG9yLCBzZXR1cExpZ2h0ID0gc2xvdC5kYXRhLmNvbG9yLCBzZXR1cERhcmsgPSBzbG90LmRhdGEuZGFya0NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlnaHQuYWRkKChzZXR1cExpZ2h0LnIgLSBsaWdodC5yKSAqIGFscGhhLCAoc2V0dXBMaWdodC5nIC0gbGlnaHQuZykgKiBhbHBoYSwgKHNldHVwTGlnaHQuYiAtIGxpZ2h0LmIpICogYWxwaGEsIChzZXR1cExpZ2h0LmEgLSBsaWdodC5hKSAqIGFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhcmsuYWRkKChzZXR1cERhcmsuciAtIGRhcmsucikgKiBhbHBoYSwgKHNldHVwRGFyay5nIC0gZGFyay5nKSAqIGFscGhhLCAoc2V0dXBEYXJrLmIgLSBkYXJrLmIpICogYWxwaGEsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDAsIHIyID0gMCwgZzIgPSAwLCBiMiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFR3b0NvbG9yVGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HXTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQl07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xyXG4gICAgICAgICAgICAgICAgICAgIHIyID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfUjJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcyID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfRzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGIyID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQjJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SXTtcclxuICAgICAgICAgICAgICAgICAgICBnID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQl07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9BXTtcclxuICAgICAgICAgICAgICAgICAgICByMiA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SMl07XHJcbiAgICAgICAgICAgICAgICAgICAgZzIgPSBmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfRzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGIyID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0IyXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gVHdvQ29sb3JUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlJdIC0gcikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGcgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuR10gLSBnKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYiArPSAoZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5CXSAtIGIpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBhICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLkFdIC0gYSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHIyICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlIyXSAtIHIyKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZzIgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuRzJdIC0gZzIpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBiMiArPSAoZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5CMl0gLSBiMikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmNvbG9yLnNldChyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmRhcmtDb2xvci5zZXQocjIsIGcyLCBiMiwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBzbG90LmNvbG9yLCBkYXJrID0gc2xvdC5kYXJrQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0LnNldEZyb21Db2xvcihzbG90LmRhdGEuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXJrLnNldEZyb21Db2xvcihzbG90LmRhdGEuZGFya0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQuYWRkKChyIC0gbGlnaHQucikgKiBhbHBoYSwgKGcgLSBsaWdodC5nKSAqIGFscGhhLCAoYiAtIGxpZ2h0LmIpICogYWxwaGEsIChhIC0gbGlnaHQuYSkgKiBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGFyay5hZGQoKHIyIC0gZGFyay5yKSAqIGFscGhhLCAoZzIgLSBkYXJrLmcpICogYWxwaGEsIChiMiAtIGRhcmsuYikgKiBhbHBoYSwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUyA9IDg7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9USU1FID0gLTg7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SID0gLTc7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HID0gLTY7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CID0gLTU7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9BID0gLTQ7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SMiA9IC0zO1xyXG4gICAgICAgICAgICBUd29Db2xvclRpbWVsaW5lLlBSRVZfRzIgPSAtMjtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0IyID0gLTE7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUiA9IDE7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuRyA9IDI7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuQiA9IDM7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuQSA9IDQ7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUjIgPSA1O1xyXG4gICAgICAgICAgICBUd29Db2xvclRpbWVsaW5lLkcyID0gNjtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5CMiA9IDc7XHJcbiAgICAgICAgICAgIHJldHVybiBUd29Db2xvclRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuVHdvQ29sb3JUaW1lbGluZSA9IFR3b0NvbG9yVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIEF0dGFjaG1lbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEF0dGFjaG1lbnRUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudE5hbWVzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLmF0dGFjaG1lbnQgPDwgMjQpICsgdGhpcy5zbG90SW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0RnJhbWVDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgYXR0YWNobWVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdID0gYXR0YWNobWVudE5hbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhPdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0YWNobWVudChza2VsZXRvbiwgc2xvdCwgc2xvdC5kYXRhLmF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5zZXR1cCB8fCBibGVuZCA9PSBNaXhCbGVuZC5maXJzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KHNrZWxldG9uLCBzbG90LCBzbG90LmRhdGEuYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IGZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMSkgLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnROYW1lID0gdGhpcy5hdHRhY2htZW50TmFtZXNbZnJhbWVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF1cclxuICAgICAgICAgICAgICAgICAgICAuc2V0QXR0YWNobWVudChhdHRhY2htZW50TmFtZSA9PSBudWxsID8gbnVsbCA6IHNrZWxldG9uLmdldEF0dGFjaG1lbnQodGhpcy5zbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2VsZXRvbiwgc2xvdCwgYXR0YWNobWVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHNsb3QuYXR0YWNobWVudCA9IGF0dGFjaG1lbnROYW1lID09IG51bGwgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNobWVudFRpbWVsaW5lO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5BdHRhY2htZW50VGltZWxpbmUgPSBBdHRhY2htZW50VGltZWxpbmU7XHJcbiAgICAgICAgdmFyIHplcm9zID0gbnVsbDtcclxuICAgICAgICB2YXIgRGVmb3JtVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoRGVmb3JtVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERlZm9ybVRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZVZlcnRpY2VzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoNjQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERlZm9ybVRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUuZGVmb3JtIDw8IDI3KSArICt0aGlzLmF0dGFjaG1lbnQuaWQgKyB0aGlzLnNsb3RJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRGVmb3JtVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHZlcnRpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lVmVydGljZXNbZnJhbWVJbmRleF0gPSB2ZXJ0aWNlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRGVmb3JtVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdEF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghKHNsb3RBdHRhY2htZW50IGluc3RhbmNlb2YgY29yZS5WZXJ0ZXhBdHRhY2htZW50KSB8fCAhKHNsb3RBdHRhY2htZW50LmRlZm9ybUF0dGFjaG1lbnQgPT0gdGhpcy5hdHRhY2htZW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmb3JtQXJyYXkgPSBzbG90LmRlZm9ybTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZvcm1BcnJheS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICBibGVuZCA9IE1peEJsZW5kLnNldHVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lVmVydGljZXMgPSB0aGlzLmZyYW1lVmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBmcmFtZVZlcnRpY2VzWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1BcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1BcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZm9ybV8xID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoZGVmb3JtQXJyYXksIHZlcnRleENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhBdHRhY2htZW50LmJvbmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXBWZXJ0aWNlcyA9IHZlcnRleEF0dGFjaG1lbnQudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1fMVtpXSArPSAoc2V0dXBWZXJ0aWNlc1tpXSAtIGRlZm9ybV8xW2ldKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAxIC0gYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1fMVtpXSAqPSBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlZm9ybSA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKGRlZm9ybUFycmF5LCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RWZXJ0aWNlcyA9IGZyYW1lVmVydGljZXNbZnJhbWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhBdHRhY2htZW50ID0gc2xvdEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4QXR0YWNobWVudC5ib25lcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IHZlcnRleENvdW50OyBpXzErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8xXSArPSBsYXN0VmVydGljZXNbaV8xXSAtIHNldHVwVmVydGljZXNbaV8xXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzIgPSAwOyBpXzIgPCB2ZXJ0ZXhDb3VudDsgaV8yKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzJdICs9IGxhc3RWZXJ0aWNlc1tpXzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkobGFzdFZlcnRpY2VzLCAwLCBkZWZvcm0sIDAsIHZlcnRleENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhBdHRhY2htZW50XzEgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4QXR0YWNobWVudF8xLmJvbmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50XzEudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMyA9IDA7IGlfMyA8IHZlcnRleENvdW50OyBpXzMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwID0gc2V0dXBWZXJ0aWNlc1tpXzNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfM10gPSBzZXR1cCArIChsYXN0VmVydGljZXNbaV8zXSAtIHNldHVwKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzQgPSAwOyBpXzQgPCB2ZXJ0ZXhDb3VudDsgaV80KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV80XSA9IGxhc3RWZXJ0aWNlc1tpXzRdICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzUgPSAwOyBpXzUgPCB2ZXJ0ZXhDb3VudDsgaV81KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzVdICs9IChsYXN0VmVydGljZXNbaV81XSAtIGRlZm9ybVtpXzVdKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4QXR0YWNobWVudC5ib25lcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR1cFZlcnRpY2VzID0gdmVydGV4QXR0YWNobWVudC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV82ID0gMDsgaV82IDwgdmVydGV4Q291bnQ7IGlfNisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV82XSArPSAobGFzdFZlcnRpY2VzW2lfNl0gLSBzZXR1cFZlcnRpY2VzW2lfNl0pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfNyA9IDA7IGlfNyA8IHZlcnRleENvdW50OyBpXzcrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzddICs9IGxhc3RWZXJ0aWNlc1tpXzddICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2VmVydGljZXMgPSBmcmFtZVZlcnRpY2VzW2ZyYW1lIC0gMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFZlcnRpY2VzID0gZnJhbWVWZXJ0aWNlc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSAtIDFdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleEF0dGFjaG1lbnQuYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV84ID0gMDsgaV84IDwgdmVydGV4Q291bnQ7IGlfOCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV84XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV84XSArPSBwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzhdIC0gcHJldikgKiBwZXJjZW50IC0gc2V0dXBWZXJ0aWNlc1tpXzhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV85ID0gMDsgaV85IDwgdmVydGV4Q291bnQ7IGlfOSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV85XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV85XSArPSBwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzldIC0gcHJldikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEwID0gMDsgaV8xMCA8IHZlcnRleENvdW50OyBpXzEwKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2lfMTBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMTBdID0gcHJldiArIChuZXh0VmVydGljZXNbaV8xMF0gLSBwcmV2KSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhBdHRhY2htZW50XzIgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhBdHRhY2htZW50XzIuYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR1cFZlcnRpY2VzID0gdmVydGV4QXR0YWNobWVudF8yLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTEgPSAwOyBpXzExIDwgdmVydGV4Q291bnQ7IGlfMTErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzExXSwgc2V0dXAgPSBzZXR1cFZlcnRpY2VzW2lfMTFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8xMV0gPSBzZXR1cCArIChwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzExXSAtIHByZXYpICogcGVyY2VudCAtIHNldHVwKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTIgPSAwOyBpXzEyIDwgdmVydGV4Q291bnQ7IGlfMTIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzEyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMTJdID0gKHByZXYgKyAobmV4dFZlcnRpY2VzW2lfMTJdIC0gcHJldikgKiBwZXJjZW50KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTMgPSAwOyBpXzEzIDwgdmVydGV4Q291bnQ7IGlfMTMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2lfMTNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzEzXSArPSAocHJldiArIChuZXh0VmVydGljZXNbaV8xM10gLSBwcmV2KSAqIHBlcmNlbnQgLSBkZWZvcm1baV8xM10pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4QXR0YWNobWVudCA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleEF0dGFjaG1lbnQuYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR1cFZlcnRpY2VzID0gdmVydGV4QXR0YWNobWVudC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzE0ID0gMDsgaV8xNCA8IHZlcnRleENvdW50OyBpXzE0KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV8xNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzE0XSArPSAocHJldiArIChuZXh0VmVydGljZXNbaV8xNF0gLSBwcmV2KSAqIHBlcmNlbnQgLSBzZXR1cFZlcnRpY2VzW2lfMTRdKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTUgPSAwOyBpXzE1IDwgdmVydGV4Q291bnQ7IGlfMTUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzE1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMTVdICs9IChwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzE1XSAtIHByZXYpICogcGVyY2VudCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRGVmb3JtVGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5EZWZvcm1UaW1lbGluZSA9IERlZm9ybVRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBFdmVudFRpbWVsaW5lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRXZlbnRUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEV2ZW50VGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGltZWxpbmVUeXBlLmV2ZW50IDw8IDI0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFRpbWVsaW5lLnByb3RvdHlwZS5nZXRGcmFtZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gZXZlbnQudGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW2ZyYW1lSW5kZXhdID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEV2ZW50VGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyZWRFdmVudHMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0VGltZSA+IHRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgTnVtYmVyLk1BWF9WQUxVRSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0VGltZSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFzdFRpbWUgPj0gZnJhbWVzW2ZyYW1lQ291bnQgLSAxXSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUaW1lIDwgZnJhbWVzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIGxhc3RUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZnJhbWUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZXNbZnJhbWUgLSAxXSAhPSBmcmFtZVRpbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgZnJhbWUgPCBmcmFtZUNvdW50ICYmIHRpbWUgPj0gZnJhbWVzW2ZyYW1lXTsgZnJhbWUrKylcclxuICAgICAgICAgICAgICAgICAgICBmaXJlZEV2ZW50cy5wdXNoKHRoaXMuZXZlbnRzW2ZyYW1lXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudFRpbWVsaW5lO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5FdmVudFRpbWVsaW5lID0gRXZlbnRUaW1lbGluZTtcclxuICAgICAgICB2YXIgRHJhd09yZGVyVGltZWxpbmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEcmF3T3JkZXJUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd09yZGVycyA9IG5ldyBBcnJheShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBEcmF3T3JkZXJUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUaW1lbGluZVR5cGUuZHJhd09yZGVyIDw8IDI0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEcmF3T3JkZXJUaW1lbGluZS5wcm90b3R5cGUuZ2V0RnJhbWVDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERyYXdPcmRlclRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBkcmF3T3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd09yZGVyc1tmcmFtZUluZGV4XSA9IGRyYXdPcmRlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRHJhd09yZGVyVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyID0gc2tlbGV0b24uZHJhd09yZGVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhPdXQgJiYgYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weShza2VsZXRvbi5zbG90cywgMCwgc2tlbGV0b24uZHJhd09yZGVyLCAwLCBza2VsZXRvbi5zbG90cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwIHx8IGJsZW5kID09IE1peEJsZW5kLmZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weShza2VsZXRvbi5zbG90cywgMCwgc2tlbGV0b24uZHJhd09yZGVyLCAwLCBza2VsZXRvbi5zbG90cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnJhbWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSkgLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlclRvU2V0dXBJbmRleCA9IHRoaXMuZHJhd09yZGVyc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhd09yZGVyVG9TZXR1cEluZGV4ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkoc2xvdHMsIDAsIGRyYXdPcmRlciwgMCwgc2xvdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyVG9TZXR1cEluZGV4Lmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW2ldID0gc2xvdHNbZHJhd09yZGVyVG9TZXR1cEluZGV4W2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIERyYXdPcmRlclRpbWVsaW5lO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5EcmF3T3JkZXJUaW1lbGluZSA9IERyYXdPcmRlclRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBJa0NvbnN0cmFpbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhJa0NvbnN0cmFpbnRUaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSWtDb25zdHJhaW50VGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5pa0NvbnN0cmFpbnQgPDwgMjQpICsgdGhpcy5pa0NvbnN0cmFpbnRJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIG1peCwgc29mdG5lc3MsIGJlbmREaXJlY3Rpb24sIGNvbXByZXNzLCBzdHJldGNoKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IElrQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgSWtDb25zdHJhaW50VGltZWxpbmUuTUlYXSA9IG1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5TT0ZUTkVTU10gPSBzb2Z0bmVzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5CRU5EX0RJUkVDVElPTl0gPSBiZW5kRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIElrQ29uc3RyYWludFRpbWVsaW5lLkNPTVBSRVNTXSA9IGNvbXByZXNzID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgSWtDb25zdHJhaW50VGltZWxpbmUuU1RSRVRDSF0gPSBzdHJldGNoID8gMSA6IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5pa0NvbnN0cmFpbnRzW3RoaXMuaWtDb25zdHJhaW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQubWl4ID0gY29uc3RyYWludC5kYXRhLm1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc29mdG5lc3MgPSBjb25zdHJhaW50LmRhdGEuc29mdG5lc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBjb25zdHJhaW50LmRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBjb25zdHJhaW50LmRhdGEuc3RyZXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQubWl4ICs9IChjb25zdHJhaW50LmRhdGEubWl4IC0gY29uc3RyYWludC5taXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNvZnRuZXNzICs9IChjb25zdHJhaW50LmRhdGEuc29mdG5lc3MgLSBjb25zdHJhaW50LnNvZnRuZXNzKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gY29uc3RyYWludC5kYXRhLmJlbmREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNvbXByZXNzID0gY29uc3RyYWludC5kYXRhLmNvbXByZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gY29uc3RyYWludC5kYXRhLnN0cmV0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggPSBjb25zdHJhaW50LmRhdGEubWl4ICsgKGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVhdIC0gY29uc3RyYWludC5kYXRhLm1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zb2Z0bmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NPRlRORVNTXSAtIGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzcykgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBNaXhEaXJlY3Rpb24ubWl4T3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBjb25zdHJhaW50LmRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBjb25zdHJhaW50LmRhdGEuc3RyZXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9CRU5EX0RJUkVDVElPTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNvbXByZXNzID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0NPTVBSRVNTXSAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NUUkVUQ0hdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQubWl4ICs9IChmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfTUlYXSAtIGNvbnN0cmFpbnQubWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNvZnRuZXNzICs9IChmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU09GVE5FU1NdIC0gY29uc3RyYWludC5zb2Z0bmVzcykgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBNaXhEaXJlY3Rpb24ubWl4SW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9CRU5EX0RJUkVDVElPTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNvbXByZXNzID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0NPTVBSRVNTXSAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NUUkVUQ0hdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIElrQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1peCA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfTUlYXTtcclxuICAgICAgICAgICAgICAgIHZhciBzb2Z0bmVzcyA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU09GVE5FU1NdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggPSBjb25zdHJhaW50LmRhdGEubWl4ICsgKG1peCArIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5NSVhdIC0gbWl4KSAqIHBlcmNlbnQgLSBjb25zdHJhaW50LmRhdGEubWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc29mdG5lc3MgPSBjb25zdHJhaW50LmRhdGEuc29mdG5lc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoc29mdG5lc3MgKyAoZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuU09GVE5FU1NdIC0gc29mdG5lc3MpICogcGVyY2VudCAtIGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzcykgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhPdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gY29uc3RyYWludC5kYXRhLmJlbmREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBjb25zdHJhaW50LmRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGNvbnN0cmFpbnQuZGF0YS5zdHJldGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9CRU5EX0RJUkVDVElPTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0NPTVBSRVNTXSAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NUUkVUQ0hdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggKz0gKG1peCArIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5NSVhdIC0gbWl4KSAqIHBlcmNlbnQgLSBjb25zdHJhaW50Lm1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNvZnRuZXNzICs9IChzb2Z0bmVzcyArIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5TT0ZUTkVTU10gLSBzb2Z0bmVzcykgKiBwZXJjZW50IC0gY29uc3RyYWludC5zb2Z0bmVzcykgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhJbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5jb21wcmVzcyA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQ09NUFJFU1NdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU1RSRVRDSF0gIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMgPSA2O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RJTUUgPSAtNjtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVggPSAtNTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9TT0ZUTkVTUyA9IC00O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OID0gLTM7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQ09NUFJFU1MgPSAtMjtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9TVFJFVENIID0gLTE7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLk1JWCA9IDE7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLlNPRlRORVNTID0gMjtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuQkVORF9ESVJFQ1RJT04gPSAzO1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5DT01QUkVTUyA9IDQ7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLlNUUkVUQ0ggPSA1O1xyXG4gICAgICAgICAgICByZXR1cm4gSWtDb25zdHJhaW50VGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5Ja0NvbnN0cmFpbnRUaW1lbGluZSA9IElrQ29uc3RyYWludFRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnRyYW5zZm9ybUNvbnN0cmFpbnQgPDwgMjQpICsgdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50SW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgcm90YXRlTWl4LCB0cmFuc2xhdGVNaXgsIHNjYWxlTWl4LCBzaGVhck1peCkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCAqPSBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUk9UQVRFXSA9IHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuVFJBTlNMQVRFXSA9IHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0NBTEVdID0gc2NhbGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNIRUFSXSA9IHNoZWFyTWl4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uLnRyYW5zZm9ybUNvbnN0cmFpbnRzW3RoaXMudHJhbnNmb3JtQ29uc3RyYWludEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RyYWludC5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnN0cmFpbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggPSBkYXRhLnRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2NhbGVNaXggPSBkYXRhLnNjYWxlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zaGVhck1peCA9IGRhdGEuc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCArPSAoZGF0YS5yb3RhdGVNaXggLSBjb25zdHJhaW50LnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ICs9IChkYXRhLnRyYW5zbGF0ZU1peCAtIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zY2FsZU1peCArPSAoZGF0YS5zY2FsZU1peCAtIGNvbnN0cmFpbnQuc2NhbGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNoZWFyTWl4ICs9IChkYXRhLnNoZWFyTWl4IC0gY29uc3RyYWludC5zaGVhck1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IDAsIHRyYW5zbGF0ZSA9IDAsIHNjYWxlID0gMCwgc2hlYXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gZnJhbWVzW2kgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9ST1RBVEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA9IGZyYW1lc1tpICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVFJBTlNMQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IGZyYW1lc1tpICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0NBTEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWFyID0gZnJhbWVzW2kgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9TSEVBUl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1JPVEFURV07XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVFJBTlNMQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NDQUxFXTtcclxuICAgICAgICAgICAgICAgICAgICBzaGVhciA9IGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NIRUFSXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUk9UQVRFXSAtIHJvdGF0ZSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlRSQU5TTEFURV0gLSB0cmFuc2xhdGUpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZSArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNDQUxFXSAtIHNjYWxlKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlYXIgKz0gKGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5TSEVBUl0gLSBzaGVhcikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjb25zdHJhaW50LmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5yb3RhdGVNaXggPSBkYXRhLnJvdGF0ZU1peCArIChyb3RhdGUgLSBkYXRhLnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4ICsgKHRyYW5zbGF0ZSAtIGRhdGEudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2NhbGVNaXggPSBkYXRhLnNjYWxlTWl4ICsgKHNjYWxlIC0gZGF0YS5zY2FsZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peCArIChzaGVhciAtIGRhdGEuc2hlYXJNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCArPSAocm90YXRlIC0gY29uc3RyYWludC5yb3RhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggKz0gKHRyYW5zbGF0ZSAtIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2NhbGVNaXggKz0gKHNjYWxlIC0gY29uc3RyYWludC5zY2FsZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNoZWFyTWl4ICs9IChzaGVhciAtIGNvbnN0cmFpbnQuc2hlYXJNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTID0gNTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVElNRSA9IC01O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9ST1RBVEUgPSAtNDtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVFJBTlNMQVRFID0gLTM7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NDQUxFID0gLTI7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NIRUFSID0gLTE7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5ST1RBVEUgPSAxO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuVFJBTlNMQVRFID0gMjtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNDQUxFID0gMztcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNIRUFSID0gNDtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZTtcclxuICAgICAgICB9KEN1cnZlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZSA9IFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZTtcclxuICAgICAgICB2YXIgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5wYXRoQ29uc3RyYWludFBvc2l0aW9uIDw8IDI0KSArIHRoaXMucGF0aENvbnN0cmFpbnRJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCAqPSBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuVkFMVUVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b24ucGF0aENvbnN0cmFpbnRzW3RoaXMucGF0aENvbnN0cmFpbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb3NpdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9zaXRpb24gKz0gKGNvbnN0cmFpbnQuZGF0YS5wb3NpdGlvbiAtIGNvbnN0cmFpbnQucG9zaXRpb24pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTXSlcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVkFMVUVdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5QUkVWX1ZBTFVFXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5WQUxVRV0gLSBwb3NpdGlvbikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9zaXRpb24gPSBjb25zdHJhaW50LmRhdGEucG9zaXRpb24gKyAocG9zaXRpb24gLSBjb25zdHJhaW50LmRhdGEucG9zaXRpb24pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb3NpdGlvbiArPSAocG9zaXRpb24gLSBjb25zdHJhaW50LnBvc2l0aW9uKSAqIGFscGhhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFUyA9IDI7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5QUkVWX1RJTUUgPSAtMjtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVkFMVUUgPSAtMTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlZBTFVFID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZTtcclxuICAgICAgICB9KEN1cnZlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZSA9IFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZTtcclxuICAgICAgICB2YXIgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUucGF0aENvbnN0cmFpbnRTcGFjaW5nIDw8IDI0KSArIHRoaXMucGF0aENvbnN0cmFpbnRJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uLnBhdGhDb25zdHJhaW50c1t0aGlzLnBhdGhDb25zdHJhaW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3BhY2luZyA9IGNvbnN0cmFpbnQuZGF0YS5zcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zcGFjaW5nICs9IChjb25zdHJhaW50LmRhdGEuc3BhY2luZyAtIGNvbnN0cmFpbnQuc3BhY2luZykgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5FTlRSSUVTXSlcclxuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5QUkVWX1ZBTFVFXTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nID0gZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUuUFJFVl9WQUxVRV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nICs9IChmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5WQUxVRV0gLSBzcGFjaW5nKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zcGFjaW5nID0gY29uc3RyYWludC5kYXRhLnNwYWNpbmcgKyAoc3BhY2luZyAtIGNvbnN0cmFpbnQuZGF0YS5zcGFjaW5nKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3BhY2luZyArPSAoc3BhY2luZyAtIGNvbnN0cmFpbnQuc3BhY2luZykgKiBhbHBoYTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lO1xyXG4gICAgICAgIH0oUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5QYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSA9IFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lO1xyXG4gICAgICAgIHZhciBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUucGF0aENvbnN0cmFpbnRNaXggPDwgMjQpICsgdGhpcy5wYXRoQ29uc3RyYWludEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCAqPSBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5ST1RBVEVdID0gcm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuVFJBTlNMQVRFXSA9IHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b24ucGF0aENvbnN0cmFpbnRzW3RoaXMucGF0aENvbnN0cmFpbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5yb3RhdGVNaXggPSBjb25zdHJhaW50LmRhdGEucm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggPSBjb25zdHJhaW50LmRhdGEudHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5yb3RhdGVNaXggKz0gKGNvbnN0cmFpbnQuZGF0YS5yb3RhdGVNaXggLSBjb25zdHJhaW50LnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ICs9IChjb25zdHJhaW50LmRhdGEudHJhbnNsYXRlTWl4IC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGUgPSAwLCB0cmFuc2xhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfUk9UQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9UUkFOU0xBVEVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1JPVEFURV07XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlID0gZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1RSQU5TTEFURV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICs9IChmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlJPVEFURV0gLSByb3RhdGUpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuVFJBTlNMQVRFXSAtIHRyYW5zbGF0ZSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5yb3RhdGVNaXggPSBjb25zdHJhaW50LmRhdGEucm90YXRlTWl4ICsgKHJvdGF0ZSAtIGNvbnN0cmFpbnQuZGF0YS5yb3RhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggPSBjb25zdHJhaW50LmRhdGEudHJhbnNsYXRlTWl4ICsgKHRyYW5zbGF0ZSAtIGNvbnN0cmFpbnQuZGF0YS50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCArPSAocm90YXRlIC0gY29uc3RyYWludC5yb3RhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggKz0gKHRyYW5zbGF0ZSAtIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVMgPSAzO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfVElNRSA9IC0zO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfUk9UQVRFID0gLTI7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9UUkFOU0xBVEUgPSAtMTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5ST1RBVEUgPSAxO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlRSQU5TTEFURSA9IDI7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZSA9IFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmU7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQW5pbWF0aW9uU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZShkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lU2NhbGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmtleWVkU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IEV2ZW50UXVldWUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5SURzID0gbmV3IGNvcmUuSW50U2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrRW50cnlQb29sID0gbmV3IGNvcmUuUG9vbChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVHJhY2tFbnRyeSgpOyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgZGVsdGEgKj0gdGhpcy50aW1lU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRyYWNrc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmFuaW1hdGlvbkxhc3QgPSBjdXJyZW50Lm5leHRBbmltYXRpb25MYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQudHJhY2tMYXN0ID0gY3VycmVudC5uZXh0VHJhY2tMYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RGVsdGEgPSBkZWx0YSAqIGN1cnJlbnQudGltZVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmRlbGF5ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRlbGF5IC09IGN1cnJlbnREZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGVsYXkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWx0YSA9IC1jdXJyZW50LmRlbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRlbGF5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRpbWUgPSBjdXJyZW50LnRyYWNrTGFzdCAtIG5leHQuZGVsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGltZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRlbGF5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHJhY2tUaW1lICs9IGN1cnJlbnQudGltZVNjYWxlID09IDAgPyAwIDogKG5leHRUaW1lIC8gY3VycmVudC50aW1lU2NhbGUgKyBkZWx0YSkgKiBuZXh0LnRpbWVTY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQudHJhY2tUaW1lICs9IGN1cnJlbnREZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudChpLCBuZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0Lm1peGluZ0Zyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQubWl4VGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudC50cmFja0xhc3QgPj0gY3VycmVudC50cmFja0VuZCAmJiBjdXJyZW50Lm1peGluZ0Zyb20gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVuZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTmV4dChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm1peGluZ0Zyb20gIT0gbnVsbCAmJiB0aGlzLnVwZGF0ZU1peGluZ0Zyb20oY3VycmVudCwgZGVsdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gY3VycmVudC5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1peGluZ0Zyb20gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbS5taXhpbmdUbyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChmcm9tICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5kKGZyb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20ubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnRyYWNrVGltZSArPSBjdXJyZW50RGVsdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS51cGRhdGVNaXhpbmdGcm9tID0gZnVuY3Rpb24gKHRvLCBkZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0by5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IHRoaXMudXBkYXRlTWl4aW5nRnJvbShmcm9tLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBmcm9tLmFuaW1hdGlvbkxhc3QgPSBmcm9tLm5leHRBbmltYXRpb25MYXN0O1xyXG4gICAgICAgICAgICAgICAgZnJvbS50cmFja0xhc3QgPSBmcm9tLm5leHRUcmFja0xhc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAodG8ubWl4VGltZSA+IDAgJiYgdG8ubWl4VGltZSA+PSB0by5taXhEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tLnRvdGFsQWxwaGEgPT0gMCB8fCB0by5taXhEdXJhdGlvbiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLm1peGluZ0Zyb20gPSBmcm9tLm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tLm1peGluZ0Zyb20gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20ubWl4aW5nRnJvbS5taXhpbmdUbyA9IHRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0by5pbnRlcnJ1cHRBbHBoYSA9IGZyb20uaW50ZXJydXB0QWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5kKGZyb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmcm9tLnRyYWNrVGltZSArPSBkZWx0YSAqIGZyb20udGltZVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdG8ubWl4VGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbiBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zQ2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwcGxpZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTYgPSAwLCBuXzEgPSB0cmFja3MubGVuZ3RoOyBpXzE2IDwgbl8xOyBpXzE2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRyYWNrc1tpXzE2XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsIHx8IGN1cnJlbnQuZGVsYXkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxlbmQgPSBpXzE2ID09IDAgPyBjb3JlLk1peEJsZW5kLmZpcnN0IDogY3VycmVudC5taXhCbGVuZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWl4ID0gY3VycmVudC5hbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5taXhpbmdGcm9tICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peCAqPSB0aGlzLmFwcGx5TWl4aW5nRnJvbShjdXJyZW50LCBza2VsZXRvbiwgYmxlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQudHJhY2tUaW1lID49IGN1cnJlbnQudHJhY2tFbmQgJiYgY3VycmVudC5uZXh0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkxhc3QgPSBjdXJyZW50LmFuaW1hdGlvbkxhc3QsIGFuaW1hdGlvblRpbWUgPSBjdXJyZW50LmdldEFuaW1hdGlvblRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVDb3VudCA9IGN1cnJlbnQuYW5pbWF0aW9uLnRpbWVsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lcyA9IGN1cnJlbnQuYW5pbWF0aW9uLnRpbWVsaW5lcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGlfMTYgPT0gMCAmJiBtaXggPT0gMSkgfHwgYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHRpbWVsaW5lQ291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMud2Via2l0NjAyQnVnZml4SGVscGVyKG1peCwgYmxlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gdGltZWxpbmVzW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZSBpbnN0YW5jZW9mIGNvcmUuQXR0YWNobWVudFRpbWVsaW5lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRhY2htZW50VGltZWxpbmUodGltZWxpbmUsIHNrZWxldG9uLCBhbmltYXRpb25UaW1lLCBibGVuZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYXBwbHkoc2tlbGV0b24sIGFuaW1hdGlvbkxhc3QsIGFuaW1hdGlvblRpbWUsIGV2ZW50cywgbWl4LCBibGVuZCwgY29yZS5NaXhEaXJlY3Rpb24ubWl4SW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVNb2RlID0gY3VycmVudC50aW1lbGluZU1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEZyYW1lID0gY3VycmVudC50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RnJhbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShjdXJyZW50LnRpbWVsaW5lc1JvdGF0aW9uLCB0aW1lbGluZUNvdW50IDw8IDEsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzUm90YXRpb24gPSBjdXJyZW50LnRpbWVsaW5lc1JvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGltZWxpbmVDb3VudDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lXzEgPSB0aW1lbGluZXNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lQmxlbmQgPSB0aW1lbGluZU1vZGVbaWldID09IEFuaW1hdGlvblN0YXRlLlNVQlNFUVVFTlQgPyBibGVuZCA6IGNvcmUuTWl4QmxlbmQuc2V0dXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVfMSBpbnN0YW5jZW9mIGNvcmUuUm90YXRlVGltZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Um90YXRlVGltZWxpbmUodGltZWxpbmVfMSwgc2tlbGV0b24sIGFuaW1hdGlvblRpbWUsIG1peCwgdGltZWxpbmVCbGVuZCwgdGltZWxpbmVzUm90YXRpb24sIGlpIDw8IDEsIGZpcnN0RnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmVfMSBpbnN0YW5jZW9mIGNvcmUuQXR0YWNobWVudFRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUF0dGFjaG1lbnRUaW1lbGluZSh0aW1lbGluZV8xLCBza2VsZXRvbiwgYW5pbWF0aW9uVGltZSwgYmxlbmQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy53ZWJraXQ2MDJCdWdmaXhIZWxwZXIobWl4LCBibGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVfMS5hcHBseShza2VsZXRvbiwgYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSwgZXZlbnRzLCBtaXgsIHRpbWVsaW5lQmxlbmQsIGNvcmUuTWl4RGlyZWN0aW9uLm1peEluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlRXZlbnRzKGN1cnJlbnQsIGFuaW1hdGlvblRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dEFuaW1hdGlvbkxhc3QgPSBhbmltYXRpb25UaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dFRyYWNrTGFzdCA9IGN1cnJlbnQudHJhY2tUaW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNldHVwU3RhdGUgPSB0aGlzLnVua2V5ZWRTdGF0ZSArIEFuaW1hdGlvblN0YXRlLlNFVFVQO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNrZWxldG9uLnNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuYXR0YWNobWVudFN0YXRlID09IHNldHVwU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnROYW1lID0gc2xvdC5kYXRhLmF0dGFjaG1lbnROYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmF0dGFjaG1lbnQgPSAoYXR0YWNobWVudE5hbWUgPT0gbnVsbCA/IG51bGwgOiBza2VsZXRvbi5nZXRBdHRhY2htZW50KHNsb3QuZGF0YS5pbmRleCwgYXR0YWNobWVudE5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVua2V5ZWRTdGF0ZSArPSAyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGxpZWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hcHBseU1peGluZ0Zyb20gPSBmdW5jdGlvbiAodG8sIHNrZWxldG9uLCBibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0by5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20ubWl4aW5nRnJvbSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlNaXhpbmdGcm9tKGZyb20sIHNrZWxldG9uLCBibGVuZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0by5taXhEdXJhdGlvbiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWl4ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5maXJzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmQgPSBjb3JlLk1peEJsZW5kLnNldHVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWl4ID0gdG8ubWl4VGltZSAvIHRvLm1peER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXggPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCAhPSBjb3JlLk1peEJsZW5kLmZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuZCA9IGZyb20ubWl4QmxlbmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gbWl4IDwgZnJvbS5ldmVudFRocmVzaG9sZCA/IHRoaXMuZXZlbnRzIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IG1peCA8IGZyb20uYXR0YWNobWVudFRocmVzaG9sZCwgZHJhd09yZGVyID0gbWl4IDwgZnJvbS5kcmF3T3JkZXJUaHJlc2hvbGQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uTGFzdCA9IGZyb20uYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSA9IGZyb20uZ2V0QW5pbWF0aW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lQ291bnQgPSBmcm9tLmFuaW1hdGlvbi50aW1lbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lcyA9IGZyb20uYW5pbWF0aW9uLnRpbWVsaW5lcztcclxuICAgICAgICAgICAgICAgIHZhciBhbHBoYUhvbGQgPSBmcm9tLmFscGhhICogdG8uaW50ZXJydXB0QWxwaGEsIGFscGhhTWl4ID0gYWxwaGFIb2xkICogKDEgLSBtaXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IGNvcmUuTWl4QmxlbmQuYWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lc1tpXS5hcHBseShza2VsZXRvbiwgYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSwgZXZlbnRzLCBhbHBoYU1peCwgYmxlbmQsIGNvcmUuTWl4RGlyZWN0aW9uLm1peE91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVNb2RlID0gZnJvbS50aW1lbGluZU1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lSG9sZE1peCA9IGZyb20udGltZWxpbmVIb2xkTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEZyYW1lID0gZnJvbS50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RGcmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5zZXRBcnJheVNpemUoZnJvbS50aW1lbGluZXNSb3RhdGlvbiwgdGltZWxpbmVDb3VudCA8PCAxLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzUm90YXRpb24gPSBmcm9tLnRpbWVsaW5lc1JvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb20udG90YWxBbHBoYSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gdGltZWxpbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gY29yZS5NaXhEaXJlY3Rpb24ubWl4T3V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVCbGVuZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aW1lbGluZU1vZGVbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RhdGUuU1VCU0VRVUVOVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYXdPcmRlciAmJiB0aW1lbGluZSBpbnN0YW5jZW9mIGNvcmUuRHJhd09yZGVyVGltZWxpbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lQmxlbmQgPSBibGVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFscGhhTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdGF0ZS5GSVJTVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZUJsZW5kID0gY29yZS5NaXhCbGVuZC5zZXR1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFscGhhTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdGF0ZS5IT0xEX1NVQlNFUVVFTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVCbGVuZCA9IGJsZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYWxwaGFIb2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdGF0ZS5IT0xEX0ZJUlNUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lQmxlbmQgPSBjb3JlLk1peEJsZW5kLnNldHVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYWxwaGFIb2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZUJsZW5kID0gY29yZS5NaXhCbGVuZC5zZXR1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9sZE1peCA9IHRpbWVsaW5lSG9sZE1peFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFscGhhSG9sZCAqIE1hdGgubWF4KDAsIDEgLSBob2xkTWl4Lm1peFRpbWUgLyBob2xkTWl4Lm1peER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLnRvdGFsQWxwaGEgKz0gYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZSBpbnN0YW5jZW9mIGNvcmUuUm90YXRlVGltZWxpbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Um90YXRlVGltZWxpbmUodGltZWxpbmUsIHNrZWxldG9uLCBhbmltYXRpb25UaW1lLCBhbHBoYSwgdGltZWxpbmVCbGVuZCwgdGltZWxpbmVzUm90YXRpb24sIGkgPDwgMSwgZmlyc3RGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5BdHRhY2htZW50VGltZWxpbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXR0YWNobWVudFRpbWVsaW5lKHRpbWVsaW5lLCBza2VsZXRvbiwgYW5pbWF0aW9uVGltZSwgdGltZWxpbmVCbGVuZCwgYXR0YWNobWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMud2Via2l0NjAyQnVnZml4SGVscGVyKGFscGhhLCBibGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhd09yZGVyICYmIHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5EcmF3T3JkZXJUaW1lbGluZSAmJiB0aW1lbGluZUJsZW5kID09IGNvcmUuTWl4QmxlbmQuc2V0dXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gY29yZS5NaXhEaXJlY3Rpb24ubWl4SW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5hcHBseShza2VsZXRvbiwgYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSwgZXZlbnRzLCBhbHBoYSwgdGltZWxpbmVCbGVuZCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0by5taXhEdXJhdGlvbiA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZUV2ZW50cyhmcm9tLCBhbmltYXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmcm9tLm5leHRBbmltYXRpb25MYXN0ID0gYW5pbWF0aW9uVGltZTtcclxuICAgICAgICAgICAgICAgIGZyb20ubmV4dFRyYWNrTGFzdCA9IGZyb20udHJhY2tUaW1lO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5QXR0YWNobWVudFRpbWVsaW5lID0gZnVuY3Rpb24gKHRpbWVsaW5lLCBza2VsZXRvbiwgdGltZSwgYmxlbmQsIGF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RpbWVsaW5lLnNsb3RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNsb3QuYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRpbWVsaW5lLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IGNvcmUuTWl4QmxlbmQuc2V0dXAgfHwgYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5maXJzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KHNrZWxldG9uLCBzbG90LCBzbG90LmRhdGEuYXR0YWNobWVudE5hbWUsIGF0dGFjaG1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSBmcmFtZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSBjb3JlLkFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KHNrZWxldG9uLCBzbG90LCB0aW1lbGluZS5hdHRhY2htZW50TmFtZXNbZnJhbWVJbmRleF0sIGF0dGFjaG1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzbG90LmF0dGFjaG1lbnRTdGF0ZSA8PSB0aGlzLnVua2V5ZWRTdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmF0dGFjaG1lbnRTdGF0ZSA9IHRoaXMudW5rZXllZFN0YXRlICsgQW5pbWF0aW9uU3RhdGUuU0VUVVA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBzbG90LCBhdHRhY2htZW50TmFtZSwgYXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHNsb3QuYXR0YWNobWVudCA9IGF0dGFjaG1lbnROYW1lID09IG51bGwgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudChzbG90LmRhdGEuaW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50cylcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmF0dGFjaG1lbnRTdGF0ZSA9IHRoaXMudW5rZXllZFN0YXRlICsgQW5pbWF0aW9uU3RhdGUuQ1VSUkVOVDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5Um90YXRlVGltZWxpbmUgPSBmdW5jdGlvbiAodGltZWxpbmUsIHNrZWxldG9uLCB0aW1lLCBhbHBoYSwgYmxlbmQsIHRpbWVsaW5lc1JvdGF0aW9uLCBpLCBmaXJzdEZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RGcmFtZSlcclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXNSb3RhdGlvbltpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5KHNrZWxldG9uLCAwLCB0aW1lLCBudWxsLCAxLCBibGVuZCwgY29yZS5NaXhEaXJlY3Rpb24ubWl4SW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVUaW1lbGluZSA9IHRpbWVsaW5lO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHJvdGF0ZVRpbWVsaW5lLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbcm90YXRlVGltZWxpbmUuYm9uZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIxID0gMCwgcjIgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5NaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUucm90YXRpb24gPSBib25lLmRhdGEucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5NaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIxID0gYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIyID0gYm9uZS5kYXRhLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHIxID0gYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5zZXR1cCA/IGJvbmUuZGF0YS5yb3RhdGlvbiA6IGJvbmUucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBjb3JlLlJvdGF0ZVRpbWVsaW5lLkVOVFJJRVNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByMiA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgY29yZS5Sb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gY29yZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgY29yZS5Sb3RhdGVUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZSb3RhdGlvbiA9IGZyYW1lc1tmcmFtZSArIGNvcmUuUm90YXRlVGltZWxpbmUuUFJFVl9ST1RBVElPTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHJvdGF0ZVRpbWVsaW5lLmdldEN1cnZlUGVyY2VudCgoZnJhbWUgPj4gMSkgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIGNvcmUuUm90YXRlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByMiA9IGZyYW1lc1tmcmFtZSArIGNvcmUuUm90YXRlVGltZWxpbmUuUk9UQVRJT05dIC0gcHJldlJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByMiAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIyIC8gMzYwKSB8IDApKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjIgPSBwcmV2Um90YXRpb24gKyByMiAqIHBlcmNlbnQgKyBib25lLmRhdGEucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gcjIgLyAzNjApIHwgMCkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IDAsIGRpZmYgPSByMiAtIHIxO1xyXG4gICAgICAgICAgICAgICAgZGlmZiAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIGRpZmYgLyAzNjApIHwgMCkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsID0gdGltZWxpbmVzUm90YXRpb25baV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFRvdGFsID0gMCwgbGFzdERpZmYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUb3RhbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REaWZmID0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUb3RhbCA9IHRpbWVsaW5lc1JvdGF0aW9uW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RGlmZiA9IHRpbWVsaW5lc1JvdGF0aW9uW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBkaWZmID4gMCwgZGlyID0gbGFzdFRvdGFsID49IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuTWF0aFV0aWxzLnNpZ251bShsYXN0RGlmZikgIT0gY29yZS5NYXRoVXRpbHMuc2lnbnVtKGRpZmYpICYmIE1hdGguYWJzKGxhc3REaWZmKSA8PSA5MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobGFzdFRvdGFsKSA+IDE4MClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUb3RhbCArPSAzNjAgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0obGFzdFRvdGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgPSBkaWZmICsgbGFzdFRvdGFsIC0gbGFzdFRvdGFsICUgMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgIT0gY3VycmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gMzYwICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGxhc3RUb3RhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzUm90YXRpb25baV0gPSB0b3RhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpbWVsaW5lc1JvdGF0aW9uW2kgKyAxXSA9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICByMSArPSB0b3RhbCAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiA9IHIxIC0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByMSAvIDM2MCkgfCAwKSkgKiAzNjA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5xdWV1ZUV2ZW50cyA9IGZ1bmN0aW9uIChlbnRyeSwgYW5pbWF0aW9uVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblN0YXJ0ID0gZW50cnkuYW5pbWF0aW9uU3RhcnQsIGFuaW1hdGlvbkVuZCA9IGVudHJ5LmFuaW1hdGlvbkVuZDtcclxuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbkVuZCAtIGFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrTGFzdFdyYXBwZWQgPSBlbnRyeS50cmFja0xhc3QgJSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMCwgbiA9IGV2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gZXZlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudF8xLnRpbWUgPCB0cmFja0xhc3RXcmFwcGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRfMS50aW1lID4gYW5pbWF0aW9uRW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmV2ZW50KGVudHJ5LCBldmVudF8xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxvb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSBkdXJhdGlvbiA9PSAwIHx8IHRyYWNrTGFzdFdyYXBwZWQgPiBlbnRyeS50cmFja1RpbWUgJSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGFuaW1hdGlvblRpbWUgPj0gYW5pbWF0aW9uRW5kICYmIGVudHJ5LmFuaW1hdGlvbkxhc3QgPCBhbmltYXRpb25FbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5jb21wbGV0ZShlbnRyeSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8yID0gZXZlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudF8yLnRpbWUgPCBhbmltYXRpb25TdGFydClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5ldmVudChlbnRyeSwgZXZlbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZERyYWluRGlzYWJsZWQgPSB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRyYWNrKGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZCA9IG9sZERyYWluRGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5jbGVhclRyYWNrID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFja0luZGV4ID49IHRoaXMudHJhY2tzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMudHJhY2tzW3RyYWNrSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVuZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZU5leHQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IGVudHJ5Lm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbmQoZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkubWl4aW5nRnJvbSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkubWl4aW5nVG8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gZnJvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzW2N1cnJlbnQudHJhY2tJbmRleF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuc2V0Q3VycmVudCA9IGZ1bmN0aW9uIChpbmRleCwgY3VycmVudCwgaW50ZXJydXB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZXhwYW5kVG9JbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrc1tpbmRleF0gPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnJ1cHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuaW50ZXJydXB0KGZyb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWl4aW5nRnJvbSA9IGZyb207XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbS5taXhpbmdUbyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5taXhUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbS5taXhpbmdGcm9tICE9IG51bGwgJiYgZnJvbS5taXhEdXJhdGlvbiA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuaW50ZXJydXB0QWxwaGEgKj0gTWF0aC5taW4oMSwgZnJvbS5taXhUaW1lIC8gZnJvbS5taXhEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbS50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zdGFydChjdXJyZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRBbmltYXRpb25XaXRoKHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRBbmltYXRpb25XaXRoID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFuaW1hdGlvbiBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJydXB0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5leHBhbmRUb0luZGV4KHRyYWNrSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHRUcmFja0xhc3QgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tJbmRleF0gPSBjdXJyZW50Lm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuaW50ZXJydXB0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVuZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTmV4dChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJydXB0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTmV4dChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJhY2tFbnRyeSh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50KHRyYWNrSW5kZXgsIGVudHJ5LCBpbnRlcnJ1cHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbk5hbWUsIGxvb3AsIGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbmltYXRpb25XaXRoKHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYWRkQW5pbWF0aW9uV2l0aCA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYW5pbWF0aW9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5leHBhbmRUb0luZGV4KHRyYWNrSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsYXN0Lm5leHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJhY2tFbnRyeSh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGxhc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudCh0cmFja0luZGV4LCBlbnRyeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5uZXh0ID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGF5IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gbGFzdC5hbmltYXRpb25FbmQgLSBsYXN0LmFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QubG9vcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSArPSBkdXJhdGlvbiAqICgxICsgKChsYXN0LnRyYWNrVGltZSAvIGR1cmF0aW9uKSB8IDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSArPSBNYXRoLm1heChkdXJhdGlvbiwgbGFzdC50cmFja1RpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXkgLT0gdGhpcy5kYXRhLmdldE1peChsYXN0LmFuaW1hdGlvbiwgYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSA9IGxhc3QudHJhY2tUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVudHJ5LmRlbGF5ID0gZGVsYXk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRFbXB0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBtaXhEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zZXRBbmltYXRpb25XaXRoKHRyYWNrSW5kZXgsIEFuaW1hdGlvblN0YXRlLmVtcHR5QW5pbWF0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5taXhEdXJhdGlvbiA9IG1peER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudHJhY2tFbmQgPSBtaXhEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFkZEVtcHR5QW5pbWF0aW9uID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIG1peER1cmF0aW9uLCBkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5IDw9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgLT0gbWl4RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmFkZEFuaW1hdGlvbldpdGgodHJhY2tJbmRleCwgQW5pbWF0aW9uU3RhdGUuZW1wdHlBbmltYXRpb24sIGZhbHNlLCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5taXhEdXJhdGlvbiA9IG1peER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudHJhY2tFbmQgPSBtaXhEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEVtcHR5QW5pbWF0aW9ucyA9IGZ1bmN0aW9uIChtaXhEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZERyYWluRGlzYWJsZWQgPSB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMudHJhY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW1wdHlBbmltYXRpb24oY3VycmVudC50cmFja0luZGV4LCBtaXhEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluRGlzYWJsZWQgPSBvbGREcmFpbkRpc2FibGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuZXhwYW5kVG9JbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy50cmFja3MubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmVuc3VyZUFycmF5Q2FwYWNpdHkodGhpcy50cmFja3MsIGluZGV4ICsgMSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnRyYWNrRW50cnkgPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wLCBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyYWNrRW50cnlQb29sLm9idGFpbigpO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudHJhY2tJbmRleCA9IHRyYWNrSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5sb29wID0gbG9vcDtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmhvbGRQcmV2aW91cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuZXZlbnRUaHJlc2hvbGQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuYXR0YWNobWVudFRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5kcmF3T3JkZXJUaHJlc2hvbGQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuYW5pbWF0aW9uU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuYW5pbWF0aW9uRW5kID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuYW5pbWF0aW9uTGFzdCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZW50cnkubmV4dEFuaW1hdGlvbkxhc3QgPSAtMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmRlbGF5ID0gMDtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRyYWNrVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50cmFja0xhc3QgPSAtMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm5leHRUcmFja0xhc3QgPSAtMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRyYWNrRW5kID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRpbWVTY2FsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hbHBoYSA9IDE7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5pbnRlcnJ1cHRBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5taXhUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm1peER1cmF0aW9uID0gbGFzdCA9PSBudWxsID8gMCA6IHRoaXMuZGF0YS5nZXRNaXgobGFzdC5hbmltYXRpb24sIGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5taXhCbGVuZCA9IGNvcmUuTWl4QmxlbmQucmVwbGFjZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmRpc3Bvc2VOZXh0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kaXNwb3NlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLl9hbmltYXRpb25zQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlJRHMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy50cmFja3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cmFja3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbnRyeS5taXhpbmdGcm9tICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5taXhpbmdGcm9tID09IG51bGwgfHwgZW50cnkubWl4QmxlbmQgIT0gY29yZS5NaXhCbGVuZC5hZGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVIb2xkKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBlbnRyeS5taXhpbmdUbztcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChlbnRyeSAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNvbXB1dGVIb2xkID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBlbnRyeS5taXhpbmdUbztcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZXMgPSBlbnRyeS5hbmltYXRpb24udGltZWxpbmVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lc0NvdW50ID0gZW50cnkuYW5pbWF0aW9uLnRpbWVsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVNb2RlID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoZW50cnkudGltZWxpbmVNb2RlLCB0aW1lbGluZXNDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50aW1lbGluZUhvbGRNaXgubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZURpcE1peCA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKGVudHJ5LnRpbWVsaW5lSG9sZE1peCwgdGltZWxpbmVzQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SURzID0gdGhpcy5wcm9wZXJ0eUlEcztcclxuICAgICAgICAgICAgICAgIGlmICh0byAhPSBudWxsICYmIHRvLmhvbGRQcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU1vZGVbaV0gPSBwcm9wZXJ0eUlEcy5hZGQodGltZWxpbmVzW2ldLmdldFByb3BlcnR5SWQoKSkgPyBBbmltYXRpb25TdGF0ZS5IT0xEX0ZJUlNUIDogQW5pbWF0aW9uU3RhdGUuSE9MRF9TVUJTRVFVRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRlcjogZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gdGltZWxpbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRpbWVsaW5lLmdldFByb3BlcnR5SWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5SURzLmFkZChpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lTW9kZVtpXSA9IEFuaW1hdGlvblN0YXRlLlNVQlNFUVVFTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT0gbnVsbCB8fCB0aW1lbGluZSBpbnN0YW5jZW9mIGNvcmUuQXR0YWNobWVudFRpbWVsaW5lIHx8IHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5EcmF3T3JkZXJUaW1lbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB0aW1lbGluZSBpbnN0YW5jZW9mIGNvcmUuRXZlbnRUaW1lbGluZSB8fCAhdG8uYW5pbWF0aW9uLmhhc1RpbWVsaW5lKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU1vZGVbaV0gPSBBbmltYXRpb25TdGF0ZS5GSVJTVDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHQgPSB0by5taXhpbmdUbzsgbmV4dCAhPSBudWxsOyBuZXh0ID0gbmV4dC5taXhpbmdUbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuYW5pbWF0aW9uLmhhc1RpbWVsaW5lKGlkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5taXhEdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU1vZGVbaV0gPSBBbmltYXRpb25TdGF0ZS5IT0xEX01JWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZURpcE1peFtpXSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU1vZGVbaV0gPSBBbmltYXRpb25TdGF0ZS5IT0xEX0ZJUlNUO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbiAodHJhY2tJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrSW5kZXggPj0gdGhpcy50cmFja3MubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzW3RyYWNrSW5kZXhdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxpc3RlbmVyIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyTGlzdGVuZXJOb3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uQnlOYW1lID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbk5hbWUsIGxvb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmICghQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmcxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmcxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBBbmltYXRpb25TdGF0ZS5zZXRBbmltYXRpb25CeU5hbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzZXRBbmltYXRpb24gZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb24odHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRBbmltYXRpb25CeU5hbWUgPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmcyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmcyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBBbmltYXRpb25TdGF0ZS5hZGRBbmltYXRpb25CeU5hbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZGRBbmltYXRpb24gZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRpb24odHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuaGFzQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmRhdGEuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uICE9PSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuaGFzQW5pbWF0aW9uQnlOYW1lID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmczKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmczID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBBbmltYXRpb25TdGF0ZS5oYXNBbmltYXRpb25CeU5hbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBoYXNBbmltYXRpb24gZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5lbXB0eUFuaW1hdGlvbiA9IG5ldyBjb3JlLkFuaW1hdGlvbihcIjxlbXB0eT5cIiwgW10sIDApO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5TVUJTRVFVRU5UID0gMDtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuRklSU1QgPSAxO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5IT0xEX1NVQlNFUVVFTlQgPSAyO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5IT0xEX0ZJUlNUID0gMztcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuSE9MRF9NSVggPSA0O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5TRVRVUCA9IDE7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLkNVUlJFTlQgPSAyO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmcyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLmRlcHJlY2F0ZWRXYXJuaW5nMyA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGU7XHJcbiAgICAgICAgdmFyIFRyYWNrRW50cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFja0VudHJ5KCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXhCbGVuZCA9IGNvcmUuTWl4QmxlbmQucmVwbGFjZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVNb2RlID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lSG9sZE1peCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZXNSb3RhdGlvbiA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRyYWNrRW50cnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWl4aW5nRnJvbSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1peGluZ1RvID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZU1vZGUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVIb2xkTWl4Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYWNrRW50cnkucHJvdG90eXBlLmdldEFuaW1hdGlvblRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5hbmltYXRpb25FbmQgLSB0aGlzLmFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25TdGFydDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudHJhY2tUaW1lICUgZHVyYXRpb24pICsgdGhpcy5hbmltYXRpb25TdGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnRyYWNrVGltZSArIHRoaXMuYW5pbWF0aW9uU3RhcnQsIHRoaXMuYW5pbWF0aW9uRW5kKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uTGFzdCA9IGZ1bmN0aW9uIChhbmltYXRpb25MYXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxhc3QgPSBhbmltYXRpb25MYXN0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0QW5pbWF0aW9uTGFzdCA9IGFuaW1hdGlvbkxhc3Q7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYWNrRW50cnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFja1RpbWUgPj0gdGhpcy5hbmltYXRpb25FbmQgLSB0aGlzLmFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFja0VudHJ5LnByb3RvdHlwZS5yZXNldFJvdGF0aW9uRGlyZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVzUm90YXRpb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNrRW50cnkucHJvdG90eXBlLCBcInRpbWVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IFRyYWNrRW50cnkudGltZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRyYWNrVGltZSBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrVGltZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBUcmFja0VudHJ5LnRpbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0cmFja1RpbWUgZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrVGltZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tFbnRyeS5wcm90b3R5cGUsIFwiZW5kVGltZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3BpbmUgRGVwcmVjYXRpb24gV2FybmluZzogVHJhY2tFbnRyeS5lbmRUaW1lIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdHJhY2tFbmQgZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFja1RpbWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3BpbmUgRGVwcmVjYXRpb24gV2FybmluZzogVHJhY2tFbnRyeS5lbmRUaW1lIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdHJhY2tFbmQgZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrVGltZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBUcmFja0VudHJ5LnByb3RvdHlwZS5sb29wc0NvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy50cmFja1RpbWUgLyB0aGlzLnRyYWNrRW5kKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzIgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrRW50cnk7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlRyYWNrRW50cnkgPSBUcmFja0VudHJ5O1xyXG4gICAgICAgIHZhciBFdmVudFF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZShhbmltU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbkRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1TdGF0ZSA9IGFuaW1TdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goRXZlbnRUeXBlLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLmFuaW1hdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuaW50ZXJydXB0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLmFuaW1hdGlvbnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goRXZlbnRUeXBlLmRpc3Bvc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goRXZlbnRUeXBlLmNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbiAoZW50cnksIGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5kZXByZWNhdGVTdHVmZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghRXZlbnRRdWV1ZS5kZXByZWNhdGVkV2FybmluZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBFdmVudFF1ZXVlLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3BpbmUgRGVwcmVjYXRpb24gV2FybmluZzogb25Db21wbGV0ZSwgb25TdGFydCwgb25FbmQsIG9uRXZlbnQgYXJ0IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbGlzdGVuZXJzIGZyb20gbm93IG9uLiAnc3RhdGUuYWRkTGlzdGVuZXIoeyBjb21wbGV0ZTogZnVuY3Rpb24odHJhY2ssIGV2ZW50KSB7IH0gfSknXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEV2ZW50UXVldWUucHJvdG90eXBlLmRyYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhaW5EaXNhYmxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5hbmltU3RhdGUubGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBvYmplY3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG9iamVjdHNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5zdGFydDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5saXN0ZW5lciAhPSBudWxsICYmIGVudHJ5Lmxpc3RlbmVyLnN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmxpc3RlbmVyLnN0YXJ0KGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaWldLnN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWldLnN0YXJ0KGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lm9uU3RhcnQgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIGVudHJ5Lm9uU3RhcnQoZW50cnkudHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1TdGF0ZS5vblN0YXJ0ICYmIHRoaXMuZGVwcmVjYXRlU3R1ZmYoKSAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmICYmIHRoaXMuYW5pbVN0YXRlLm9uU3RhcnQoZW50cnkudHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuaW50ZXJydXB0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuaW50ZXJydXB0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmxpc3RlbmVyLmludGVycnVwdChlbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2lpXS5pbnRlcnJ1cHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpaV0uaW50ZXJydXB0KGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5lbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5lbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGlzdGVuZXIuZW5kKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaWldLmVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lpXS5lbmQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkub25FbmQgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIGVudHJ5Lm9uRW5kKGVudHJ5LnRyYWNrSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGUub25FbmQgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIHRoaXMuYW5pbVN0YXRlLm9uRW5kKGVudHJ5LnRyYWNrSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5kaXNwb3NlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuZGlzcG9zZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5saXN0ZW5lci5kaXNwb3NlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaWldLmRpc3Bvc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpaV0uZGlzcG9zZShlbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1TdGF0ZS50cmFja0VudHJ5UG9vbC5mcmVlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5jb21wbGV0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5saXN0ZW5lciAhPSBudWxsICYmIGVudHJ5Lmxpc3RlbmVyLmNvbXBsZXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmxpc3RlbmVyLmNvbXBsZXRlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaWldLmNvbXBsZXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWldLmNvbXBsZXRlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGNvcmUuTWF0aFV0aWxzLnRvSW50KGVudHJ5Lmxvb3BzQ291bnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbkNvbXBsZXRlICYmIHRoaXMuZGVwcmVjYXRlU3R1ZmYoKSAmJiBlbnRyeS5vbkNvbXBsZXRlKGVudHJ5LnRyYWNrSW5kZXgsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLm9uQ29tcGxldGUgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIHRoaXMuYW5pbVN0YXRlLm9uQ29tcGxldGUoZW50cnkudHJhY2tJbmRleCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLmV2ZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzMgPSBvYmplY3RzW2krKyArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuZXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGlzdGVuZXIuZXZlbnQoZW50cnksIGV2ZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpaV0uZXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpaV0uZXZlbnQoZW50cnksIGV2ZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkub25FdmVudCAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgZW50cnkub25FdmVudChlbnRyeS50cmFja0luZGV4LCBldmVudF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLm9uRXZlbnQgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIHRoaXMuYW5pbVN0YXRlLm9uRXZlbnQoZW50cnkudHJhY2tJbmRleCwgZXZlbnRfMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5kZXByZWNhdGVkV2FybmluZzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50UXVldWU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkV2ZW50UXVldWUgPSBFdmVudFF1ZXVlO1xyXG4gICAgICAgIHZhciBFdmVudFR5cGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcInN0YXJ0XCJdID0gMF0gPSBcInN0YXJ0XCI7XHJcbiAgICAgICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJpbnRlcnJ1cHRcIl0gPSAxXSA9IFwiaW50ZXJydXB0XCI7XHJcbiAgICAgICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJlbmRcIl0gPSAyXSA9IFwiZW5kXCI7XHJcbiAgICAgICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJkaXNwb3NlXCJdID0gM10gPSBcImRpc3Bvc2VcIjtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImNvbXBsZXRlXCJdID0gNF0gPSBcImNvbXBsZXRlXCI7XHJcbiAgICAgICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJldmVudFwiXSA9IDVdID0gXCJldmVudFwiO1xyXG4gICAgICAgIH0pKEV2ZW50VHlwZSA9IGNvcmUuRXZlbnRUeXBlIHx8IChjb3JlLkV2ZW50VHlwZSA9IHt9KSk7XHJcbiAgICAgICAgdmFyIEFuaW1hdGlvblN0YXRlQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlQWRhcHRlcigpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZUFkYXB0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbiAoZW50cnksIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZUFkYXB0ZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkFuaW1hdGlvblN0YXRlQWRhcHRlciA9IEFuaW1hdGlvblN0YXRlQWRhcHRlcjtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBBbmltYXRpb25TdGF0ZURhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZURhdGEoc2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRvTWl4VGltZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbkRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbkRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2VsZXRvbkRhdGEgPSBza2VsZXRvbkRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZS5zZXRNaXggPSBmdW5jdGlvbiAoZnJvbU5hbWUsIHRvTmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihmcm9tTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgZnJvbU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvID0gdGhpcy5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbih0b05hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyB0b05hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNaXhXaXRoKGZyb20sIHRvLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlRGF0YS5wcm90b3R5cGUuc2V0TWl4QnlOYW1lID0gZnVuY3Rpb24gKGZyb21OYW1lLCB0b05hbWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFuaW1hdGlvblN0YXRlRGF0YS5kZXByZWNhdGVkV2FybmluZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25TdGF0ZURhdGEuZGVwcmVjYXRlZFdhcm5pbmcxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXByZWNhdGlvbiBXYXJuaW5nOiBBbmltYXRpb25TdGF0ZURhdGEuc2V0TWl4QnlOYW1lIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugc2V0TWl4IGZyb20gbm93IG9uLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWl4KGZyb21OYW1lLCB0b05hbWUsIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZS5zZXRNaXhXaXRoID0gZnVuY3Rpb24gKGZyb20sIHRvLCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmcm9tIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBmcm9tLm5hbWUgKyBcIi5cIiArIHRvLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRvTWl4VGltZVtrZXldID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlRGF0YS5wcm90b3R5cGUuZ2V0TWl4ID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZnJvbS5uYW1lICsgXCIuXCIgKyB0by5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hbmltYXRpb25Ub01peFRpbWVba2V5XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0TWl4IDogdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlRGF0YS5kZXByZWNhdGVkV2FybmluZzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlRGF0YTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQW5pbWF0aW9uU3RhdGVEYXRhID0gQW5pbWF0aW9uU3RhdGVEYXRhO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEF0bGFzQXR0YWNobWVudExvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEF0bGFzQXR0YWNobWVudExvYWRlcihhdGxhcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdGxhcyA9IGF0bGFzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUubmV3UmVnaW9uQXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbiBub3QgZm91bmQgaW4gYXRsYXM6IFwiICsgcGF0aCArIFwiIChyZWdpb24gYXR0YWNobWVudDogXCIgKyBuYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBuZXcgY29yZS5SZWdpb25BdHRhY2htZW50KG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0YWNobWVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdNZXNoQXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbiBub3QgZm91bmQgaW4gYXRsYXM6IFwiICsgcGF0aCArIFwiIChtZXNoIGF0dGFjaG1lbnQ6IFwiICsgbmFtZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IGNvcmUuTWVzaEF0dGFjaG1lbnQobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld0JvdW5kaW5nQm94QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuQm91bmRpbmdCb3hBdHRhY2htZW50KG5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld1BhdGhBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5QYXRoQXR0YWNobWVudChuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdQb2ludEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2tpbiwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLlBvaW50QXR0YWNobWVudChuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdDbGlwcGluZ0F0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2tpbiwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkNsaXBwaW5nQXR0YWNobWVudChuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEF0bGFzQXR0YWNobWVudExvYWRlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQXRsYXNBdHRhY2htZW50TG9hZGVyID0gQXRsYXNBdHRhY2htZW50TG9hZGVyO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEJsZW5kTW9kZTtcclxuICAgICAgICAoZnVuY3Rpb24gKEJsZW5kTW9kZSkge1xyXG4gICAgICAgICAgICBCbGVuZE1vZGVbQmxlbmRNb2RlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xyXG4gICAgICAgICAgICBCbGVuZE1vZGVbQmxlbmRNb2RlW1wiQWRkaXRpdmVcIl0gPSAxXSA9IFwiQWRkaXRpdmVcIjtcclxuICAgICAgICAgICAgQmxlbmRNb2RlW0JsZW5kTW9kZVtcIk11bHRpcGx5XCJdID0gMl0gPSBcIk11bHRpcGx5XCI7XHJcbiAgICAgICAgICAgIEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJTY3JlZW5cIl0gPSAzXSA9IFwiU2NyZWVuXCI7XHJcbiAgICAgICAgfSkoQmxlbmRNb2RlID0gY29yZS5CbGVuZE1vZGUgfHwgKGNvcmUuQmxlbmRNb2RlID0ge30pKTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBCb25lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQm9uZShkYXRhLCBza2VsZXRvbiwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBQSVhJLk1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5heSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzaGVhclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWVkVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm9uZS5wcm90b3R5cGUsIFwid29ybGRYXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC50eDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvbmUucHJvdG90eXBlLCBcIndvcmxkWVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXgudHk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCh0aGlzLngsIHRoaXMueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZVgsIHRoaXMuc2NhbGVZLCB0aGlzLnNoZWFyWCwgdGhpcy5zaGVhclkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS51cGRhdGVXb3JsZFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHRoaXMueCwgdGhpcy55LCB0aGlzLnJvdGF0aW9uLCB0aGlzLnNjYWxlWCwgdGhpcy5zY2FsZVksIHRoaXMuc2hlYXJYLCB0aGlzLnNoZWFyWSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCA9IGZ1bmN0aW9uICh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVksIHNoZWFyWCwgc2hlYXJZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF4ID0geDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXkgPSB5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNjYWxlWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNjYWxlWSA9IHNjYWxlWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWCA9IHNoZWFyWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWSA9IHNoZWFyWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGllZFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSB0aGlzLnNrZWxldG9uLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHZhciBzeSA9IEJvbmUueURvd24gPyAtdGhpcy5za2VsZXRvbi5zY2FsZVkgOiB0aGlzLnNrZWxldG9uLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uWSA9IHJvdGF0aW9uICsgOTAgKyBzaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uICsgc2hlYXJYKSAqIHNjYWxlWCAqIHN4O1xyXG4gICAgICAgICAgICAgICAgICAgIG0uYyA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvblkpICogc2NhbGVZICogc3g7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5iID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHJvdGF0aW9uICsgc2hlYXJYKSAqIHNjYWxlWCAqIHN5O1xyXG4gICAgICAgICAgICAgICAgICAgIG0uZCA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvblkpICogc2NhbGVZICogc3k7XHJcbiAgICAgICAgICAgICAgICAgICAgbS50eCA9IHggKiBzeCArIHNrZWxldG9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgbS50eSA9IHkgKiBzeSArIHNrZWxldG9uLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhID0gcGFyZW50Lm1hdHJpeC5hLCBwYiA9IHBhcmVudC5tYXRyaXguYywgcGMgPSBwYXJlbnQubWF0cml4LmIsIHBkID0gcGFyZW50Lm1hdHJpeC5kO1xyXG4gICAgICAgICAgICAgICAgbS50eCA9IHBhICogeCArIHBiICogeSArIHBhcmVudC5tYXRyaXgudHg7XHJcbiAgICAgICAgICAgICAgICBtLnR5ID0gcGMgKiB4ICsgcGQgKiB5ICsgcGFyZW50Lm1hdHJpeC50eTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhLnRyYW5zZm9ybU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob3JtYWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uWSA9IHJvdGF0aW9uICsgOTAgKyBzaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYSA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYiA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvblkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGMgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGQgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hID0gcGEgKiBsYSArIHBiICogbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYyA9IHBhICogbGIgKyBwYiAqIGxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmIgPSBwYyAqIGxhICsgcGQgKiBsYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kID0gcGMgKiBsYiArIHBkICogbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuT25seVRyYW5zbGF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGlvblkgPSByb3RhdGlvbiArIDkwICsgc2hlYXJZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmEgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmMgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5iID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHJvdGF0aW9uICsgc2hlYXJYKSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHJvdGF0aW9uWSkgKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1JvdGF0aW9uT3JSZWZsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGEgKiBwYSArIHBjICogcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IDAuMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguYWJzKHBhICogcGQgLSBwYiAqIHBjKSAvIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYSAvPSB0aGlzLnNrZWxldG9uLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjIC89IHRoaXMuc2tlbGV0b24uc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGIgPSBwYyAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZCA9IHBhICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByeCA9IE1hdGguYXRhbjIocGMsIHBhKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByeCA9IDkwIC0gTWF0aC5hdGFuMihwZCwgcGIpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IHJvdGF0aW9uICsgc2hlYXJYIC0gcHJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSByb3RhdGlvbiArIHNoZWFyWSAtIHByeCArIDkwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGEgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocngpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGIgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocnkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGMgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocngpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGQgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocnkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmEgPSBwYSAqIGxhIC0gcGIgKiBsYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5jID0gcGEgKiBsYiAtIHBiICogbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYiA9IHBjICogbGEgKyBwZCAqIGxjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmQgPSBwYyAqIGxiICsgcGQgKiBsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29zID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbiA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6YSA9IChwYSAqIGNvcyArIHBiICogc2luKSAvIHN4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgemMgPSAocGMgKiBjb3MgKyBwZCAqIHNpbikgLyBzeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoemEgKiB6YSArIHpjICogemMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gMSAvIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHphICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpjICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQoemEgKiB6YSArIHpjICogemMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnRyYW5zZm9ybU1vZGUgPT0gY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChwYSAqIHBkIC0gcGIgKiBwYyA8IDApICE9IChCb25lLnlEb3duID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5za2VsZXRvbi5zY2FsZVggPCAwICE9IHRoaXMuc2tlbGV0b24uc2NhbGVZID4gMCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnNrZWxldG9uLnNjYWxlWCA8IDAgIT0gdGhpcy5za2VsZXRvbi5zY2FsZVkgPCAwKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gLXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5QSSAvIDIgKyBNYXRoLmF0YW4yKHpjLCB6YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6YiA9IE1hdGguY29zKHIpICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHpkID0gTWF0aC5zaW4ocikgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGEgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcoc2hlYXJYKSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxiID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKDkwICsgc2hlYXJZKSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxjID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHNoZWFyWCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZCA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyg5MCArIHNoZWFyWSkgKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYSA9IHphICogbGEgKyB6YiAqIGxjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmMgPSB6YSAqIGxiICsgemIgKiBsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5iID0gemMgKiBsYSArIHpkICogbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZCA9IHpjICogbGIgKyB6ZCAqIGxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtLmEgKj0gc3g7XHJcbiAgICAgICAgICAgICAgICBtLmMgKj0gc3g7XHJcbiAgICAgICAgICAgICAgICBtLmIgKj0gc3k7XHJcbiAgICAgICAgICAgICAgICBtLmQgKj0gc3k7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnNldFRvU2V0dXBQb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBkYXRhLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBkYXRhLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gZGF0YS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IGRhdGEuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclggPSBkYXRhLnNoZWFyWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJZID0gZGF0YS5zaGVhclk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb25YID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5tYXRyaXguYiwgdGhpcy5tYXRyaXguYSkgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb25ZID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5tYXRyaXguZCwgdGhpcy5tYXRyaXguYykgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmdldFdvcmxkU2NhbGVYID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQobS5hICogbS5hICsgbS5jICogbS5jKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuZ2V0V29ybGRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChtLmIgKiBtLmIgKyBtLmQgKiBtLmQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS51cGRhdGVBcHBsaWVkVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWVkVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXggPSBtLnR4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXkgPSBtLnR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJvdGF0aW9uID0gTWF0aC5hdGFuMihtLmIsIG0uYSkgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVYID0gTWF0aC5zcXJ0KG0uYSAqIG0uYSArIG0uYiAqIG0uYik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVZID0gTWF0aC5zcXJ0KG0uYyAqIG0uYyArIG0uZCAqIG0uZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJYID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzaGVhclkgPSBNYXRoLmF0YW4yKG0uYSAqIG0uYyArIG0uYiAqIG0uZCwgbS5hICogbS5kIC0gbS5iICogbS5jKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcG0gPSBwYXJlbnQubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpZCA9IDEgLyAocG0uYSAqIHBtLmQgLSBwbS5iICogcG0uYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBtLnR4IC0gcG0udHgsIGR5ID0gbS50eSAtIHBtLnR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5heCA9IChkeCAqIHBtLmQgKiBwaWQgLSBkeSAqIHBtLmMgKiBwaWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5heSA9IChkeSAqIHBtLmEgKiBwaWQgLSBkeCAqIHBtLmIgKiBwaWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlhID0gcGlkICogcG0uZDtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IHBpZCAqIHBtLmE7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWIgPSBwaWQgKiBwbS5jO1xyXG4gICAgICAgICAgICAgICAgdmFyIGljID0gcGlkICogcG0uYjtcclxuICAgICAgICAgICAgICAgIHZhciByYSA9IGlhICogbS5hIC0gaWIgKiBtLmI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmIgPSBpYSAqIG0uYyAtIGliICogbS5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJjID0gaWQgKiBtLmIgLSBpYyAqIG0uYTtcclxuICAgICAgICAgICAgICAgIHZhciByZCA9IGlkICogbS5kIC0gaWMgKiBtLmM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzaGVhclggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVYID0gTWF0aC5zcXJ0KHJhICogcmEgKyByYyAqIHJjKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzY2FsZVggPiAwLjAwMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0ID0gcmEgKiByZCAtIHJiICogcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVZID0gZGV0IC8gdGhpcy5hc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWSA9IE1hdGguYXRhbjIocmEgKiByYiArIHJjICogcmQsIGRldCkgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcm90YXRpb24gPSBNYXRoLmF0YW4yKHJjLCByYSkgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNjYWxlWSA9IE1hdGguc3FydChyYiAqIHJiICsgcmQgKiByZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyb3RhdGlvbiA9IDkwIC0gTWF0aC5hdGFuMihyZCwgcmIpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS53b3JsZFRvTG9jYWwgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG0uYSwgYiA9IG0uYywgYyA9IG0uYiwgZCA9IG0uZDtcclxuICAgICAgICAgICAgICAgIHZhciBpbnZEZXQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSB3b3JsZC54IC0gbS50eCwgeSA9IHdvcmxkLnkgLSBtLnR5O1xyXG4gICAgICAgICAgICAgICAgd29ybGQueCA9ICh4ICogZCAqIGludkRldCAtIHkgKiBiICogaW52RGV0KTtcclxuICAgICAgICAgICAgICAgIHdvcmxkLnkgPSAoeSAqIGEgKiBpbnZEZXQgLSB4ICogYyAqIGludkRldCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ybGQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmxvY2FsVG9Xb3JsZCA9IGZ1bmN0aW9uIChsb2NhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gbG9jYWwueCwgeSA9IGxvY2FsLnk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbC54ID0geCAqIG0uYSArIHkgKiBtLmMgKyBtLnR4O1xyXG4gICAgICAgICAgICAgICAgbG9jYWwueSA9IHggKiBtLmIgKyB5ICogbS5kICsgbS50eTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUud29ybGRUb0xvY2FsUm90YXRpb24gPSBmdW5jdGlvbiAod29ybGRSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyh3b3JsZFJvdGF0aW9uKSwgY29zID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHdvcmxkUm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIobWF0LmEgKiBzaW4gLSBtYXQuYiAqIGNvcywgbWF0LmQgKiBjb3MgLSBtYXQuYyAqIHNpbikgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLmxvY2FsVG9Xb3JsZFJvdGF0aW9uID0gZnVuY3Rpb24gKGxvY2FsUm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcobG9jYWxSb3RhdGlvbiksIGNvcyA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhsb2NhbFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXQgPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKGNvcyAqIG1hdC5iICsgc2luICogbWF0LmQsIGNvcyAqIG1hdC5hICsgc2luICogbWF0LmMpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS5yb3RhdGVXb3JsZCA9IGZ1bmN0aW9uIChkZWdyZWVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdC5hLCBiID0gbWF0LmMsIGMgPSBtYXQuYiwgZCA9IG1hdC5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcyA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhkZWdyZWVzKSwgc2luID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKGRlZ3JlZXMpO1xyXG4gICAgICAgICAgICAgICAgbWF0LmEgPSBjb3MgKiBhIC0gc2luICogYztcclxuICAgICAgICAgICAgICAgIG1hdC5jID0gY29zICogYiAtIHNpbiAqIGQ7XHJcbiAgICAgICAgICAgICAgICBtYXQuYiA9IHNpbiAqIGEgKyBjb3MgKiBjO1xyXG4gICAgICAgICAgICAgICAgbWF0LmQgPSBzaW4gKiBiICsgY29zICogZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGllZFZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUueURvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIEJvbmU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkJvbmUgPSBCb25lO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEJvbmVEYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQm9uZURhdGEoaW5kZXgsIG5hbWUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtTW9kZSA9IFRyYW5zZm9ybU1vZGUuTm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2luUmVxdWlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBtdXN0IGJlID49IDAuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQm9uZURhdGE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkJvbmVEYXRhID0gQm9uZURhdGE7XHJcbiAgICAgICAgdmFyIFRyYW5zZm9ybU1vZGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChUcmFuc2Zvcm1Nb2RlKSB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcclxuICAgICAgICAgICAgVHJhbnNmb3JtTW9kZVtUcmFuc2Zvcm1Nb2RlW1wiT25seVRyYW5zbGF0aW9uXCJdID0gMV0gPSBcIk9ubHlUcmFuc2xhdGlvblwiO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Nb2RlW1RyYW5zZm9ybU1vZGVbXCJOb1JvdGF0aW9uT3JSZWZsZWN0aW9uXCJdID0gMl0gPSBcIk5vUm90YXRpb25PclJlZmxlY3Rpb25cIjtcclxuICAgICAgICAgICAgVHJhbnNmb3JtTW9kZVtUcmFuc2Zvcm1Nb2RlW1wiTm9TY2FsZVwiXSA9IDNdID0gXCJOb1NjYWxlXCI7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vU2NhbGVPclJlZmxlY3Rpb25cIl0gPSA0XSA9IFwiTm9TY2FsZU9yUmVmbGVjdGlvblwiO1xyXG4gICAgICAgIH0pKFRyYW5zZm9ybU1vZGUgPSBjb3JlLlRyYW5zZm9ybU1vZGUgfHwgKGNvcmUuVHJhbnNmb3JtTW9kZSA9IHt9KSk7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQ29uc3RyYWludERhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb25zdHJhaW50RGF0YShuYW1lLCBvcmRlciwgc2tpblJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2luUmVxdWlyZWQgPSBza2luUmVxdWlyZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cmFpbnREYXRhO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Db25zdHJhaW50RGF0YSA9IENvbnN0cmFpbnREYXRhO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRXZlbnQodGltZSwgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuRXZlbnQgPSBFdmVudDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBFdmVudERhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudERhdGEobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnREYXRhO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5FdmVudERhdGEgPSBFdmVudERhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgSWtDb25zdHJhaW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSWtDb25zdHJhaW50KGRhdGEsIHNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJlbmREaXJlY3Rpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJldGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1peCA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvZnRuZXNzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWl4ID0gZGF0YS5taXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvZnRuZXNzID0gZGF0YS5zb2Z0bmVzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuYmVuZERpcmVjdGlvbiA9IGRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3MgPSBkYXRhLmNvbXByZXNzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJldGNoID0gZGF0YS5zdHJldGNoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmJvbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMucHVzaChza2VsZXRvbi5maW5kQm9uZShkYXRhLmJvbmVzW2ldLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gc2tlbGV0b24uZmluZEJvbmUoZGF0YS50YXJnZXQubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgSWtDb25zdHJhaW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYm9uZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5MShib25lc1swXSwgdGFyZ2V0LndvcmxkWCwgdGFyZ2V0LndvcmxkWSwgdGhpcy5jb21wcmVzcywgdGhpcy5zdHJldGNoLCB0aGlzLmRhdGEudW5pZm9ybSwgdGhpcy5taXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkyKGJvbmVzWzBdLCBib25lc1sxXSwgdGFyZ2V0LndvcmxkWCwgdGFyZ2V0LndvcmxkWSwgdGhpcy5iZW5kRGlyZWN0aW9uLCB0aGlzLnN0cmV0Y2gsIHRoaXMuc29mdG5lc3MsIHRoaXMubWl4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHkxID0gZnVuY3Rpb24gKGJvbmUsIHRhcmdldFgsIHRhcmdldFksIGNvbXByZXNzLCBzdHJldGNoLCB1bmlmb3JtLCBhbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFib25lLmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICBib25lLnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gYm9uZS5wYXJlbnQubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhID0gcC5hLCBwYiA9IHAuYywgcGMgPSBwLmIsIHBkID0gcC5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uSUsgPSAtYm9uZS5hc2hlYXJYIC0gYm9uZS5hcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChib25lLmRhdGEudHJhbnNmb3JtTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk9ubHlUcmFuc2xhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB0YXJnZXRYIC0gYm9uZS53b3JsZFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ID0gdGFyZ2V0WSAtIGJvbmUud29ybGRZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1JvdGF0aW9uT3JSZWZsZWN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGguYWJzKHBhICogcGQgLSBwYiAqIHBjKSAvIChwYSAqIHBhICsgcGMgKiBwYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYSA9IHBhIC8gYm9uZS5za2VsZXRvbi5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYyA9IHBjIC8gYm9uZS5za2VsZXRvbi5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBiID0gLXNjICogcyAqIGJvbmUuc2tlbGV0b24uc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZCA9IHNhICogcyAqIGJvbmUuc2tlbGV0b24uc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbklLICs9IE1hdGguYXRhbjIoc2MsIHNhKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHRhcmdldFggLSBwLnR4LCB5ID0gdGFyZ2V0WSAtIHAudHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gcGEgKiBwZCAtIHBiICogcGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gKHggKiBwZCAtIHkgKiBwYikgLyBkIC0gYm9uZS5heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSAoeSAqIHBhIC0geCAqIHBjKSAvIGQgLSBib25lLmF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm90YXRpb25JSyArPSBNYXRoLmF0YW4yKHR5LCB0eCkgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9uZS5hc2NhbGVYIDwgMClcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbklLICs9IDE4MDtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbklLID4gMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uSUsgLT0gMzYwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm90YXRpb25JSyA8IC0xODApXHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb25JSyArPSAzNjA7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSBib25lLmFzY2FsZVgsIHN5ID0gYm9uZS5hc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzIHx8IHN0cmV0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJvbmUuZGF0YS50cmFuc2Zvcm1Nb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGVPclJlZmxlY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRhcmdldFggLSBib25lLndvcmxkWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5ID0gdGFyZ2V0WSAtIGJvbmUud29ybGRZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGJvbmUuZGF0YS5sZW5ndGggKiBzeCwgZGQgPSBNYXRoLnNxcnQodHggKiB0eCArIHR5ICogdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY29tcHJlc3MgJiYgZGQgPCBiKSB8fCAoc3RyZXRjaCAmJiBkZCA+IGIpICYmIGIgPiAwLjAwMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAoZGQgLyBiIC0gMSkgKiBhbHBoYSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4ICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3kgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib25lLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aChib25lLmF4LCBib25lLmF5LCBib25lLmFyb3RhdGlvbiArIHJvdGF0aW9uSUsgKiBhbHBoYSwgc3gsIHN5LCBib25lLmFzaGVhclgsIGJvbmUuYXNoZWFyWSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHkyID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHRhcmdldFgsIHRhcmdldFksIGJlbmREaXIsIHN0cmV0Y2gsIHNvZnRuZXNzLCBhbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5hcHBsaWVkVmFsaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gcGFyZW50LmF4LCBweSA9IHBhcmVudC5heSwgcHN4ID0gcGFyZW50LmFzY2FsZVgsIHN4ID0gcHN4LCBwc3kgPSBwYXJlbnQuYXNjYWxlWSwgY3N4ID0gY2hpbGQuYXNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHZhciBwbWF0ID0gcGFyZW50Lm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciBvczEgPSAwLCBvczIgPSAwLCBzMiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAocHN4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBzeCA9IC1wc3g7XHJcbiAgICAgICAgICAgICAgICAgICAgb3MxID0gMTgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvczEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwc3kgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHN5ID0gLXBzeTtcclxuICAgICAgICAgICAgICAgICAgICBzMiA9IC1zMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjc3ggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3N4ID0gLWNzeDtcclxuICAgICAgICAgICAgICAgICAgICBvczIgPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb3MyID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IGNoaWxkLmF4LCBjeSA9IDAsIGN3eCA9IDAsIGN3eSA9IDAsIGEgPSBwbWF0LmEsIGIgPSBwbWF0LmMsIGMgPSBwbWF0LmIsIGQgPSBwbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IE1hdGguYWJzKHBzeCAtIHBzeSkgPD0gMC4wMDAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN3eCA9IGEgKiBjeCArIHBtYXQudHg7XHJcbiAgICAgICAgICAgICAgICAgICAgY3d5ID0gYyAqIGN4ICsgcG1hdC50eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gY2hpbGQuYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3d4ID0gYSAqIGN4ICsgYiAqIGN5ICsgcG1hdC50eDtcclxuICAgICAgICAgICAgICAgICAgICBjd3kgPSBjICogY3ggKyBkICogY3kgKyBwbWF0LnR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBwID0gcGFyZW50LnBhcmVudC5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICBhID0gcHAuYTtcclxuICAgICAgICAgICAgICAgIGIgPSBwcC5jO1xyXG4gICAgICAgICAgICAgICAgYyA9IHBwLmI7XHJcbiAgICAgICAgICAgICAgICBkID0gcHAuZDtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IDEgLyAoYSAqIGQgLSBiICogYyksIHggPSBjd3ggLSBwcC50eCwgeSA9IGN3eSAtIHBwLnR5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gKHggKiBkIC0geSAqIGIpICogaWQgLSBweCwgZHkgPSAoeSAqIGEgLSB4ICogYykgKiBpZCAtIHB5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGwxID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgbDIgPSBjaGlsZC5kYXRhLmxlbmd0aCAqIGNzeCwgYTEsIGEyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGwxIDwgMC4wMDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseTEocGFyZW50LCB0YXJnZXRYLCB0YXJnZXRZLCBmYWxzZSwgc3RyZXRjaCwgZmFsc2UsIGFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgoY3gsIGN5LCAwLCBjaGlsZC5hc2NhbGVYLCBjaGlsZC5hc2NhbGVZLCBjaGlsZC5hc2hlYXJYLCBjaGlsZC5hc2hlYXJZKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0WCAtIHBwLnR4O1xyXG4gICAgICAgICAgICAgICAgeSA9IHRhcmdldFkgLSBwcC50eTtcclxuICAgICAgICAgICAgICAgIHZhciB0eCA9ICh4ICogZCAtIHkgKiBiKSAqIGlkIC0gcHgsIHR5ID0gKHkgKiBhIC0geCAqIGMpICogaWQgLSBweTtcclxuICAgICAgICAgICAgICAgIHZhciBkZCA9IHR4ICogdHggKyB0eSAqIHR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvZnRuZXNzICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2Z0bmVzcyAqPSBwc3ggKiAoY3N4ICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZCA9IE1hdGguc3FydChkZCksIHNkID0gdGQgLSBsMSAtIGwyICogcHN4ICsgc29mdG5lc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE1hdGgubWluKDEsIHNkIC8gKHNvZnRuZXNzICogMikpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IChzZCAtIHNvZnRuZXNzICogKDEgLSBwICogcCkpIC8gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4IC09IHAgKiB0eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgLT0gcCAqIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZCA9IHR4ICogdHggKyB0eSAqIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dGVyOiBpZiAodSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGwyICo9IHBzeDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29zID0gKGRkIC0gbDEgKiBsMSAtIGwyICogbDIpIC8gKDIgKiBsMSAqIGwyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29zIDwgLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvcyA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29zID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeCAqPSAoTWF0aC5zcXJ0KGRkKSAvIChsMSArIGwyKSAtIDEpICogYWxwaGEgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhMiA9IE1hdGguYWNvcyhjb3MpICogYmVuZERpcjtcclxuICAgICAgICAgICAgICAgICAgICBhID0gbDEgKyBsMiAqIGNvcztcclxuICAgICAgICAgICAgICAgICAgICBiID0gbDIgKiBNYXRoLnNpbihhMik7XHJcbiAgICAgICAgICAgICAgICAgICAgYTEgPSBNYXRoLmF0YW4yKHR5ICogYSAtIHR4ICogYiwgdHggKiBhICsgdHkgKiBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBwc3ggKiBsMjtcclxuICAgICAgICAgICAgICAgICAgICBiID0gcHN5ICogbDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFhID0gYSAqIGEsIGJiID0gYiAqIGIsIHRhID0gTWF0aC5hdGFuMih0eSwgdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBiYiAqIGwxICogbDEgKyBhYSAqIGRkIC0gYWEgKiBiYjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYzEgPSAtMiAqIGJiICogbDEsIGMyID0gYmIgLSBhYTtcclxuICAgICAgICAgICAgICAgICAgICBkID0gYzEgKiBjMSAtIDQgKiBjMiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IE1hdGguc3FydChkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMxIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAtcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IC0oYzEgKyBxKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByMCA9IHEgLyBjMiwgcjEgPSBjIC8gcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmFicyhyMCkgPCBNYXRoLmFicyhyMSkgPyByMCA6IHIxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAqIHIgPD0gZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoZGQgLSByICogcikgKiBiZW5kRGlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTEgPSB0YSAtIE1hdGguYXRhbjIoeSwgcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IE1hdGguYXRhbjIoeSAvIHBzeSwgKHIgLSBsMSkgLyBwc3gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkFuZ2xlID0gY29yZS5NYXRoVXRpbHMuUEksIG1pblggPSBsMSAtIGEsIG1pbkRpc3QgPSBtaW5YICogbWluWCwgbWluWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heEFuZ2xlID0gMCwgbWF4WCA9IGwxICsgYSwgbWF4RGlzdCA9IG1heFggKiBtYXhYLCBtYXhZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjID0gLWEgKiBsMSAvIChhYSAtIGJiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+PSAtMSAmJiBjIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IE1hdGguYWNvcyhjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGEgKiBNYXRoLmNvcyhjKSArIGwxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYiAqIE1hdGguc2luKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0geCAqIHggKyB5ICogeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5BbmdsZSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiBtYXhEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhBbmdsZSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRkIDw9IChtaW5EaXN0ICsgbWF4RGlzdCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGExID0gdGEgLSBNYXRoLmF0YW4yKG1pblkgKiBiZW5kRGlyLCBtaW5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBtaW5BbmdsZSAqIGJlbmREaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhMSA9IHRhIC0gTWF0aC5hdGFuMihtYXhZICogYmVuZERpciwgbWF4WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gbWF4QW5nbGUgKiBiZW5kRGlyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvcyA9IE1hdGguYXRhbjIoY3ksIGN4KSAqIHMyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gcGFyZW50LmFyb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGExID0gKGExIC0gb3MpICogY29yZS5NYXRoVXRpbHMucmFkRGVnICsgb3MxIC0gcm90YXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoYTEgPiAxODApXHJcbiAgICAgICAgICAgICAgICAgICAgYTEgLT0gMzYwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYTEgPCAtMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGExICs9IDM2MDtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgocHgsIHB5LCByb3RhdGlvbiArIGExICogYWxwaGEsIHN4LCBwYXJlbnQuYXNjYWxlWSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IGNoaWxkLmFyb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGEyID0gKChhMiArIG9zKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZyAtIGNoaWxkLmFzaGVhclgpICogczIgKyBvczIgLSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChhMiA+IDE4MClcclxuICAgICAgICAgICAgICAgICAgICBhMiAtPSAzNjA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhMiA8IC0xODApXHJcbiAgICAgICAgICAgICAgICAgICAgYTIgKz0gMzYwO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKGN4LCBjeSwgcm90YXRpb24gKyBhMiAqIGFscGhhLCBjaGlsZC5hc2NhbGVYLCBjaGlsZC5hc2NhbGVZLCBjaGlsZC5hc2hlYXJYLCBjaGlsZC5hc2hlYXJZKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIElrQ29uc3RyYWludDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuSWtDb25zdHJhaW50ID0gSWtDb25zdHJhaW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIElrQ29uc3RyYWludERhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoSWtDb25zdHJhaW50RGF0YSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSWtDb25zdHJhaW50RGF0YShuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCAwLCBmYWxzZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5iZW5kRGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbXByZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJldGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51bmlmb3JtID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5taXggPSAxO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc29mdG5lc3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBJa0NvbnN0cmFpbnREYXRhO1xyXG4gICAgICAgIH0oY29yZS5Db25zdHJhaW50RGF0YSkpO1xyXG4gICAgICAgIGNvcmUuSWtDb25zdHJhaW50RGF0YSA9IElrQ29uc3RyYWludERhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgUGF0aENvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoQ29uc3RyYWludChkYXRhLCBza2VsZXRvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNpbmcgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25zID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnZlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGhzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEuYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMucHVzaChza2VsZXRvbi5maW5kQm9uZShkYXRhLmJvbmVzW2ldLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gc2tlbGV0b24uZmluZFNsb3QoZGF0YS50YXJnZXQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gZGF0YS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2luZyA9IGRhdGEuc3BhY2luZztcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy50YXJnZXQuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoYXR0YWNobWVudCBpbnN0YW5jZW9mIGNvcmUuUGF0aEF0dGFjaG1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gdHJhbnNsYXRlTWl4ID4gMCwgcm90YXRlID0gcm90YXRlTWl4ID4gMDtcclxuICAgICAgICAgICAgICAgIGlmICghdHJhbnNsYXRlICYmICFyb3RhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZ01vZGUgPSBkYXRhLnNwYWNpbmdNb2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aFNwYWNpbmcgPSBzcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVNb2RlID0gZGF0YS5yb3RhdGVNb2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhbmdlbnRzID0gcm90YXRlTW9kZSA9PSBjb3JlLlJvdGF0ZU1vZGUuVGFuZ2VudCwgc2NhbGUgPSByb3RhdGVNb2RlID09IGNvcmUuUm90YXRlTW9kZS5DaGFpblNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVDb3VudCA9IHRoaXMuYm9uZXMubGVuZ3RoLCBzcGFjZXNDb3VudCA9IHRhbmdlbnRzID8gYm9uZUNvdW50IDogYm9uZUNvdW50ICsgMTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy5zcGFjZXMsIHNwYWNlc0NvdW50KSwgbGVuZ3RocyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuc3BhY2luZztcclxuICAgICAgICAgICAgICAgIGlmIChzY2FsZSB8fCBsZW5ndGhTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy5sZW5ndGhzLCBib25lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3BhY2VzQ291bnQgLSAxOyBpIDwgbjspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwTGVuZ3RoID0gYm9uZS5kYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHVwTGVuZ3RoIDwgUGF0aENvbnN0cmFpbnQuZXBzaWxvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzWysraV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBzZXR1cExlbmd0aCAqIGJvbmUubWF0cml4LmEsIHkgPSBzZXR1cExlbmd0aCAqIGJvbmUubWF0cml4LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1tpXSA9IGxlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzWysraV0gPSAobGVuZ3RoU3BhY2luZyA/IHNldHVwTGVuZ3RoICsgc3BhY2luZyA6IHNwYWNpbmcpICogbGVuZ3RoXzEgLyBzZXR1cExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3BhY2VzQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzW2ldID0gc3BhY2luZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLmNvbXB1dGVXb3JsZFBvc2l0aW9ucyhhdHRhY2htZW50LCBzcGFjZXNDb3VudCwgdGFuZ2VudHMsIGRhdGEucG9zaXRpb25Nb2RlID09IGNvcmUuUG9zaXRpb25Nb2RlLlBlcmNlbnQsIHNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuUGVyY2VudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZVggPSBwb3NpdGlvbnNbMF0sIGJvbmVZID0gcG9zaXRpb25zWzFdLCBvZmZzZXRSb3RhdGlvbiA9IGRhdGEub2Zmc2V0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0Um90YXRpb24gPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aXAgPSByb3RhdGVNb2RlID09IGNvcmUuUm90YXRlTW9kZS5DaGFpbjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy50YXJnZXQuYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Um90YXRpb24gKj0gcC5hICogcC5kIC0gcC5iICogcC5jID4gMCA/IGNvcmUuTWF0aFV0aWxzLmRlZ1JhZCA6IC1jb3JlLk1hdGhVdGlscy5kZWdSYWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IDM7IGkgPCBib25lQ291bnQ7IGkrKywgcCArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0LnR4ICs9IChib25lWCAtIG1hdC50eCkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0LnR5ICs9IChib25lWSAtIG1hdC50eSkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwb3NpdGlvbnNbcF0sIHkgPSBwb3NpdGlvbnNbcCArIDFdLCBkeCA9IHggLSBib25lWCwgZHkgPSB5IC0gYm9uZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMiA9IGxlbmd0aHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfMiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gbGVuZ3RoXzIgLSAxKSAqIHJvdGF0ZU1peCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXQuYSAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib25lWCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZVkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBtYXQuYSwgYiA9IG1hdC5jLCBjID0gbWF0LmIsIGQgPSBtYXQuZCwgciA9IDAsIGNvcyA9IDAsIHNpbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YW5nZW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBwb3NpdGlvbnNbcCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGFjZXNbaSArIDFdID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcG9zaXRpb25zW3AgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IE1hdGguYXRhbjIoZHksIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAtPSBNYXRoLmF0YW4yKGMsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8zID0gYm9uZS5kYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmVYICs9IChsZW5ndGhfMyAqIChjb3MgKiBhIC0gc2luICogYykgLSBkeCkgKiByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lWSArPSAobGVuZ3RoXzMgKiAoc2luICogYSArIGNvcyAqIGMpIC0gZHkpICogcm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBvZmZzZXRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IGNvcmUuTWF0aFV0aWxzLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAtPSBjb3JlLk1hdGhVdGlscy5QSTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgPCAtY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAqPSByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmEgPSBjb3MgKiBhIC0gc2luICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmMgPSBjb3MgKiBiIC0gc2luICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgPSBzaW4gKiBhICsgY29zICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgPSBzaW4gKiBiICsgY29zICogZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hcHBsaWVkVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmNvbXB1dGVXb3JsZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChwYXRoLCBzcGFjZXNDb3VudCwgdGFuZ2VudHMsIHBlcmNlbnRQb3NpdGlvbiwgcGVyY2VudFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXMsIG91dCA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMucG9zaXRpb25zLCBzcGFjZXNDb3VudCAqIDMgKyAyKSwgd29ybGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlZCA9IHBhdGguY2xvc2VkO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzTGVuZ3RoID0gcGF0aC53b3JsZFZlcnRpY2VzTGVuZ3RoLCBjdXJ2ZUNvdW50ID0gdmVydGljZXNMZW5ndGggLyA2LCBwcmV2Q3VydmUgPSBQYXRoQ29uc3RyYWludC5OT05FO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoLmNvbnN0YW50U3BlZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RocyA9IHBhdGgubGVuZ3RocztcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZUNvdW50IC09IGNsb3NlZCA/IDEgOiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoTGVuZ3RoXzEgPSBsZW5ndGhzW2N1cnZlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50UG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICo9IHBhdGhMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZXNDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzW2ldICo9IHBhdGhMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGQgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLndvcmxkLCA4KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbyA9IDAsIGN1cnZlID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyssIG8gKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBzcGFjZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHNwYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwICU9IHBhdGhMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwICs9IHBhdGhMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDdXJ2ZSAhPSBQYXRoQ29uc3RyYWludC5CRUZPUkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q3VydmUgPSBQYXRoQ29uc3RyYWludC5CRUZPUkU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIDIsIDQsIHdvcmxkLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQmVmb3JlUG9zaXRpb24ocCwgd29ybGQsIDAsIG91dCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwID4gcGF0aExlbmd0aF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkN1cnZlICE9IFBhdGhDb25zdHJhaW50LkFGVEVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkN1cnZlID0gUGF0aENvbnN0cmFpbnQuQUZURVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIHZlcnRpY2VzTGVuZ3RoIC0gNiwgNCwgd29ybGQsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBZnRlclBvc2l0aW9uKHAgLSBwYXRoTGVuZ3RoXzEsIHdvcmxkLCAwLCBvdXQsIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7OyBjdXJ2ZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzQgPSBsZW5ndGhzW2N1cnZlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID4gbGVuZ3RoXzQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VydmUgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwIC89IGxlbmd0aF80O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBsZW5ndGhzW2N1cnZlIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IChwIC0gcHJldikgLyAobGVuZ3RoXzQgLSBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSAhPSBwcmV2Q3VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDdXJ2ZSA9IGN1cnZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZCAmJiBjdXJ2ZSA9PSBjdXJ2ZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIHZlcnRpY2VzTGVuZ3RoIC0gNCwgNCwgd29ybGQsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAwLCA0LCB3b3JsZCwgNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIGN1cnZlICogNiArIDIsIDgsIHdvcmxkLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnZlUG9zaXRpb24ocCwgd29ybGRbMF0sIHdvcmxkWzFdLCB3b3JsZFsyXSwgd29ybGRbM10sIHdvcmxkWzRdLCB3b3JsZFs1XSwgd29ybGRbNl0sIHdvcmxkWzddLCBvdXQsIG8sIHRhbmdlbnRzIHx8IChpID4gMCAmJiBzcGFjZSA9PSAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNMZW5ndGggKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZCA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMud29ybGQsIHZlcnRpY2VzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgMiwgdmVydGljZXNMZW5ndGggLSA0LCB3b3JsZCwgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIDAsIDIsIHdvcmxkLCB2ZXJ0aWNlc0xlbmd0aCAtIDQsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRpY2VzTGVuZ3RoIC0gMl0gPSB3b3JsZFswXTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFt2ZXJ0aWNlc0xlbmd0aCAtIDFdID0gd29ybGRbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNMZW5ndGggLT0gNDtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZCA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMud29ybGQsIHZlcnRpY2VzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgMiwgdmVydGljZXNMZW5ndGgsIHdvcmxkLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjdXJ2ZXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLmN1cnZlcywgY3VydmVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSB3b3JsZFswXSwgeTEgPSB3b3JsZFsxXSwgY3gxID0gMCwgY3kxID0gMCwgY3gyID0gMCwgY3kyID0gMCwgeDIgPSAwLCB5MiA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1weCA9IDAsIHRtcHkgPSAwLCBkZGRmeCA9IDAsIGRkZGZ5ID0gMCwgZGRmeCA9IDAsIGRkZnkgPSAwLCBkZnggPSAwLCBkZnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHcgPSAyOyBpIDwgY3VydmVDb3VudDsgaSsrLCB3ICs9IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjeDEgPSB3b3JsZFt3XTtcclxuICAgICAgICAgICAgICAgICAgICBjeTEgPSB3b3JsZFt3ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY3gyID0gd29ybGRbdyArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN5MiA9IHdvcmxkW3cgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICB4MiA9IHdvcmxkW3cgKyA0XTtcclxuICAgICAgICAgICAgICAgICAgICB5MiA9IHdvcmxkW3cgKyA1XTtcclxuICAgICAgICAgICAgICAgICAgICB0bXB4ID0gKHgxIC0gY3gxICogMiArIGN4MikgKiAwLjE4NzU7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1weSA9ICh5MSAtIGN5MSAqIDIgKyBjeTIpICogMC4xODc1O1xyXG4gICAgICAgICAgICAgICAgICAgIGRkZGZ4ID0gKChjeDEgLSBjeDIpICogMyAtIHgxICsgeDIpICogMC4wOTM3NTtcclxuICAgICAgICAgICAgICAgICAgICBkZGRmeSA9ICgoY3kxIC0gY3kyKSAqIDMgLSB5MSArIHkyKSAqIDAuMDkzNzU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRmeCA9IHRtcHggKiAyICsgZGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRmeSA9IHRtcHkgKiAyICsgZGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ4ID0gKGN4MSAtIHgxKSAqIDAuNzUgKyB0bXB4ICsgZGRkZnggKiAwLjE2NjY2NjY3O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeSA9IChjeTEgLSB5MSkgKiAwLjc1ICsgdG1weSArIGRkZGZ5ICogMC4xNjY2NjY2NztcclxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRkZnggKz0gZGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRmeSArPSBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ4ICs9IGRkZnggKyBkZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICBkZnkgKz0gZGRmeSArIGRkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmVzW2ldID0gcGF0aExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgICAgICAgICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICo9IHBhdGhMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlc1tpXSAqPSBwYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBjdXJ2ZUxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbyA9IDAsIGN1cnZlID0gMCwgc2VnbWVudCA9IDA7IGkgPCBzcGFjZXNDb3VudDsgaSsrLCBvICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBzcGFjZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgJT0gcGF0aExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCArPSBwYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQmVmb3JlUG9zaXRpb24ocCwgd29ybGQsIDAsIG91dCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwID4gcGF0aExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFmdGVyUG9zaXRpb24ocCAtIHBhdGhMZW5ndGgsIHdvcmxkLCB2ZXJ0aWNlc0xlbmd0aCAtIDQsIG91dCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7IGN1cnZlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF81ID0gY3VydmVzW2N1cnZlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPiBsZW5ndGhfNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VydmUgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgLz0gbGVuZ3RoXzU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBjdXJ2ZXNbY3VydmUgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAocCAtIHByZXYpIC8gKGxlbmd0aF81IC0gcHJldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSAhPSBwcmV2Q3VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkN1cnZlID0gY3VydmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpaSA9IGN1cnZlICogNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB3b3JsZFtpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gd29ybGRbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3gxID0gd29ybGRbaWkgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3kxID0gd29ybGRbaWkgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3gyID0gd29ybGRbaWkgKyA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3kyID0gd29ybGRbaWkgKyA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB3b3JsZFtpaSArIDZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHdvcmxkW2lpICsgN107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcHggPSAoeDEgLSBjeDEgKiAyICsgY3gyKSAqIDAuMDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcHkgPSAoeTEgLSBjeTEgKiAyICsgY3kyKSAqIDAuMDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkZGZ4ID0gKChjeDEgLSBjeDIpICogMyAtIHgxICsgeDIpICogMC4wMDY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkZGZ5ID0gKChjeTEgLSBjeTIpICogMyAtIHkxICsgeTIpICogMC4wMDY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkZnggPSB0bXB4ICogMiArIGRkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZGZ5ID0gdG1weSAqIDIgKyBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZ4ID0gKGN4MSAtIHgxKSAqIDAuMyArIHRtcHggKyBkZGRmeCAqIDAuMTY2NjY2Njc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmeSA9IChjeTEgLSB5MSkgKiAwLjMgKyB0bXB5ICsgZGRkZnkgKiAwLjE2NjY2NjY3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZUxlbmd0aCA9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1swXSA9IGN1cnZlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMTsgaWkgPCA4OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZnggKz0gZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGRmeCArPSBkZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkZnkgKz0gZGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZUxlbmd0aCArPSBNYXRoLnNxcnQoZGZ4ICogZGZ4ICsgZGZ5ICogZGZ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW2lpXSA9IGN1cnZlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZnkgKz0gZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzWzhdID0gY3VydmVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4ICsgZGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5ICsgZGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1s5XSA9IGN1cnZlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcCAqPSBjdXJ2ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7IHNlZ21lbnQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzYgPSBzZWdtZW50c1tzZWdtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPiBsZW5ndGhfNilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCAvPSBsZW5ndGhfNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHNlZ21lbnRzW3NlZ21lbnQgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBzZWdtZW50ICsgKHAgLSBwcmV2KSAvIChsZW5ndGhfNiAtIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnZlUG9zaXRpb24ocCAqIDAuMSwgeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5Miwgb3V0LCBvLCB0YW5nZW50cyB8fCAoaSA+IDAgJiYgc3BhY2UgPT0gMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFkZEJlZm9yZVBvc2l0aW9uID0gZnVuY3Rpb24gKHAsIHRlbXAsIGksIG91dCwgbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gdGVtcFtpXSwgeTEgPSB0ZW1wW2kgKyAxXSwgZHggPSB0ZW1wW2kgKyAyXSAtIHgxLCBkeSA9IHRlbXBbaSArIDNdIC0geTEsIHIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XHJcbiAgICAgICAgICAgICAgICBvdXRbb10gPSB4MSArIHAgKiBNYXRoLmNvcyhyKTtcclxuICAgICAgICAgICAgICAgIG91dFtvICsgMV0gPSB5MSArIHAgKiBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgICAgIG91dFtvICsgMl0gPSByO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuYWRkQWZ0ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uIChwLCB0ZW1wLCBpLCBvdXQsIG8pIHtcclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IHRlbXBbaSArIDJdLCB5MSA9IHRlbXBbaSArIDNdLCBkeCA9IHgxIC0gdGVtcFtpXSwgZHkgPSB5MSAtIHRlbXBbaSArIDFdLCByID0gTWF0aC5hdGFuMihkeSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgb3V0W29dID0geDEgKyBwICogTWF0aC5jb3Mocik7XHJcbiAgICAgICAgICAgICAgICBvdXRbbyArIDFdID0geTEgKyBwICogTWF0aC5zaW4ocik7XHJcbiAgICAgICAgICAgICAgICBvdXRbbyArIDJdID0gcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmFkZEN1cnZlUG9zaXRpb24gPSBmdW5jdGlvbiAocCwgeDEsIHkxLCBjeDEsIGN5MSwgY3gyLCBjeTIsIHgyLCB5Miwgb3V0LCBvLCB0YW5nZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAgPT0gMCB8fCBpc05hTihwKSlcclxuICAgICAgICAgICAgICAgICAgICBwID0gMC4wMDAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR0ID0gcCAqIHAsIHR0dCA9IHR0ICogcCwgdSA9IDEgLSBwLCB1dSA9IHUgKiB1LCB1dXUgPSB1dSAqIHU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXQgPSB1ICogcCwgdXQzID0gdXQgKiAzLCB1dXQzID0gdSAqIHV0MywgdXR0MyA9IHV0MyAqIHA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHgxICogdXV1ICsgY3gxICogdXV0MyArIGN4MiAqIHV0dDMgKyB4MiAqIHR0dCwgeSA9IHkxICogdXV1ICsgY3kxICogdXV0MyArIGN5MiAqIHV0dDMgKyB5MiAqIHR0dDtcclxuICAgICAgICAgICAgICAgIG91dFtvXSA9IHg7XHJcbiAgICAgICAgICAgICAgICBvdXRbbyArIDFdID0geTtcclxuICAgICAgICAgICAgICAgIGlmICh0YW5nZW50cylcclxuICAgICAgICAgICAgICAgICAgICBvdXRbbyArIDJdID0gTWF0aC5hdGFuMih5IC0gKHkxICogdXUgKyBjeTEgKiB1dCAqIDIgKyBjeTIgKiB0dCksIHggLSAoeDEgKiB1dSArIGN4MSAqIHV0ICogMiArIGN4MiAqIHR0KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50Lk5PTkUgPSAtMTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQuQkVGT1JFID0gLTI7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50LkFGVEVSID0gLTM7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50LmVwc2lsb24gPSAwLjAwMDAxO1xyXG4gICAgICAgICAgICByZXR1cm4gUGF0aENvbnN0cmFpbnQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlBhdGhDb25zdHJhaW50ID0gUGF0aENvbnN0cmFpbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgUGF0aENvbnN0cmFpbnREYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBhdGhDb25zdHJhaW50RGF0YSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aENvbnN0cmFpbnREYXRhKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIDAsIGZhbHNlKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGF0aENvbnN0cmFpbnREYXRhO1xyXG4gICAgICAgIH0oY29yZS5Db25zdHJhaW50RGF0YSkpO1xyXG4gICAgICAgIGNvcmUuUGF0aENvbnN0cmFpbnREYXRhID0gUGF0aENvbnN0cmFpbnREYXRhO1xyXG4gICAgICAgIHZhciBQb3NpdGlvbk1vZGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChQb3NpdGlvbk1vZGUpIHtcclxuICAgICAgICAgICAgUG9zaXRpb25Nb2RlW1Bvc2l0aW9uTW9kZVtcIkZpeGVkXCJdID0gMF0gPSBcIkZpeGVkXCI7XHJcbiAgICAgICAgICAgIFBvc2l0aW9uTW9kZVtQb3NpdGlvbk1vZGVbXCJQZXJjZW50XCJdID0gMV0gPSBcIlBlcmNlbnRcIjtcclxuICAgICAgICB9KShQb3NpdGlvbk1vZGUgPSBjb3JlLlBvc2l0aW9uTW9kZSB8fCAoY29yZS5Qb3NpdGlvbk1vZGUgPSB7fSkpO1xyXG4gICAgICAgIHZhciBTcGFjaW5nTW9kZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFNwYWNpbmdNb2RlKSB7XHJcbiAgICAgICAgICAgIFNwYWNpbmdNb2RlW1NwYWNpbmdNb2RlW1wiTGVuZ3RoXCJdID0gMF0gPSBcIkxlbmd0aFwiO1xyXG4gICAgICAgICAgICBTcGFjaW5nTW9kZVtTcGFjaW5nTW9kZVtcIkZpeGVkXCJdID0gMV0gPSBcIkZpeGVkXCI7XHJcbiAgICAgICAgICAgIFNwYWNpbmdNb2RlW1NwYWNpbmdNb2RlW1wiUGVyY2VudFwiXSA9IDJdID0gXCJQZXJjZW50XCI7XHJcbiAgICAgICAgfSkoU3BhY2luZ01vZGUgPSBjb3JlLlNwYWNpbmdNb2RlIHx8IChjb3JlLlNwYWNpbmdNb2RlID0ge30pKTtcclxuICAgICAgICB2YXIgUm90YXRlTW9kZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFJvdGF0ZU1vZGUpIHtcclxuICAgICAgICAgICAgUm90YXRlTW9kZVtSb3RhdGVNb2RlW1wiVGFuZ2VudFwiXSA9IDBdID0gXCJUYW5nZW50XCI7XHJcbiAgICAgICAgICAgIFJvdGF0ZU1vZGVbUm90YXRlTW9kZVtcIkNoYWluXCJdID0gMV0gPSBcIkNoYWluXCI7XHJcbiAgICAgICAgICAgIFJvdGF0ZU1vZGVbUm90YXRlTW9kZVtcIkNoYWluU2NhbGVcIl0gPSAyXSA9IFwiQ2hhaW5TY2FsZVwiO1xyXG4gICAgICAgIH0pKFJvdGF0ZU1vZGUgPSBjb3JlLlJvdGF0ZU1vZGUgfHwgKGNvcmUuUm90YXRlTW9kZSA9IHt9KSk7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2tlbGV0b24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTa2VsZXRvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDYWNoZSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZVJlc2V0ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ib25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lRGF0YSA9IGRhdGEuYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmVEYXRhLnBhcmVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lID0gbmV3IGNvcmUuQm9uZShib25lRGF0YSwgdGhpcywgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuYm9uZXNbYm9uZURhdGEucGFyZW50LmluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZSA9IG5ldyBjb3JlLkJvbmUoYm9uZURhdGEsIHRoaXMsIHBhcmVudF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEuY2hpbGRyZW4ucHVzaChib25lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3T3JkZXIgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90RGF0YSA9IGRhdGEuc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzW3Nsb3REYXRhLmJvbmVEYXRhLmluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5ldyBjb3JlLlNsb3Qoc2xvdERhdGEsIGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xvdHMucHVzaChzbG90KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdPcmRlci5wdXNoKHNsb3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pa0NvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuaWtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpa0NvbnN0cmFpbnREYXRhID0gZGF0YS5pa0NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWtDb25zdHJhaW50cy5wdXNoKG5ldyBjb3JlLklrQ29uc3RyYWludChpa0NvbnN0cmFpbnREYXRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEudHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtQ29uc3RyYWludERhdGEgPSBkYXRhLnRyYW5zZm9ybUNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHMucHVzaChuZXcgY29yZS5UcmFuc2Zvcm1Db25zdHJhaW50KHRyYW5zZm9ybUNvbnN0cmFpbnREYXRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb25zdHJhaW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnBhdGhDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludERhdGEgPSBkYXRhLnBhdGhDb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb25zdHJhaW50cy5wdXNoKG5ldyBjb3JlLlBhdGhDb25zdHJhaW50KHBhdGhDb25zdHJhaW50RGF0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVDYWNoZSA9IHRoaXMuX3VwZGF0ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FjaGUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVSZXNldC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBib25lLnNvcnRlZCA9IGJvbmUuZGF0YS5za2luUmVxdWlyZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hY3RpdmUgPSAhYm9uZS5zb3J0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5za2luICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbkJvbmVzID0gdGhpcy5za2luLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5za2luLmJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbc2tpbkJvbmVzW2ldLmluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUgPSBib25lLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoYm9uZSAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaWtDb25zdHJhaW50cyA9IHRoaXMuaWtDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1Db25zdHJhaW50cyA9IHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aENvbnN0cmFpbnRzID0gdGhpcy5wYXRoQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWtDb3VudCA9IGlrQ29uc3RyYWludHMubGVuZ3RoLCB0cmFuc2Zvcm1Db3VudCA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzLmxlbmd0aCwgcGF0aENvdW50ID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50Q291bnQgPSBpa0NvdW50ICsgdHJhbnNmb3JtQ291bnQgKyBwYXRoQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBvdXRlcjogZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpa0NvdW50OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gaWtDb25zdHJhaW50c1tpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhdGEub3JkZXIgPT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0SWtDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHRyYW5zZm9ybUNvdW50OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gdHJhbnNmb3JtQ29uc3RyYWludHNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludC5kYXRhLm9yZGVyID09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFRyYW5zZm9ybUNvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcGF0aENvdW50OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gcGF0aENvbnN0cmFpbnRzW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuZGF0YS5vcmRlciA9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRQYXRoQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShib25lc1tpXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zb3J0SWtDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYWN0aXZlID0gY29uc3RyYWludC50YXJnZXQuaXNBY3RpdmUoKSAmJiAoIWNvbnN0cmFpbnQuZGF0YS5za2luUmVxdWlyZWQgfHwgKHRoaXMuc2tpbiAhPSBudWxsICYmIGNvcmUuVXRpbHMuY29udGFpbnModGhpcy5za2luLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50LmRhdGEsIHRydWUpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBjb25zdHJhaW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW5lZCA9IGNvbnN0cmFpbnQuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY29uc3RyYWluZWRbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWluZWQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNvbnN0cmFpbmVkW2NvbnN0cmFpbmVkLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3VwZGF0ZUNhY2hlLmluZGV4T2YoY2hpbGQpID4gLTEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlUmVzZXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDYWNoZS5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0UmVzZXQocGFyZW50LmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbmVkW2NvbnN0cmFpbmVkLmxlbmd0aCAtIDFdLnNvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zb3J0UGF0aENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5hY3RpdmUgPSBjb25zdHJhaW50LnRhcmdldC5ib25lLmlzQWN0aXZlKCkgJiYgKCFjb25zdHJhaW50LmRhdGEuc2tpblJlcXVpcmVkIHx8ICh0aGlzLnNraW4gIT0gbnVsbCAmJiBjb3JlLlV0aWxzLmNvbnRhaW5zKHRoaXMuc2tpbi5jb25zdHJhaW50cywgY29uc3RyYWludC5kYXRhLCB0cnVlKSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IGNvbnN0cmFpbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNsb3QuZGF0YS5pbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90Qm9uZSA9IHNsb3QuYm9uZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNraW4gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRQYXRoQ29uc3RyYWludEF0dGFjaG1lbnQodGhpcy5za2luLCBzbG90SW5kZXgsIHNsb3RCb25lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuZGVmYXVsdFNraW4gIT0gbnVsbCAmJiB0aGlzLmRhdGEuZGVmYXVsdFNraW4gIT0gdGhpcy5za2luKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCh0aGlzLmRhdGEuZGVmYXVsdFNraW4sIHNsb3RJbmRleCwgc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLmRhdGEuc2tpbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCh0aGlzLmRhdGEuc2tpbnNbaV0sIHNsb3RJbmRleCwgc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgY29yZS5QYXRoQXR0YWNobWVudClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRQYXRoQ29uc3RyYWludEF0dGFjaG1lbnRXaXRoKGF0dGFjaG1lbnQsIHNsb3RCb25lKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW5lZCA9IGNvbnN0cmFpbnQuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZUNvdW50ID0gY29uc3RyYWluZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib25lQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKGNvbnN0cmFpbmVkW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFJlc2V0KGNvbnN0cmFpbmVkW2ldLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluZWRbaV0uc29ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNvcnRUcmFuc2Zvcm1Db25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYWN0aXZlID0gY29uc3RyYWludC50YXJnZXQuaXNBY3RpdmUoKSAmJiAoIWNvbnN0cmFpbnQuZGF0YS5za2luUmVxdWlyZWQgfHwgKHRoaXMuc2tpbiAhPSBudWxsICYmIGNvcmUuVXRpbHMuY29udGFpbnModGhpcy5za2luLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50LmRhdGEsIHRydWUpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUoY29uc3RyYWludC50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbmVkID0gY29uc3RyYWludC5ib25lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lQ291bnQgPSBjb25zdHJhaW5lZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludC5kYXRhLmxvY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib25lQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjb25zdHJhaW5lZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShjaGlsZC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl91cGRhdGVDYWNoZS5pbmRleE9mKGNoaWxkKSA+IC0xKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVSZXNldC5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUoY29uc3RyYWluZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYm9uZUNvdW50OyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFJlc2V0KGNvbnN0cmFpbmVkW2lpXS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYm9uZUNvdW50OyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbmVkW2lpXS5zb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBzbG90SW5kZXgsIHNsb3RCb25lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudHMgPSBza2luLmF0dGFjaG1lbnRzW3Nsb3RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF0dGFjaG1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudFdpdGgoYXR0YWNobWVudHNba2V5XSwgc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudFdpdGggPSBmdW5jdGlvbiAoYXR0YWNobWVudCwgc2xvdEJvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLlBhdGhBdHRhY2htZW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEJvbmVzID0gYXR0YWNobWVudC5ib25lcztcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQm9uZXMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKHNsb3RCb25lKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgcGF0aEJvbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZUNvdW50ID0gcGF0aEJvbmVzW2krK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBpICsgYm9uZUNvdW50OyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZUluZGV4ID0gcGF0aEJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShib25lc1tib25lSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNvcnRCb25lID0gZnVuY3Rpb24gKGJvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib25lLnNvcnRlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gYm9uZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgYm9uZS5zb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2FjaGUucHVzaChib25lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNvcnRSZXNldCA9IGZ1bmN0aW9uIChib25lcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib25lLnNvcnRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UmVzZXQoYm9uZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5zb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZVdvcmxkVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNhY2hlUmVzZXQgPSB0aGlzLnVwZGF0ZUNhY2hlUmVzZXQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHVwZGF0ZUNhY2hlUmVzZXQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSB1cGRhdGVDYWNoZVJlc2V0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUuYXggPSBib25lLng7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5heSA9IGJvbmUueTtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFyb3RhdGlvbiA9IGJvbmUucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hc2NhbGVYID0gYm9uZS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hc2NhbGVZID0gYm9uZS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hc2hlYXJYID0gYm9uZS5zaGVhclg7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hc2hlYXJZID0gYm9uZS5zaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5hcHBsaWVkVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNhY2hlID0gdGhpcy5fdXBkYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHVwZGF0ZUNhY2hlLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYWNoZVtpXS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNldFRvU2V0dXBQb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRCb25lc1RvU2V0dXBQb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNsb3RzVG9TZXR1cFBvc2UoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNldEJvbmVzVG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZXNbaV0uc2V0VG9TZXR1cFBvc2UoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gaWtDb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50Lm1peCA9IGNvbnN0cmFpbnQuZGF0YS5taXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zb2Z0bmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNvbXByZXNzID0gY29uc3RyYWludC5kYXRhLmNvbXByZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGNvbnN0cmFpbnQuZGF0YS5zdHJldGNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUNvbnN0cmFpbnRzID0gdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnN0cmFpbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zaGVhck1peCA9IGRhdGEuc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aENvbnN0cmFpbnRzID0gdGhpcy5wYXRoQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBhdGhDb25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHBhdGhDb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnN0cmFpbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvc2l0aW9uID0gZGF0YS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNwYWNpbmcgPSBkYXRhLnNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5yb3RhdGVNaXggPSBkYXRhLnJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc2V0U2xvdHNUb1NldHVwUG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weShzbG90cywgMCwgdGhpcy5kcmF3T3JkZXIsIDAsIHNsb3RzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBzbG90c1tpXS5zZXRUb1NldHVwUG9zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZ2V0Um9vdEJvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib25lcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvbmVzWzBdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZmluZEJvbmUgPSBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib25lTmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvbmVOYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmUuZGF0YS5uYW1lID09IGJvbmVOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZmluZEJvbmVJbmRleCA9IGZ1bmN0aW9uIChib25lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVOYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm9uZU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib25lc1tpXS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZmluZFNsb3QgPSBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbG90TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNsb3ROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuZGF0YS5uYW1lID09IHNsb3ROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZmluZFNsb3RJbmRleCA9IGZ1bmN0aW9uIChzbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3ROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2xvdE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90c1tpXS5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc2V0U2tpbkJ5TmFtZSA9IGZ1bmN0aW9uIChza2luTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNraW4gPSB0aGlzLmRhdGEuZmluZFNraW4oc2tpbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNraW4gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIG5vdCBmb3VuZDogXCIgKyBza2luTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNraW4oc2tpbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zZXRTa2luID0gZnVuY3Rpb24gKG5ld1NraW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdTa2luID09IHRoaXMuc2tpbilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U2tpbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2tpbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTa2luLmF0dGFjaEFsbCh0aGlzLCB0aGlzLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzbG90LmRhdGEuYXR0YWNobWVudE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZV8xICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ld1NraW4uZ2V0QXR0YWNobWVudChpLCBuYW1lXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbiA9IG5ld1NraW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5nZXRBdHRhY2htZW50QnlOYW1lID0gZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0YWNobWVudCh0aGlzLmRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSksIGF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmdldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0YWNobWVudE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2tpbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLnNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuZGVmYXVsdFNraW4gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmRlZmF1bHRTa2luLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbG90TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmRhdGEubmFtZSA9PSBzbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50TmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50KGksIGF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgYXR0YWNobWVudE5hbWUgKyBcIiwgZm9yIHNsb3Q6IFwiICsgc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmZpbmRJa0NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpa0NvbnN0cmFpbnQgPSBpa0NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpa0NvbnN0cmFpbnQuZGF0YS5uYW1lID09IGNvbnN0cmFpbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWtDb25zdHJhaW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kVHJhbnNmb3JtQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUNvbnN0cmFpbnRzID0gdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludC5kYXRhLm5hbWUgPT0gY29uc3RyYWludE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJhaW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kUGF0aENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gcGF0aENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhdGEubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChvZmZzZXQsIHNpemUsIHRlbXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHsgdGVtcCA9IG5ldyBBcnJheSgyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9mZnNldCBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNpemUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlciA9IHRoaXMuZHJhd09yZGVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IGRyYXdPcmRlcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3QuYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgY29yZS5SZWdpb25BdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzTGVuZ3RoID0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0ZW1wLCB2ZXJ0aWNlc0xlbmd0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdC5ib25lLCB2ZXJ0aWNlcywgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLk1lc2hBdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNoID0gYXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSBtZXNoLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGVtcCwgdmVydGljZXNMZW5ndGgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIHZlcnRpY2VzTGVuZ3RoLCB2ZXJ0aWNlcywgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGlpIDwgbm47IGlpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdmVydGljZXNbaWldLCB5ID0gdmVydGljZXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldC5zZXQobWluWCwgbWluWSk7XHJcbiAgICAgICAgICAgICAgICBzaXplLnNldChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTa2VsZXRvbi5wcm90b3R5cGUsIFwiZmxpcFhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID09IC0xO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTa2VsZXRvbi5kZXByZWNhdGVkV2FybmluZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2tlbGV0b24uZGVwcmVjYXRlZFdhcm5pbmcxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3BpbmUgRGVwcmVjYXRpb24gV2FybmluZzogYFNrZWxldG9uLmZsaXBYL2ZsaXBZYCB3YXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzY2FsZVgvc2NhbGVZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHZhbHVlID8gMS4wIDogLTEuMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNrZWxldG9uLnByb3RvdHlwZSwgXCJmbGlwWVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVkgPT0gLTE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVNrZWxldG9uLmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTa2VsZXRvbi5kZXByZWNhdGVkV2FybmluZzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBgU2tlbGV0b24uZmxpcFgvZmxpcFlgIHdhcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHNjYWxlWC9zY2FsZVlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gdmFsdWUgPyAxLjAgOiAtMS4wO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5kZXByZWNhdGVkV2FybmluZzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrZWxldG9uO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ta2VsZXRvbiA9IFNrZWxldG9uO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFNrZWxldG9uQmluYXJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2tlbGV0b25CaW5hcnkoYXR0YWNobWVudExvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZE1lc2hlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TG9hZGVyID0gYXR0YWNobWVudExvYWRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZFNrZWxldG9uRGF0YSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tlbGV0b25EYXRhID0gbmV3IGNvcmUuU2tlbGV0b25EYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEubmFtZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgQmluYXJ5SW5wdXQoYmluYXJ5KTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5oYXNoID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnZlcnNpb24gPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b25EYXRhLnZlcnNpb24gPT09ICczLjguNzUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gXCJVbnN1cHBvcnRlZCBza2VsZXRvbiBkYXRhLCAzLjguNzUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGV4cG9ydCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBTcGluZS5cIjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS54ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEueSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLndpZHRoID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuaGVpZ2h0ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9uZXNzZW50aWFsID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuZnBzID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmltYWdlc1BhdGggPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmF1ZGlvUGF0aCA9IGlucHV0LnJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc3RyaW5ncy5wdXNoKGlucHV0LnJlYWRTdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGlucHV0LnJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzIgPSBpID09IDAgPyBudWxsIDogc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuQm9uZURhdGEoaSwgbmFtZV8yLCBwYXJlbnRfMik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGlvbiA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEueCA9IGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS55ID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNjYWxlWCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2NhbGVZID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zaGVhclggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNoZWFyWSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRyYW5zZm9ybU1vZGUgPSBTa2VsZXRvbkJpbmFyeS5UcmFuc2Zvcm1Nb2RlVmFsdWVzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9uZXNzZW50aWFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihkYXRhLmNvbG9yLCBpbnB1dC5yZWFkSW50MzIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmJvbmVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3ROYW1lID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lRGF0YSA9IHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLlNsb3REYXRhKGksIHNsb3ROYW1lLCBib25lRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IoZGF0YS5jb2xvciwgaW5wdXQucmVhZEludDMyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXJrQ29sb3IgPSBpbnB1dC5yZWFkSW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGFya0NvbG9yICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYjg4OFRvQ29sb3IoZGF0YS5kYXJrQ29sb3IgPSBuZXcgY29yZS5Db2xvcigpLCBkYXJrQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYXR0YWNobWVudE5hbWUgPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5ibGVuZE1vZGUgPSBTa2VsZXRvbkJpbmFyeS5CbGVuZE1vZGVWYWx1ZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNsb3RzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBubiA9IHZvaWQgMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuSWtDb25zdHJhaW50RGF0YShpbnB1dC5yZWFkU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3JkZXIgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJvbmVzLnB1c2goc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc29mdG5lc3MgPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYmVuZERpcmVjdGlvbiA9IGlucHV0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb21wcmVzcyA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdHJldGNoID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnVuaWZvcm0gPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5pa0NvbnN0cmFpbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBubiA9IHZvaWQgMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludERhdGEoaW5wdXQucmVhZFN0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9yZGVyID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNraW5SZXF1aXJlZCA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBubjsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ib25lcy5wdXNoKHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50YXJnZXQgPSBza2VsZXRvbkRhdGEuYm9uZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5sb2NhbCA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWxhdGl2ZSA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRSb3RhdGlvbiA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0WCA9IGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRZID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFNjYWxlWCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0U2NhbGVZID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRTaGVhclkgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdGF0ZU1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlTWl4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zY2FsZU1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2hlYXJNaXggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEudHJhbnNmb3JtQ29uc3RyYWludHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5uID0gdm9pZCAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5QYXRoQ29uc3RyYWludERhdGEoaW5wdXQucmVhZFN0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9yZGVyID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNraW5SZXF1aXJlZCA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBubjsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ib25lcy5wdXNoKHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50YXJnZXQgPSBza2VsZXRvbkRhdGEuc2xvdHNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbk1vZGUgPSBTa2VsZXRvbkJpbmFyeS5Qb3NpdGlvbk1vZGVWYWx1ZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zcGFjaW5nTW9kZSA9IFNrZWxldG9uQmluYXJ5LlNwYWNpbmdNb2RlVmFsdWVzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucm90YXRlTW9kZSA9IFNrZWxldG9uQmluYXJ5LlJvdGF0ZU1vZGVWYWx1ZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRSb3RhdGlvbiA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbk1vZGUgPT0gY29yZS5Qb3NpdGlvbk1vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zcGFjaW5nID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc3BhY2luZ01vZGUgPT0gY29yZS5TcGFjaW5nTW9kZS5MZW5ndGggfHwgZGF0YS5zcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkZpeGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwYWNpbmcgKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGVNaXggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRyYW5zbGF0ZU1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5wYXRoQ29uc3RyYWludHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0U2tpbiA9IHRoaXMucmVhZFNraW4oaW5wdXQsIHNrZWxldG9uRGF0YSwgdHJ1ZSwgbm9uZXNzZW50aWFsKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0U2tpbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmRlZmF1bHRTa2luID0gZGVmYXVsdFNraW47XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNraW5zLnB1c2goZGVmYXVsdFNraW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gc2tlbGV0b25EYXRhLnNraW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShza2VsZXRvbkRhdGEuc2tpbnMsIG4gPSBpICsgaW5wdXQucmVhZEludCh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5za2luc1tpXSA9IHRoaXMucmVhZFNraW4oaW5wdXQsIHNrZWxldG9uRGF0YSwgZmFsc2UsIG5vbmVzc2VudGlhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuID0gdGhpcy5saW5rZWRNZXNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua2VkTWVzaCA9IHRoaXMubGlua2VkTWVzaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBza2luID0gbGlua2VkTWVzaC5za2luID09IG51bGwgPyBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gOiBza2VsZXRvbkRhdGEuZmluZFNraW4obGlua2VkTWVzaC5za2luKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIG5vdCBmb3VuZDogXCIgKyBsaW5rZWRNZXNoLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMyA9IHNraW4uZ2V0QXR0YWNobWVudChsaW5rZWRNZXNoLnNsb3RJbmRleCwgbGlua2VkTWVzaC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfMyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgbWVzaCBub3QgZm91bmQ6IFwiICsgbGlua2VkTWVzaC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZE1lc2gubWVzaC5kZWZvcm1BdHRhY2htZW50ID0gbGlua2VkTWVzaC5pbmhlcml0RGVmb3JtID8gcGFyZW50XzMgOiBsaW5rZWRNZXNoLm1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkTWVzaC5tZXNoLnNldFBhcmVudE1lc2gocGFyZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rZWRNZXNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLkV2ZW50RGF0YShpbnB1dC5yZWFkU3RyaW5nUmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaW50VmFsdWUgPSBpbnB1dC5yZWFkSW50KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZsb2F0VmFsdWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnN0cmluZ1ZhbHVlID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYXVkaW9QYXRoID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmF1ZGlvUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudm9sdW1lID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmFsYW5jZSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuZXZlbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5hbmltYXRpb25zLnB1c2godGhpcy5yZWFkQW5pbWF0aW9uKGlucHV0LCBpbnB1dC5yZWFkU3RyaW5nKCksIHNrZWxldG9uRGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNrZWxldG9uRGF0YTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkucHJvdG90eXBlLnJlYWRTa2luID0gZnVuY3Rpb24gKGlucHV0LCBza2VsZXRvbkRhdGEsIGRlZmF1bHRTa2luLCBub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBza2luID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90Q291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRTa2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdENvdW50ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNraW4gPSBuZXcgY29yZS5Ta2luKFwiZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNraW4gPSBuZXcgY29yZS5Ta2luKGlucHV0LnJlYWRTdHJpbmdSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpbi5ib25lcy5sZW5ndGggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tpbi5ib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uYm9uZXNbaV0gPSBza2VsZXRvbkRhdGEuYm9uZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2luLmNvbnN0cmFpbnRzLnB1c2goc2tlbGV0b25EYXRhLmlrQ29uc3RyYWludHNbaW5wdXQucmVhZEludCh0cnVlKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5wdXQucmVhZEludCh0cnVlKTsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5jb25zdHJhaW50cy5wdXNoKHNrZWxldG9uRGF0YS50cmFuc2Zvcm1Db25zdHJhaW50c1tpbnB1dC5yZWFkSW50KHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2luLmNvbnN0cmFpbnRzLnB1c2goc2tlbGV0b25EYXRhLnBhdGhDb25zdHJhaW50c1tpbnB1dC5yZWFkSW50KHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xvdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDAsIG5uID0gaW5wdXQucmVhZEludCh0cnVlKTsgaWkgPCBubjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8zID0gaW5wdXQucmVhZFN0cmluZ1JlZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMucmVhZEF0dGFjaG1lbnQoaW5wdXQsIHNrZWxldG9uRGF0YSwgc2tpbiwgc2xvdEluZGV4LCBuYW1lXzMsIG5vbmVzc2VudGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2luLnNldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBuYW1lXzMsIGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBza2luO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoaW5wdXQsIHNrZWxldG9uRGF0YSwgc2tpbiwgc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSwgbm9uZXNzZW50aWFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRhY2htZW50TmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5kZXggPSBpbnB1dC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTa2VsZXRvbkJpbmFyeS5BdHRhY2htZW50VHlwZVZhbHVlc1t0eXBlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLkF0dGFjaG1lbnRUeXBlLlJlZ2lvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpbnB1dC5yZWFkSW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1JlZ2lvbkF0dGFjaG1lbnQoc2tpbiwgbmFtZSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdpb24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi54ID0geCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ueSA9IHkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnNjYWxlWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnNjYWxlWSA9IHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnJvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IHdpZHRoICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5oZWlnaHQgPSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IocmVnaW9uLmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5BdHRhY2htZW50VHlwZS5Cb3VuZGluZ0JveDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnJlYWRWZXJ0aWNlcyhpbnB1dCwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBub25lc3NlbnRpYWwgPyBpbnB1dC5yZWFkSW50MzIoKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Qm91bmRpbmdCb3hBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm94ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94LndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3gudmVydGljZXMgPSB2ZXJ0aWNlcy52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmJvbmVzID0gdmVydGljZXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihib3guY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLkF0dGFjaG1lbnRUeXBlLk1lc2g6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGlucHV0LnJlYWRJbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXZzID0gdGhpcy5yZWFkRmxvYXRBcnJheShpbnB1dCwgdmVydGV4Q291bnQgPDwgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnJlYWRTaG9ydEFycmF5KGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5yZWFkVmVydGljZXMoaW5wdXQsIHZlcnRleENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh1bGxMZW5ndGggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9uZXNzZW50aWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IHRoaXMucmVhZFNob3J0QXJyYXkoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc2ggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3TWVzaEF0dGFjaG1lbnQoc2tpbiwgbmFtZSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNoID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IobWVzaC5jb2xvciwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmJvbmVzID0gdmVydGljZXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gudmVydGljZXMgPSB2ZXJ0aWNlcy52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC53b3JsZFZlcnRpY2VzTGVuZ3RoID0gdmVydGV4Q291bnQgPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC50cmlhbmdsZXMgPSB0cmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gucmVnaW9uVVZzID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmh1bGxMZW5ndGggPSBodWxsTGVuZ3RoIDw8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guZWRnZXMgPSBlZGdlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gud2lkdGggPSB3aWR0aCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5oZWlnaHQgPSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLkF0dGFjaG1lbnRUeXBlLkxpbmtlZE1lc2g6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGlucHV0LnJlYWRJbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbk5hbWUgPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfNCA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaGVyaXREZWZvcm0gPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9uZXNzZW50aWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdNZXNoQXR0YWNobWVudChza2luLCBuYW1lLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc2ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihtZXNoLmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gud2lkdGggPSB3aWR0aCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5oZWlnaHQgPSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZE1lc2hlcy5wdXNoKG5ldyBMaW5rZWRNZXNoKG1lc2gsIHNraW5OYW1lLCBzbG90SW5kZXgsIHBhcmVudF80LCBpbmhlcml0RGVmb3JtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuUGF0aDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VkXzEgPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RhbnRTcGVlZCA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMucmVhZFZlcnRpY2VzKGlucHV0LCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhzID0gY29yZS5VdGlscy5uZXdBcnJheSh2ZXJ0ZXhDb3VudCAvIDMsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxlbmd0aHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1tpXSA9IGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5vbmVzc2VudGlhbCA/IGlucHV0LnJlYWRJbnQzMigpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3UGF0aEF0dGFjaG1lbnQoc2tpbiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jbG9zZWQgPSBjbG9zZWRfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb25zdGFudFNwZWVkID0gY29uc3RhbnRTcGVlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC53b3JsZFZlcnRpY2VzTGVuZ3RoID0gdmVydGV4Q291bnQgPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC52ZXJ0aWNlcyA9IHZlcnRpY2VzLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmJvbmVzID0gdmVydGljZXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGVuZ3RocyA9IGxlbmd0aHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihwYXRoLmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuUG9pbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5vbmVzc2VudGlhbCA/IGlucHV0LnJlYWRJbnQzMigpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1BvaW50QXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHggKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKHBvaW50LmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLkF0dGFjaG1lbnRUeXBlLkNsaXBwaW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRTbG90SW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnJlYWRWZXJ0aWNlcyhpbnB1dCwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBub25lc3NlbnRpYWwgPyBpbnB1dC5yZWFkSW50MzIoKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld0NsaXBwaW5nQXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXAgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmVuZFNsb3QgPSBza2VsZXRvbkRhdGEuc2xvdHNbZW5kU2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC53b3JsZFZlcnRpY2VzTGVuZ3RoID0gdmVydGV4Q291bnQgPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC52ZXJ0aWNlcyA9IHZlcnRpY2VzLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmJvbmVzID0gdmVydGljZXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihjbGlwLmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGlwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZFZlcnRpY2VzID0gZnVuY3Rpb24gKGlucHV0LCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzTGVuZ3RoID0gdmVydGV4Q291bnQgPDwgMTtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGlmICghaW5wdXQucmVhZEJvb2xlYW4oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnZlcnRpY2VzID0gdGhpcy5yZWFkRmxvYXRBcnJheShpbnB1dCwgdmVydGljZXNMZW5ndGgsIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzQXJyYXkgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lQ291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVzQXJyYXkucHVzaChib25lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBib25lQ291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZXNBcnJheS5wdXNoKGlucHV0LnJlYWRJbnQodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2goaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaChpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0cy5wdXNoKGlucHV0LnJlYWRGbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy52ZXJ0aWNlcyA9IGNvcmUuVXRpbHMudG9GbG9hdEFycmF5KHdlaWdodHMpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuYm9uZXMgPSBib25lc0FycmF5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZEZsb2F0QXJyYXkgPSBmdW5jdGlvbiAoaW5wdXQsIG4sIHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkucHJvdG90eXBlLnJlYWRTaG9ydEFycmF5ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGlucHV0LnJlYWRTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgc2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wQ29sb3IxID0gbmV3IGNvcmUuQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wQ29sb3IyID0gbmV3IGNvcmUuQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5wdXQucmVhZEludCh0cnVlKTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpaSA8IG5uOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVR5cGUgPSBpbnB1dC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGltZWxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LlNMT1RfQVRUQUNITUVOVDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkF0dGFjaG1lbnRUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkU3RyaW5nUmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbZnJhbWVDb3VudCAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuU0xPVF9DT0xPUjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkNvbG9yVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lSW5kZXggPSAwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKHRlbXBDb2xvcjEsIGlucHV0LnJlYWRJbnQzMigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGltZSwgdGVtcENvbG9yMS5yLCB0ZW1wQ29sb3IxLmcsIHRlbXBDb2xvcjEuYiwgdGVtcENvbG9yMS5hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuQ29sb3JUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LlNMT1RfVFdPX0NPTE9SOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuVHdvQ29sb3JUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IodGVtcENvbG9yMSwgaW5wdXQucmVhZEludDMyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYjg4OFRvQ29sb3IodGVtcENvbG9yMiwgaW5wdXQucmVhZEludDMyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aW1lLCB0ZW1wQ29sb3IxLnIsIHRlbXBDb2xvcjEuZywgdGVtcENvbG9yMS5iLCB0ZW1wQ29sb3IxLmEsIHRlbXBDb2xvcjIuciwgdGVtcENvbG9yMi5nLCB0ZW1wQ29sb3IyLmIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA8IGZyYW1lQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoaW5wdXQsIGZyYW1lSW5kZXgsIHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1soZnJhbWVDb3VudCAtIDEpICogY29yZS5Ud29Db2xvclRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5wdXQucmVhZEludCh0cnVlKTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lSW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpaSA8IG5uOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVR5cGUgPSBpbnB1dC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGltZWxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LkJPTkVfUk9UQVRFOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuUm90YXRlVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lSW5kZXggPSAwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlJvdGF0ZVRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQk9ORV9UUkFOU0xBVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LkJPTkVfU0NBTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LkJPTkVfU0hFQVI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU2NhbGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT0gU2tlbGV0b25CaW5hcnkuQk9ORV9TQ0FMRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgY29yZS5TY2FsZVRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lVHlwZSA9PSBTa2VsZXRvbkJpbmFyeS5CT05FX1NIRUFSKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlNoZWFyVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuVHJhbnNsYXRlVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lSW5kZXggPSAwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSAqIHRpbWVsaW5lU2NhbGUsIGlucHV0LnJlYWRGbG9hdCgpICogdGltZWxpbmVTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5wdXQucmVhZEludCh0cnVlKTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lQ291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLklrQ29uc3RyYWludFRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmlrQ29uc3RyYWludEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlLCBpbnB1dC5yZWFkQnl0ZSgpLCBpbnB1dC5yZWFkQm9vbGVhbigpLCBpbnB1dC5yZWFkQm9vbGVhbigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnRyYW5zZm9ybUNvbnN0cmFpbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lSW5kZXggPSAwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2tlbGV0b25EYXRhLnBhdGhDb25zdHJhaW50c1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGlpIDwgbm47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lVHlwZSA9IGlucHV0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aW1lbGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuUEFUSF9QT1NJVElPTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuUEFUSF9TUEFDSU5HOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNjYWxlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVUeXBlID09IFNrZWxldG9uQmluYXJ5LlBBVEhfU1BBQ0lORykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkxlbmd0aCB8fCBkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb25Nb2RlID09IGNvcmUuUG9zaXRpb25Nb2RlLkZpeGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5wYXRoQ29uc3RyYWludEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpICogdGltZWxpbmVTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LlBBVEhfTUlYOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5wYXRoQ29uc3RyYWludEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNraW4gPSBza2VsZXRvbkRhdGEuc2tpbnNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGlpIDwgbm47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpaSA9IDAsIG5ubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGlpaSA8IG5ubjsgaWlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgaW5wdXQucmVhZFN0cmluZ1JlZigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZCA9IGF0dGFjaG1lbnQuYm9uZXMgIT0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGF0dGFjaG1lbnQudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmb3JtTGVuZ3RoID0gd2VpZ2h0ZWQgPyB2ZXJ0aWNlcy5sZW5ndGggLyAzICogMiA6IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkRlZm9ybVRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZm9ybSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybSA9IHdlaWdodGVkID8gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGRlZm9ybUxlbmd0aCkgOiB2ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGRlZm9ybUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSBzdGFydDsgdiA8IGVuZDsgdisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVt2XSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdiA9IHN0YXJ0OyB2IDwgZW5kOyB2KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW3ZdID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlaWdodGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gMCwgdm4gPSBkZWZvcm0ubGVuZ3RoOyB2IDwgdm47IHYrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1bdl0gKz0gdmVydGljZXNbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGltZSwgZGVmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA8IGZyYW1lQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW2ZyYW1lQ291bnQgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyQ291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdPcmRlckNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkRyYXdPcmRlclRpbWVsaW5lKGRyYXdPcmRlckNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdENvdW50ID0gc2tlbGV0b25EYXRhLnNsb3RzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYXdPcmRlckNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldENvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlciA9IGNvcmUuVXRpbHMubmV3QXJyYXkoc2xvdENvdW50LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSBzbG90Q291bnQgLSAxOyBpaSA+PSAwOyBpaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW2lpXSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5jaGFuZ2VkID0gY29yZS5VdGlscy5uZXdBcnJheShzbG90Q291bnQgLSBvZmZzZXRDb3VudCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0gMCwgdW5jaGFuZ2VkSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb2Zmc2V0Q291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsSW5kZXggIT0gc2xvdEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZFt1bmNoYW5nZWRJbmRleCsrXSA9IG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcmRlcltvcmlnaW5hbEluZGV4ICsgaW5wdXQucmVhZEludCh0cnVlKV0gPSBvcmlnaW5hbEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsSW5kZXggPCBzbG90Q291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNoYW5nZWRbdW5jaGFuZ2VkSW5kZXgrK10gPSBvcmlnaW5hbEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gc2xvdENvdW50IC0gMTsgaWkgPj0gMDsgaWktLSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXJbaWldID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcmRlcltpaV0gPSB1bmNoYW5nZWRbLS11bmNoYW5nZWRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGksIHRpbWUsIGRyYXdPcmRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbZHJhd09yZGVyQ291bnQgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5FdmVudFRpbWVsaW5lKGV2ZW50Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudERhdGEgPSBza2VsZXRvbkRhdGEuZXZlbnRzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfNCA9IG5ldyBjb3JlLkV2ZW50KHRpbWUsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzQuaW50VmFsdWUgPSBpbnB1dC5yZWFkSW50KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNC5mbG9hdFZhbHVlID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzQuc3RyaW5nVmFsdWUgPSBpbnB1dC5yZWFkQm9vbGVhbigpID8gaW5wdXQucmVhZFN0cmluZygpIDogZXZlbnREYXRhLnN0cmluZ1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRfNC5kYXRhLmF1ZGlvUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF80LnZvbHVtZSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNC5iYWxhbmNlID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoaSwgZXZlbnRfNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbZXZlbnRDb3VudCAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5BbmltYXRpb24obmFtZSwgdGltZWxpbmVzLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkQ3VydmUgPSBmdW5jdGlvbiAoaW5wdXQsIGZyYW1lSW5kZXgsIHRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0LnJlYWRCeXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFNrZWxldG9uQmluYXJ5LkNVUlZFX1NURVBQRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldFN0ZXBwZWQoZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQ1VSVkVfQkVaSUVSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUuc2V0Q3VydmUgPSBmdW5jdGlvbiAodGltZWxpbmUsIGZyYW1lSW5kZXgsIGN4MSwgY3kxLCBjeDIsIGN5Mikge1xyXG4gICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0Q3VydmUoZnJhbWVJbmRleCwgY3gxLCBjeTEsIGN4MiwgY3kyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQXR0YWNobWVudFR5cGVWYWx1ZXMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNl07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlRyYW5zZm9ybU1vZGVWYWx1ZXMgPSBbY29yZS5UcmFuc2Zvcm1Nb2RlLk5vcm1hbCwgY29yZS5UcmFuc2Zvcm1Nb2RlLk9ubHlUcmFuc2xhdGlvbiwgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vUm90YXRpb25PclJlZmxlY3Rpb24sIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlLCBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbl07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlBvc2l0aW9uTW9kZVZhbHVlcyA9IFtjb3JlLlBvc2l0aW9uTW9kZS5GaXhlZCwgY29yZS5Qb3NpdGlvbk1vZGUuUGVyY2VudF07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlNwYWNpbmdNb2RlVmFsdWVzID0gW2NvcmUuU3BhY2luZ01vZGUuTGVuZ3RoLCBjb3JlLlNwYWNpbmdNb2RlLkZpeGVkLCBjb3JlLlNwYWNpbmdNb2RlLlBlcmNlbnRdO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5Sb3RhdGVNb2RlVmFsdWVzID0gW2NvcmUuUm90YXRlTW9kZS5UYW5nZW50LCBjb3JlLlJvdGF0ZU1vZGUuQ2hhaW4sIGNvcmUuUm90YXRlTW9kZS5DaGFpblNjYWxlXTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQmxlbmRNb2RlVmFsdWVzID0gW2NvcmUuQmxlbmRNb2RlLk5vcm1hbCwgY29yZS5CbGVuZE1vZGUuQWRkaXRpdmUsIGNvcmUuQmxlbmRNb2RlLk11bHRpcGx5LCBjb3JlLkJsZW5kTW9kZS5TY3JlZW5dO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5CT05FX1JPVEFURSA9IDA7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LkJPTkVfVFJBTlNMQVRFID0gMTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQk9ORV9TQ0FMRSA9IDI7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LkJPTkVfU0hFQVIgPSAzO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5TTE9UX0FUVEFDSE1FTlQgPSAwO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5TTE9UX0NPTE9SID0gMTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuU0xPVF9UV09fQ09MT1IgPSAyO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5QQVRIX1BPU0lUSU9OID0gMDtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuUEFUSF9TUEFDSU5HID0gMTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuUEFUSF9NSVggPSAyO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5DVVJWRV9MSU5FQVIgPSAwO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5DVVJWRV9TVEVQUEVEID0gMTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQ1VSVkVfQkVaSUVSID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFNrZWxldG9uQmluYXJ5O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ta2VsZXRvbkJpbmFyeSA9IFNrZWxldG9uQmluYXJ5O1xyXG4gICAgICAgIHZhciBCaW5hcnlJbnB1dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJpbmFyeUlucHV0KGRhdGEsIHN0cmluZ3MsIGluZGV4LCBidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzID09PSB2b2lkIDApIHsgc3RyaW5ncyA9IG5ldyBBcnJheSgpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmIChidWZmZXIgPT09IHZvaWQgMCkgeyBidWZmZXIgPSBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIpOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmdldEludDgodGhpcy5pbmRleCsrKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRTaG9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuYnVmZmVyLmdldEludDE2KHRoaXMuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5hcnlJbnB1dC5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0SW50MzIodGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmFyeUlucHV0LnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24gKG9wdGltaXplUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGIgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgaWYgKChiICYgMHg4MCkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IChiICYgMHg3RikgPDwgNztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGIgJiAweDgwKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAoYiAmIDB4N0YpIDw8IDE0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGIgJiAweDgwKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IChiICYgMHg3RikgPDwgMjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGIgJiAweDgwKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAyODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpbWl6ZVBvc2l0aXZlID8gcmVzdWx0IDogKChyZXN1bHQgPj4+IDEpIF4gLShyZXN1bHQgJiAxKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmFyeUlucHV0LnByb3RvdHlwZS5yZWFkU3RyaW5nUmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09IDAgPyBudWxsIDogdGhpcy5zdHJpbmdzW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmFyeUlucHV0LnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IHRoaXMucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnl0ZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVDb3VudDspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIgPj4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGIgJiAweDFGKSA8PCA2IHwgdGhpcy5yZWFkQnl0ZSgpICYgMHgzRikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYiAmIDB4MEYpIDw8IDEyIHwgKHRoaXMucmVhZEJ5dGUoKSAmIDB4M0YpIDw8IDYgfCB0aGlzLnJlYWRCeXRlKCkgJiAweDNGKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5hcnlJbnB1dC5wcm90b3R5cGUucmVhZEZsb2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0RmxvYXQzMih0aGlzLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRCb29sZWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJ5dGUoKSAhPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQmluYXJ5SW5wdXQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB2YXIgTGlua2VkTWVzaCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIExpbmtlZE1lc2gobWVzaCwgc2tpbiwgc2xvdEluZGV4LCBwYXJlbnQsIGluaGVyaXREZWZvcm0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW4gPSBza2luO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5oZXJpdERlZm9ybSA9IGluaGVyaXREZWZvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIExpbmtlZE1lc2g7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB2YXIgVmVydGljZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBWZXJ0aWNlcyhib25lcywgdmVydGljZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib25lcyA9PT0gdm9pZCAwKSB7IGJvbmVzID0gbnVsbDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzID09PSB2b2lkIDApIHsgdmVydGljZXMgPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gYm9uZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFZlcnRpY2VzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2tlbGV0b25Cb3VuZHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTa2VsZXRvbkJvdW5kcygpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4WSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94ZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbnMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvblBvb2wgPSBuZXcgY29yZS5Qb29sKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KDE2KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2tlbGV0b24sIHVwZGF0ZUFhYmIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ0JveGVzID0gdGhpcy5ib3VuZGluZ0JveGVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uUG9vbCA9IHRoaXMucG9seWdvblBvb2w7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcclxuICAgICAgICAgICAgICAgIHZhciBzbG90Q291bnQgPSBzbG90cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUG9vbC5mcmVlQWxsKHBvbHlnb25zKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsb3RDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3QuYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLkJvdW5kaW5nQm94QXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ0JveGVzLnB1c2goYm91bmRpbmdCb3gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25Qb29sLm9idGFpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggIT0gYm91bmRpbmdCb3gud29ybGRWZXJ0aWNlc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCBib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoLCBwb2x5Z29uLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWFiYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWFiYkNvbXB1dGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmFhYmJDb21wdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHBvbHlnb247XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IHBvbHlnb24ubGVuZ3RoOyBpaSA8IG5uOyBpaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdmVydGljZXNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHZlcnRpY2VzW2lpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4WCA9IG1heFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuYWFiYkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPj0gdGhpcy5taW5YICYmIHggPD0gdGhpcy5tYXhYICYmIHkgPj0gdGhpcy5taW5ZICYmIHkgPD0gdGhpcy5tYXhZO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuYWFiYkludGVyc2VjdHNTZWdtZW50ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcclxuICAgICAgICAgICAgICAgIGlmICgoeDEgPD0gbWluWCAmJiB4MiA8PSBtaW5YKSB8fCAoeTEgPD0gbWluWSAmJiB5MiA8PSBtaW5ZKSB8fCAoeDEgPj0gbWF4WCAmJiB4MiA+PSBtYXhYKSB8fCAoeTEgPj0gbWF4WSAmJiB5MiA+PSBtYXhZKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9ICh5MiAtIHkxKSAvICh4MiAtIHgxKTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gbSAqIChtaW5YIC0geDEpICsgeTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IG1pblkgJiYgeSA8IG1heFkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB5ID0gbSAqIChtYXhYIC0geDEpICsgeTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IG1pblkgJiYgeSA8IG1heFkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IChtaW5ZIC0geTEpIC8gbSArIHgxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPiBtaW5YICYmIHggPCBtYXhYKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgeCA9IChtYXhZIC0geTEpIC8gbSArIHgxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPiBtaW5YICYmIHggPCBtYXhYKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuYWFiYkludGVyc2VjdHNTa2VsZXRvbiA9IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pblggPCBib3VuZHMubWF4WCAmJiB0aGlzLm1heFggPiBib3VuZHMubWluWCAmJiB0aGlzLm1pblkgPCBib3VuZHMubWF4WSAmJiB0aGlzLm1heFkgPiBib3VuZHMubWluWTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnRQb2x5Z29uKHBvbHlnb25zW2ldLCB4LCB5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3hlc1tpXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuY29udGFpbnNQb2ludFBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbiwgeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbjtcclxuICAgICAgICAgICAgICAgIHZhciBubiA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IG5uIC0gMjtcclxuICAgICAgICAgICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBubjsgaWkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhZID0gdmVydGljZXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlkgPSB2ZXJ0aWNlc1twcmV2SW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZlcnRleFkgPCB5ICYmIHByZXZZID49IHkpIHx8IChwcmV2WSA8IHkgJiYgdmVydGV4WSA+PSB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4WCA9IHZlcnRpY2VzW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleFggKyAoeSAtIHZlcnRleFkpIC8gKHByZXZZIC0gdmVydGV4WSkgKiAodmVydGljZXNbcHJldkluZGV4XSAtIHZlcnRleFgpIDwgeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IGlpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc2lkZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmludGVyc2VjdHNTZWdtZW50ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1NlZ21lbnRQb2x5Z29uKHBvbHlnb25zW2ldLCB4MSwgeTEsIHgyLCB5MikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94ZXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmludGVyc2VjdHNTZWdtZW50UG9seWdvbiA9IGZ1bmN0aW9uIChwb2x5Z29uLCB4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbjtcclxuICAgICAgICAgICAgICAgIHZhciBubiA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoMTIgPSB4MSAtIHgyLCBoZWlnaHQxMiA9IHkxIC0geTI7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGV0MSA9IHgxICogeTIgLSB5MSAqIHgyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgzID0gdmVydGljZXNbbm4gLSAyXSwgeTMgPSB2ZXJ0aWNlc1tubiAtIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHg0ID0gdmVydGljZXNbaWldLCB5NCA9IHZlcnRpY2VzW2lpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldDIgPSB4MyAqIHk0IC0geTMgKiB4NDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGgzNCA9IHgzIC0geDQsIGhlaWdodDM0ID0geTMgLSB5NDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0MyA9IHdpZHRoMTIgKiBoZWlnaHQzNCAtIGhlaWdodDEyICogd2lkdGgzNDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IChkZXQxICogd2lkdGgzNCAtIHdpZHRoMTIgKiBkZXQyKSAvIGRldDM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoeCA+PSB4MyAmJiB4IDw9IHg0KSB8fCAoeCA+PSB4NCAmJiB4IDw9IHgzKSkgJiYgKCh4ID49IHgxICYmIHggPD0geDIpIHx8ICh4ID49IHgyICYmIHggPD0geDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IChkZXQxICogaGVpZ2h0MzQgLSBoZWlnaHQxMiAqIGRldDIpIC8gZGV0MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoeSA+PSB5MyAmJiB5IDw9IHk0KSB8fCAoeSA+PSB5NCAmJiB5IDw9IHkzKSkgJiYgKCh5ID49IHkxICYmIHkgPD0geTIpIHx8ICh5ID49IHkyICYmIHkgPD0geTEpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4MyA9IHg0O1xyXG4gICAgICAgICAgICAgICAgICAgIHkzID0geTQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5nZXRQb2x5Z29uID0gZnVuY3Rpb24gKGJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRpbmdCb3ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3VuZGluZ0JveCBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmJvdW5kaW5nQm94ZXMuaW5kZXhPZihib3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT0gLTEgPyBudWxsIDogdGhpcy5wb2x5Z29uc1tpbmRleF07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2tlbGV0b25Cb3VuZHM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNrZWxldG9uQm91bmRzID0gU2tlbGV0b25Cb3VuZHM7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2tlbGV0b25DbGlwcGluZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNrZWxldG9uQ2xpcHBpbmcoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWFuZ3VsYXRvciA9IG5ldyBjb3JlLlRyaWFuZ3VsYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGluZ1BvbHlnb24gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcE91dHB1dCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGVkVmVydGljZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcHBlZFRyaWFuZ2xlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JhdGNoID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcFN0YXJ0ID0gZnVuY3Rpb24gKHNsb3QsIGNsaXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXBBdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBBdHRhY2htZW50ID0gY2xpcDtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gY2xpcC53b3JsZFZlcnRpY2VzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy5jbGlwcGluZ1BvbHlnb24sIG4pO1xyXG4gICAgICAgICAgICAgICAgY2xpcC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCBuLCB2ZXJ0aWNlcywgMCwgMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpcHBpbmdQb2x5Z29uID0gdGhpcy5jbGlwcGluZ1BvbHlnb247XHJcbiAgICAgICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLm1ha2VDbG9ja3dpc2UoY2xpcHBpbmdQb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwcGluZ1BvbHlnb25zID0gdGhpcy5jbGlwcGluZ1BvbHlnb25zID0gdGhpcy50cmlhbmd1bGF0b3IuZGVjb21wb3NlKGNsaXBwaW5nUG9seWdvbiwgdGhpcy50cmlhbmd1bGF0b3IudHJpYW5ndWxhdGUoY2xpcHBpbmdQb2x5Z29uKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbl8yID0gY2xpcHBpbmdQb2x5Z29ucy5sZW5ndGg7IGkgPCBuXzI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gY2xpcHBpbmdQb2x5Z29uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLm1ha2VDbG9ja3dpc2UocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHBvbHlnb25bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaChwb2x5Z29uWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjbGlwcGluZ1BvbHlnb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcEVuZFdpdGhTbG90ID0gZnVuY3Rpb24gKHNsb3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXBBdHRhY2htZW50ICE9IG51bGwgJiYgdGhpcy5jbGlwQXR0YWNobWVudC5lbmRTbG90ID09IHNsb3QuZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBFbmQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXBBdHRhY2htZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwaW5nUG9seWdvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGVkVmVydGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGluZ1BvbHlnb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuaXNDbGlwcGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaXBBdHRhY2htZW50ICE9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQ2xpcHBpbmcucHJvdG90eXBlLmNsaXBUcmlhbmdsZXMgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRpY2VzTGVuZ3RoLCB0cmlhbmdsZXMsIHRyaWFuZ2xlc0xlbmd0aCwgdXZzLCBsaWdodCwgZGFyaywgdHdvQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwT3V0cHV0ID0gdGhpcy5jbGlwT3V0cHV0LCBjbGlwcGVkVmVydGljZXMgPSB0aGlzLmNsaXBwZWRWZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwcGVkVHJpYW5nbGVzID0gdGhpcy5jbGlwcGVkVHJpYW5nbGVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25zID0gdGhpcy5jbGlwcGluZ1BvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25zQ291bnQgPSB0aGlzLmNsaXBwaW5nUG9seWdvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleFNpemUgPSB0d29Db2xvciA/IDEyIDogODtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGNsaXBwZWRUcmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIG91dGVyOiBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlc0xlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IHRyaWFuZ2xlc1tpXSA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldF0sIHkxID0gdmVydGljZXNbdmVydGV4T2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUxID0gdXZzW3ZlcnRleE9mZnNldF0sIHYxID0gdXZzW3ZlcnRleE9mZnNldCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHRyaWFuZ2xlc1tpICsgMV0gPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXRdLCB5MiA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1MiA9IHV2c1t2ZXJ0ZXhPZmZzZXRdLCB2MiA9IHV2c1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgPSB0cmlhbmdsZXNbaSArIDJdIDw8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzID0gdmVydGljZXNbdmVydGV4T2Zmc2V0XSwgeTMgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdTMgPSB1dnNbdmVydGV4T2Zmc2V0XSwgdjMgPSB1dnNbdmVydGV4T2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwb2x5Z29uc0NvdW50OyBwKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBjbGlwcGVkVmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGlwKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHBvbHlnb25zW3BdLCBjbGlwT3V0cHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBPdXRwdXRMZW5ndGggPSBjbGlwT3V0cHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlwT3V0cHV0TGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZDAgPSB5MiAtIHkzLCBkMSA9IHgzIC0geDIsIGQyID0geDEgLSB4MywgZDQgPSB5MyAtIHkxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAxIC8gKGQwICogZDIgKyBkMSAqICh5MSAtIHkzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcE91dHB1dENvdW50ID0gY2xpcE91dHB1dExlbmd0aCA+PiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBPdXRwdXRJdGVtcyA9IHRoaXMuY2xpcE91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwcGVkVmVydGljZXNJdGVtcyA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKGNsaXBwZWRWZXJ0aWNlcywgcyArIGNsaXBPdXRwdXRDb3VudCAqIHZlcnRleFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNsaXBPdXRwdXRMZW5ndGg7IGlpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGNsaXBPdXRwdXRJdGVtc1tpaV0sIHkgPSBjbGlwT3V0cHV0SXRlbXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMl0gPSBsaWdodC5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzXSA9IGxpZ2h0Lmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDRdID0gbGlnaHQuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNV0gPSBsaWdodC5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMCA9IHggLSB4MywgYzEgPSB5IC0geTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAoZDAgKiBjMCArIGQxICogYzEpICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IChkNCAqIGMwICsgZDIgKiBjMSkgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMSAtIGEgLSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA2XSA9IHUxICogYSArIHUyICogYiArIHUzICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgN10gPSB2MSAqIGEgKyB2MiAqIGIgKyB2MyAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR3b0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA4XSA9IGRhcmsucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDldID0gZGFyay5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTBdID0gZGFyay5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTFdID0gZGFyay5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IHZlcnRleFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoY2xpcHBlZFRyaWFuZ2xlcywgcyArIDMgKiAoY2xpcE91dHB1dENvdW50IC0gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcE91dHB1dENvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDE7IGlpIDwgY2xpcE91dHB1dENvdW50OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3NdID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3MgKyAxXSA9IChpbmRleCArIGlpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVHJpYW5nbGVzSXRlbXNbcyArIDJdID0gKGluZGV4ICsgaWkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBjbGlwT3V0cHV0Q291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoY2xpcHBlZFZlcnRpY2VzLCBzICsgMyAqIHZlcnRleFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbc10gPSB4MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxXSA9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDJdID0gbGlnaHQucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzXSA9IGxpZ2h0Lmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNF0gPSBsaWdodC5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDVdID0gbGlnaHQuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHdvQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNl0gPSB1MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgN10gPSB2MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOF0gPSB4MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOV0gPSB5MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTBdID0gbGlnaHQucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTFdID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTJdID0gbGlnaHQuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTNdID0gbGlnaHQuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTRdID0gdTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE1XSA9IHYyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxNl0gPSB4MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTddID0geTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE4XSA9IGxpZ2h0LnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE5XSA9IGxpZ2h0Lmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIwXSA9IGxpZ2h0LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIxXSA9IGxpZ2h0LmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIyXSA9IHUzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyM10gPSB2MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA2XSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA3XSA9IHYxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA4XSA9IGRhcmsucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOV0gPSBkYXJrLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDEwXSA9IGRhcmsuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTFdID0gZGFyay5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMl0gPSB4MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTNdID0geTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE0XSA9IGxpZ2h0LnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE1XSA9IGxpZ2h0Lmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE2XSA9IGxpZ2h0LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE3XSA9IGxpZ2h0LmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE4XSA9IHUyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxOV0gPSB2MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjBdID0gZGFyay5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMV0gPSBkYXJrLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIyXSA9IGRhcmsuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjNdID0gZGFyay5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyNF0gPSB4MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjVdID0geTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI2XSA9IGxpZ2h0LnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI3XSA9IGxpZ2h0Lmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI4XSA9IGxpZ2h0LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI5XSA9IGxpZ2h0LmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDMwXSA9IHUzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzMV0gPSB2MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMzJdID0gZGFyay5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzM10gPSBkYXJrLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDM0XSA9IGRhcmsuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMzVdID0gZGFyay5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGNsaXBwZWRUcmlhbmdsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBwZWRUcmlhbmdsZXNJdGVtcyA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKGNsaXBwZWRUcmlhbmdsZXMsIHMgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRUcmlhbmdsZXNJdGVtc1tzXSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3MgKyAxXSA9IChpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3MgKyAyXSA9IChpbmRleCArIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNsaXBwaW5nQXJlYSwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxPdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChjbGlwcGluZ0FyZWEubGVuZ3RoICUgNCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5zY3JhdGNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGhpcy5zY3JhdGNoO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goeDEpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh5MSk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHgyKTtcclxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goeTIpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh4Myk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHkzKTtcclxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goeDEpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh5MSk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwcGluZ1ZlcnRpY2VzID0gY2xpcHBpbmdBcmVhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBwaW5nVmVydGljZXNMYXN0ID0gY2xpcHBpbmdBcmVhLmxlbmd0aCAtIDQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDs7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlWCA9IGNsaXBwaW5nVmVydGljZXNbaV0sIGVkZ2VZID0gY2xpcHBpbmdWZXJ0aWNlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VYMiA9IGNsaXBwaW5nVmVydGljZXNbaSArIDJdLCBlZGdlWTIgPSBjbGlwcGluZ1ZlcnRpY2VzW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gZWRnZVggLSBlZGdlWDIsIGRlbHRhWSA9IGVkZ2VZIC0gZWRnZVkyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dFZlcnRpY2VzID0gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0VmVydGljZXNMZW5ndGggPSBpbnB1dC5sZW5ndGggLSAyLCBvdXRwdXRTdGFydCA9IG91dHB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlucHV0VmVydGljZXNMZW5ndGg7IGlpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0WCA9IGlucHV0VmVydGljZXNbaWldLCBpbnB1dFkgPSBpbnB1dFZlcnRpY2VzW2lpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dFgyID0gaW5wdXRWZXJ0aWNlc1tpaSArIDJdLCBpbnB1dFkyID0gaW5wdXRWZXJ0aWNlc1tpaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZTIgPSBkZWx0YVggKiAoaW5wdXRZMiAtIGVkZ2VZMikgLSBkZWx0YVkgKiAoaW5wdXRYMiAtIGVkZ2VYMikgPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFYICogKGlucHV0WSAtIGVkZ2VZMikgLSBkZWx0YVkgKiAoaW5wdXRYIC0gZWRnZVgyKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGlucHV0WDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGlucHV0WTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMwID0gaW5wdXRZMiAtIGlucHV0WSwgYzIgPSBpbnB1dFgyIC0gaW5wdXRYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVhID0gKGMyICogKGVkZ2VZIC0gaW5wdXRZKSAtIGMwICogKGVkZ2VYIC0gaW5wdXRYKSkgLyAoYzAgKiAoZWRnZVgyIC0gZWRnZVgpIC0gYzIgKiAoZWRnZVkyIC0gZWRnZVkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVkZ2VYICsgKGVkZ2VYMiAtIGVkZ2VYKSAqIHVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVkZ2VZICsgKGVkZ2VZMiAtIGVkZ2VZKSAqIHVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMwID0gaW5wdXRZMiAtIGlucHV0WSwgYzIgPSBpbnB1dFgyIC0gaW5wdXRYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVhID0gKGMyICogKGVkZ2VZIC0gaW5wdXRZKSAtIGMwICogKGVkZ2VYIC0gaW5wdXRYKSkgLyAoYzAgKiAoZWRnZVgyIC0gZWRnZVgpIC0gYzIgKiAoZWRnZVkyIC0gZWRnZVkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVkZ2VYICsgKGVkZ2VYMiAtIGVkZ2VYKSAqIHVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVkZ2VZICsgKGVkZ2VZMiAtIGVkZ2VZKSAqIHVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGlucHV0WDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXRZMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRTdGFydCA9PSBvdXRwdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3V0cHV0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dHB1dFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gY2xpcHBpbmdWZXJ0aWNlc0xhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGVtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE91dHB1dCAhPSBvdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE91dHB1dC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb3V0cHV0Lmxlbmd0aCAtIDI7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3V0cHV0W2ldID0gb3V0cHV0W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3V0cHV0Lmxlbmd0aCA9IG9yaWdpbmFsT3V0cHV0Lmxlbmd0aCAtIDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpcHBlZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5tYWtlQ2xvY2t3aXNlID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHBvbHlnb247XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXNsZW5ndGggPSBwb2x5Z29uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gdmVydGljZXNbdmVydGljZXNsZW5ndGggLSAyXSAqIHZlcnRpY2VzWzFdIC0gdmVydGljZXNbMF0gKiB2ZXJ0aWNlc1t2ZXJ0aWNlc2xlbmd0aCAtIDFdLCBwMXggPSAwLCBwMXkgPSAwLCBwMnggPSAwLCBwMnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlc2xlbmd0aCAtIDM7IGkgPCBuOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwMXggPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBwMXkgPSB2ZXJ0aWNlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcDJ4ID0gdmVydGljZXNbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAyeSA9IHZlcnRpY2VzW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICBhcmVhICs9IHAxeCAqIHAyeSAtIHAyeCAqIHAxeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGFzdFggPSB2ZXJ0aWNlc2xlbmd0aCAtIDIsIG4gPSB2ZXJ0aWNlc2xlbmd0aCA+PiAxOyBpIDwgbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpXSwgeSA9IHZlcnRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsYXN0WCAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tvdGhlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaSArIDFdID0gdmVydGljZXNbb3RoZXIgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tvdGhlcl0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW290aGVyICsgMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2tlbGV0b25DbGlwcGluZztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2tlbGV0b25DbGlwcGluZyA9IFNrZWxldG9uQ2xpcHBpbmc7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2tlbGV0b25EYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2tlbGV0b25EYXRhKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pa0NvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb25zdHJhaW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcHMgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEJvbmUgPSBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib25lTmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvbmVOYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmUubmFtZSA9PSBib25lTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kQm9uZUluZGV4ID0gZnVuY3Rpb24gKGJvbmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9uZU5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib25lTmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmVzW2ldLm5hbWUgPT0gYm9uZU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRTbG90ID0gZnVuY3Rpb24gKHNsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbG90TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90Lm5hbWUgPT0gc2xvdE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZFNsb3RJbmRleCA9IGZ1bmN0aW9uIChzbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3ROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2xvdE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90c1tpXS5uYW1lID09IHNsb3ROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kU2tpbiA9IGZ1bmN0aW9uIChza2luTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNraW5OYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tpbk5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNraW5zID0gdGhpcy5za2lucztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tpbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNraW4gPSBza2luc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbi5uYW1lID09IHNraW5OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2tpbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRFdmVudCA9IGZ1bmN0aW9uIChldmVudERhdGFOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhTmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV2ZW50RGF0YU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBldmVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzUgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzUubmFtZSA9PSBldmVudERhdGFOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRfNTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbmltYXRpb25OYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24ubmFtZSA9PSBhbmltYXRpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZElrQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlrQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBpa0NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50Lm5hbWUgPT0gY29uc3RyYWludE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJhaW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZFRyYW5zZm9ybUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1Db25zdHJhaW50cyA9IHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gdHJhbnNmb3JtQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kUGF0aENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gcGF0aENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50Lm5hbWUgPT0gY29uc3RyYWludE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJhaW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZFBhdGhDb25zdHJhaW50SW5kZXggPSBmdW5jdGlvbiAocGF0aENvbnN0cmFpbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGF0aENvbnN0cmFpbnROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aENvbnN0cmFpbnRzW2ldLm5hbWUgPT0gcGF0aENvbnN0cmFpbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrZWxldG9uRGF0YTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2tlbGV0b25EYXRhID0gU2tlbGV0b25EYXRhO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgY29yZS5GQUlMX09OX05PTl9FWElTVElOR19TS0lOID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIFNrZWxldG9uSnNvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNrZWxldG9uSnNvbihhdHRhY2htZW50TG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlua2VkTWVzaGVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRMb2FkZXIgPSBhdHRhY2htZW50TG9hZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5wcm90b3R5cGUucmVhZFNrZWxldG9uRGF0YSA9IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uRGF0YSA9IG5ldyBjb3JlLlNrZWxldG9uRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0eXBlb2YgKGpzb24pID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tlbGV0b25NYXAgPSByb290LnNrZWxldG9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uTWFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuaGFzaCA9IHNrZWxldG9uTWFwLmhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnZlcnNpb24gPSBza2VsZXRvbk1hcC5zcGluZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b25EYXRhLnZlcnNpb24uc3Vic3RyKDAsIDMpICE9PSAnMy44Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBcIlBpeGlKUyBTcGluZSBwbHVnaW4gc3VwcG9ydHMgb25seSBmb3JtYXQgZm9yIFNwaW5lIDMuOC4gWW91ciBtb2RlbCBoYXMgdmVyc2lvbiBcIiArIHNrZWxldG9uTWFwLnNwaW5lICsgXCIuIFBsZWFzZSBsb29rIGluIHBpeGktc3BpbmUgcmVwb3NpdG9yeSBSRUFETUUgZm9yIGFub3RoZXIgYnJhbmNoLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uRGF0YS52ZXJzaW9uID09PSAnMy44Ljc1Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBcIlVuc3VwcG9ydGVkIHNrZWxldG9uIGRhdGEsIDMuOC43NSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgZXhwb3J0IHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIFNwaW5lLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnggPSBza2VsZXRvbk1hcC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS55ID0gc2tlbGV0b25NYXAueTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEud2lkdGggPSBza2VsZXRvbk1hcC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuaGVpZ2h0ID0gc2tlbGV0b25NYXAuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5mcHMgPSBza2VsZXRvbk1hcC5mcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmltYWdlc1BhdGggPSBza2VsZXRvbk1hcC5pbWFnZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5ib25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5ib25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZU1hcCA9IHJvb3QuYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfNSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROYW1lID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInBhcmVudFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzUgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUocGFyZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50XzUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgYm9uZSBub3QgZm91bmQ6IFwiICsgcGFyZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5Cb25lRGF0YShza2VsZXRvbkRhdGEuYm9uZXMubGVuZ3RoLCBib25lTWFwLm5hbWUsIHBhcmVudF81KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwibGVuZ3RoXCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEueCA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJ4XCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEueSA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJ5XCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm90YXRpb24gPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwicm90YXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NhbGVYID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNjYWxlWFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zY2FsZVkgPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwic2NhbGVZXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNoZWFyWCA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJzaGVhclhcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2hlYXJZID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNoZWFyWVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50cmFuc2Zvcm1Nb2RlID0gU2tlbGV0b25Kc29uLnRyYW5zZm9ybU1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJ0cmFuc2Zvcm1cIiwgXCJub3JtYWxcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNraW5SZXF1aXJlZCA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJza2luXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmJvbmVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3Quc2xvdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3Quc2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RNYXAgPSByb290LnNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE5hbWUgPSBzbG90TWFwLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lTmFtZSA9IHNsb3RNYXAuYm9uZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVEYXRhID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmVEYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbG90IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5TbG90RGF0YShza2VsZXRvbkRhdGEuc2xvdHMubGVuZ3RoLCBzbG90TmFtZSwgYm9uZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKHNsb3RNYXAsIFwiY29sb3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhcmsgPSB0aGlzLmdldFZhbHVlKHNsb3RNYXAsIFwiZGFya1wiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhcmsgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXJrQ29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGFya0NvbG9yLnNldEZyb21TdHJpbmcoZGFyayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRhY2htZW50TmFtZSA9IHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJhdHRhY2htZW50XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJsZW5kTW9kZSA9IFNrZWxldG9uSnNvbi5ibGVuZE1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJibGVuZFwiLCBcIm5vcm1hbFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5zbG90cy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb290LmlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290LmlrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gcm9vdC5pa1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5Ja0NvbnN0cmFpbnREYXRhKGNvbnN0cmFpbnRNYXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3JkZXIgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwib3JkZXJcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNraW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnN0cmFpbnRNYXAuYm9uZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lTmFtZSA9IGNvbnN0cmFpbnRNYXAuYm9uZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklLIGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYm9uZXMucHVzaChib25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0TmFtZSA9IGNvbnN0cmFpbnRNYXAudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZSh0YXJnZXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJSyB0YXJnZXQgYm9uZSBub3QgZm91bmQ6IFwiICsgdGFyZ2V0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcIm1peFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zb2Z0bmVzcyA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzb2Z0bmVzc1wiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJlbmREaXJlY3Rpb24gPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwiYmVuZFBvc2l0aXZlXCIsIHRydWUpID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXByZXNzID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcImNvbXByZXNzXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdHJldGNoID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInN0cmV0Y2hcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnVuaWZvcm0gPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwidW5pZm9ybVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5pa0NvbnN0cmFpbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290LnRyYW5zZm9ybS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludE1hcCA9IHJvb3QudHJhbnNmb3JtW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnREYXRhKGNvbnN0cmFpbnRNYXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub3JkZXIgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwib3JkZXJcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNraW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnN0cmFpbnRNYXAuYm9uZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lTmFtZSA9IGNvbnN0cmFpbnRNYXAuYm9uZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybSBjb25zdHJhaW50IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYm9uZXMucHVzaChib25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0TmFtZSA9IGNvbnN0cmFpbnRNYXAudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZSh0YXJnZXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2Zvcm0gY29uc3RyYWludCB0YXJnZXQgYm9uZSBub3QgZm91bmQ6IFwiICsgdGFyZ2V0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubG9jYWwgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwibG9jYWxcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlbGF0aXZlID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInJlbGF0aXZlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRSb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRYID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInhcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRZID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRTY2FsZVggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2NhbGVYXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFNjYWxlWSA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzY2FsZVlcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0U2hlYXJZID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNoZWFyWVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGVNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicm90YXRlTWl4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRyYW5zbGF0ZU1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJ0cmFuc2xhdGVNaXhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NhbGVNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2NhbGVNaXhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2hlYXJNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2hlYXJNaXhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS50cmFuc2Zvcm1Db25zdHJhaW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb290LnBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QucGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludE1hcCA9IHJvb3QucGF0aFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5QYXRoQ29uc3RyYWludERhdGEoY29uc3RyYWludE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcmRlciA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJvcmRlclwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5za2luUmVxdWlyZWQgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2tpblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29uc3RyYWludE1hcC5ib25lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVOYW1lID0gY29uc3RyYWludE1hcC5ib25lc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib25lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmb3JtIGNvbnN0cmFpbnQgYm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXROYW1lID0gY29uc3RyYWludE1hcC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGFyZ2V0ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90KHRhcmdldE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggdGFyZ2V0IHNsb3Qgbm90IGZvdW5kOiBcIiArIHRhcmdldE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uTW9kZSA9IFNrZWxldG9uSnNvbi5wb3NpdGlvbk1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJwb3NpdGlvbk1vZGVcIiwgXCJwZXJjZW50XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zcGFjaW5nTW9kZSA9IFNrZWxldG9uSnNvbi5zcGFjaW5nTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNwYWNpbmdNb2RlXCIsIFwibGVuZ3RoXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGVNb2RlID0gU2tlbGV0b25Kc29uLnJvdGF0ZU1vZGVGcm9tU3RyaW5nKHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGVNb2RlXCIsIFwidGFuZ2VudFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0Um90YXRpb24gPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicm90YXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicG9zaXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uTW9kZSA9PSBjb3JlLlBvc2l0aW9uTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb24gKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BhY2luZyA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzcGFjaW5nXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkxlbmd0aCB8fCBkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwYWNpbmcgKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm90YXRlTWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInJvdGF0ZU1peFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50cmFuc2xhdGVNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwidHJhbnNsYXRlTWl4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEucGF0aENvbnN0cmFpbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3Quc2tpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3Quc2tpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNraW5NYXAgPSByb290LnNraW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbiA9IG5ldyBjb3JlLlNraW4oc2tpbk1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraW5NYXAuYm9uZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBza2luTWFwLmJvbmVzLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKHNraW5NYXAuYm9uZXNbaWldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIGJvbmUgbm90IGZvdW5kOiBcIiArIHNraW5NYXAuYm9uZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uYm9uZXMucHVzaChib25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbk1hcC5paykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNraW5NYXAuaWsubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbkRhdGEuZmluZElrQ29uc3RyYWludChza2luTWFwLmlrW2lpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2tpbiBJSyBjb25zdHJhaW50IG5vdCBmb3VuZDogXCIgKyBza2luTWFwLmlrW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2luLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraW5NYXAudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2tpbk1hcC50cmFuc2Zvcm0ubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbkRhdGEuZmluZFRyYW5zZm9ybUNvbnN0cmFpbnQoc2tpbk1hcC50cmFuc2Zvcm1baWldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIHRyYW5zZm9ybSBjb25zdHJhaW50IG5vdCBmb3VuZDogXCIgKyBza2luTWFwLnRyYW5zZm9ybVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2luTWFwLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBza2luTWFwLnBhdGgubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbkRhdGEuZmluZFBhdGhDb25zdHJhaW50KHNraW5NYXAucGF0aFtpaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gcGF0aCBjb25zdHJhaW50IG5vdCBmb3VuZDogXCIgKyBza2luTWFwLnBhdGhbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzbG90TmFtZSBpbiBza2luTWFwLmF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdChzbG90TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90TWFwID0gc2tpbk1hcC5hdHRhY2htZW50c1tzbG90TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlbnRyeU5hbWUgaW4gc2xvdE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChzbG90TWFwW2VudHJ5TmFtZV0sIHNraW4sIHNsb3QuaW5kZXgsIGVudHJ5TmFtZSwgc2tlbGV0b25EYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2luLnNldEF0dGFjaG1lbnQoc2xvdC5pbmRleCwgZW50cnlOYW1lLCBhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuc2tpbnMucHVzaChza2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraW4ubmFtZSA9PSBcImRlZmF1bHRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5kZWZhdWx0U2tpbiA9IHNraW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLmxpbmtlZE1lc2hlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua2VkTWVzaCA9IHRoaXMubGlua2VkTWVzaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBza2luID0gbGlua2VkTWVzaC5za2luID09IG51bGwgPyBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gOiBza2VsZXRvbkRhdGEuZmluZFNraW4obGlua2VkTWVzaC5za2luKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIG5vdCBmb3VuZDogXCIgKyBsaW5rZWRNZXNoLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfNiA9IHNraW4uZ2V0QXR0YWNobWVudChsaW5rZWRNZXNoLnNsb3RJbmRleCwgbGlua2VkTWVzaC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfNiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgbWVzaCBub3QgZm91bmQ6IFwiICsgbGlua2VkTWVzaC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZE1lc2gubWVzaC5kZWZvcm1BdHRhY2htZW50ID0gbGlua2VkTWVzaC5pbmhlcml0RGVmb3JtID8gcGFyZW50XzYgOiBsaW5rZWRNZXNoLm1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkTWVzaC5tZXNoLnNldFBhcmVudE1lc2gocGFyZW50XzYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rZWRNZXNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChyb290LmV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByb290LmV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRNYXAgPSByb290LmV2ZW50c1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLkV2ZW50RGF0YShldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmludFZhbHVlID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJpbnRcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmxvYXRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiZmxvYXRcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RyaW5nVmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcInN0cmluZ1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hdWRpb1BhdGggPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImF1ZGlvXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5hdWRpb1BhdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52b2x1bWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcInZvbHVtZVwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmFsYW5jZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiYmFsYW5jZVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuZXZlbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFuaW1hdGlvbk5hbWUgaW4gcm9vdC5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25NYXAgPSByb290LmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEFuaW1hdGlvbihhbmltYXRpb25NYXAsIGFuaW1hdGlvbk5hbWUsIHNrZWxldG9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNrZWxldG9uRGF0YTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnByb3RvdHlwZS5yZWFkQXR0YWNobWVudCA9IGZ1bmN0aW9uIChtYXAsIHNraW4sIHNsb3RJbmRleCwgbmFtZSwgc2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcIm5hbWVcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInR5cGVcIiwgXCJyZWdpb25cIik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVnaW9uXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJwYXRoXCIsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1JlZ2lvbkF0dGFjaG1lbnQoc2tpbiwgbmFtZSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdpb24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi54ID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwieFwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ueSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnNjYWxlWCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInNjYWxlWFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnNjYWxlWSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInNjYWxlWVwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnJvdGF0aW9uID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwicm90YXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IG1hcC53aWR0aCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uaGVpZ2h0ID0gbWFwLmhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJjb2xvclwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib3VuZGluZ2JveFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Qm91bmRpbmdCb3hBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm94ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkVmVydGljZXMobWFwLCBib3gsIG1hcC52ZXJ0ZXhDb3VudCA8PCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94LmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaW5rZWRtZXNoXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJwYXRoXCIsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdNZXNoQXR0YWNobWVudChza2luLCBuYW1lLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc2ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJjb2xvclwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLndpZHRoID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwid2lkdGhcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5oZWlnaHQgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJoZWlnaHRcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF83ID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwicGFyZW50XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50XzcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rZWRNZXNoZXMucHVzaChuZXcgTGlua2VkTWVzaChtZXNoLCB0aGlzLmdldFZhbHVlKG1hcCwgXCJza2luXCIsIG51bGwpLCBzbG90SW5kZXgsIHBhcmVudF83LCB0aGlzLmdldFZhbHVlKG1hcCwgXCJkZWZvcm1cIiwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dnMgPSBtYXAudXZzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRWZXJ0aWNlcyhtYXAsIG1lc2gsIHV2cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLnRyaWFuZ2xlcyA9IG1hcC50cmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gucmVnaW9uVVZzID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmVkZ2VzID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiZWRnZXNcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guaHVsbExlbmd0aCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImh1bGxcIiwgMCkgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdGhcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdQYXRoQXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNsb3NlZCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNsb3NlZFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguY29uc3RhbnRTcGVlZCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbnN0YW50U3BlZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IG1hcC52ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkVmVydGljZXMobWFwLCBwYXRoLCB2ZXJ0ZXhDb3VudCA8PCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aHMgPSBjb3JlLlV0aWxzLm5ld0FycmF5KHZlcnRleENvdW50IC8gMywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzW2ldID0gbWFwLmxlbmd0aHNbaV0gKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5sZW5ndGhzID0gbGVuZ3RocztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdQb2ludEF0dGFjaG1lbnQoc2tpbiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJ4XCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJ5XCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnJvdGF0aW9uID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwicm90YXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGlwcGluZ1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld0NsaXBwaW5nQXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXAgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiZW5kXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90KGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaXBwaW5nIGVuZCBzbG90IG5vdCBmb3VuZDogXCIgKyBlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC5lbmRTbG90ID0gc2xvdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBtYXAudmVydGV4Q291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFZlcnRpY2VzKG1hcCwgY2xpcCwgdmVydGV4Q291bnQgPDwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAuY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGlwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucHJvdG90eXBlLnJlYWRWZXJ0aWNlcyA9IGZ1bmN0aW9uIChtYXAsIGF0dGFjaG1lbnQsIHZlcnRpY2VzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC53b3JsZFZlcnRpY2VzTGVuZ3RoID0gdmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBtYXAudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNMZW5ndGggPT0gdmVydGljZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZFZlcnRpY2VzID0gY29yZS5VdGlscy50b0Zsb2F0QXJyYXkodmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkVmVydGljZXNbaV0gKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQudmVydGljZXMgPSBzY2FsZWRWZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVDb3VudCA9IHZlcnRpY2VzW2krK107XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZXMucHVzaChib25lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5uID0gaSArIGJvbmVDb3VudCAqIDQ7IGkgPCBubjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmVzLnB1c2godmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2godmVydGljZXNbaSArIDFdICogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2godmVydGljZXNbaSArIDJdICogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2godmVydGljZXNbaSArIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmJvbmVzID0gYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LnZlcnRpY2VzID0gY29yZS5VdGlscy50b0Zsb2F0QXJyYXkod2VpZ2h0cyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5wcm90b3R5cGUucmVhZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNrZWxldG9uRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLnNsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2xvdE5hbWUgaW4gbWFwLnNsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90TWFwID0gbWFwLnNsb3RzW3Nsb3ROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RJbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdGltZWxpbmVOYW1lIGluIHNsb3RNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1hcCA9IHNsb3RNYXBbdGltZWxpbmVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT0gXCJhdHRhY2htZW50XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5BdHRhY2htZW50VGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCB2YWx1ZU1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT0gXCJjb2xvclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuQ29sb3JUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gbmV3IGNvcmUuQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3Iuc2V0RnJvbVN0cmluZyh2YWx1ZU1hcC5jb2xvciB8fCBcImZmZmZmZmZmXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRpbWVcIiwgMCksIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZSh2YWx1ZU1hcCwgdGltZWxpbmUsIGZyYW1lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogY29yZS5Db2xvclRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PSBcInR3b0NvbG9yXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Ud29Db2xvclRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGFyayA9IG5ldyBjb3JlLkNvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0LnNldEZyb21TdHJpbmcodmFsdWVNYXAubGlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXJrLnNldEZyb21TdHJpbmcodmFsdWVNYXAuZGFyayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgbGlnaHQuciwgbGlnaHQuZywgbGlnaHQuYiwgbGlnaHQuYSwgZGFyay5yLCBkYXJrLmcsIGRhcmsuYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLlR3b0NvbG9yVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBzbG90OiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIHNsb3ROYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5ib25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGJvbmVOYW1lIGluIG1hcC5ib25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZU1hcCA9IG1hcC5ib25lc1tib25lTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lSW5kZXggPSBza2VsZXRvbkRhdGEuZmluZEJvbmVJbmRleChib25lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib25lSW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpbWVsaW5lTmFtZSBpbiBib25lTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVNYXAgPSBib25lTWFwW3RpbWVsaW5lTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09PSBcInJvdGF0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuUm90YXRlVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJhbmdsZVwiLCAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLlJvdGF0ZVRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJ0cmFuc2xhdGVcIiB8fCB0aW1lbGluZU5hbWUgPT09IFwic2NhbGVcIiB8fCB0aW1lbGluZU5hbWUgPT09IFwic2hlYXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU2NhbGUgPSAxLCBkZWZhdWx0VmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT09IFwic2NhbGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlNjYWxlVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmVOYW1lID09PSBcInNoZWFyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuU2hlYXJUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlRyYW5zbGF0ZVRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwieFwiLCBkZWZhdWx0VmFsdWUpLCB5ID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ5XCIsIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgeCAqIHRpbWVsaW5lU2NhbGUsIHkgKiB0aW1lbGluZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBib25lOiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIGJvbmVOYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5paykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbnN0cmFpbnROYW1lIGluIG1hcC5paykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludE1hcCA9IG1hcC5pa1tjb25zdHJhaW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b25EYXRhLmZpbmRJa0NvbnN0cmFpbnQoY29uc3RyYWludE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Ja0NvbnN0cmFpbnRUaW1lbGluZShjb25zdHJhaW50TWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmlrQ29uc3RyYWludEluZGV4ID0gc2tlbGV0b25EYXRhLmlrQ29uc3RyYWludHMuaW5kZXhPZihjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IGNvbnN0cmFpbnRNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRpbWVcIiwgMCksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwibWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInNvZnRuZXNzXCIsIDApICogc2NhbGUsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwiYmVuZFBvc2l0aXZlXCIsIHRydWUpID8gMSA6IC0xLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcImNvbXByZXNzXCIsIGZhbHNlKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJzdHJldGNoXCIsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZSh2YWx1ZU1hcCwgdGltZWxpbmUsIGZyYW1lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXAudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29uc3RyYWludE5hbWUgaW4gbWFwLnRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludE1hcCA9IG1hcC50cmFuc2Zvcm1bY29uc3RyYWludE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uRGF0YS5maW5kVHJhbnNmb3JtQ29uc3RyYWludChjb25zdHJhaW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZShjb25zdHJhaW50TWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnRyYW5zZm9ybUNvbnN0cmFpbnRJbmRleCA9IHNrZWxldG9uRGF0YS50cmFuc2Zvcm1Db25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludE1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gY29uc3RyYWludE1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJyb3RhdGVNaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidHJhbnNsYXRlTWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInNjYWxlTWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInNoZWFyTWl4XCIsIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogY29yZS5UcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXAucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbnN0cmFpbnROYW1lIGluIG1hcC5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gbWFwLnBhdGhbY29uc3RyYWludE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFBhdGhDb25zdHJhaW50SW5kZXgoY29uc3RyYWludE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGNvbnN0cmFpbnQgbm90IGZvdW5kOiBcIiArIGNvbnN0cmFpbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBza2VsZXRvbkRhdGEucGF0aENvbnN0cmFpbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdGltZWxpbmVOYW1lIGluIGNvbnN0cmFpbnRNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1hcCA9IGNvbnN0cmFpbnRNYXBbdGltZWxpbmVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT09IFwicG9zaXRpb25cIiB8fCB0aW1lbGluZU5hbWUgPT09IFwic3BhY2luZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTY2FsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJzcGFjaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgY29yZS5QYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkxlbmd0aCB8fCBkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbk1vZGUgPT0gY29yZS5Qb3NpdGlvbk1vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnBhdGhDb25zdHJhaW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCB0aW1lbGluZU5hbWUsIDApICogdGltZWxpbmVTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLlBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT09IFwibWl4XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5QYXRoQ29uc3RyYWludE1peFRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUucGF0aENvbnN0cmFpbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRpbWVcIiwgMCksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwicm90YXRlTWl4XCIsIDEpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRyYW5zbGF0ZU1peFwiLCAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLlBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5kZWZvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkZWZvcm1OYW1lIGluIG1hcC5kZWZvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZm9ybU1hcCA9IG1hcC5kZWZvcm1bZGVmb3JtTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2luID0gc2tlbGV0b25EYXRhLmZpbmRTa2luKGRlZm9ybU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZS5GQUlMX09OX05PTl9FWElTVElOR19TS0lOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2tpbiBub3QgZm91bmQ6IFwiICsgZGVmb3JtTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzbG90TmFtZSBpbiBkZWZvcm1NYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90TWFwID0gZGVmb3JtTWFwW3Nsb3ROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdEluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsb3Qgbm90IGZvdW5kOiBcIiArIHNsb3RNYXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0aW1lbGluZU5hbWUgaW4gc2xvdE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1hcCA9IHNsb3RNYXBbdGltZWxpbmVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIHRpbWVsaW5lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmb3JtIGF0dGFjaG1lbnQgbm90IGZvdW5kOiBcIiArIHRpbWVsaW5lTWFwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZCA9IGF0dGFjaG1lbnQuYm9uZXMgIT0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBhdHRhY2htZW50LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZvcm1MZW5ndGggPSB3ZWlnaHRlZCA/IHZlcnRpY2VzLmxlbmd0aCAvIDMgKiAyIDogdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkRlZm9ybVRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmb3JtID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidmVydGljZXNcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm0gPSB3ZWlnaHRlZCA/IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShkZWZvcm1MZW5ndGgpIDogdmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGRlZm9ybUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcIm9mZnNldFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHZlcnRpY2VzVmFsdWUsIDAsIGRlZm9ybSwgc3RhcnQsIHZlcnRpY2VzVmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBuID0gaSArIHZlcnRpY2VzVmFsdWUubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV0gKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlaWdodGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZvcm1MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2ldICs9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgZGVmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkcmF3T3JkZXJOb2RlID0gbWFwLmRyYXdPcmRlcjtcclxuICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXJOb2RlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyTm9kZSA9IG1hcC5kcmF3b3JkZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhd09yZGVyTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuRHJhd09yZGVyVGltZWxpbmUoZHJhd09yZGVyTm9kZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90Q291bnQgPSBza2VsZXRvbkRhdGEuc2xvdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRyYXdPcmRlck5vZGUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlck1hcCA9IGRyYXdPcmRlck5vZGVbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmF3T3JkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuZ2V0VmFsdWUoZHJhd09yZGVyTWFwLCBcIm9mZnNldHNcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcmRlciA9IGNvcmUuVXRpbHMubmV3QXJyYXkoc2xvdENvdW50LCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5jaGFuZ2VkID0gY29yZS5VdGlscy5uZXdBcnJheShzbG90Q291bnQgLSBvZmZzZXRzLmxlbmd0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IDAsIHVuY2hhbmdlZEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBvZmZzZXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChvZmZzZXRNYXAuc2xvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RJbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgb2Zmc2V0TWFwLnNsb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4ICE9IHNsb3RJbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jaGFuZ2VkW3VuY2hhbmdlZEluZGV4KytdID0gb3JpZ2luYWxJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcmRlcltvcmlnaW5hbEluZGV4ICsgb2Zmc2V0TWFwLm9mZnNldF0gPSBvcmlnaW5hbEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IHNsb3RDb3VudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNoYW5nZWRbdW5jaGFuZ2VkSW5kZXgrK10gPSBvcmlnaW5hbEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc2xvdENvdW50IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdPcmRlcltpXSA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW2ldID0gdW5jaGFuZ2VkWy0tdW5jaGFuZ2VkSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgdGhpcy5nZXRWYWx1ZShkcmF3T3JkZXJNYXAsIFwidGltZVwiLCAwKSwgZHJhd09yZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkV2ZW50VGltZWxpbmUobWFwLmV2ZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5ldmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TWFwID0gbWFwLmV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHNrZWxldG9uRGF0YS5maW5kRXZlbnQoZXZlbnRNYXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudERhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBmb3VuZDogXCIgKyBldmVudE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzYgPSBuZXcgY29yZS5FdmVudChjb3JlLlV0aWxzLnRvU2luZ2xlUHJlY2lzaW9uKHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwidGltZVwiLCAwKSksIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzYuaW50VmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImludFwiLCBldmVudERhdGEuaW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudF82LmZsb2F0VmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImZsb2F0XCIsIGV2ZW50RGF0YS5mbG9hdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNi5zdHJpbmdWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwic3RyaW5nXCIsIGV2ZW50RGF0YS5zdHJpbmdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudF82LmRhdGEuYXVkaW9QYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzYudm9sdW1lID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJ2b2x1bWVcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF82LmJhbGFuY2UgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImJhbGFuY2VcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCsrLCBldmVudF82KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igd2hpbGUgcGFyc2luZyBhbmltYXRpb24sIGR1cmF0aW9uIGlzIE5hTlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5hbmltYXRpb25zLnB1c2gobmV3IGNvcmUuQW5pbWF0aW9uKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnByb3RvdHlwZS5yZWFkQ3VydmUgPSBmdW5jdGlvbiAobWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXAuaGFzT3duUHJvcGVydHkoXCJjdXJ2ZVwiKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmN1cnZlID09PSBcInN0ZXBwZWRcIilcclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRTdGVwcGVkKGZyYW1lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnZlID0gbWFwLmN1cnZlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEN1cnZlKGZyYW1lSW5kZXgsIGN1cnZlLCB0aGlzLmdldFZhbHVlKG1hcCwgXCJjMlwiLCAwKSwgdGhpcy5nZXRWYWx1ZShtYXAsIFwiYzNcIiwgMSksIHRoaXMuZ2V0VmFsdWUobWFwLCBcImM0XCIsIDEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChtYXAsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFtwcm9wXSAhPT0gdW5kZWZpbmVkID8gbWFwW3Byb3BdIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24uYmxlbmRNb2RlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcIm5vcm1hbFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLkJsZW5kTW9kZS5Ob3JtYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwiYWRkaXRpdmVcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5CbGVuZE1vZGUuQWRkaXRpdmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibXVsdGlwbHlcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5CbGVuZE1vZGUuTXVsdGlwbHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwic2NyZWVuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuQmxlbmRNb2RlLlNjcmVlbjtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYmxlbmQgbW9kZTogXCIgKyBzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucG9zaXRpb25Nb2RlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcImZpeGVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuUG9zaXRpb25Nb2RlLkZpeGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcInBlcmNlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5Qb3NpdGlvbk1vZGUuUGVyY2VudDtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcG9zaXRpb24gbW9kZTogXCIgKyBzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24uc3BhY2luZ01vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibGVuZ3RoXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuU3BhY2luZ01vZGUuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcImZpeGVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuU3BhY2luZ01vZGUuRml4ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwicGVyY2VudFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlNwYWNpbmdNb2RlLlBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBvc2l0aW9uIG1vZGU6IFwiICsgc3RyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnJvdGF0ZU1vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwidGFuZ2VudFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlJvdGF0ZU1vZGUuVGFuZ2VudDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJjaGFpblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlJvdGF0ZU1vZGUuQ2hhaW47XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwiY2hhaW5zY2FsZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlJvdGF0ZU1vZGUuQ2hhaW5TY2FsZTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm90YXRlIG1vZGU6IFwiICsgc3RyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnRyYW5zZm9ybU1vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibm9ybWFsXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob3JtYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwib25seXRyYW5zbGF0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVHJhbnNmb3JtTW9kZS5Pbmx5VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibm9yb3RhdGlvbm9ycmVmbGVjdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlRyYW5zZm9ybU1vZGUuTm9Sb3RhdGlvbk9yUmVmbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJub3NjYWxlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcIm5vc2NhbGVvcnJlZmxlY3Rpb25cIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGVPclJlZmxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zZm9ybSBtb2RlOiBcIiArIHN0cik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTa2VsZXRvbkpzb247XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNrZWxldG9uSnNvbiA9IFNrZWxldG9uSnNvbjtcclxuICAgICAgICB2YXIgTGlua2VkTWVzaCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIExpbmtlZE1lc2gobWVzaCwgc2tpbiwgc2xvdEluZGV4LCBwYXJlbnQsIGluaGVyaXREZWZvcm0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW4gPSBza2luO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5oZXJpdERlZm9ybSA9IGluaGVyaXREZWZvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIExpbmtlZE1lc2g7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTa2luRW50cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTa2luRW50cnkoc2xvdEluZGV4LCBuYW1lLCBhdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTa2luRW50cnk7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNraW5FbnRyeSA9IFNraW5FbnRyeTtcclxuICAgICAgICB2YXIgU2tpbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNraW4obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcyA9IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5zZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNsb3RJbmRleCwgbmFtZSwgYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRhY2htZW50IGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IHRoaXMuYXR0YWNobWVudHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdEluZGV4ID49IGF0dGFjaG1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50cy5sZW5ndGggPSBzbG90SW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhdHRhY2htZW50c1tzbG90SW5kZXhdKVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzW3Nsb3RJbmRleF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzW3Nsb3RJbmRleF1bbmFtZV0gPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5hZGRTa2luID0gZnVuY3Rpb24gKHNraW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2tpbi5ib25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tpbi5ib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJvbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvbmVzW2pdID09IGJvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBza2luLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2luLmNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHNbal0gPT0gY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudHMgPSBza2luLmdldEF0dGFjaG1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dGFjaG1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBhdHRhY2htZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoYXR0YWNobWVudC5zbG90SW5kZXgsIGF0dGFjaG1lbnQubmFtZSwgYXR0YWNobWVudC5hdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tpbi5wcm90b3R5cGUuY29weVNraW4gPSBmdW5jdGlvbiAoc2tpbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBza2luLmJvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2luLmJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYm9uZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9uZXNbal0gPT0gYm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvbmVzLnB1c2goYm9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNraW4uY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNraW4uY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50c1tqXSA9PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IHNraW4uZ2V0QXR0YWNobWVudHMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0YWNobWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IGF0dGFjaG1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50LmF0dGFjaG1lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQuYXR0YWNobWVudCBpbnN0YW5jZW9mIGNvcmUuTWVzaEF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5hdHRhY2htZW50ID0gYXR0YWNobWVudC5hdHRhY2htZW50Lm5ld0xpbmtlZE1lc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQuc2xvdEluZGV4LCBhdHRhY2htZW50Lm5hbWUsIGF0dGFjaG1lbnQuYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmF0dGFjaG1lbnQgPSBhdHRhY2htZW50LmF0dGFjaG1lbnQuY29weSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoYXR0YWNobWVudC5zbG90SW5kZXgsIGF0dGFjaG1lbnQubmFtZSwgYXR0YWNobWVudC5hdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLmdldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGljdGlvbmFyeSA9IHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5ID8gZGljdGlvbmFyeVtuYW1lXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLnJlbW92ZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGljdGlvbmFyeSA9IHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWN0aW9uYXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlbbmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5nZXRBdHRhY2htZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0YWNobWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEF0dGFjaG1lbnRzID0gdGhpcy5hdHRhY2htZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdEF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfNCBpbiBzbG90QXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdEF0dGFjaG1lbnRzW25hbWVfNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2gobmV3IFNraW5FbnRyeShpLCBuYW1lXzQsIGF0dGFjaG1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5nZXRBdHRhY2htZW50c0ZvclNsb3QgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBhdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RBdHRhY2htZW50cyA9IHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChzbG90QXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzUgaW4gc2xvdEF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdEF0dGFjaG1lbnRzW25hbWVfNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHMucHVzaChuZXcgU2tpbkVudHJ5KHNsb3RJbmRleCwgbmFtZV81LCBhdHRhY2htZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tpbi5wcm90b3R5cGUuYXR0YWNoQWxsID0gZnVuY3Rpb24gKHNrZWxldG9uLCBvbGRTa2luKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90QXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90QXR0YWNobWVudCAmJiBzbG90SW5kZXggPCBvbGRTa2luLmF0dGFjaG1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGljdGlvbmFyeSA9IG9sZFNraW4uYXR0YWNobWVudHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRpY3Rpb25hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2luQXR0YWNobWVudCA9IGRpY3Rpb25hcnlba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90QXR0YWNobWVudCA9PSBza2luQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTa2luO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ta2luID0gU2tpbjtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTbG90ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2xvdChkYXRhLCBib25lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZm9ybSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChib25lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm9uZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lID0gYm9uZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXJrQ29sb3IgPSBkYXRhLmRhcmtDb2xvciA9PSBudWxsID8gbnVsbCA6IG5ldyBjb3JlLkNvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRvU2V0dXBQb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHRoaXMuZGF0YS5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2xvdC5wcm90b3R5cGUuZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNsb3QucHJvdG90eXBlLnNldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0YWNobWVudCA9PSBhdHRhY2htZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRUaW1lID0gdGhpcy5ib25lLnNrZWxldG9uLnRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZm9ybS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTbG90LnByb3RvdHlwZS5zZXRBdHRhY2htZW50VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRUaW1lID0gdGhpcy5ib25lLnNrZWxldG9uLnRpbWUgLSB0aW1lO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTbG90LnByb3RvdHlwZS5nZXRBdHRhY2htZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvbmUuc2tlbGV0b24udGltZSAtIHRoaXMuYXR0YWNobWVudFRpbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNsb3QucHJvdG90eXBlLnNldFRvU2V0dXBQb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5kYXRhLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhcmtDb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGFya0NvbG9yLnNldEZyb21Db2xvcih0aGlzLmRhdGEuZGFya0NvbG9yKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuYXR0YWNobWVudE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQodGhpcy5ib25lLnNrZWxldG9uLmdldEF0dGFjaG1lbnQodGhpcy5kYXRhLmluZGV4LCB0aGlzLmRhdGEuYXR0YWNobWVudE5hbWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNsb3Q7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNsb3QgPSBTbG90O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFNsb3REYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2xvdERhdGEoaW5kZXgsIG5hbWUsIGJvbmVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gbmV3IGNvcmUuQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IG11c3QgYmUgPj0gMC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVEYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm9uZURhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZURhdGEgPSBib25lRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU2xvdERhdGE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNsb3REYXRhID0gU2xvdERhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgVGV4dHVyZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRleHR1cmUoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmUuZmlsdGVyRnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWFyZXN0XCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLk5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmVhclwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5MaW5lYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pcG1hcFwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5NaXBNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pcG1hcG5lYXJlc3RuZWFyZXN0XCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLk1pcE1hcE5lYXJlc3ROZWFyZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtaXBtYXBsaW5lYXJuZWFyZXN0XCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLk1pcE1hcExpbmVhck5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pcG1hcG5lYXJlc3RsaW5lYXJcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTmVhcmVzdExpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlwbWFwbGluZWFybGluZWFyXCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLk1pcE1hcExpbmVhckxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRleHR1cmUgZmlsdGVyIFwiICsgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmUud3JhcEZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXh0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlycm9yZWR0ZXBlYXRcIjogcmV0dXJuIFRleHR1cmVXcmFwLk1pcnJvcmVkUmVwZWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFtcHRvZWRnZVwiOiByZXR1cm4gVGV4dHVyZVdyYXAuQ2xhbXBUb0VkZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdFwiOiByZXR1cm4gVGV4dHVyZVdyYXAuUmVwZWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGV4dHVyZSB3cmFwIFwiICsgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5UZXh0dXJlID0gVGV4dHVyZTtcclxuICAgICAgICB2YXIgVGV4dHVyZUZpbHRlcjtcclxuICAgICAgICAoZnVuY3Rpb24gKFRleHR1cmVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgVGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTmVhcmVzdFwiXSA9IDk3MjhdID0gXCJOZWFyZXN0XCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVGaWx0ZXJbVGV4dHVyZUZpbHRlcltcIkxpbmVhclwiXSA9IDk3MjldID0gXCJMaW5lYXJcIjtcclxuICAgICAgICAgICAgVGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwXCJdID0gOTk4N10gPSBcIk1pcE1hcFwiO1xyXG4gICAgICAgICAgICBUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJNaXBNYXBOZWFyZXN0TmVhcmVzdFwiXSA9IDk5ODRdID0gXCJNaXBNYXBOZWFyZXN0TmVhcmVzdFwiO1xyXG4gICAgICAgICAgICBUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJNaXBNYXBMaW5lYXJOZWFyZXN0XCJdID0gOTk4NV0gPSBcIk1pcE1hcExpbmVhck5lYXJlc3RcIjtcclxuICAgICAgICAgICAgVGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwTmVhcmVzdExpbmVhclwiXSA9IDk5ODZdID0gXCJNaXBNYXBOZWFyZXN0TGluZWFyXCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVGaWx0ZXJbVGV4dHVyZUZpbHRlcltcIk1pcE1hcExpbmVhckxpbmVhclwiXSA9IDk5ODddID0gXCJNaXBNYXBMaW5lYXJMaW5lYXJcIjtcclxuICAgICAgICB9KShUZXh0dXJlRmlsdGVyID0gY29yZS5UZXh0dXJlRmlsdGVyIHx8IChjb3JlLlRleHR1cmVGaWx0ZXIgPSB7fSkpO1xyXG4gICAgICAgIHZhciBUZXh0dXJlV3JhcDtcclxuICAgICAgICAoZnVuY3Rpb24gKFRleHR1cmVXcmFwKSB7XHJcbiAgICAgICAgICAgIFRleHR1cmVXcmFwW1RleHR1cmVXcmFwW1wiTWlycm9yZWRSZXBlYXRcIl0gPSAzMzY0OF0gPSBcIk1pcnJvcmVkUmVwZWF0XCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVXcmFwW1RleHR1cmVXcmFwW1wiQ2xhbXBUb0VkZ2VcIl0gPSAzMzA3MV0gPSBcIkNsYW1wVG9FZGdlXCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVXcmFwW1RleHR1cmVXcmFwW1wiUmVwZWF0XCJdID0gMTA0OTddID0gXCJSZXBlYXRcIjtcclxuICAgICAgICB9KShUZXh0dXJlV3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAgfHwgKGNvcmUuVGV4dHVyZVdyYXAgPSB7fSkpO1xyXG4gICAgICAgIHZhciBUZXh0dXJlUmVnaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dHVyZVJlZ2lvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBJWEkuVkVSU0lPTlswXSA9PSAnMycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC5jcm9wLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4LnRyaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC50cmltLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4Lm9yaWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUElYSS5WRVJTSU9OWzBdID09ICczJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LmNyb3AuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4LnRyaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC50cmltLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC5vcmlnLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5fdXZzLngwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwidlwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLl91dnMueTA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJ1MlwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLl91dnMueDI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJ2MlwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLl91dnMueTI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJvZmZzZXRYXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC50cmltID8gdGV4LnRyaW0ueCA6IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJvZmZzZXRZXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRlcHJlY2F0aW9uIFdhcm5pbmc6IEBIYWNrZXJoYW06IEkgZ3Vlc3MsIGlmIHlvdSBhcmUgdXNpbmcgUElYSS1TUElORSBBVExBUyByZWdpb24ub2Zmc2V0WSwgeW91IHdhbnQgYSB0ZXh0dXJlLCByaWdodD8gVXNlIHJlZ2lvbi50ZXh0dXJlIGZyb20gbm93IG9uLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGluZU9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJwaXhpT2Zmc2V0WVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy50ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgudHJpbSA/IHRleC50cmltLnkgOiAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwic3BpbmVPZmZzZXRZXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxIZWlnaHQgLSB0aGlzLmhlaWdodCAtICh0ZXgudHJpbSA/IHRleC50cmltLnkgOiAwKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUElYSS5WRVJTSU9OWzBdID09ICczJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4LnRyaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgudHJpbS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LmNyb3Aud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgub3JpZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsSGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBJWEkuVkVSU0lPTlswXSA9PSAnMycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleC50cmltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LnRyaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXguY3JvcC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgub3JpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuZnJhbWUueDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5mcmFtZS55O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwicm90YXRlXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUucm90YXRlICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZVJlZ2lvbjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVGV4dHVyZVJlZ2lvbiA9IFRleHR1cmVSZWdpb247XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgVGV4dHVyZUF0bGFzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dHVyZUF0bGFzKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlciwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0bGFzVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU3BpbmVBdGxhcyhhdGxhc1RleHQsIHRleHR1cmVMb2FkZXIsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXMucHJvdG90eXBlLmFkZFRleHR1cmUgPSBmdW5jdGlvbiAobmFtZSwgdGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VzID0gdGhpcy5wYWdlcztcclxuICAgICAgICAgICAgICAgIHZhciBwYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXNbaV0uYmFzZVRleHR1cmUgPT09IHRleHR1cmUuYmFzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBuZXcgVGV4dHVyZUF0bGFzUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UubmFtZSA9ICd0ZXh0dXJlUGFnZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLndpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5taW5GaWx0ZXIgPSBwYWdlLm1hZ0ZpbHRlciA9IGNvcmUuVGV4dHVyZUZpbHRlci5OZWFyZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UudVdyYXAgPSBjb3JlLlRleHR1cmVXcmFwLkNsYW1wVG9FZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UudldyYXAgPSBjb3JlLlRleHR1cmVXcmFwLkNsYW1wVG9FZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gbmV3IFRleHR1cmVBdGxhc1JlZ2lvbigpO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLmluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGV4dHVyZUF0bGFzLnByb3RvdHlwZS5hZGRUZXh0dXJlSGFzaCA9IGZ1bmN0aW9uICh0ZXh0dXJlcywgc3RyaXBFeHRlbnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0ZXh0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGV4dHVyZShzdHJpcEV4dGVuc2lvbiAmJiBrZXkuaW5kZXhPZignLicpICE9PSAtMSA/IGtleS5zdWJzdHIoMCwga2V5Lmxhc3RJbmRleE9mKCcuJykpIDoga2V5LCB0ZXh0dXJlc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhcy5wcm90b3R5cGUuYWRkU3BpbmVBdGxhcyA9IGZ1bmN0aW9uIChhdGxhc1RleHQsIHRleHR1cmVMb2FkZXIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlciwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXMucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXRsYXNUZXh0LCB0ZXh0dXJlTG9hZGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlTG9hZGVyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGV4dHVyZUxvYWRlciBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IFRleHR1cmVBdGxhc1JlYWRlcihhdGxhc1RleHQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gbmV3IEFycmF5KDQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGVQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSByZWFkZXIucmVhZExpbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlID0gbmV3IFRleHR1cmVBdGxhc1BhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UubmFtZSA9IGxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2Uud2lkdGggPSBwYXJzZUludCh0dXBsZVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5oZWlnaHQgPSBwYXJzZUludCh0dXBsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UubWluRmlsdGVyID0gY29yZS5UZXh0dXJlLmZpbHRlckZyb21TdHJpbmcodHVwbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5tYWdGaWx0ZXIgPSBjb3JlLlRleHR1cmUuZmlsdGVyRnJvbVN0cmluZyh0dXBsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS51V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuQ2xhbXBUb0VkZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnZXcmFwID0gY29yZS5UZXh0dXJlV3JhcC5DbGFtcFRvRWRnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJ4XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS51V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuUmVwZWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UudldyYXAgPSBjb3JlLlRleHR1cmVXcmFwLlJlcGVhdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBcInh5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS51V3JhcCA9IHBhZ2UudldyYXAgPSBjb3JlLlRleHR1cmVXcmFwLlJlcGVhdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVMb2FkZXIobGluZSwgZnVuY3Rpb24gKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlcy5zcGxpY2UoX3RoaXMucGFnZXMuaW5kZXhPZihwYWdlKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5iYXNlVGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuc2V0U2l6ZShwYWdlLndpZHRoLCBwYWdlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VzLnB1c2gocGFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5zZXRGaWx0ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWdlLndpZHRoIHx8ICFwYWdlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLndpZHRoID0gdGV4dHVyZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UuaGVpZ2h0ID0gdGV4dHVyZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhZ2Uud2lkdGggfHwgIXBhZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SIHNwaW5lIGF0bGFzIHBhZ2UgXCIgKyBwYWdlLm5hbWUgKyBcIjogbWVzaGVzIHdvbnQgd29yayBpZiB5b3UgZG9udCBzcGVjaWZ5IHNpemUgaW4gYXRsYXMgKGh0dHA6Ly93d3cuaHRtbDVnYW1lZGV2cy5jb20vdG9waWMvMTg4ODgtcGl4aS1zcGluZXMtYW5kLW1lc2hlcy8/cD0xMDcxMjEpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVQYXJzZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFnZXMucHVzaChwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyBUZXh0dXJlQXRsYXNSZWdpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5uYW1lID0gbGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5wYWdlID0gcGFnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVWYWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZVZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT0gXCJ0cnVlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocm90YXRlVmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PSBcImZhbHNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gKCg3MjAgLSBwYXJzZUZsb2F0KHJvdGF0ZVZhbHVlKSkgJSAzNjApIC8gNDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQodHVwbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludCh0dXBsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludCh0dXBsZVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHBhZ2UuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLz0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLz0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIC89IHJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLz0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzd2FwV0ggPSByb3RhdGUgJSA0ICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoeCwgeSwgc3dhcFdIID8gaGVpZ2h0IDogd2lkdGgsIHN3YXBXSCA/IHdpZHRoIDogaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucmVhZFR1cGxlKHR1cGxlKSA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSBwYXJzZUludCh0dXBsZVswXSkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VJbnQodHVwbGVbMV0pIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBwYXJzZUludCh0dXBsZVswXSkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBwYXJzZUludCh0dXBsZVsxXSkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgb3JpZ2luYWxXaWR0aCwgb3JpZ2luYWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaW0gPSBuZXcgUElYSS5SZWN0YW5nbGUob2Zmc2V0WCwgb3JpZ2luYWxIZWlnaHQgLSBoZWlnaHQgLSBvZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQSVhJLlZFUlNJT05bMF0gIT0gJzMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUgPSBuZXcgUElYSS5UZXh0dXJlKHJlZ2lvbi5wYWdlLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgcm90YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZTIgPSBuZXcgUElYSS5SZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3AgPSBmcmFtZTIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltLndpZHRoID0gb3JpZ2luYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi50ZXh0dXJlID0gbmV3IFBJWEkuVGV4dHVyZShyZWdpb24ucGFnZS5iYXNlVGV4dHVyZSwgZnJhbWUyLCBjcm9wLCB0cmltLCByb3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLmluZGV4ID0gcGFyc2VJbnQocmVhZGVyLnJlYWRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi50ZXh0dXJlLnVwZGF0ZVV2cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaW9ucy5wdXNoKHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0ZVBhcnNlcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXMucHJvdG90eXBlLmZpbmRSZWdpb24gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWdpb25zW2ldLm5hbWUgPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VzW2ldLmJhc2VUZXh0dXJlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmVBdGxhcztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVGV4dHVyZUF0bGFzID0gVGV4dHVyZUF0bGFzO1xyXG4gICAgICAgIHZhciBUZXh0dXJlQXRsYXNSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZXh0dXJlQXRsYXNSZWFkZXIodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXNSZWFkZXIucHJvdG90eXBlLnJlYWRMaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5saW5lcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lc1t0aGlzLmluZGV4KytdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXNSZWFkZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvbiA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxpbmU6IFwiICsgbGluZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKS50cmltKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhc1JlYWRlci5wcm90b3R5cGUucmVhZFR1cGxlID0gZnVuY3Rpb24gKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMucmVhZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZihcIjpcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sb24gPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsYXN0TWF0Y2ggPSBjb2xvbiArIDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYSA9IGxpbmUuaW5kZXhPZihcIixcIiwgbGFzdE1hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWEgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlW2ldID0gbGluZS5zdWJzdHIobGFzdE1hdGNoLCBjb21tYSAtIGxhc3RNYXRjaCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNYXRjaCA9IGNvbW1hICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHR1cGxlW2ldID0gbGluZS5zdWJzdHJpbmcobGFzdE1hdGNoKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQXRsYXNSZWFkZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB2YXIgVGV4dHVyZUF0bGFzUGFnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRleHR1cmVBdGxhc1BhZ2UoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVGV4dHVyZUF0bGFzUGFnZS5wcm90b3R5cGUuc2V0RmlsdGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PSBjb3JlLlRleHR1cmVGaWx0ZXIuTGluZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4LnNjYWxlTW9kZSA9IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5taW5GaWx0ZXIgPT0gY29yZS5UZXh0dXJlRmlsdGVyLk5lYXJlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXguc2NhbGVNb2RlID0gUElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4Lm1pcG1hcCA9IFBJWEkuTUlQTUFQX01PREVTLlBPVzI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PSBjb3JlLlRleHR1cmVGaWx0ZXIuTWlwTWFwTmVhcmVzdE5lYXJlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4LnNjYWxlTW9kZSA9IFBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleC5zY2FsZU1vZGUgPSBQSVhJLlNDQUxFX01PREVTLkxJTkVBUjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQXRsYXNQYWdlO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5UZXh0dXJlQXRsYXNQYWdlID0gVGV4dHVyZUF0bGFzUGFnZTtcclxuICAgICAgICB2YXIgVGV4dHVyZUF0bGFzUmVnaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRleHR1cmVBdGxhc1JlZ2lvbiwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dHVyZUF0bGFzUmVnaW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQXRsYXNSZWdpb247XHJcbiAgICAgICAgfShjb3JlLlRleHR1cmVSZWdpb24pKTtcclxuICAgICAgICBjb3JlLlRleHR1cmVBdGxhc1JlZ2lvbiA9IFRleHR1cmVBdGxhc1JlZ2lvbjtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBUcmFuc2Zvcm1Db25zdHJhaW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtQ29uc3RyYWludChkYXRhLCBza2VsZXRvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWFyTWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVtcCA9IG5ldyBjb3JlLlZlY3RvcjIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ib25lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvbmVzLnB1c2goc2tlbGV0b24uZmluZEJvbmUoZGF0YS5ib25lc1tpXS5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHNrZWxldG9uLmZpbmRCb25lKGRhdGEudGFyZ2V0Lm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEubG9jYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnJlbGF0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UmVsYXRpdmVMb2NhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUFic29sdXRlTG9jYWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEucmVsYXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlSZWxhdGl2ZVdvcmxkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QWJzb2x1dGVXb3JsZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseUFic29sdXRlV29ybGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRNYXQgPSB0YXJnZXQubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhID0gdGFyZ2V0TWF0LmEsIHRiID0gdGFyZ2V0TWF0LmMsIHRjID0gdGFyZ2V0TWF0LmIsIHRkID0gdGFyZ2V0TWF0LmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVnUmFkUmVmbGVjdCA9IHRhICogdGQgLSB0YiAqIHRjID4gMCA/IGNvcmUuTWF0aFV0aWxzLmRlZ1JhZCA6IC1jb3JlLk1hdGhVdGlscy5kZWdSYWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0Um90YXRpb24gPSB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb24gKiBkZWdSYWRSZWZsZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFNoZWFyWSA9IHRoaXMuZGF0YS5vZmZzZXRTaGVhclkgKiBkZWdSYWRSZWZsZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZU1peCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbWF0LmEsIGIgPSBtYXQuYywgYyA9IG1hdC5iLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5hdGFuMih0YywgdGEpIC0gTWF0aC5hdGFuMihjLCBhKSArIG9mZnNldFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IGNvcmUuTWF0aFV0aWxzLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAtPSBjb3JlLk1hdGhVdGlscy5QSTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgPCAtY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAqPSByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyKSwgc2luID0gTWF0aC5zaW4ocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5hID0gY29zICogYSAtIHNpbiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5jID0gY29zICogYiAtIHNpbiAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5iID0gc2luICogYSArIGNvcyAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5kID0gc2luICogYiArIGNvcyAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZU1peCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy50ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubG9jYWxUb1dvcmxkKHRlbXAuc2V0KHRoaXMuZGF0YS5vZmZzZXRYLCB0aGlzLmRhdGEub2Zmc2V0WSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQudHggKz0gKHRlbXAueCAtIG1hdC50eCkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC50eSArPSAodGVtcC55IC0gbWF0LnR5KSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVNaXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KG1hdC5hICogbWF0LmEgKyBtYXQuYiAqIG1hdC5iKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gTWF0aC5zcXJ0KHRhICogdGEgKyB0YyAqIHRjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiAwLjAwMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChzICsgKHRzIC0gcyArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVgpICogc2NhbGVNaXgpIC8gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmEgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChtYXQuYyAqIG1hdC5jICsgbWF0LmQgKiBtYXQuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzID0gTWF0aC5zcXJ0KHRiICogdGIgKyB0ZCAqIHRkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiAwLjAwMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChzICsgKHRzIC0gcyArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVkpICogc2NhbGVNaXgpIC8gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmMgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlYXJNaXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gbWF0LmMsIGQgPSBtYXQuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5ID0gTWF0aC5hdGFuMihkLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmF0YW4yKHRkLCB0YikgLSBNYXRoLmF0YW4yKHRjLCB0YSkgLSAoYnkgLSBNYXRoLmF0YW4yKG1hdC5iLCBtYXQuYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IGNvcmUuTWF0aFV0aWxzLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAtPSBjb3JlLk1hdGhVdGlscy5QSTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgPCAtY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGJ5ICsgKHIgKyBvZmZzZXRTaGVhclkpICogc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KGIgKiBiICsgZCAqIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYyA9IE1hdGguY29zKHIpICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgPSBNYXRoLnNpbihyKSAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLmFwcGxpZWRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseVJlbGF0aXZlV29ybGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRNYXQgPSB0YXJnZXQubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhID0gdGFyZ2V0TWF0LmEsIHRiID0gdGFyZ2V0TWF0LmMsIHRjID0gdGFyZ2V0TWF0LmIsIHRkID0gdGFyZ2V0TWF0LmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVnUmFkUmVmbGVjdCA9IHRhICogdGQgLSB0YiAqIHRjID4gMCA/IGNvcmUuTWF0aFV0aWxzLmRlZ1JhZCA6IC1jb3JlLk1hdGhVdGlscy5kZWdSYWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0Um90YXRpb24gPSB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb24gKiBkZWdSYWRSZWZsZWN0LCBvZmZzZXRTaGVhclkgPSB0aGlzLmRhdGEub2Zmc2V0U2hlYXJZICogZGVnUmFkUmVmbGVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdCA9IGJvbmUubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGVNaXggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdC5hLCBiID0gbWF0LmMsIGMgPSBtYXQuYiwgZCA9IG1hdC5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGguYXRhbjIodGMsIHRhKSArIG9mZnNldFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+IGNvcmUuTWF0aFV0aWxzLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAtPSBjb3JlLk1hdGhVdGlscy5QSTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgPCAtY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAqPSByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyKSwgc2luID0gTWF0aC5zaW4ocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5hID0gY29zICogYSAtIHNpbiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5jID0gY29zICogYiAtIHNpbiAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5iID0gc2luICogYSArIGNvcyAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5kID0gc2luICogYiArIGNvcyAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZU1peCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy50ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubG9jYWxUb1dvcmxkKHRlbXAuc2V0KHRoaXMuZGF0YS5vZmZzZXRYLCB0aGlzLmRhdGEub2Zmc2V0WSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQudHggKz0gdGVtcC54ICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQudHkgKz0gdGVtcC55ICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZU1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAoTWF0aC5zcXJ0KHRhICogdGEgKyB0YyAqIHRjKSAtIDEgKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVYKSAqIHNjYWxlTWl4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmEgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChNYXRoLnNxcnQodGIgKiB0YiArIHRkICogdGQpIC0gMSArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVkpICogc2NhbGVNaXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYyAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuZCAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVhck1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmF0YW4yKHRkLCB0YikgLSBNYXRoLmF0YW4yKHRjLCB0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIC09IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociA8IC1jb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG1hdC5jLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLmF0YW4yKGQsIGIpICsgKHIgLSBjb3JlLk1hdGhVdGlscy5QSSAvIDIgKyBvZmZzZXRTaGVhclkpICogc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KGIgKiBiICsgZCAqIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYyA9IE1hdGguY29zKHIpICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgPSBNYXRoLnNpbihyKSAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLmFwcGxpZWRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseUFic29sdXRlTG9jYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvbmUuYXBwbGllZFZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBib25lLmFyb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0YXJnZXQuYXJvdGF0aW9uIC0gcm90YXRpb24gKyB0aGlzLmRhdGEub2Zmc2V0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gKz0gciAqIHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBib25lLmF4LCB5ID0gYm9uZS5heTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSAodGFyZ2V0LmF4IC0geCArIHRoaXMuZGF0YS5vZmZzZXRYKSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSAodGFyZ2V0LmF5IC0geSArIHRoaXMuZGF0YS5vZmZzZXRZKSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IGJvbmUuYXNjYWxlWCwgc2NhbGVZID0gYm9uZS5hc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZU1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlWCA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSAoc2NhbGVYICsgKHRhcmdldC5hc2NhbGVYIC0gc2NhbGVYICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWCkgKiBzY2FsZU1peCkgLyBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZVkgPiAwLjAwMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gKHNjYWxlWSArICh0YXJnZXQuYXNjYWxlWSAtIHNjYWxlWSArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVkpICogc2NhbGVNaXgpIC8gc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hlYXJZID0gYm9uZS5hc2hlYXJZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVhck1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0YXJnZXQuYXNoZWFyWSAtIHNoZWFyWSArIHRoaXMuZGF0YS5vZmZzZXRTaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclkgKz0gciAqIHNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib25lLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVksIGJvbmUuYXNoZWFyWCwgc2hlYXJZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHlSZWxhdGl2ZUxvY2FsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZU1peCA9IHRoaXMucm90YXRlTWl4LCB0cmFuc2xhdGVNaXggPSB0aGlzLnRyYW5zbGF0ZU1peCwgc2NhbGVNaXggPSB0aGlzLnNjYWxlTWl4LCBzaGVhck1peCA9IHRoaXMuc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5hcHBsaWVkVmFsaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib25lLmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gYm9uZS5hcm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZU1peCAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiArPSAodGFyZ2V0LmFyb3RhdGlvbiArIHRoaXMuZGF0YS5vZmZzZXRSb3RhdGlvbikgKiByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBib25lLmF4LCB5ID0gYm9uZS5heTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSAodGFyZ2V0LmF4ICsgdGhpcy5kYXRhLm9mZnNldFgpICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9ICh0YXJnZXQuYXkgKyB0aGlzLmRhdGEub2Zmc2V0WSkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSBib25lLmFzY2FsZVgsIHNjYWxlWSA9IGJvbmUuYXNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVNaXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZVggPiAwLjAwMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVYICo9ICgodGFyZ2V0LmFzY2FsZVggLSAxICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWCkgKiBzY2FsZU1peCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVZID4gMC4wMDAwMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWSAqPSAoKHRhcmdldC5hc2NhbGVZIC0gMSArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVkpICogc2NhbGVNaXgpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoZWFyWSA9IGJvbmUuYXNoZWFyWTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlYXJNaXggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVhclkgKz0gKHRhcmdldC5hc2hlYXJZICsgdGhpcy5kYXRhLm9mZnNldFNoZWFyWSkgKiBzaGVhck1peDtcclxuICAgICAgICAgICAgICAgICAgICBib25lLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aCh4LCB5LCByb3RhdGlvbiwgc2NhbGVYLCBzY2FsZVksIGJvbmUuYXNoZWFyWCwgc2hlYXJZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybUNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnQgPSBUcmFuc2Zvcm1Db25zdHJhaW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFRyYW5zZm9ybUNvbnN0cmFpbnREYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYW5zZm9ybUNvbnN0cmFpbnREYXRhLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1Db25zdHJhaW50RGF0YShuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCAwLCBmYWxzZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yb3RhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNsYXRlTWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNjYWxlTWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNoZWFyTWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldFJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldFggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXRTY2FsZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0U2NhbGVZID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldFNoZWFyWSA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWxhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9jYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtQ29uc3RyYWludERhdGE7XHJcbiAgICAgICAgfShjb3JlLkNvbnN0cmFpbnREYXRhKSk7XHJcbiAgICAgICAgY29yZS5UcmFuc2Zvcm1Db25zdHJhaW50RGF0YSA9IFRyYW5zZm9ybUNvbnN0cmFpbnREYXRhO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFRyaWFuZ3VsYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyaWFuZ3VsYXRvcigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udmV4UG9seWdvbnMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udmV4UG9seWdvbnNJbmRpY2VzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXNBcnJheSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbmNhdmVBcnJheSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvblBvb2wgPSBuZXcgY29yZS5Qb29sKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbkluZGljZXNQb29sID0gbmV3IGNvcmUuUG9vbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJpYW5ndWxhdG9yLnByb3RvdHlwZS50cmlhbmd1bGF0ZSA9IGZ1bmN0aW9uICh2ZXJ0aWNlc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSB2ZXJ0aWNlc0FycmF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleENvdW50ID0gdmVydGljZXNBcnJheS5sZW5ndGggPj4gMTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1tpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNDb25jYXZlID0gdGhpcy5pc0NvbmNhdmVBcnJheTtcclxuICAgICAgICAgICAgICAgIGlzQ29uY2F2ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0ZXhDb3VudDsgaSA8IG47ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbmNhdmVbaV0gPSBUcmlhbmd1bGF0b3IuaXNDb25jYXZlKGksIHZlcnRleENvdW50LCB2ZXJ0aWNlcywgaW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh2ZXJ0ZXhDb3VudCA+IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB2ZXJ0ZXhDb3VudCAtIDEsIGkgPSAwLCBuZXh0ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlcjogaWYgKCFpc0NvbmNhdmVbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IGluZGljZXNbcHJldmlvdXNdIDw8IDEsIHAyID0gaW5kaWNlc1tpXSA8PCAxLCBwMyA9IGluZGljZXNbbmV4dF0gPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMXggPSB2ZXJ0aWNlc1twMV0sIHAxeSA9IHZlcnRpY2VzW3AxICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcDJ4ID0gdmVydGljZXNbcDJdLCBwMnkgPSB2ZXJ0aWNlc1twMiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAzeCA9IHZlcnRpY2VzW3AzXSwgcDN5ID0gdmVydGljZXNbcDMgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gKG5leHQgKyAxKSAlIHZlcnRleENvdW50OyBpaSAhPSBwcmV2aW91czsgaWkgPSAoaWkgKyAxKSAlIHZlcnRleENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbmNhdmVbaWldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGluZGljZXNbaWldIDw8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZ4ID0gdmVydGljZXNbdl0sIHZ5ID0gdmVydGljZXNbdiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhKHAzeCwgcDN5LCBwMXgsIHAxeSwgdngsIHZ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdG9yLnBvc2l0aXZlQXJlYShwMXgsIHAxeSwgcDJ4LCBwMnksIHZ4LCB2eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhKHAyeCwgcDJ5LCBwM3gsIHAzeSwgdngsIHZ5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29uY2F2ZVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IChuZXh0ICsgMSkgJSB2ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1sodmVydGV4Q291bnQgKyBpIC0gMSkgJSB2ZXJ0ZXhDb3VudF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGluZGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGluZGljZXNbKGkgKyAxKSAlIHZlcnRleENvdW50XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb25jYXZlLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gKHZlcnRleENvdW50ICsgaSAtIDEpICUgdmVydGV4Q291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IGkgPT0gdmVydGV4Q291bnQgPyAwIDogaTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbmNhdmVbcHJldmlvdXNJbmRleF0gPSBUcmlhbmd1bGF0b3IuaXNDb25jYXZlKHByZXZpb3VzSW5kZXgsIHZlcnRleENvdW50LCB2ZXJ0aWNlcywgaW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb25jYXZlW25leHRJbmRleF0gPSBUcmlhbmd1bGF0b3IuaXNDb25jYXZlKG5leHRJbmRleCwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1sxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpYW5nbGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0b3IucHJvdG90eXBlLmRlY29tcG9zZSA9IGZ1bmN0aW9uICh2ZXJ0aWNlc0FycmF5LCB0cmlhbmdsZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHZlcnRpY2VzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udmV4UG9seWdvbnMgPSB0aGlzLmNvbnZleFBvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uUG9vbC5mcmVlQWxsKGNvbnZleFBvbHlnb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnZleFBvbHlnb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udmV4UG9seWdvbnNJbmRpY2VzID0gdGhpcy5jb252ZXhQb2x5Z29uc0luZGljZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5mcmVlQWxsKGNvbnZleFBvbHlnb25zSW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29uc0luZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uSW5kaWNlcyA9IHRoaXMucG9seWdvbkluZGljZXNQb29sLm9idGFpbigpO1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5wb2x5Z29uUG9vbC5vYnRhaW4oKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBmYW5CYXNlSW5kZXggPSAtMSwgbGFzdFdpbmRpbmcgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgbjsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gdHJpYW5nbGVzW2ldIDw8IDEsIHQyID0gdHJpYW5nbGVzW2kgKyAxXSA8PCAxLCB0MyA9IHRyaWFuZ2xlc1tpICsgMl0gPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSB2ZXJ0aWNlc1t0MV0sIHkxID0gdmVydGljZXNbdDEgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSB2ZXJ0aWNlc1t0Ml0sIHkyID0gdmVydGljZXNbdDIgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDMgPSB2ZXJ0aWNlc1t0M10sIHkzID0gdmVydGljZXNbdDMgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbkJhc2VJbmRleCA9PSB0MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHBvbHlnb24ubGVuZ3RoIC0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRpbmcxID0gVHJpYW5ndWxhdG9yLndpbmRpbmcocG9seWdvbltvXSwgcG9seWdvbltvICsgMV0sIHBvbHlnb25bbyArIDJdLCBwb2x5Z29uW28gKyAzXSwgeDMsIHkzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRpbmcyID0gVHJpYW5ndWxhdG9yLndpbmRpbmcoeDMsIHkzLCBwb2x5Z29uWzBdLCBwb2x5Z29uWzFdLCBwb2x5Z29uWzJdLCBwb2x5Z29uWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRpbmcxID09IGxhc3RXaW5kaW5nICYmIHdpbmRpbmcyID09IGxhc3RXaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHkzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25JbmRpY2VzLnB1c2godDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmV4UG9seWdvbnNJbmRpY2VzLnB1c2gocG9seWdvbkluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uUG9vbC5mcmVlKHBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uSW5kaWNlc1Bvb2wuZnJlZShwb2x5Z29uSW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IHRoaXMucG9seWdvblBvb2wub2J0YWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHkxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHgyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHkyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHgzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHkzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMgPSB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5vYnRhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMucHVzaCh0MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25JbmRpY2VzLnB1c2godDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcy5wdXNoKHQzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFdpbmRpbmcgPSBUcmlhbmd1bGF0b3Iud2luZGluZyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFuQmFzZUluZGV4ID0gdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleFBvbHlnb25zLnB1c2gocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udmV4UG9seWdvbnNJbmRpY2VzLnB1c2gocG9seWdvbkluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjb252ZXhQb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcyA9IGNvbnZleFBvbHlnb25zSW5kaWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbkluZGljZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gcG9seWdvbkluZGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHBvbHlnb25JbmRpY2VzW3BvbHlnb25JbmRpY2VzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24gPSBjb252ZXhQb2x5Z29uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHBvbHlnb24ubGVuZ3RoIC0gNDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlByZXZYID0gcG9seWdvbltvXSwgcHJldlByZXZZID0gcG9seWdvbltvICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZYID0gcG9seWdvbltvICsgMl0sIHByZXZZID0gcG9seWdvbltvICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0WCA9IHBvbHlnb25bMF0sIGZpcnN0WSA9IHBvbHlnb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFggPSBwb2x5Z29uWzJdLCBzZWNvbmRZID0gcG9seWdvblszXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZGluZyA9IFRyaWFuZ3VsYXRvci53aW5kaW5nKHByZXZQcmV2WCwgcHJldlByZXZZLCBwcmV2WCwgcHJldlksIGZpcnN0WCwgZmlyc3RZKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWkgPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJJbmRpY2VzID0gY29udmV4UG9seWdvbnNJbmRpY2VzW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVySW5kaWNlcy5sZW5ndGggIT0gMylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJGaXJzdEluZGV4ID0gb3RoZXJJbmRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJTZWNvbmRJbmRleCA9IG90aGVySW5kaWNlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyTGFzdEluZGV4ID0gb3RoZXJJbmRpY2VzWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb2x5ID0gY29udmV4UG9seWdvbnNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDMgPSBvdGhlclBvbHlbb3RoZXJQb2x5Lmxlbmd0aCAtIDJdLCB5MyA9IG90aGVyUG9seVtvdGhlclBvbHkubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckZpcnN0SW5kZXggIT0gZmlyc3RJbmRleCB8fCBvdGhlclNlY29uZEluZGV4ICE9IGxhc3RJbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZGluZzEgPSBUcmlhbmd1bGF0b3Iud2luZGluZyhwcmV2UHJldlgsIHByZXZQcmV2WSwgcHJldlgsIHByZXZZLCB4MywgeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZGluZzIgPSBUcmlhbmd1bGF0b3Iud2luZGluZyh4MywgeTMsIGZpcnN0WCwgZmlyc3RZLCBzZWNvbmRYLCBzZWNvbmRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRpbmcxID09IHdpbmRpbmcgJiYgd2luZGluZzIgPT0gd2luZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJQb2x5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckluZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaCh4Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMucHVzaChvdGhlckxhc3RJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2UHJldlggPSBwcmV2WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQcmV2WSA9IHByZXZZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlggPSB4MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZZID0geTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gY29udmV4UG9seWdvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gY29udmV4UG9seWdvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udmV4UG9seWdvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25Qb29sLmZyZWUocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25JbmRpY2VzID0gY29udmV4UG9seWdvbnNJbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29uc0luZGljZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5mcmVlKHBvbHlnb25JbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmV4UG9seWdvbnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUgPSBmdW5jdGlvbiAoaW5kZXgsIHZlcnRleENvdW50LCB2ZXJ0aWNlcywgaW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kaWNlc1sodmVydGV4Q291bnQgKyBpbmRleCAtIDEpICUgdmVydGV4Q291bnRdIDw8IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGluZGljZXNbaW5kZXhdIDw8IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGluZGljZXNbKGluZGV4ICsgMSkgJSB2ZXJ0ZXhDb3VudF0gPDwgMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5wb3NpdGl2ZUFyZWEodmVydGljZXNbcHJldmlvdXNdLCB2ZXJ0aWNlc1twcmV2aW91cyArIDFdLCB2ZXJ0aWNlc1tjdXJyZW50XSwgdmVydGljZXNbY3VycmVudCArIDFdLCB2ZXJ0aWNlc1tuZXh0XSwgdmVydGljZXNbbmV4dCArIDFdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdG9yLnBvc2l0aXZlQXJlYSA9IGZ1bmN0aW9uIChwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDF4ICogKHAzeSAtIHAyeSkgKyBwMnggKiAocDF5IC0gcDN5KSArIHAzeCAqIChwMnkgLSBwMXkpID49IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRvci53aW5kaW5nID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBweCA9IHAyeCAtIHAxeCwgcHkgPSBwMnkgLSBwMXk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDN4ICogcHkgLSBwM3kgKiBweCArIHB4ICogcDF5IC0gcDF4ICogcHkgPj0gMCA/IDEgOiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRyaWFuZ3VsYXRvcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVHJpYW5ndWxhdG9yID0gVHJpYW5ndWxhdG9yO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEludFNldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEludFNldCgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJbnRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5zID0gdGhpcy5jb250YWlucyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5W3ZhbHVlIHwgMF0gPSB2YWx1ZSB8IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBJbnRTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheVt2YWx1ZSB8IDBdICE9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSW50U2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlbdmFsdWUgfCAwXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSW50U2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXkubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEludFNldDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuSW50U2V0ID0gSW50U2V0O1xyXG4gICAgICAgIHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyID09PSB2b2lkIDApIHsgciA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmIChnID09PSB2b2lkIDApIHsgZyA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmIChiID09PSB2b2lkIDApIHsgYiA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmIChhID09PSB2b2lkIDApIHsgYSA9IDA7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICAgICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yLnByb3RvdHlwZS5zZXRGcm9tQ29sb3IgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gYy5yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nID0gYy5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gYy5iO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hID0gYy5hO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yLnByb3RvdHlwZS5zZXRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGhleCkge1xyXG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LmNoYXJBdCgwKSA9PSAnIycgPyBoZXguc3Vic3RyKDEpIDogaGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoaGV4LnN1YnN0cigwLCAyKSwgMTYpIC8gMjU1LjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludChoZXguc3Vic3RyKDIsIDIpLCAxNikgLyAyNTUuMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KGhleC5zdWJzdHIoNCwgMiksIDE2KSAvIDI1NS4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hID0gKGhleC5sZW5ndGggIT0gOCA/IDI1NSA6IHBhcnNlSW50KGhleC5zdWJzdHIoNiwgMiksIDE2KSkgLyAyNTUuMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDb2xvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuciArPSByO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nICs9IGc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmIgKz0gYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYSArPSBhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnIgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnIgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuciA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nID4gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmcgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYiA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmEgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmEgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IucmdiYTg4ODhUb0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IuciA9ICgodmFsdWUgJiAweGZmMDAwMDAwKSA+Pj4gMjQpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY29sb3IuZyA9ICgodmFsdWUgJiAweDAwZmYwMDAwKSA+Pj4gMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY29sb3IuYiA9ICgodmFsdWUgJiAweDAwMDBmZjAwKSA+Pj4gOCkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjb2xvci5hID0gKCh2YWx1ZSAmIDB4MDAwMDAwZmYpKSAvIDI1NTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IucmdiODg4VG9Db2xvciA9IGZ1bmN0aW9uIChjb2xvciwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yLnIgPSAoKHZhbHVlICYgMHgwMGZmMDAwMCkgPj4+IDE2KSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIGNvbG9yLmcgPSAoKHZhbHVlICYgMHgwMDAwZmYwMCkgPj4+IDgpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY29sb3IuYiA9ICgodmFsdWUgJiAweDAwMDAwMGZmKSkgLyAyNTU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yLldISVRFID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICBDb2xvci5SRUQgPSBuZXcgQ29sb3IoMSwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIENvbG9yLkdSRUVOID0gbmV3IENvbG9yKDAsIDEsIDAsIDEpO1xyXG4gICAgICAgICAgICBDb2xvci5CTFVFID0gbmV3IENvbG9yKDAsIDAsIDEsIDEpO1xyXG4gICAgICAgICAgICBDb2xvci5NQUdFTlRBID0gbmV3IENvbG9yKDEsIDAsIDEsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sb3I7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkNvbG9yID0gQ29sb3I7XHJcbiAgICAgICAgdmFyIE1hdGhVdGlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1hdGhVdGlscygpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBNYXRoVXRpbHMuY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuY29zRGVnID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyhkZWdyZWVzICogTWF0aFV0aWxzLmRlZ1JhZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5zaW5EZWcgPSBmdW5jdGlvbiAoZGVncmVlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKGRlZ3JlZXMgKiBNYXRoVXRpbHMuZGVnUmFkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnNpZ251bSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gMCA/IDEgOiB2YWx1ZSA8IDAgPyAtMSA6IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy50b0ludCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCA+IDAgPyBNYXRoLmZsb29yKHgpIDogTWF0aC5jZWlsKHgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuY2JydCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCA8IDAgPyAteSA6IHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5yYW5kb21Ucmlhbmd1bGFyID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLnJhbmRvbVRyaWFuZ3VsYXJXaXRoKG1pbiwgbWF4LCAobWluICsgbWF4KSAqIDAuNSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5yYW5kb21Ucmlhbmd1bGFyV2l0aCA9IGZ1bmN0aW9uIChtaW4sIG1heCwgbW9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgICAgICBpZiAodSA8PSAobW9kZSAtIG1pbikgLyBkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW4gKyBNYXRoLnNxcnQodSAqIGQgKiAobW9kZSAtIG1pbikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heCAtIE1hdGguc3FydCgoMSAtIHUpICogZCAqIChtYXggLSBtb2RlKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5QSSA9IDMuMTQxNTkyNztcclxuICAgICAgICAgICAgTWF0aFV0aWxzLlBJMiA9IE1hdGhVdGlscy5QSSAqIDI7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5yYWRpYW5zVG9EZWdyZWVzID0gMTgwIC8gTWF0aFV0aWxzLlBJO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMucmFkRGVnID0gTWF0aFV0aWxzLnJhZGlhbnNUb0RlZ3JlZXM7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5kZWdyZWVzVG9SYWRpYW5zID0gTWF0aFV0aWxzLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuZGVnUmFkID0gTWF0aFV0aWxzLmRlZ3JlZXNUb1JhZGlhbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLk1hdGhVdGlscyA9IE1hdGhVdGlscztcclxuICAgICAgICB2YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHRoaXMuYXBwbHlJbnRlcm5hbChhKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEludGVycG9sYXRpb247XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0aW9uO1xyXG4gICAgICAgIHZhciBQb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUG93LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQb3cocG93ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wb3dlciA9IDI7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wb3dlciA9IHBvd2VyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBvdy5wcm90b3R5cGUuYXBwbHlJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8PSAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGEgKiAyLCB0aGlzLnBvd2VyKSAvIDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coKGEgLSAxKSAqIDIsIHRoaXMucG93ZXIpIC8gKHRoaXMucG93ZXIgJSAyID09IDAgPyAtMiA6IDIpICsgMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBvdztcclxuICAgICAgICB9KEludGVycG9sYXRpb24pKTtcclxuICAgICAgICBjb3JlLlBvdyA9IFBvdztcclxuICAgICAgICB2YXIgUG93T3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBvd091dCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUG93T3V0KHBvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcG93ZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUG93T3V0LnByb3RvdHlwZS5hcHBseUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhhIC0gMSwgdGhpcy5wb3dlcikgKiAodGhpcy5wb3dlciAlIDIgPT0gMCA/IC0xIDogMSkgKyAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUG93T3V0O1xyXG4gICAgICAgIH0oUG93KSk7XHJcbiAgICAgICAgY29yZS5Qb3dPdXQgPSBQb3dPdXQ7XHJcbiAgICAgICAgdmFyIFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVXRpbHMoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVXRpbHMuYXJyYXlDb3B5ID0gZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlU3RhcnQsIGRlc3QsIGRlc3RTdGFydCwgbnVtRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzb3VyY2VTdGFydCwgaiA9IGRlc3RTdGFydDsgaSA8IHNvdXJjZVN0YXJ0ICsgbnVtRWxlbWVudHM7IGkrKywgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtqXSA9IHNvdXJjZVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXRpbHMuc2V0QXJyYXlTaXplID0gZnVuY3Rpb24gKGFycmF5LCBzaXplLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAwOyB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2l6ZSA9IGFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTaXplID09IHNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTaXplIDwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvbGRTaXplOyBpIDwgc2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5lbnN1cmVBcnJheUNhcGFjaXR5ID0gZnVuY3Rpb24gKGFycmF5LCBzaXplLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAwOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IHNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnNldEFycmF5U2l6ZShhcnJheSwgc2l6ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5uZXdBcnJheSA9IGZ1bmN0aW9uIChzaXplLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5uZXdGbG9hdEFycmF5ID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5uZXdTaG9ydEFycmF5ID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXRpbHMudG9GbG9hdEFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMuU1VQUE9SVFNfVFlQRURfQVJSQVlTID8gbmV3IEZsb2F0MzJBcnJheShhcnJheSkgOiBhcnJheTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXRpbHMudG9TaW5nbGVQcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMgPyBNYXRoLmZyb3VuZCh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXRpbHMud2Via2l0NjAyQnVnZml4SGVscGVyID0gZnVuY3Rpb24gKGFscGhhLCBibGVuZCkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5jb250YWlucyA9IGZ1bmN0aW9uIChhcnJheSwgZWxlbWVudCwgaWRlbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZGVudGl0eSA9PT0gdm9pZCAwKSB7IGlkZW50aXR5ID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PSBlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXRpbHMuU1VQUE9SVFNfVFlQRURfQVJSQVlTID0gdHlwZW9mIChGbG9hdDMyQXJyYXkpICE9PSBcInVuZGVmaW5lZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gVXRpbHM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlV0aWxzID0gVXRpbHM7XHJcbiAgICAgICAgdmFyIERlYnVnVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEZWJ1Z1V0aWxzKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERlYnVnVXRpbHMubG9nQm9uZXMgPSBmdW5jdGlvbiAoc2tlbGV0b24pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhib25lLmRhdGEubmFtZSArIFwiLCBcIiArIG1hdC5hICsgXCIsIFwiICsgbWF0LmIgKyBcIiwgXCIgKyBtYXQuYyArIFwiLCBcIiArIG1hdC5kICsgXCIsIFwiICsgbWF0LnR4ICsgXCIsIFwiICsgbWF0LnR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIERlYnVnVXRpbHM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkRlYnVnVXRpbHMgPSBEZWJ1Z1V0aWxzO1xyXG4gICAgICAgIHZhciBQb29sID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUG9vbChpbnN0YW50aWF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdG9yID0gaW5zdGFudGlhdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBvb2wucHJvdG90eXBlLm9idGFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA+IDAgPyB0aGlzLml0ZW1zLnBvcCgpIDogdGhpcy5pbnN0YW50aWF0b3IoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUG9vbC5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXNldClcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBvb2wucHJvdG90eXBlLmZyZWVBbGwgPSBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWUoaXRlbXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQb29sLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBvb2w7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlBvb2wgPSBQb29sO1xyXG4gICAgICAgIHZhciBWZWN0b3IyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVmVjdG9yMih4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7IHggPSAwOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7IHkgPSAwOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBWZWN0b3IyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVmVjdG9yMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMueTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFZlY3RvcjIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54IC89IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgLz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5WZWN0b3IyID0gVmVjdG9yMjtcclxuICAgICAgICB2YXIgVGltZUtlZXBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRpbWVLZWVwZXIoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heERlbHRhID0gMC4wNjQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVGltZUtlZXBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YSA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lVGltZSArPSB0aGlzLmRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgKz0gdGhpcy5kZWx0YTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbHRhID4gdGhpcy5tYXhEZWx0YSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gdGhpcy5tYXhEZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBub3c7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lQ291bnQrKztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lVGltZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IHRoaXMuZnJhbWVDb3VudCAvIHRoaXMuZnJhbWVUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVGltZUtlZXBlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVGltZUtlZXBlciA9IFRpbWVLZWVwZXI7XHJcbiAgICAgICAgdmFyIFdpbmRvd2VkTWVhbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFdpbmRvd2VkTWVhbih3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93U2l6ZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1NpemUgPSAzMjsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRlZFZhbHVlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lYW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBBcnJheSh3aW5kb3dTaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBXaW5kb3dlZE1lYW4ucHJvdG90eXBlLmhhc0Vub3VnaERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRlZFZhbHVlcyA+PSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFdpbmRvd2VkTWVhbi5wcm90b3R5cGUuYWRkVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkVmFsdWVzIDwgdGhpcy52YWx1ZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkZWRWYWx1ZXMrKztcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW3RoaXMubGFzdFZhbHVlKytdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0VmFsdWUgPiB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXaW5kb3dlZE1lYW4ucHJvdG90eXBlLmdldE1lYW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNFbm91Z2hEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYW4gKz0gdGhpcy52YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWFuID0gbWVhbiAvIHRoaXMudmFsdWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZWFuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBXaW5kb3dlZE1lYW47XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLldpbmRvd2VkTWVhbiA9IFdpbmRvd2VkTWVhbjtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBBdHRhY2htZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNobWVudDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQXR0YWNobWVudCA9IEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgdmFyIFZlcnRleEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVmVydGV4QXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVmVydGV4QXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaWQgPSAoVmVydGV4QXR0YWNobWVudC5uZXh0SUQrKyAmIDY1NTM1KSA8PCAxMTtcclxuICAgICAgICAgICAgICAgIF90aGlzLndvcmxkVmVydGljZXNMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGVmb3JtQXR0YWNobWVudCA9IF90aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFZlcnRleEF0dGFjaG1lbnQucHJvdG90eXBlLmNvbXB1dGVXb3JsZFZlcnRpY2VzT2xkID0gZnVuY3Rpb24gKHNsb3QsIHdvcmxkVmVydGljZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdCwgMCwgdGhpcy53b3JsZFZlcnRpY2VzTGVuZ3RoLCB3b3JsZFZlcnRpY2VzLCAwLCAyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVmVydGV4QXR0YWNobWVudC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbiAoc2xvdCwgc3RhcnQsIGNvdW50LCB3b3JsZFZlcnRpY2VzLCBvZmZzZXQsIHN0cmlkZSkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSBvZmZzZXQgKyAoY291bnQgPj4gMSkgKiBzdHJpZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tlbGV0b24gPSBzbG90LmJvbmUuc2tlbGV0b247XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmb3JtQXJyYXkgPSBzbG90LmRlZm9ybTtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmb3JtQXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBkZWZvcm1BcnJheTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gc2xvdC5ib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG1hdC50eDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG1hdC50eTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdC5hLCBiID0gbWF0LmMsIGMgPSBtYXQuYiwgZCA9IG1hdC5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHZfMSA9IHN0YXJ0LCB3ID0gb2Zmc2V0OyB3IDwgY291bnQ7IHZfMSArPSAyLCB3ICs9IHN0cmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnggPSB2ZXJ0aWNlc1t2XzFdLCB2eSA9IHZlcnRpY2VzW3ZfMSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3ddID0gdnggKiBhICsgdnkgKiBiICsgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1t3ICsgMV0gPSB2eCAqIGMgKyB2eSAqIGQgKyB5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IDAsIHNraXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBib25lc1t2XTtcclxuICAgICAgICAgICAgICAgICAgICB2ICs9IG4gKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHNraXAgKz0gbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbkJvbmVzID0gc2tlbGV0b24uYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmb3JtQXJyYXkubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gb2Zmc2V0LCBiID0gc2tpcCAqIDM7IHcgPCBjb3VudDsgdyArPSBzdHJpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd4ID0gMCwgd3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGJvbmVzW3YrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHYgPCBuOyB2KyssIGIgKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdCA9IHNrZWxldG9uQm9uZXNbYm9uZXNbdl1dLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2eCA9IHZlcnRpY2VzW2JdLCB2eSA9IHZlcnRpY2VzW2IgKyAxXSwgd2VpZ2h0ID0gdmVydGljZXNbYiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3ggKz0gKHZ4ICogbWF0LmEgKyB2eSAqIG1hdC5jICsgbWF0LnR4KSAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd5ICs9ICh2eCAqIG1hdC5iICsgdnkgKiBtYXQuZCArIG1hdC50eSkgKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1t3XSA9IHd4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3cgKyAxXSA9IHd5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZvcm0gPSBkZWZvcm1BcnJheTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gb2Zmc2V0LCBiID0gc2tpcCAqIDMsIGYgPSBza2lwIDw8IDE7IHcgPCBjb3VudDsgdyArPSBzdHJpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd4ID0gMCwgd3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGJvbmVzW3YrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHYgPCBuOyB2KyssIGIgKz0gMywgZiArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gc2tlbGV0b25Cb25lc1tib25lc1t2XV0ubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZ4ID0gdmVydGljZXNbYl0gKyBkZWZvcm1bZl0sIHZ5ID0gdmVydGljZXNbYiArIDFdICsgZGVmb3JtW2YgKyAxXSwgd2VpZ2h0ID0gdmVydGljZXNbYiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3ggKz0gKHZ4ICogbWF0LmEgKyB2eSAqIG1hdC5jICsgbWF0LnR4KSAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd5ICs9ICh2eCAqIG1hdC5iICsgdnkgKiBtYXQuZCArIG1hdC50eSkgKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1t3XSA9IHd4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3cgKyAxXSA9IHd5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVmVydGV4QXR0YWNobWVudC5wcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvbmVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmJvbmVzID0gbmV3IEFycmF5KHRoaXMuYm9uZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLmJvbmVzLCAwLCBhdHRhY2htZW50LmJvbmVzLCAwLCB0aGlzLmJvbmVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5ib25lcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC52ZXJ0aWNlcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheSh0aGlzLnZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy52ZXJ0aWNlcywgMCwgYXR0YWNobWVudC52ZXJ0aWNlcywgMCwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQudmVydGljZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC53b3JsZFZlcnRpY2VzTGVuZ3RoID0gdGhpcy53b3JsZFZlcnRpY2VzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5kZWZvcm1BdHRhY2htZW50ID0gdGhpcy5kZWZvcm1BdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBWZXJ0ZXhBdHRhY2htZW50Lm5leHRJRCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBWZXJ0ZXhBdHRhY2htZW50O1xyXG4gICAgICAgIH0oQXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuVmVydGV4QXR0YWNobWVudCA9IFZlcnRleEF0dGFjaG1lbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQXR0YWNobWVudFR5cGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChBdHRhY2htZW50VHlwZSkge1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIlJlZ2lvblwiXSA9IDBdID0gXCJSZWdpb25cIjtcclxuICAgICAgICAgICAgQXR0YWNobWVudFR5cGVbQXR0YWNobWVudFR5cGVbXCJCb3VuZGluZ0JveFwiXSA9IDFdID0gXCJCb3VuZGluZ0JveFwiO1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIk1lc2hcIl0gPSAyXSA9IFwiTWVzaFwiO1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIkxpbmtlZE1lc2hcIl0gPSAzXSA9IFwiTGlua2VkTWVzaFwiO1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIlBhdGhcIl0gPSA0XSA9IFwiUGF0aFwiO1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIlBvaW50XCJdID0gNV0gPSBcIlBvaW50XCI7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiQ2xpcHBpbmdcIl0gPSA2XSA9IFwiQ2xpcHBpbmdcIjtcclxuICAgICAgICB9KShBdHRhY2htZW50VHlwZSA9IGNvcmUuQXR0YWNobWVudFR5cGUgfHwgKGNvcmUuQXR0YWNobWVudFR5cGUgPSB7fSkpO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEJvdW5kaW5nQm94QXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhCb3VuZGluZ0JveEF0dGFjaG1lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94QXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBCb3VuZGluZ0JveEF0dGFjaG1lbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBCb3VuZGluZ0JveEF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29weVRvKGNvcHkpO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94QXR0YWNobWVudDtcclxuICAgICAgICB9KGNvcmUuVmVydGV4QXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuQm91bmRpbmdCb3hBdHRhY2htZW50ID0gQm91bmRpbmdCb3hBdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIENsaXBwaW5nQXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDbGlwcGluZ0F0dGFjaG1lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENsaXBwaW5nQXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigwLjIyNzUsIDAuMjI3NSwgMC44MDc4LCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGlwcGluZ0F0dGFjaG1lbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBDbGlwcGluZ0F0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29weVRvKGNvcHkpO1xyXG4gICAgICAgICAgICAgICAgY29weS5lbmRTbG90ID0gdGhpcy5lbmRTbG90O1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIENsaXBwaW5nQXR0YWNobWVudDtcclxuICAgICAgICB9KGNvcmUuVmVydGV4QXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuQ2xpcHBpbmdBdHRhY2htZW50ID0gQ2xpcHBpbmdBdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIE1lc2hBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKE1lc2hBdHRhY2htZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNZXNoQXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRlbXBDb2xvciA9IG5ldyBjb3JlLkNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1lc2hBdHRhY2htZW50LnByb3RvdHlwZS5nZXRQYXJlbnRNZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWVzaDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLnNldFBhcmVudE1lc2ggPSBmdW5jdGlvbiAocGFyZW50TWVzaCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZXNoID0gcGFyZW50TWVzaDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNZXNoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gcGFyZW50TWVzaC5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gcGFyZW50TWVzaC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmxkVmVydGljZXNMZW5ndGggPSBwYXJlbnRNZXNoLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25VVnMgPSBwYXJlbnRNZXNoLnJlZ2lvblVWcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWFuZ2xlcyA9IHBhcmVudE1lc2gudHJpYW5nbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHVsbExlbmd0aCA9IHBhcmVudE1lc2guaHVsbExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmxkVmVydGljZXNMZW5ndGggPSBwYXJlbnRNZXNoLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1lc2hBdHRhY2htZW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50TWVzaCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld0xpbmtlZE1lc2goKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IE1lc2hBdHRhY2htZW50KHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnJlZ2lvbiA9IHRoaXMucmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgY29weS5wYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhjb3B5KTtcclxuICAgICAgICAgICAgICAgIGNvcHkucmVnaW9uVVZzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlZ2lvblVWcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy5yZWdpb25VVnMsIDAsIGNvcHkucmVnaW9uVVZzLCAwLCB0aGlzLnJlZ2lvblVWcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29weS51dnMgPSBuZXcgQXJyYXkodGhpcy51dnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHRoaXMudXZzLCAwLCBjb3B5LnV2cywgMCwgdGhpcy51dnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcHkudHJpYW5nbGVzID0gbmV3IEFycmF5KHRoaXMudHJpYW5nbGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLnRyaWFuZ2xlcywgMCwgY29weS50cmlhbmdsZXMsIDAsIHRoaXMudHJpYW5nbGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb3B5Lmh1bGxMZW5ndGggPSB0aGlzLmh1bGxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGdlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29weS5lZGdlcyA9IG5ldyBBcnJheSh0aGlzLmVkZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy5lZGdlcywgMCwgY29weS5lZGdlcywgMCwgdGhpcy5lZGdlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29weS53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1lc2hBdHRhY2htZW50LnByb3RvdHlwZS5uZXdMaW5rZWRNZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgTWVzaEF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvcHkucmVnaW9uID0gdGhpcy5yZWdpb247XHJcbiAgICAgICAgICAgICAgICBjb3B5LnBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIGNvcHkuZGVmb3JtQXR0YWNobWVudCA9IHRoaXMuZGVmb3JtQXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgIGNvcHkuc2V0UGFyZW50TWVzaCh0aGlzLnBhcmVudE1lc2ggIT0gbnVsbCA/IHRoaXMucGFyZW50TWVzaCA6IHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNZXNoQXR0YWNobWVudDtcclxuICAgICAgICB9KGNvcmUuVmVydGV4QXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuTWVzaEF0dGFjaG1lbnQgPSBNZXNoQXR0YWNobWVudDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBQYXRoQXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQYXRoQXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aEF0dGFjaG1lbnQobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29uc3RhbnRTcGVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYXRoQXR0YWNobWVudC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IFBhdGhBdHRhY2htZW50KHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhjb3B5KTtcclxuICAgICAgICAgICAgICAgIGNvcHkubGVuZ3RocyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHRoaXMubGVuZ3RocywgMCwgY29weS5sZW5ndGhzLCAwLCB0aGlzLmxlbmd0aHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcHkuY2xvc2VkID0gY2xvc2VkO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb25zdGFudFNwZWVkID0gdGhpcy5jb25zdGFudFNwZWVkO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBhdGhBdHRhY2htZW50O1xyXG4gICAgICAgIH0oY29yZS5WZXJ0ZXhBdHRhY2htZW50KSk7XHJcbiAgICAgICAgY29yZS5QYXRoQXR0YWNobWVudCA9IFBhdGhBdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFBvaW50QXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQb2ludEF0dGFjaG1lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50QXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigwLjM4LCAwLjk0LCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQb2ludEF0dGFjaG1lbnQucHJvdG90eXBlLmNvbXB1dGVXb3JsZFBvc2l0aW9uID0gZnVuY3Rpb24gKGJvbmUsIHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICBwb2ludC54ID0gdGhpcy54ICogbWF0LmEgKyB0aGlzLnkgKiBtYXQuYyArIGJvbmUud29ybGRYO1xyXG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IHRoaXMueCAqIG1hdC5iICsgdGhpcy55ICogbWF0LmQgKyBib25lLndvcmxkWTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUG9pbnRBdHRhY2htZW50LnByb3RvdHlwZS5jb21wdXRlV29ybGRSb3RhdGlvbiA9IGZ1bmN0aW9uIChib25lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHRoaXMucm90YXRpb24pLCBzaW4gPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGNvcyAqIG1hdC5hICsgc2luICogbWF0LmM7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGNvcyAqIG1hdC5iICsgc2luICogbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUG9pbnRBdHRhY2htZW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgUG9pbnRBdHRhY2htZW50KHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnggPSB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvcHkuY29sb3Iuc2V0RnJvbUNvbG9yKHRoaXMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgfShjb3JlLlZlcnRleEF0dGFjaG1lbnQpKTtcclxuICAgICAgICBjb3JlLlBvaW50QXR0YWNobWVudCA9IFBvaW50QXR0YWNobWVudDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBSZWdpb25BdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFJlZ2lvbkF0dGFjaG1lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlZ2lvbkF0dGFjaG1lbnQobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMueSA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KDgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXZzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KDgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGVtcENvbG9yID0gbmV3IGNvcmUuQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5wcm90b3R5cGUudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lvblNjYWxlWCA9IHRoaXMud2lkdGggLyB0aGlzLnJlZ2lvbi5vcmlnaW5hbFdpZHRoICogdGhpcy5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uU2NhbGVZID0gdGhpcy5oZWlnaHQgLyB0aGlzLnJlZ2lvbi5vcmlnaW5hbEhlaWdodCAqIHRoaXMuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWCA9IC10aGlzLndpZHRoIC8gMiAqIHRoaXMuc2NhbGVYICsgdGhpcy5yZWdpb24ub2Zmc2V0WCAqIHJlZ2lvblNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFkgPSAtdGhpcy5oZWlnaHQgLyAyICogdGhpcy5zY2FsZVkgKyB0aGlzLnJlZ2lvbi5vZmZzZXRZICogcmVnaW9uU2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWDIgPSBsb2NhbFggKyB0aGlzLnJlZ2lvbi53aWR0aCAqIHJlZ2lvblNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFkyID0gbG9jYWxZICsgdGhpcy5yZWdpb24uaGVpZ2h0ICogcmVnaW9uU2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGlhbnMgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcclxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFhDb3MgPSBsb2NhbFggKiBjb3MgKyB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxYU2luID0gbG9jYWxYICogc2luO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWUNvcyA9IGxvY2FsWSAqIGNvcyArIHRoaXMueTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFlTaW4gPSBsb2NhbFkgKiBzaW47XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxYMkNvcyA9IGxvY2FsWDIgKiBjb3MgKyB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxYMlNpbiA9IGxvY2FsWDIgKiBzaW47XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxZMkNvcyA9IGxvY2FsWTIgKiBjb3MgKyB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxZMlNpbiA9IGxvY2FsWTIgKiBzaW47XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDFdID0gbG9jYWxYQ29zIC0gbG9jYWxZU2luO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kxXSA9IGxvY2FsWUNvcyArIGxvY2FsWFNpbjtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YMl0gPSBsb2NhbFhDb3MgLSBsb2NhbFkyU2luO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kyXSA9IGxvY2FsWTJDb3MgKyBsb2NhbFhTaW47XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDNdID0gbG9jYWxYMkNvcyAtIGxvY2FsWTJTaW47XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTNdID0gbG9jYWxZMkNvcyArIGxvY2FsWDJTaW47XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDRdID0gbG9jYWxYMkNvcyAtIGxvY2FsWVNpbjtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZNF0gPSBsb2NhbFlDb3MgKyBsb2NhbFgyU2luO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAocmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIHZhciB1dnMgPSB0aGlzLnV2cztcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpb24ucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzJdID0gcmVnaW9uLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzNdID0gcmVnaW9uLnYyO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s0XSA9IHJlZ2lvbi51O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s1XSA9IHJlZ2lvbi52O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s2XSA9IHJlZ2lvbi51MjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbN10gPSByZWdpb24udjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbMF0gPSByZWdpb24udTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzFdID0gcmVnaW9uLnYyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzBdID0gcmVnaW9uLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzFdID0gcmVnaW9uLnYyO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1syXSA9IHJlZ2lvbi51O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1szXSA9IHJlZ2lvbi52O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s0XSA9IHJlZ2lvbi51MjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbNV0gPSByZWdpb24udjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbNl0gPSByZWdpb24udTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzddID0gcmVnaW9uLnYyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uIChib25lLCB3b3JsZFZlcnRpY2VzLCBvZmZzZXQsIHN0cmlkZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleE9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdCA9IGJvbmUubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBtYXQudHgsIHkgPSBtYXQudHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdC5hLCBiID0gbWF0LmMsIGMgPSBtYXQuYiwgZCA9IG1hdC5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgICAgIG9mZnNldFggPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDFdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZMV07XHJcbiAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW29mZnNldF0gPSBvZmZzZXRYICogYSArIG9mZnNldFkgKiBiICsgeDtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0ICsgMV0gPSBvZmZzZXRYICogYyArIG9mZnNldFkgKiBkICsgeTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGU7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gyXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFkgPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTJdO1xyXG4gICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1tvZmZzZXRdID0gb2Zmc2V0WCAqIGEgKyBvZmZzZXRZICogYiArIHg7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW29mZnNldCArIDFdID0gb2Zmc2V0WCAqIGMgKyBvZmZzZXRZICogZCArIHk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kzXTtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0XSA9IG9mZnNldFggKiBhICsgb2Zmc2V0WSAqIGIgKyB4O1xyXG4gICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1tvZmZzZXQgKyAxXSA9IG9mZnNldFggKiBjICsgb2Zmc2V0WSAqIGQgKyB5O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFggPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDRdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZNF07XHJcbiAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW29mZnNldF0gPSBvZmZzZXRYICogYSArIG9mZnNldFkgKiBiICsgeDtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0ICsgMV0gPSBvZmZzZXRYICogYyArIG9mZnNldFkgKiBkICsgeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IFJlZ2lvbkF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvcHkucmVnaW9uID0gdGhpcy5yZWdpb247XHJcbiAgICAgICAgICAgICAgICBjb3B5LnJlbmRlcmVyT2JqZWN0ID0gdGhpcy5yZW5kZXJlck9iamVjdDtcclxuICAgICAgICAgICAgICAgIGNvcHkucGF0aCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgICAgIGNvcHkueCA9IHRoaXMueDtcclxuICAgICAgICAgICAgICAgIGNvcHkueSA9IHRoaXMueTtcclxuICAgICAgICAgICAgICAgIGNvcHkuc2NhbGVYID0gdGhpcy5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgY29weS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICBjb3B5LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvcHkuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLnV2cywgMCwgY29weS51dnMsIDAsIDgpO1xyXG4gICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy5vZmZzZXQsIDAsIGNvcHkub2Zmc2V0LCAwLCA4KTtcclxuICAgICAgICAgICAgICAgIGNvcHkuY29sb3Iuc2V0RnJvbUNvbG9yKHRoaXMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuT1gxID0gMDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWTEgPSAxO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Lk9YMiA9IDI7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuT1kyID0gMztcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWDMgPSA0O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Lk9ZMyA9IDU7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuT1g0ID0gNjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWTQgPSA3O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlgxID0gMDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5ZMSA9IDE7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzFSID0gMjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMUcgPSAzO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMxQiA9IDQ7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzFBID0gNTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5VMSA9IDY7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuVjEgPSA3O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlgyID0gODtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5ZMiA9IDk7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzJSID0gMTA7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzJHID0gMTE7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzJCID0gMTI7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzJBID0gMTM7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuVTIgPSAxNDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5WMiA9IDE1O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlgzID0gMTY7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuWTMgPSAxNztcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DM1IgPSAxODtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DM0cgPSAxOTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DM0IgPSAyMDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DM0EgPSAyMTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5VMyA9IDIyO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlYzID0gMjM7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuWDQgPSAyNDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5ZNCA9IDI1O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkM0UiA9IDI2O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkM0RyA9IDI3O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkM0QiA9IDI4O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkM0QSA9IDI5O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlU0ID0gMzA7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuVjQgPSAzMTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZ2lvbkF0dGFjaG1lbnQ7XHJcbiAgICAgICAgfShjb3JlLkF0dGFjaG1lbnQpKTtcclxuICAgICAgICBjb3JlLlJlZ2lvbkF0dGFjaG1lbnQgPSBSZWdpb25BdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEppdHRlckVmZmVjdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEppdHRlckVmZmVjdChqaXR0ZXJYLCBqaXR0ZXJZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlclggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXJZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaml0dGVyWCA9IGppdHRlclg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlclkgPSBqaXR0ZXJZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEppdHRlckVmZmVjdC5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbiAoc2tlbGV0b24pIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSml0dGVyRWZmZWN0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocG9zaXRpb24sIHV2LCBsaWdodCwgZGFyaykge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueCArPSBjb3JlLk1hdGhVdGlscy5yYW5kb21Ucmlhbmd1bGFyKC10aGlzLmppdHRlclgsIHRoaXMuaml0dGVyWSk7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi55ICs9IGNvcmUuTWF0aFV0aWxzLnJhbmRvbVRyaWFuZ3VsYXIoLXRoaXMuaml0dGVyWCwgdGhpcy5qaXR0ZXJZKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSml0dGVyRWZmZWN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBKaXR0ZXJFZmZlY3Q7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkppdHRlckVmZmVjdCA9IEppdHRlckVmZmVjdDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTd2lybEVmZmVjdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN3aXJsRWZmZWN0KHJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyWSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFN3aXJsRWZmZWN0LnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uIChza2VsZXRvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFggPSBza2VsZXRvbi54ICsgdGhpcy5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFkgPSBza2VsZXRvbi55ICsgdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTd2lybEVmZmVjdC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB1diwgbGlnaHQsIGRhcmspIHtcclxuICAgICAgICAgICAgICAgIHZhciByYWRBbmdsZSA9IHRoaXMuYW5nbGUgKiBjb3JlLk1hdGhVdGlscy5kZWdyZWVzVG9SYWRpYW5zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBwb3NpdGlvbi54IC0gdGhpcy53b3JsZFg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHBvc2l0aW9uLnkgLSB0aGlzLndvcmxkWTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCB0aGlzLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IFN3aXJsRWZmZWN0LmludGVycG9sYXRpb24uYXBwbHkoMCwgcmFkQW5nbGUsICh0aGlzLnJhZGl1cyAtIGRpc3QpIC8gdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi54ID0gY29zICogeCAtIHNpbiAqIHkgKyB0aGlzLndvcmxkWDtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi55ID0gc2luICogeCArIGNvcyAqIHkgKyB0aGlzLndvcmxkWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU3dpcmxFZmZlY3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU3dpcmxFZmZlY3QuaW50ZXJwb2xhdGlvbiA9IG5ldyBjb3JlLlBvd091dCgyKTtcclxuICAgICAgICAgICAgcmV0dXJuIFN3aXJsRWZmZWN0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Td2lybEVmZmVjdCA9IFN3aXJsRWZmZWN0O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIU1hdGguZnJvdW5kKSB7XHJcbiAgICAgICAgTWF0aC5mcm91bmQgPSBNYXRoLmZyb3VuZCA9IChmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbMF0gPSB4LCBhcnJheVswXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KShuZXcgRmxvYXQzMkFycmF5KDEpKTtcclxuICAgIH1cclxufSkoKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgcGl4aV9zcGluZS5jb3JlLkJvbmUueURvd24gPSB0cnVlO1xyXG4gICAgdmFyIHRlbXBSZ2IgPSBbMCwgMCwgMF07XHJcbiAgICB2YXIgU3BpbmVTcHJpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcGluZVNwcml0ZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcGluZVNwcml0ZSgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnJlZ2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLmF0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTcGluZVNwcml0ZTtcclxuICAgIH0oUElYSS5TcHJpdGUpKTtcclxuICAgIHBpeGlfc3BpbmUuU3BpbmVTcHJpdGUgPSBTcGluZVNwcml0ZTtcclxuICAgIHZhciBncCA9IFBJWEkuR3JhcGhpY3NHZW9tZXRyeS5wcm90b3R5cGU7XHJcbiAgICBpZiAoIWdwLmludmFsaWRhdGUpIHtcclxuICAgICAgICB2YXIgdG1wXzEgPSBbXTtcclxuICAgICAgICBncC5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xyXG4gICAgICAgICAgICB0bXBfMS5wdXNoKDApO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IHRtcF8xO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIFNwaW5lTWVzaCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwaW5lTWVzaCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcGluZU1lc2godGV4dHVyZSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGV4dHVyZSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnJlZ2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLmF0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTcGluZU1lc2g7XHJcbiAgICB9KFBJWEkuU2ltcGxlTWVzaCkpO1xyXG4gICAgcGl4aV9zcGluZS5TcGluZU1lc2ggPSBTcGluZU1lc2g7XHJcbiAgICB2YXIgU3BpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcGluZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcGluZShzcGluZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgaWYgKCFzcGluZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaW5lRGF0YSBwYXJhbSBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBzcGluZURhdGEpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwaW5lRGF0YSBwYXJhbSBjYW50IGJlIHN0cmluZy4gUGxlYXNlIHVzZSBzcGluZS5TcGluZS5mcm9tQXRsYXMoXCJZT1VSX1JFU09VUkNFX05BTUVcIikgZnJvbSBub3cgb24uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuc3BpbmVEYXRhID0gc3BpbmVEYXRhO1xyXG4gICAgICAgICAgICBfdGhpcy5za2VsZXRvbiA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuU2tlbGV0b24oc3BpbmVEYXRhKTtcclxuICAgICAgICAgICAgX3RoaXMuc2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdGVEYXRhID0gbmV3IHBpeGlfc3BpbmUuY29yZS5BbmltYXRpb25TdGF0ZURhdGEoc3BpbmVEYXRhKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBuZXcgcGl4aV9zcGluZS5jb3JlLkFuaW1hdGlvblN0YXRlKF90aGlzLnN0YXRlRGF0YSk7XHJcbiAgICAgICAgICAgIF90aGlzLnNsb3RDb250YWluZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLnRlbXBDbGlwQ29udGFpbmVycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IF90aGlzLnNrZWxldG9uLnNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBfdGhpcy5za2VsZXRvbi5zbG90c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IF90aGlzLm5ld0NvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2xvdENvbnRhaW5lcnMucHVzaChzbG90Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZENoaWxkKHNsb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGVtcENsaXBDb250YWluZXJzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHBpeGlfc3BpbmUuY29yZS5SZWdpb25BdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZU5hbWUgPSBhdHRhY2htZW50LnJlZ2lvbi5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBfdGhpcy5jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudCwgc3ByaXRlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc3ByaXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZU5hbWUgPSBzcHJpdGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBwaXhpX3NwaW5lLmNvcmUuTWVzaEF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IF90aGlzLmNyZWF0ZU1lc2goc2xvdCwgYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaCA9IG1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaElkID0gYXR0YWNobWVudC5pZDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKG1lc2gpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHBpeGlfc3BpbmUuY29yZS5DbGlwcGluZ0F0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVHcmFwaGljcyhzbG90LCBhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNsb3QuY2xpcHBpbmdDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc2xvdC5jdXJyZW50R3JhcGhpY3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudGludFJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKTtcclxuICAgICAgICAgICAgX3RoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGluZS5wcm90b3R5cGUsIFwiYXV0b1VwZGF0ZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2F1dG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB2YWx1ZSA/IFNwaW5lLnByb3RvdHlwZS5hdXRvVXBkYXRlVHJhbnNmb3JtIDogUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGluZS5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGluZS5wcm90b3R5cGUsIFwidGludFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBJWEkudXRpbHMucmdiMmhleCh0aGlzLnRpbnRSZ2IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW50UmdiID0gUElYSS51dGlscy5oZXgycmdiKHZhbHVlLCB0aGlzLnRpbnRSZ2IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwaW5lLnByb3RvdHlwZSwgXCJkZWxheUxpbWl0XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSB0eXBlb2YgdGhpcy5sb2NhbERlbGF5TGltaXQgIT09IFwidW5kZWZpbmVkXCIgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxEZWxheUxpbWl0IDogU3BpbmUuZ2xvYmFsRGVsYXlMaW1pdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaW1pdCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgICAgICB2YXIgZGVsYXlMaW1pdCA9IHRoaXMuZGVsYXlMaW1pdDtcclxuICAgICAgICAgICAgaWYgKGR0ID4gZGVsYXlMaW1pdClcclxuICAgICAgICAgICAgICAgIGR0ID0gZGVsYXlMaW1pdDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUoZHQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmFwcGx5KHRoaXMuc2tlbGV0b24pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2tlbGV0b24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuc2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5za2VsZXRvbi5zbG90cztcclxuICAgICAgICAgICAgdmFyIGdsb2JhbENsciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgICAgIHZhciBsaWdodCA9IG51bGwsIGRhcmsgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZ2xvYmFsQ2xyKSB7XHJcbiAgICAgICAgICAgICAgICBsaWdodCA9IGdsb2JhbENsci5saWdodDtcclxuICAgICAgICAgICAgICAgIGRhcmsgPSBnbG9iYWxDbHIuZGFyaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ID0gdGhpcy50aW50UmdiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0aGFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHRoaXMuc2xvdENvbnRhaW5lcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVDb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0Q29sb3IgPSBhdHRhY2htZW50LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBwaXhpX3NwaW5lLmNvcmUuUmVnaW9uQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRNZXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaE5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyID0gcmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3QuY3VycmVudFNwcml0ZU5hbWUgfHwgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSAhPT0gYXIubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZU5hbWUgPSBhci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnNwcml0ZXMgPSBzbG90LnNwcml0ZXMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudCwgc3ByaXRlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9IHNwcml0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9PT0gYXIubmFtZSAmJiAhc2xvdC5oYWNrUmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNwcml0ZVJlZ2lvbihhdHRhY2htZW50LCBzbG90LmN1cnJlbnRTcHJpdGUsIHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHNsb3RDb250YWluZXIudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZXRGcm9tTWF0cml4KHNsb3QuYm9uZS5tYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRTcHJpdGUuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlQ29sb3IgPSBzbG90LmN1cnJlbnRTcHJpdGUuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzBdID0gbGlnaHRbMF0gKiBzbG90LmNvbG9yLnIgKiBhdHRDb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzFdID0gbGlnaHRbMV0gKiBzbG90LmNvbG9yLmcgKiBhdHRDb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzJdID0gbGlnaHRbMl0gKiBzbG90LmNvbG9yLmIgKiBhdHRDb2xvci5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUudGludCA9IFBJWEkudXRpbHMucmdiMmhleCh0ZW1wUmdiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLmJsZW5kTW9kZSA9IHNsb3QuYmxlbmRNb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHBpeGlfc3BpbmUuY29yZS5NZXNoQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBQSVhJLlRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5fd29ybGRJRCA9IHNsb3RDb250YWluZXIudHJhbnNmb3JtLl93b3JsZElEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbG90LmN1cnJlbnRNZXNoSWQgfHwgc2xvdC5jdXJyZW50TWVzaElkICE9PSBhdHRhY2htZW50LmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNoSWQgPSBhdHRhY2htZW50LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50TWVzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5tZXNoZXMgPSBzbG90Lm1lc2hlcyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QubWVzaGVzW21lc2hJZF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5tZXNoZXNbbWVzaElkXS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNoID0gdGhpcy5jcmVhdGVNZXNoKHNsb3QsIGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChtZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoID0gc2xvdC5tZXNoZXNbbWVzaElkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaE5hbWUgPSBhdHRhY2htZW50Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2hJZCA9IG1lc2hJZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb21wdXRlV29ybGRWZXJ0aWNlc09sZChzbG90LCBzbG90LmN1cnJlbnRNZXNoLnZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50TWVzaC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGVDb2xvciA9IHNsb3QuY3VycmVudE1lc2guY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzBdID0gbGlnaHRbMF0gKiBzbG90LmNvbG9yLnIgKiBhdHRDb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzFdID0gbGlnaHRbMV0gKiBzbG90LmNvbG9yLmcgKiBhdHRDb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUmdiWzJdID0gbGlnaHRbMl0gKiBzbG90LmNvbG9yLmIgKiBhdHRDb2xvci5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoLnRpbnQgPSBQSVhJLnV0aWxzLnJnYjJoZXgodGVtcFJnYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2guYmxlbmRNb2RlID0gc2xvdC5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgcGl4aV9zcGluZS5jb3JlLkNsaXBwaW5nQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdC5jdXJyZW50R3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFwaGljcyhzbG90LCBhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzbG90LmNsaXBwaW5nQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzbG90LmN1cnJlbnRHcmFwaGljcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlR3JhcGhpY3Moc2xvdCwgYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hbHBoYSA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZUNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIwID0gc2xvdC5jb2xvci5yICogYXR0Q29sb3IucjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZzAgPSBzbG90LmNvbG9yLmcgKiBhdHRDb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiMCA9IHNsb3QuY29sb3IuYiAqIGF0dENvbG9yLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQ29sb3Iuc2V0TGlnaHQobGlnaHRbMF0gKiByMCArIGRhcmtbMF0gKiAoMS4wIC0gcjApLCBsaWdodFsxXSAqIGcwICsgZGFya1sxXSAqICgxLjAgLSBnMCksIGxpZ2h0WzJdICogYjAgKyBkYXJrWzJdICogKDEuMCAtIGIwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuZGFya0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIwID0gc2xvdC5kYXJrQ29sb3IucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZzAgPSBzbG90LmRhcmtDb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiMCA9IHNsb3QuZGFya0NvbG9yLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByMCA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZzAgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIwID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVDb2xvci5zZXREYXJrKGxpZ2h0WzBdICogcjAgKyBkYXJrWzBdICogKDEgLSByMCksIGxpZ2h0WzFdICogZzAgKyBkYXJrWzFdICogKDEgLSBnMCksIGxpZ2h0WzJdICogYjAgKyBkYXJrWzJdICogKDEgLSBiMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hbHBoYSA9IHNsb3QuY29sb3IuYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZHJhd09yZGVyID0gdGhpcy5za2VsZXRvbi5kcmF3T3JkZXI7XHJcbiAgICAgICAgICAgIHZhciBjbGlwcGluZ0F0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgY2xpcHBpbmdDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbZHJhd09yZGVyW2ldLmRhdGEuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSB0aGlzLnNsb3RDb250YWluZXJzW2RyYXdPcmRlcltpXS5kYXRhLmluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghY2xpcHBpbmdDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdENvbnRhaW5lci5wYXJlbnQgIT09IG51bGwgJiYgc2xvdENvbnRhaW5lci5wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5wYXJlbnQucmVtb3ZlQ2hpbGQoc2xvdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50R3JhcGhpY3MgJiYgc2xvdC5nZXRBdHRhY2htZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0NvbnRhaW5lciA9IHNsb3QuY2xpcHBpbmdDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdBdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gc2xvdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcHBpbmdBdHRhY2htZW50LmVuZFNsb3QgPT0gc2xvdC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwaW5nQXR0YWNobWVudC5lbmRTbG90ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcHBpbmdDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnRlbXBDbGlwQ29udGFpbmVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy50ZW1wQ2xpcENvbnRhaW5lcnNbaV0gPSB0aGlzLm5ld0NvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdDb250YWluZXIuYWRkQ2hpbGQoc2xvdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlwcGluZ0F0dGFjaG1lbnQuZW5kU2xvdCA9PSBzbG90LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwaW5nQ29udGFpbmVyLnJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdBdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXSA9IHNsb3RDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICA7XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLnNldFNwcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCBzcHJpdGUsIHJlZ2lvbikge1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlLmF0dGFjaG1lbnQgPT09IGF0dGFjaG1lbnQgJiYgc3ByaXRlLnJlZ2lvbiA9PT0gcmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ByaXRlLnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgc3ByaXRlLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICBzcHJpdGUudGV4dHVyZSA9IHJlZ2lvbi50ZXh0dXJlO1xyXG4gICAgICAgICAgICBzcHJpdGUucm90YXRpb24gPSBhdHRhY2htZW50LnJvdGF0aW9uICogcGl4aV9zcGluZS5jb3JlLk1hdGhVdGlscy5kZWdSYWQ7XHJcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi54ID0gYXR0YWNobWVudC54O1xyXG4gICAgICAgICAgICBzcHJpdGUucG9zaXRpb24ueSA9IGF0dGFjaG1lbnQueTtcclxuICAgICAgICAgICAgc3ByaXRlLmFscGhhID0gYXR0YWNobWVudC5jb2xvci5hO1xyXG4gICAgICAgICAgICBpZiAoIXJlZ2lvbi5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUueCA9IGF0dGFjaG1lbnQuc2NhbGVYICogYXR0YWNobWVudC53aWR0aCAvIHJlZ2lvbi5vcmlnaW5hbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnkgPSAtYXR0YWNobWVudC5zY2FsZVkgKiBhdHRhY2htZW50LmhlaWdodCAvIHJlZ2lvbi5vcmlnaW5hbEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS54ID0gcmVnaW9uLnNpemUud2lkdGggLyByZWdpb24ub3JpZ2luYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS55ID0gLXJlZ2lvbi5zaXplLmhlaWdodCAvIHJlZ2lvbi5vcmlnaW5hbEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLnNldE1lc2hSZWdpb24gPSBmdW5jdGlvbiAoYXR0YWNobWVudCwgbWVzaCwgcmVnaW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXNoLmF0dGFjaG1lbnQgPT09IGF0dGFjaG1lbnQgJiYgbWVzaC5yZWdpb24gPT09IHJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lc2gucmVnaW9uID0gcmVnaW9uO1xyXG4gICAgICAgICAgICBtZXNoLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICBtZXNoLnRleHR1cmUgPSByZWdpb24udGV4dHVyZTtcclxuICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUudXBkYXRlVXZzKCk7XHJcbiAgICAgICAgICAgIG1lc2gudXZCdWZmZXIudXBkYXRlKGF0dGFjaG1lbnQucmVnaW9uVVZzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5hdXRvVXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoU3BpbmUuZ2xvYmFsQXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IHRoaXMubGFzdFRpbWUgfHwgRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdFRpbWUpICogMC4wMDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHRpbWVEZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQSVhJLkNvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICA7XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLmNyZWF0ZVNwcml0ZSA9IGZ1bmN0aW9uIChzbG90LCBhdHRhY2htZW50LCBkZWZOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgaWYgKHNsb3QuaGFja0F0dGFjaG1lbnQgPT09IGF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IHNsb3QuaGFja1JlZ2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHJlZ2lvbi50ZXh0dXJlO1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5uZXdTcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3ByaXRlUmVnaW9uKGF0dGFjaG1lbnQsIHNwcml0ZSwgYXR0YWNobWVudC5yZWdpb24pO1xyXG4gICAgICAgICAgICBzbG90LnNwcml0ZXMgPSBzbG90LnNwcml0ZXMgfHwge307XHJcbiAgICAgICAgICAgIHNsb3Quc3ByaXRlc1tkZWZOYW1lXSA9IHNwcml0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIDtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uIChzbG90LCBhdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgIHZhciByZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgaWYgKHNsb3QuaGFja0F0dGFjaG1lbnQgPT09IGF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IHNsb3QuaGFja1JlZ2lvbjtcclxuICAgICAgICAgICAgICAgIHNsb3QuaGFja0F0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrUmVnaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RyaXAgPSB0aGlzLm5ld01lc2gocmVnaW9uLnRleHR1cmUsIG5ldyBGbG9hdDMyQXJyYXkoYXR0YWNobWVudC5yZWdpb25VVnMubGVuZ3RoKSwgYXR0YWNobWVudC5yZWdpb25VVnMsIG5ldyBVaW50MTZBcnJheShhdHRhY2htZW50LnRyaWFuZ2xlcyksIFBJWEkuRFJBV19NT0RFUy5UUklBTkdMRVMpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0cmlwLl9jYW52YXNQYWRkaW5nICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpcC5fY2FudmFzUGFkZGluZyA9IDEuNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJpcC5hbHBoYSA9IGF0dGFjaG1lbnQuY29sb3IuYTtcclxuICAgICAgICAgICAgc3RyaXAucmVnaW9uID0gYXR0YWNobWVudC5yZWdpb247XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWVzaFJlZ2lvbihhdHRhY2htZW50LCBzdHJpcCwgcmVnaW9uKTtcclxuICAgICAgICAgICAgc2xvdC5tZXNoZXMgPSBzbG90Lm1lc2hlcyB8fCB7fTtcclxuICAgICAgICAgICAgc2xvdC5tZXNoZXNbYXR0YWNobWVudC5pZF0gPSBzdHJpcDtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmlwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgO1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5jcmVhdGVHcmFwaGljcyA9IGZ1bmN0aW9uIChzbG90LCBjbGlwKSB7XHJcbiAgICAgICAgICAgIHZhciBncmFwaGljcyA9IHRoaXMubmV3R3JhcGhpY3MoKTtcclxuICAgICAgICAgICAgdmFyIHBvbHkgPSBuZXcgUElYSS5Qb2x5Z29uKFtdKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuY2xlYXIoKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4ZmZmZmZmLCAxKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZHJhd1BvbHlnb24ocG9seSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2xvdC5jdXJyZW50R3JhcGhpY3MgPSBncmFwaGljcztcclxuICAgICAgICAgICAgc2xvdC5jbGlwcGluZ0NvbnRhaW5lciA9IHRoaXMubmV3Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHNsb3QuY2xpcHBpbmdDb250YWluZXIubWFzayA9IHNsb3QuY3VycmVudEdyYXBoaWNzO1xyXG4gICAgICAgICAgICByZXR1cm4gZ3JhcGhpY3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUudXBkYXRlR3JhcGhpY3MgPSBmdW5jdGlvbiAoc2xvdCwgY2xpcCkge1xyXG4gICAgICAgICAgICB2YXIgZ2VvbSA9IHNsb3QuY3VycmVudEdyYXBoaWNzLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tLmdyYXBoaWNzRGF0YVswXS5zaGFwZS5wb2ludHM7XHJcbiAgICAgICAgICAgIHZhciBuID0gY2xpcC53b3JsZFZlcnRpY2VzTGVuZ3RoO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5sZW5ndGggPSBuO1xyXG4gICAgICAgICAgICBjbGlwLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIG4sIHZlcnRpY2VzLCAwLCAyKTtcclxuICAgICAgICAgICAgZ2VvbS5pbnZhbGlkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuaGFja1RleHR1cmVCeVNsb3RJbmRleCA9IGZ1bmN0aW9uIChzbG90SW5kZXgsIHRleHR1cmUsIHNpemUpIHtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmUgPT09IHZvaWQgMCkgeyB0ZXh0dXJlID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gdGhpcy5za2VsZXRvbi5zbG90c1tzbG90SW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gYXR0YWNobWVudC5yZWdpb247XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSBuZXcgcGl4aV9zcGluZS5jb3JlLlRleHR1cmVSZWdpb24oKTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi5zaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIHNsb3QuaGFja1JlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIHNsb3QuaGFja0F0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrUmVnaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHNsb3QuaGFja0F0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRTcHJpdGUgJiYgc2xvdC5jdXJyZW50U3ByaXRlLnJlZ2lvbiAhPSByZWdpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3ByaXRlUmVnaW9uKGF0dGFjaG1lbnQsIHNsb3QuY3VycmVudFNwcml0ZSwgcmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdC5jdXJyZW50TWVzaCAmJiBzbG90LmN1cnJlbnRNZXNoLnJlZ2lvbiAhPSByZWdpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWVzaFJlZ2lvbihhdHRhY2htZW50LCBzbG90LmN1cnJlbnRNZXNoLCByZWdpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLmhhY2tUZXh0dXJlQnlTbG90TmFtZSA9IGZ1bmN0aW9uIChzbG90TmFtZSwgdGV4dHVyZSwgc2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZSA9PT0gdm9pZCAwKSB7IHRleHR1cmUgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IG51bGw7IH1cclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5za2VsZXRvbi5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFja1RleHR1cmVCeVNsb3RJbmRleChpbmRleCwgdGV4dHVyZSwgc2l6ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuaGFja1RleHR1cmVBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSwgdGV4dHVyZSwgc2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSB0aGlzLnNrZWxldG9uLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuc2tlbGV0b24uZ2V0QXR0YWNobWVudEJ5TmFtZShzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbi50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLnNrZWxldG9uLnNsb3RzW3Nsb3RJbmRleF07XHJcbiAgICAgICAgICAgIGlmICghc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50QXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudE5hbWUgPT09IGN1cnJlbnRBdHRhY2htZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uID0gbmV3IHBpeGlfc3BpbmUuY29yZS5UZXh0dXJlUmVnaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5zaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmhhY2tSZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5oYWNrQXR0YWNobWVudCA9IGN1cnJlbnRBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5oYWNrUmVnaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmhhY2tBdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRTcHJpdGUgJiYgc2xvdC5jdXJyZW50U3ByaXRlLnJlZ2lvbiAhPSByZWdpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNwcml0ZVJlZ2lvbihjdXJyZW50QXR0YWNobWVudCwgc2xvdC5jdXJyZW50U3ByaXRlLCByZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzbG90LmN1cnJlbnRNZXNoICYmIHNsb3QuY3VycmVudE1lc2gucmVnaW9uICE9IHJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWVzaFJlZ2lvbihjdXJyZW50QXR0YWNobWVudCwgc2xvdC5jdXJyZW50TWVzaCwgcmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5uZXdDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUElYSS5Db250YWluZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5uZXdTcHJpdGUgPSBmdW5jdGlvbiAodGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BpbmVTcHJpdGUodGV4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5uZXdHcmFwaGljcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQSVhJLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUubmV3TWVzaCA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwaW5lTWVzaCh0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUudHJhbnNmb3JtSGFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuaGFja0F0dGFjaG1lbnRHcm91cHMgPSBmdW5jdGlvbiAobmFtZVN1ZmZpeCwgZ3JvdXAsIG91dEdyb3VwKSB7XHJcbiAgICAgICAgICAgIGlmICghbmFtZVN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsaXN0X2QgPSBbXSwgbGlzdF9uID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnNrZWxldG9uLnNsb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuc2tlbGV0b24uc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV82ID0gc2xvdC5jdXJyZW50U3ByaXRlTmFtZSB8fCBzbG90LmN1cnJlbnRNZXNoTmFtZSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNsb3QuY3VycmVudFNwcml0ZSB8fCBzbG90LmN1cnJlbnRNZXNoO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWVfNi5lbmRzV2l0aChuYW1lU3VmZml4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXJlbnRHcm91cCA9IGdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3Rfbi5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdXRHcm91cCAmJiB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGFyZW50R3JvdXAgPSBvdXRHcm91cDtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0X2QucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbGlzdF9kLCBsaXN0X25dO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgO1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnNrZWxldG9uLnNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLnNrZWxldG9uLnNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZV83IGluIHNsb3QubWVzaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5tZXNoZXNbbmFtZV83XS5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2xvdC5tZXNoZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZV84IGluIHNsb3Quc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlc1tuYW1lXzhdLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbG90LnNwcml0ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5zbG90Q29udGFpbmVycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xvdENvbnRhaW5lcnNbaV0uZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwaW5lRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc2tlbGV0b24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3RDb250YWluZXJzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZURhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ2xpcENvbnRhaW5lcnMgPSBudWxsO1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLmdsb2JhbEF1dG9VcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIFNwaW5lLmdsb2JhbERlbGF5TGltaXQgPSAwO1xyXG4gICAgICAgIFNwaW5lLmNsaXBwaW5nUG9seWdvbiA9IFtdO1xyXG4gICAgICAgIHJldHVybiBTcGluZTtcclxuICAgIH0oUElYSS5Db250YWluZXIpKTtcclxuICAgIHBpeGlfc3BpbmUuU3BpbmUgPSBTcGluZTtcclxuICAgIGZ1bmN0aW9uIFNsb3RDb250YWluZXJVcGRhdGVUcmFuc2Zvcm1WMygpIHtcclxuICAgICAgICB2YXIgcHQgPSB0aGlzLnBhcmVudC53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XHJcbiAgICAgICAgd3QuYSA9IGx0LmEgKiBwdC5hICsgbHQuYiAqIHB0LmM7XHJcbiAgICAgICAgd3QuYiA9IGx0LmEgKiBwdC5iICsgbHQuYiAqIHB0LmQ7XHJcbiAgICAgICAgd3QuYyA9IGx0LmMgKiBwdC5hICsgbHQuZCAqIHB0LmM7XHJcbiAgICAgICAgd3QuZCA9IGx0LmMgKiBwdC5iICsgbHQuZCAqIHB0LmQ7XHJcbiAgICAgICAgd3QudHggPSBsdC50eCAqIHB0LmEgKyBsdC50eSAqIHB0LmMgKyBwdC50eDtcclxuICAgICAgICB3dC50eSA9IGx0LnR4ICogcHQuYiArIGx0LnR5ICogcHQuZCArIHB0LnR5O1xyXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xyXG4gICAgfVxyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgUElYSS5zcGluZSA9IHBpeGlfc3BpbmU7XHJcbiAgICB2YXIgVGV4dHVyZVByb3RvID0gUElYSS5UZXh0dXJlLnByb3RvdHlwZTtcclxuICAgIGlmICghVGV4dHVyZVByb3RvLl91cGRhdGVVdnMpIHtcclxuICAgICAgICBUZXh0dXJlUHJvdG8uX3VwZGF0ZVV2cyA9IFRleHR1cmVQcm90by51cGRhdGVVdnM7XHJcbiAgICB9XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICBmdW5jdGlvbiBpc0pzb24ocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gcmVzb3VyY2UudHlwZSA9PT0gUElYSS5Mb2FkZXJSZXNvdXJjZS5UWVBFLkpTT047XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0J1ZmZlcihyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiByZXNvdXJjZS54aHJUeXBlID09PSBQSVhJLkxvYWRlclJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUjtcclxuICAgIH1cclxuICAgIFBJWEkuTG9hZGVyUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZSgnc2tlbCcsIFBJWEkuTG9hZGVyUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSKTtcclxuICAgIHZhciBBdGxhc1BhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQXRsYXNQYXJzZXIoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEF0bGFzUGFyc2VyLnVzZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzSnNvblNwaW5lTW9kZWwgPSBpc0pzb24ocmVzb3VyY2UpICYmIHJlc291cmNlLmRhdGEuYm9uZXM7XHJcbiAgICAgICAgICAgIHZhciBpc0JpbmFyeVNwaW5lTW9kZWwgPSBpc0J1ZmZlcihyZXNvdXJjZSkgJiYgKHJlc291cmNlLmV4dGVuc2lvbiA9PT0gJ3NrZWwnIHx8IHJlc291cmNlLm1ldGFkYXRhLnNwaW5lTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzSnNvblNwaW5lTW9kZWwgJiYgIWlzQmluYXJ5U3BpbmVNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGRhdGFUb1BhcnNlID0gcmVzb3VyY2UuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGlzSnNvblNwaW5lTW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuU2tlbGV0b25Kc29uKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gbmV3IHBpeGlfc3BpbmUuY29yZS5Ta2VsZXRvbkJpbmFyeShudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVG9QYXJzZSA9IG5ldyBVaW50OEFycmF5KHJlc291cmNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHJlc291cmNlLm1ldGFkYXRhIHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFTa2VsZXRvblNjYWxlID0gbWV0YWRhdGEgPyByZXNvdXJjZS5tZXRhZGF0YS5zcGluZVNrZWxldG9uU2NhbGUgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFTa2VsZXRvblNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NhbGUgPSBtZXRhZGF0YVNrZWxldG9uU2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhQXRsYXMgPSBtZXRhZGF0YSA/IHJlc291cmNlLm1ldGFkYXRhLnNwaW5lQXRsYXMgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFBdGxhcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhQXRsYXMgJiYgbWV0YWRhdGFBdGxhcy5wYWdlcykge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VyLmF0dGFjaG1lbnRMb2FkZXIgPSBuZXcgcGl4aV9zcGluZS5jb3JlLkF0bGFzQXR0YWNobWVudExvYWRlcihtZXRhZGF0YUF0bGFzKTtcclxuICAgICAgICAgICAgICAgIHJlc291cmNlLnNwaW5lRGF0YSA9IHBhcnNlci5yZWFkU2tlbGV0b25EYXRhKGRhdGFUb1BhcnNlKTtcclxuICAgICAgICAgICAgICAgIHJlc291cmNlLnNwaW5lQXRsYXMgPSBtZXRhZGF0YUF0bGFzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFBdGxhc1N1ZmZpeCA9IG1ldGFkYXRhLnNwaW5lQXRsYXNTdWZmaXggfHwgJy5hdGxhcyc7XHJcbiAgICAgICAgICAgIHZhciBhdGxhc1BhdGggPSByZXNvdXJjZS51cmw7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZ1BvcyA9IGF0bGFzUGF0aC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeVN0cmluZ1BvcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGF0bGFzUGF0aCA9IGF0bGFzUGF0aC5zdWJzdHIoMCwgcXVlcnlTdHJpbmdQb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0bGFzUGF0aCA9IGF0bGFzUGF0aC5zdWJzdHIoMCwgYXRsYXNQYXRoLmxhc3RJbmRleE9mKCcuJykpICsgbWV0YWRhdGFBdGxhc1N1ZmZpeDtcclxuICAgICAgICAgICAgaWYgKHJlc291cmNlLm1ldGFkYXRhICYmIHJlc291cmNlLm1ldGFkYXRhLnNwaW5lQXRsYXNGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBhdGxhc1BhdGggPSByZXNvdXJjZS5tZXRhZGF0YS5zcGluZUF0bGFzRmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdGxhc1BhdGggPSBhdGxhc1BhdGgucmVwbGFjZSh0aGlzLmJhc2VVcmwsICcnKTtcclxuICAgICAgICAgICAgdmFyIGF0bGFzT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiByZXNvdXJjZS5jcm9zc09yaWdpbixcclxuICAgICAgICAgICAgICAgIHhoclR5cGU6IFBJWEkuTG9hZGVyUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YS5zcGluZU1ldGFkYXRhIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSZXNvdXJjZTogcmVzb3VyY2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGltYWdlT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiByZXNvdXJjZS5jcm9zc09yaWdpbixcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YS5pbWFnZU1ldGFkYXRhIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSZXNvdXJjZTogcmVzb3VyY2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSByZXNvdXJjZS51cmwuc3Vic3RyKDAsIHJlc291cmNlLnVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XHJcbiAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UodGhpcy5iYXNlVXJsLCAnJyk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lUHJlZml4ID0gbWV0YWRhdGEuaW1hZ2VOYW1lUHJlZml4IHx8IChyZXNvdXJjZS5uYW1lICsgJ19hdGxhc19wYWdlXycpO1xyXG4gICAgICAgICAgICB2YXIgYWRhcHRlciA9IG1ldGFkYXRhLmltYWdlcyA/IHN0YXRpY0ltYWdlTG9hZGVyKG1ldGFkYXRhLmltYWdlcylcclxuICAgICAgICAgICAgICAgIDogbWV0YWRhdGEuaW1hZ2UgPyBzdGF0aWNJbWFnZUxvYWRlcih7ICdkZWZhdWx0JzogbWV0YWRhdGEuaW1hZ2UgfSlcclxuICAgICAgICAgICAgICAgICAgICA6IG1ldGFkYXRhLmltYWdlTG9hZGVyID8gbWV0YWRhdGEuaW1hZ2VMb2FkZXIodGhpcywgbmFtZVByZWZpeCwgYmFzZVVybCwgaW1hZ2VPcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGltYWdlTG9hZGVyQWRhcHRlcih0aGlzLCBuYW1lUHJlZml4LCBiYXNlVXJsLCBpbWFnZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlU2tlbGV0b25XaXRoUmF3QXRsYXMgPSBmdW5jdGlvbiAocmF3RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbmV3IHBpeGlfc3BpbmUuY29yZS5UZXh0dXJlQXRsYXMocmF3RGF0YSwgYWRhcHRlciwgZnVuY3Rpb24gKHNwaW5lQXRsYXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BpbmVBdGxhcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0YWNobWVudExvYWRlciA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuQXRsYXNBdHRhY2htZW50TG9hZGVyKHNwaW5lQXRsYXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5zcGluZURhdGEgPSBwYXJzZXIucmVhZFNrZWxldG9uRGF0YShkYXRhVG9QYXJzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnNwaW5lQXRsYXMgPSBzcGluZUF0bGFzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHJlc291cmNlLm1ldGFkYXRhICYmIHJlc291cmNlLm1ldGFkYXRhLmF0bGFzUmF3RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlU2tlbGV0b25XaXRoUmF3QXRsYXMocmVzb3VyY2UubWV0YWRhdGEuYXRsYXNSYXdEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHJlc291cmNlLm5hbWUgKyAnX2F0bGFzJywgYXRsYXNQYXRoLCBhdGxhc09wdGlvbnMsIGZ1bmN0aW9uIChhdGxhc1Jlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdGxhc1Jlc291cmNlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNrZWxldG9uV2l0aFJhd0F0bGFzKGF0bGFzUmVzb3VyY2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdGxhc1BhcnNlcjtcclxuICAgIH0oKSk7XHJcbiAgICBwaXhpX3NwaW5lLkF0bGFzUGFyc2VyID0gQXRsYXNQYXJzZXI7XHJcbiAgICBmdW5jdGlvbiBpbWFnZUxvYWRlckFkYXB0ZXIobG9hZGVyLCBuYW1lUHJlZml4LCBiYXNlVXJsLCBpbWFnZU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYmFzZVVybCAmJiBiYXNlVXJsLmxhc3RJbmRleE9mKCcvJykgIT09IChiYXNlVXJsLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIGJhc2VVcmwgKz0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZVByZWZpeCArIGxpbmU7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSBiYXNlVXJsICsgbGluZTtcclxuICAgICAgICAgICAgdmFyIGNhY2hlZFJlc291cmNlID0gbG9hZGVyLnJlc291cmNlc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjYWNoZWRSZXNvdXJjZS50ZXh0dXJlLmJhc2VUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzb3VyY2UudGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFJlc291cmNlLm9uQWZ0ZXJNaWRkbGV3YXJlLmFkZChkb25lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYWRlci5hZGQobmFtZSwgdXJsLCBpbWFnZU9wdGlvbnMsIGZ1bmN0aW9uIChyZXNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzb3VyY2UuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzb3VyY2UudGV4dHVyZS5iYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwaXhpX3NwaW5lLmltYWdlTG9hZGVyQWRhcHRlciA9IGltYWdlTG9hZGVyQWRhcHRlcjtcclxuICAgIGZ1bmN0aW9uIHN5bmNJbWFnZUxvYWRlckFkYXB0ZXIoYmFzZVVybCwgY3Jvc3NPcmlnaW4pIHtcclxuICAgICAgICBpZiAoYmFzZVVybCAmJiBiYXNlVXJsLmxhc3RJbmRleE9mKCcvJykgIT09IChiYXNlVXJsLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIGJhc2VVcmwgKz0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKFBJWEkuQmFzZVRleHR1cmUuZnJvbShsaW5lLCBjcm9zc09yaWdpbikpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwaXhpX3NwaW5lLnN5bmNJbWFnZUxvYWRlckFkYXB0ZXIgPSBzeW5jSW1hZ2VMb2FkZXJBZGFwdGVyO1xyXG4gICAgZnVuY3Rpb24gc3RhdGljSW1hZ2VMb2FkZXIocGFnZXMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWdlID0gcGFnZXNbbGluZV0gfHwgcGFnZXNbJ2RlZmF1bHQnXTtcclxuICAgICAgICAgICAgaWYgKHBhZ2UgJiYgcGFnZS5iYXNlVGV4dHVyZSlcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhZ2UuYmFzZVRleHR1cmUpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwYWdlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcGl4aV9zcGluZS5zdGF0aWNJbWFnZUxvYWRlciA9IHN0YXRpY0ltYWdlTG9hZGVyO1xyXG4gICAgaWYgKFBJWEkuTG9hZGVyKSB7XHJcbiAgICAgICAgUElYSS5Mb2FkZXIucmVnaXN0ZXJQbHVnaW4oQXRsYXNQYXJzZXIpO1xyXG4gICAgfVxyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGl4aS1zcGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pixi-spine/dist/pixi-spine.js\n");

/***/ }),

/***/ "./src/App.ts":
/*!********************!*\
  !*** ./src/App.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"App\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalVariables */ \"./src/GlobalVariables.ts\");\n/* harmony import */ var _Main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Main */ \"./src/Main.ts\");\n/* harmony import */ var _ResourceLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ResourceLoader */ \"./src/ResourceLoader.ts\");\n\r\n\r\n\r\n\r\nclass App {\r\n    constructor() {\r\n        this.getPixiApp = () => {\r\n            PIXI.settings.ROUND_PIXELS = true;\r\n            PIXI.settings.SORTABLE_CHILDREN = true;\r\n            PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\r\n            return new PIXI.Application({\r\n                width: _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width,\r\n                height: _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height,\r\n                view: this.canvas,\r\n                sharedLoader: true,\r\n                sharedTicker: true,\r\n            });\r\n        };\r\n        this.on_resize = () => {\r\n            const multiplier = window.innerHeight / _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.app_height;\r\n            const target_width = window.innerWidth / multiplier;\r\n            this.app.renderer.resize(target_width, _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.app_height);\r\n            if (window.innerWidth < window.innerHeight) {\r\n                _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_landscape = false;\r\n            }\r\n            else {\r\n                _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_landscape = true;\r\n            }\r\n            _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width = this.app.view.width;\r\n            _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height = this.app.view.height;\r\n            _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.notify_all();\r\n            if (this.main) {\r\n                this.main.resize();\r\n            }\r\n        };\r\n        _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_mobile = PIXI.utils.isMobile.any;\r\n        this.canvas = document.getElementById(\"root\");\r\n        _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.localAddress =\r\n            `${window.location.origin}${window.location.pathname}`.replace(\"index.html\", \"\");\r\n        window.rc = _ResourceLoader__WEBPACK_IMPORTED_MODULE_3__.ResourceController;\r\n        this.canvas.style.width = \"100%\";\r\n        this.canvas.style.height = \"100%\";\r\n        this.canvas.style.marginTop = \"0\";\r\n        this.canvas.style.marginLeft = \"0\";\r\n        this.app = this.getPixiApp();\r\n        this.app.renderer.view.style.display = \"none\";\r\n        this.main = new _Main__WEBPACK_IMPORTED_MODULE_2__.Main(this.app);\r\n        this.app.stage.addChildAt(this.main.container, 0);\r\n        window.main = this.main;\r\n        window.gv = _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars;\r\n        window.onresize = this.on_resize;\r\n        window.onorientationchange = this.on_resize;\r\n        this.on_resize();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQXBwLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFyRUE7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFzQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZS1zYW5kYm94Ly4vc3JjL0FwcC50cz9kMDA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbmZpZyB9IGZyb20gXCIuL0NvbmZpZ1wiO1xyXG5pbXBvcnQgeyBHbG9iYWxfVmFycyB9IGZyb20gXCIuL0dsb2JhbFZhcmlhYmxlc1wiO1xyXG5pbXBvcnQgeyBNYWluIH0gZnJvbSBcIi4vTWFpblwiO1xyXG5pbXBvcnQgeyBSZXNvdXJjZUNvbnRyb2xsZXIgfSBmcm9tIFwiLi9SZXNvdXJjZUxvYWRlclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwcCB7XHJcbiAgICByZWFkb25seSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gICAgcmVhZG9ubHkgYXBwOiBQSVhJLkFwcGxpY2F0aW9uO1xyXG4gICAgbWFpbiE6IE1haW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgR2xvYmFsX1ZhcnMuaXNfbW9iaWxlID0gUElYSS51dGlscy5pc01vYmlsZS5hbnk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvb3RcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblxyXG4gICAgICAgIEdsb2JhbF9WYXJzLmxvY2FsQWRkcmVzcyA9XHJcbiAgICAgICAgICAgIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59JHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9YC5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgXCJpbmRleC5odG1sXCIsXHJcbiAgICAgICAgICAgICAgICBcIlwiXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLnJjID0gUmVzb3VyY2VDb250cm9sbGVyO1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpblRvcCA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBcIjtcclxuXHJcbiAgICAgICAgdGhpcy5hcHAgPSB0aGlzLmdldFBpeGlBcHAoKTtcclxuICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci52aWV3LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHJcbiAgICAgICAgdGhpcy5tYWluID0gbmV3IE1haW4odGhpcy5hcHApO1xyXG5cclxuICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZEF0KHRoaXMubWFpbi5jb250YWluZXIsIDApO1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICh3aW5kb3cgYXMgYW55KS5tYWluID0gdGhpcy5tYWluO1xyXG4gICAgICAgICh3aW5kb3cgYXMgYW55KS5ndiA9IEdsb2JhbF9WYXJzO1xyXG5cclxuICAgICAgICB3aW5kb3cub25yZXNpemUgPSB0aGlzLm9uX3Jlc2l6ZTtcclxuICAgICAgICB3aW5kb3cub25vcmllbnRhdGlvbmNoYW5nZSA9IHRoaXMub25fcmVzaXplO1xyXG5cclxuICAgICAgICB0aGlzLm9uX3Jlc2l6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFBpeGlBcHAgPSAoKSA9PiB7XHJcbiAgICAgICAgUElYSS5zZXR0aW5ncy5ST1VORF9QSVhFTFMgPSB0cnVlO1xyXG4gICAgICAgIFBJWEkuc2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU4gPSB0cnVlO1xyXG4gICAgICAgIFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERSA9IFBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQSVhJLkFwcGxpY2F0aW9uKHtcclxuICAgICAgICAgICAgd2lkdGg6IENvbmZpZy5wcm9qZWN0X3dpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IENvbmZpZy5wcm9qZWN0X2hlaWdodCxcclxuICAgICAgICAgICAgdmlldzogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgIHNoYXJlZExvYWRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgc2hhcmVkVGlja2VyOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyB0cmFuc3BhcmVudDogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgb25fcmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyBHbG9iYWxfVmFycy5hcHBfaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHRhcmdldF93aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gbXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIucmVzaXplKHRhcmdldF93aWR0aCwgR2xvYmFsX1ZhcnMuYXBwX2hlaWdodCk7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICBHbG9iYWxfVmFycy5pc19sYW5kc2NhcGUgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBHbG9iYWxfVmFycy5pc19sYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ29uZmlnLnByb2plY3Rfd2lkdGggPSB0aGlzLmFwcC52aWV3LndpZHRoO1xyXG4gICAgICAgIENvbmZpZy5wcm9qZWN0X2hlaWdodCA9IHRoaXMuYXBwLnZpZXcuaGVpZ2h0O1xyXG5cclxuICAgICAgICBHbG9iYWxfVmFycy5ub3RpZnlfYWxsKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1haW4pIHtcclxuICAgICAgICAgICAgdGhpcy5tYWluLnJlc2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/App.ts\n");

/***/ }),

/***/ "./src/Config.ts":
/*!***********************!*\
  !*** ./src/Config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Config\": () => (/* binding */ Config)\n/* harmony export */ });\nconst Config = {\r\n    project_width: 1920,\r\n    project_height: 1080,\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29uZmlnLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lLXNhbmRib3gvLi9zcmMvQ29uZmlnLnRzP2YyY2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IENvbmZpZyA9IHtcclxuICAgIHByb2plY3Rfd2lkdGg6IDE5MjAsXHJcbiAgICBwcm9qZWN0X2hlaWdodDogMTA4MCxcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Config.ts\n");

/***/ }),

/***/ "./src/GlobalVariables.ts":
/*!********************************!*\
  !*** ./src/GlobalVariables.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Global_Vars\": () => (/* binding */ Global_Vars)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Observer */ \"./src/Observer.ts\");\n\r\n\r\nclass GlobalVariablesClass extends _Observer__WEBPACK_IMPORTED_MODULE_1__.Subject {\r\n    constructor() {\r\n        super();\r\n        this.app_width = _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width;\r\n        this.app_height = _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height;\r\n        this.is_mobile = false;\r\n        this.is_landscape = true;\r\n        this.localAddress = \"\";\r\n    }\r\n}\r\nconst Global_Vars = new GlobalVariablesClass();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvR2xvYmFsVmFyaWFibGVzLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFSQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BpbmUtc2FuZGJveC8uL3NyYy9HbG9iYWxWYXJpYWJsZXMudHM/ZDVkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25maWcgfSBmcm9tIFwiLi9Db25maWdcIjtcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gXCIuL09ic2VydmVyXCI7XHJcblxyXG5jbGFzcyBHbG9iYWxWYXJpYWJsZXNDbGFzcyBleHRlbmRzIFN1YmplY3Qge1xyXG4gICAgYXBwX3dpZHRoID0gQ29uZmlnLnByb2plY3Rfd2lkdGg7XHJcbiAgICBhcHBfaGVpZ2h0ID0gQ29uZmlnLnByb2plY3RfaGVpZ2h0O1xyXG5cclxuICAgIGlzX21vYmlsZSA9IGZhbHNlO1xyXG4gICAgaXNfbGFuZHNjYXBlID0gdHJ1ZTtcclxuICAgIGxvY2FsQWRkcmVzcyA9IFwiXCI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEdsb2JhbF9WYXJzID0gbmV3IEdsb2JhbFZhcmlhYmxlc0NsYXNzKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/GlobalVariables.ts\n");

/***/ }),

/***/ "./src/Main.ts":
/*!*********************!*\
  !*** ./src/Main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Main\": () => (/* binding */ Main)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResourceLoader */ \"./src/ResourceLoader.ts\");\n/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\r\n\r\n\r\n\r\nclass Main {\r\n    constructor(app) {\r\n        this.all = [];\r\n        this.currentBGColor = 0;\r\n        this.setUpGUI = () => {\r\n            this.gui = new dat_gui__WEBPACK_IMPORTED_MODULE_2__.GUI({\r\n                name: \"Spine Sandbox\",\r\n                closed: false,\r\n                closeOnTop: true,\r\n            });\r\n            this.gui.addColor(this.app.renderer, \"backgroundColor\");\r\n        };\r\n        this.showGUI = () => {\r\n            const folder1 = this.gui.addFolder(\"Spine Params\");\r\n            folder1.open();\r\n            const animScale = folder1.add(this.targetAnim.scale, \"x\", 0.1, 3, 0.01);\r\n            animScale.name(\"Animation Scale\");\r\n            animScale.onChange((value) => {\r\n                this.targetAnim.scale.set(value);\r\n            });\r\n            const animSpeed = folder1.add(this.targetAnim.state, \"timeScale\", 0.1, 3, 0.01);\r\n            animSpeed.name(\"Animation Speed\");\r\n            animSpeed.onChange((value) => {\r\n                this.targetAnim.state.timeScale = value;\r\n            });\r\n            const setDefaultSpineParams = {\r\n                add: () => {\r\n                    animScale.setValue(1);\r\n                    animSpeed.setValue(1);\r\n                },\r\n            };\r\n            const setDefaultButton = folder1.add(setDefaultSpineParams, \"add\");\r\n            setDefaultButton.name(\"Set Defaut\");\r\n            const animationsArray = this.targetAnim.state.data.skeletonData.animations.map((a) => a.name);\r\n            const skinsArray = this.targetAnim.skeleton.data.skins.map((a) => a.name);\r\n            const animationParams = {\r\n                animsArray: animationsArray,\r\n                loop: false,\r\n                skins: skinsArray,\r\n                defaultSkin: true,\r\n            };\r\n            const folder2 = this.gui.addFolder(\"Set Animation\");\r\n            folder2.open();\r\n            const chooseAnim = folder2.add(animationParams, \"animsArray\", animationsArray);\r\n            chooseAnim.name(\"Choose Animation\");\r\n            chooseAnim.setValue(\"\");\r\n            chooseAnim.onChange((value) => {\r\n                this.targetAnim.state.setAnimation(0, value, this.loopedAnim || false);\r\n                this.lastAnim = value;\r\n            });\r\n            const loopedAnim = folder2.add(animationParams, \"loop\");\r\n            loopedAnim.name(\"Loop\");\r\n            loopedAnim.onChange((value) => {\r\n                if (this.lastAnim) {\r\n                    this.targetAnim.state.setAnimation(0, this.lastAnim, value);\r\n                }\r\n                this.loopedAnim = value;\r\n            });\r\n            console.log(animationsArray);\r\n            const folder3 = this.gui.addFolder(\"Set Skin\");\r\n            folder3.open();\r\n            const chooseSkin = folder3.add(animationParams, \"skins\", skinsArray);\r\n            chooseSkin.name(\"Choose Skin\");\r\n            chooseSkin.onChange((value) => {\r\n                this.targetAnim.skeleton.setSkinByName(value);\r\n                this.targetAnim.skeleton.setSlotsToSetupPose();\r\n            });\r\n            const destroyAnim = {\r\n                add: () => {\r\n                    const aerusure = confirm(\"Are you sure? Spine animation will be removed.\");\r\n                    if (aerusure)\r\n                        this.destroySpine();\r\n                },\r\n            };\r\n            const destroyAnimButton = this.gui.add(destroyAnim, \"add\");\r\n            destroyAnimButton.name(\"Destroy Animation\");\r\n        };\r\n        this.init = () => {\r\n            console.log(\"App initialized\");\r\n            document.addEventListener(\"loadFile\", this.loadSpine);\r\n        };\r\n        this.validateResources = () => {\r\n            throw new Error();\r\n        };\r\n        this.buttonCb = () => (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {\r\n            const getTargetFileFromArray = (key) => {\r\n                const result = [];\r\n                this.all.forEach((asset) => {\r\n                    const name = asset.file.name.split(\".\").pop();\r\n                    if (name === key)\r\n                        result.push(asset);\r\n                });\r\n                return result;\r\n            };\r\n            const atlasData = getTargetFileFromArray(\"atlas\")[0];\r\n            const atlasLoaderOption = { xhrType: \"text\" };\r\n            PIXI.Loader.shared.add(atlasData.file.name, atlasData.data, atlasLoaderOption);\r\n            const imageData = getTargetFileFromArray(\"png\");\r\n            imageData.forEach((atlasPage) => {\r\n                PIXI.Loader.shared.add(atlasPage.file.name, atlasPage.data);\r\n            });\r\n            yield new Promise((resolve) => {\r\n                PIXI.Loader.shared.load(resolve);\r\n            });\r\n            const imageArr = {};\r\n            imageData.forEach((res) => {\r\n                imageArr[res.file.name] = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(res.file.name).texture.baseTexture;\r\n            });\r\n            console.log(imageArr);\r\n            const spineData = getTargetFileFromArray(\"json\")[0];\r\n            const spineLoaderOptions = {\r\n                metadata: {\r\n                    atlasRawData: _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(atlasData.file.name).data,\r\n                    images: imageArr,\r\n                },\r\n            };\r\n            console.log(_ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(atlasData.file.name).data.split(/\\r\\n|\\r|\\n/));\r\n            PIXI.Loader.shared.add(\"main.json\", spineData.data, spineLoaderOptions);\r\n            PIXI.Loader.shared.load(() => {\r\n                this.createSpineAnimation();\r\n                this.loadingText.visible = false;\r\n            });\r\n        });\r\n        this.changeStageState = (show) => {\r\n            if (show) {\r\n                this.app.renderer.view.style.display = \"\";\r\n                document.getElementById(\"frominput\").style.display = \"none\";\r\n                this.setUpGUI();\r\n                this.loadingText.visible = true;\r\n            }\r\n            else {\r\n                this.app.renderer.view.style.display = \"none\";\r\n                document.getElementById(\"frominput\").style.display = \"flex\";\r\n            }\r\n        };\r\n        this.loadSpine = () => (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {\r\n            console.log(\"loadSpine\");\r\n            const input = document.getElementById(\"fileinput\");\r\n            let files;\r\n            const fr = new FileReader();\r\n            if (typeof window.FileReader !== \"function\") {\r\n                throw new Error(\"The file API isn't supported on this browser yet.\");\r\n            }\r\n            if (!input) {\r\n                throw new Error(\"Um, couldn't find the fileinput element.\");\r\n            }\r\n            else if (!input.files) {\r\n                throw new Error(\"This browser doesn't seem to support the `files` property of file inputs.\");\r\n            }\r\n            else if (!input.files[0]) {\r\n                console.error(\"Please select a file before clicking 'Load'\");\r\n            }\r\n            else {\r\n                const required = [\"atlas\", \"json\", \"png\"];\r\n                files = input.files;\r\n                for (const file of files) {\r\n                    required.splice(required.indexOf(file.name.split(\".\").pop()), 1);\r\n                }\r\n                if (required.length !== 0) {\r\n                    console.error(`Please select ALL spine files. NOT FOUND {${required}}`);\r\n                    return;\r\n                }\r\n                this.changeStageState(true);\r\n                const loadFile = (file) => {\r\n                    return new Promise((resolve) => {\r\n                        fr.onload = (data) => {\r\n                            this.all.push({\r\n                                file,\r\n                                data: data.currentTarget.result,\r\n                            });\r\n                            fr.onload = () => { };\r\n                            resolve();\r\n                        };\r\n                        fr.readAsDataURL(file);\r\n                    });\r\n                };\r\n                for (const file of files) {\r\n                    yield loadFile(file);\r\n                }\r\n                console.log(files);\r\n                this.buttonCb();\r\n            }\r\n        });\r\n        this.createSpineAnimation = () => {\r\n            this.targetAnim = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getSpine(\"main.json\");\r\n            this.container.addChild(this.targetAnim);\r\n            this.resize();\r\n            this.showGUI();\r\n        };\r\n        this.destroySpine = () => {\r\n            var _a;\r\n            (_a = this.targetAnim) === null || _a === void 0 ? void 0 : _a.destroy({\r\n                children: true,\r\n                texture: true,\r\n                baseTexture: true,\r\n            });\r\n            this.targetAnim = undefined;\r\n            this.lastAnim = undefined;\r\n            this.loopedAnim = undefined;\r\n            this.currentSkin = undefined;\r\n            const loader = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.loader;\r\n            for (const res of Object.keys(loader.resources)) {\r\n                delete loader.resources[res];\r\n            }\r\n            this.all.length = 0;\r\n            PIXI.utils.BaseTextureCache = {};\r\n            PIXI.utils.TextureCache = {};\r\n            PIXI.utils.clearTextureCache();\r\n            loader.reset();\r\n            loader.destroy();\r\n            this.gui.destroy();\r\n            this.changeStageState(false);\r\n            document.getElementById(\"frominput\").reset();\r\n        };\r\n        this.resize = () => {\r\n            if (this.targetAnim) {\r\n                this.targetAnim.position.set(_Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width / 2, _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height / 2);\r\n            }\r\n        };\r\n        this.app = app;\r\n        this.container = new PIXI.Container();\r\n        this.loadingText = new PIXI.Text(\"Spine is loading, please wait...\", new PIXI.TextStyle({\r\n            fill: 0xffffff,\r\n            fontSize: 50,\r\n        }));\r\n        this.container.addChild(this.loadingText);\r\n        this.init();\r\n        this.resize();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTWFpbi50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQWFBO0FBVkE7QUFPQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFwVkE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF1VUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZS1zYW5kYm94Ly4vc3JjL01haW4udHM/MzRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25maWcgfSBmcm9tIFwiLi9Db25maWdcIjtcclxuaW1wb3J0IHsgUmVzb3VyY2VDb250cm9sbGVyIH0gZnJvbSBcIi4vUmVzb3VyY2VMb2FkZXJcIjtcclxuaW1wb3J0ICogYXMgZGF0IGZyb20gXCJkYXQuZ3VpXCI7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcblxyXG5leHBvcnQgY2xhc3MgTWFpbiB7XHJcbiAgICBjb250YWluZXI6IFBJWEkuQ29udGFpbmVyO1xyXG4gICAgZm9ybSE6IEhUTUxFbGVtZW50O1xyXG4gICAgYWxsOiBhbnlbXSA9IFtdO1xyXG4gICAgdGFyZ2V0QW5pbT86IFBJWEkuc3BpbmUuU3BpbmU7XHJcbiAgICBndWkhOiBkYXQuR1VJO1xyXG4gICAgbGFzdEFuaW0/OiBzdHJpbmc7XHJcbiAgICBsb29wZWRBbmltPzogYm9vbGVhbjtcclxuICAgIGN1cnJlbnRTa2luPzogc3RyaW5nO1xyXG4gICAgYXBwOiBQSVhJLkFwcGxpY2F0aW9uO1xyXG4gICAgY3VycmVudEJHQ29sb3IgPSAwO1xyXG4gICAgbG9hZGluZ1RleHQhOiBQSVhJLlRleHQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBQSVhJLkFwcGxpY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLy8gdGhpcy5zZXRVcEdVSSgpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMubG9hZGluZ1RleHQgPSBuZXcgUElYSS5UZXh0KFxyXG4gICAgICAgICAgICBcIlNwaW5lIGlzIGxvYWRpbmcsIHBsZWFzZSB3YWl0Li4uXCIsXHJcbiAgICAgICAgICAgIG5ldyBQSVhJLlRleHRTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAweGZmZmZmZixcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA1MCxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMubG9hZGluZ1RleHQpO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VXBHVUkgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5ndWkgPSBuZXcgZGF0LkdVSSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiU3BpbmUgU2FuZGJveFwiLFxyXG4gICAgICAgICAgICBjbG9zZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBjbG9zZU9uVG9wOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmd1aS5hZGRDb2xvcih0aGlzLmFwcC5yZW5kZXJlciwgXCJiYWNrZ3JvdW5kQ29sb3JcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIHNob3dHVUkgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZm9sZGVyMSA9IHRoaXMuZ3VpLmFkZEZvbGRlcihcIlNwaW5lIFBhcmFtc1wiKTtcclxuICAgICAgICBmb2xkZXIxLm9wZW4oKTtcclxuICAgICAgICBjb25zdCBhbmltU2NhbGUgPSBmb2xkZXIxLmFkZChcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zY2FsZSxcclxuICAgICAgICAgICAgXCJ4XCIsXHJcbiAgICAgICAgICAgIDAuMSxcclxuICAgICAgICAgICAgMyxcclxuICAgICAgICAgICAgMC4wMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYW5pbVNjYWxlLm5hbWUoXCJBbmltYXRpb24gU2NhbGVcIik7XHJcbiAgICAgICAgYW5pbVNjYWxlLm9uQ2hhbmdlKCh2YWx1ZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc2NhbGUuc2V0KHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgYW5pbVNwZWVkID0gZm9sZGVyMS5hZGQoXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc3RhdGUsXHJcbiAgICAgICAgICAgIFwidGltZVNjYWxlXCIsXHJcbiAgICAgICAgICAgIDAuMSxcclxuICAgICAgICAgICAgMyxcclxuICAgICAgICAgICAgMC4wMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYW5pbVNwZWVkLm5hbWUoXCJBbmltYXRpb24gU3BlZWRcIik7XHJcbiAgICAgICAgYW5pbVNwZWVkLm9uQ2hhbmdlKCh2YWx1ZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc3RhdGUudGltZVNjYWxlID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNldERlZmF1bHRTcGluZVBhcmFtcyA9IHtcclxuICAgICAgICAgICAgYWRkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhbmltU2NhbGUuc2V0VmFsdWUoMSk7XHJcbiAgICAgICAgICAgICAgICBhbmltU3BlZWQuc2V0VmFsdWUoMSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2V0RGVmYXVsdEJ1dHRvbiA9IGZvbGRlcjEuYWRkKHNldERlZmF1bHRTcGluZVBhcmFtcywgXCJhZGRcIik7XHJcbiAgICAgICAgc2V0RGVmYXVsdEJ1dHRvbi5uYW1lKFwiU2V0IERlZmF1dFwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uc0FycmF5ID1cclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zdGF0ZS5kYXRhLnNrZWxldG9uRGF0YS5hbmltYXRpb25zLm1hcChcclxuICAgICAgICAgICAgICAgIChhKSA9PiBhLm5hbWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2tpbnNBcnJheSA9IHRoaXMudGFyZ2V0QW5pbSEuc2tlbGV0b24uZGF0YS5za2lucy5tYXAoXHJcbiAgICAgICAgICAgIChhKSA9PiBhLm5hbWVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBhbmltYXRpb25QYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGFuaW1zQXJyYXk6IGFuaW1hdGlvbnNBcnJheSxcclxuICAgICAgICAgICAgbG9vcDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNraW5zOiBza2luc0FycmF5LFxyXG4gICAgICAgICAgICBkZWZhdWx0U2tpbjogdHJ1ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBmb2xkZXIyID0gdGhpcy5ndWkuYWRkRm9sZGVyKFwiU2V0IEFuaW1hdGlvblwiKTtcclxuICAgICAgICBmb2xkZXIyLm9wZW4oKTtcclxuICAgICAgICBjb25zdCBjaG9vc2VBbmltID0gZm9sZGVyMi5hZGQoXHJcbiAgICAgICAgICAgIGFuaW1hdGlvblBhcmFtcyxcclxuICAgICAgICAgICAgXCJhbmltc0FycmF5XCIsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnNBcnJheVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY2hvb3NlQW5pbS5uYW1lKFwiQ2hvb3NlIEFuaW1hdGlvblwiKTtcclxuICAgICAgICBjaG9vc2VBbmltLnNldFZhbHVlKFwiXCIpO1xyXG5cclxuICAgICAgICBjaG9vc2VBbmltLm9uQ2hhbmdlKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc3RhdGUuc2V0QW5pbWF0aW9uKFxyXG4gICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb29wZWRBbmltIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEFuaW0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgbG9vcGVkQW5pbSA9IGZvbGRlcjIuYWRkKGFuaW1hdGlvblBhcmFtcywgXCJsb29wXCIpO1xyXG4gICAgICAgIGxvb3BlZEFuaW0ubmFtZShcIkxvb3BcIik7XHJcblxyXG4gICAgICAgIGxvb3BlZEFuaW0ub25DaGFuZ2UoKHZhbHVlOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RBbmltKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEFuaW0hLnN0YXRlLnNldEFuaW1hdGlvbigwLCB0aGlzLmxhc3RBbmltLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb29wZWRBbmltID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGFuaW1hdGlvbnNBcnJheSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlcjMgPSB0aGlzLmd1aS5hZGRGb2xkZXIoXCJTZXQgU2tpblwiKTtcclxuICAgICAgICBmb2xkZXIzLm9wZW4oKTtcclxuICAgICAgICBjb25zdCBjaG9vc2VTa2luID0gZm9sZGVyMy5hZGQoYW5pbWF0aW9uUGFyYW1zLCBcInNraW5zXCIsIHNraW5zQXJyYXkpO1xyXG4gICAgICAgIGNob29zZVNraW4ubmFtZShcIkNob29zZSBTa2luXCIpO1xyXG5cclxuICAgICAgICBjaG9vc2VTa2luLm9uQ2hhbmdlKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc2tlbGV0b24uc2V0U2tpbkJ5TmFtZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc2tlbGV0b24uc2V0U2xvdHNUb1NldHVwUG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBkZXN0cm95QW5pbSA9IHtcclxuICAgICAgICAgICAgYWRkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZXJ1c3VyZSA9IGNvbmZpcm0oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJBcmUgeW91IHN1cmU/IFNwaW5lIGFuaW1hdGlvbiB3aWxsIGJlIHJlbW92ZWQuXCJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWVydXN1cmUpIHRoaXMuZGVzdHJveVNwaW5lKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZGVzdHJveUFuaW1CdXR0b24gPSB0aGlzLmd1aS5hZGQoZGVzdHJveUFuaW0sIFwiYWRkXCIpO1xyXG4gICAgICAgIGRlc3Ryb3lBbmltQnV0dG9uLm5hbWUoXCJEZXN0cm95IEFuaW1hdGlvblwiKTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdCA9ICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkFwcCBpbml0aWFsaXplZFwiKTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRGaWxlXCIsIHRoaXMubG9hZFNwaW5lKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFsaWRhdGVSZXNvdXJjZXMgPSAoKTogdm9pZCB8IG5ldmVyID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH07XHJcblxyXG4gICAgYnV0dG9uQ2IgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZ2V0VGFyZ2V0RmlsZUZyb21BcnJheSA9IChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHsgZmlsZTogRmlsZTsgZGF0YTogYW55IH0+ID0gW107XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFsbC5mb3JFYWNoKChhc3NldDogeyBmaWxlOiBGaWxlOyBkYXRhOiBQcm9ncmVzc0V2ZW50IH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhc3NldC5maWxlLm5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBrZXkpIHJlc3VsdC5wdXNoKGFzc2V0KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGF0bGFzRGF0YSA9IGdldFRhcmdldEZpbGVGcm9tQXJyYXkoXCJhdGxhc1wiKVswXTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhhdGxhc0RhdGEpO1xyXG4gICAgICAgIGNvbnN0IGF0bGFzTG9hZGVyT3B0aW9uID0geyB4aHJUeXBlOiBcInRleHRcIiB9O1xyXG5cclxuICAgICAgICBQSVhJLkxvYWRlci5zaGFyZWQuYWRkKFxyXG4gICAgICAgICAgICBhdGxhc0RhdGEuZmlsZS5uYW1lLFxyXG4gICAgICAgICAgICBhdGxhc0RhdGEuZGF0YSxcclxuICAgICAgICAgICAgYXRsYXNMb2FkZXJPcHRpb25cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBnZXRUYXJnZXRGaWxlRnJvbUFycmF5KFwicG5nXCIpO1xyXG4gICAgICAgIGltYWdlRGF0YS5mb3JFYWNoKChhdGxhc1BhZ2UpID0+IHtcclxuICAgICAgICAgICAgUElYSS5Mb2FkZXIuc2hhcmVkLmFkZChhdGxhc1BhZ2UuZmlsZS5uYW1lLCBhdGxhc1BhZ2UuZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIFBJWEkuTG9hZGVyLnNoYXJlZC5sb2FkKHJlc29sdmUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBpbWFnZUFycjogeyBba2V5OiBzdHJpbmddOiBQSVhJLkJhc2VUZXh0dXJlIH0gPSB7fTtcclxuXHJcbiAgICAgICAgaW1hZ2VEYXRhLmZvckVhY2goKHJlcykgPT4ge1xyXG4gICAgICAgICAgICBpbWFnZUFycltyZXMuZmlsZS5uYW1lXSA9IFJlc291cmNlQ29udHJvbGxlci5nZXRSZXNvdXJjZShcclxuICAgICAgICAgICAgICAgIHJlcy5maWxlLm5hbWVcclxuICAgICAgICAgICAgKS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhpbWFnZUFycik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwaW5lRGF0YSA9IGdldFRhcmdldEZpbGVGcm9tQXJyYXkoXCJqc29uXCIpWzBdO1xyXG4gICAgICAgIGNvbnN0IHNwaW5lTG9hZGVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGF0bGFzUmF3RGF0YTogUmVzb3VyY2VDb250cm9sbGVyLmdldFJlc291cmNlKFxyXG4gICAgICAgICAgICAgICAgICAgIGF0bGFzRGF0YS5maWxlLm5hbWVcclxuICAgICAgICAgICAgICAgICkuZGF0YSxcclxuICAgICAgICAgICAgICAgIGltYWdlczogaW1hZ2VBcnIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgIFJlc291cmNlQ29udHJvbGxlci5nZXRSZXNvdXJjZShhdGxhc0RhdGEuZmlsZS5uYW1lKS5kYXRhLnNwbGl0KFxyXG4gICAgICAgICAgICAgICAgL1xcclxcbnxcXHJ8XFxuL1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgUElYSS5Mb2FkZXIuc2hhcmVkLmFkZChcIm1haW4uanNvblwiLCBzcGluZURhdGEuZGF0YSwgc3BpbmVMb2FkZXJPcHRpb25zKTtcclxuXHJcbiAgICAgICAgUElYSS5Mb2FkZXIuc2hhcmVkLmxvYWQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNwaW5lQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1RleHQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjaGFuZ2VTdGFnZVN0YXRlID0gKHNob3c6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci52aWV3LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZyb21pbnB1dFwiKSEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB0aGlzLnNldFVwR1VJKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1RleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIudmlldy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJvbWlucHV0XCIpIS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsb2FkU3BpbmUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJsb2FkU3BpbmVcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGlucHV0OiBIVE1MSW5wdXRFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxyXG4gICAgICAgICAgICBcImZpbGVpbnB1dFwiXHJcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBsZXQgZmlsZXM6IEZpbGVMaXN0O1xyXG4gICAgICAgIGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuRmlsZVJlYWRlciAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIFwiVGhlIGZpbGUgQVBJIGlzbid0IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIgeWV0LlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlucHV0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVtLCBjb3VsZG4ndCBmaW5kIHRoZSBmaWxlaW5wdXQgZWxlbWVudC5cIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaW5wdXQuZmlsZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgdGhlIGBmaWxlc2AgcHJvcGVydHkgb2YgZmlsZSBpbnB1dHMuXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dC5maWxlc1swXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUGxlYXNlIHNlbGVjdCBhIGZpbGUgYmVmb3JlIGNsaWNraW5nICdMb2FkJ1wiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZCA9IFtcImF0bGFzXCIsIFwianNvblwiLCBcInBuZ1wiXTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVzID0gaW5wdXQuZmlsZXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkLnNwbGljZShcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZC5pbmRleE9mKGZpbGUubmFtZS5zcGxpdChcIi5cIikucG9wKCkhKSxcclxuICAgICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVxdWlyZWQubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGBQbGVhc2Ugc2VsZWN0IEFMTCBzcGluZSBmaWxlcy4gTk9UIEZPVU5EIHske3JlcXVpcmVkfX1gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YWdlU3RhdGUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsb2FkRmlsZSA9IChmaWxlOiBGaWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSAoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuY3VycmVudFRhcmdldC5yZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gKCkgPT4ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZEZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5sb2coZmlsZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkNiKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjcmVhdGVTcGluZUFuaW1hdGlvbiA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnRhcmdldEFuaW0gPSBSZXNvdXJjZUNvbnRyb2xsZXIuZ2V0U3BpbmUoXCJtYWluLmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy50YXJnZXRBbmltKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaG93R1VJKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRlc3Ryb3lTcGluZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnRhcmdldEFuaW0/LmRlc3Ryb3koe1xyXG4gICAgICAgICAgICBjaGlsZHJlbjogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dHVyZTogdHJ1ZSxcclxuICAgICAgICAgICAgYmFzZVRleHR1cmU6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudGFyZ2V0QW5pbSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0QW5pbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxvb3BlZEFuaW0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2tpbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3QgbG9hZGVyID0gUmVzb3VyY2VDb250cm9sbGVyLmxvYWRlcjtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZXMgb2YgT2JqZWN0LmtleXMobG9hZGVyLnJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGxvYWRlci5yZXNvdXJjZXNbcmVzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWxsLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIFBJWEkudXRpbHMuQmFzZVRleHR1cmVDYWNoZSA9IHt9O1xyXG4gICAgICAgIFBJWEkudXRpbHMuVGV4dHVyZUNhY2hlID0ge307XHJcblxyXG4gICAgICAgIFBJWEkudXRpbHMuY2xlYXJUZXh0dXJlQ2FjaGUoKTtcclxuXHJcbiAgICAgICAgbG9hZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgdGhpcy5ndWkuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5nZVN0YWdlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZyb21pbnB1dFwiKSEgYXMgSFRNTEZvcm1FbGVtZW50KS5yZXNldCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0QW5pbSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldEFuaW0ucG9zaXRpb24uc2V0KFxyXG4gICAgICAgICAgICAgICAgQ29uZmlnLnByb2plY3Rfd2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgQ29uZmlnLnByb2plY3RfaGVpZ2h0IC8gMlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Main.ts\n");

/***/ }),

/***/ "./src/Observer.ts":
/*!*************************!*\
  !*** ./src/Observer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Subject\": () => (/* binding */ Subject)\n/* harmony export */ });\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n        this.add_observer = (observer) => {\r\n            this.observers.push(observer);\r\n        };\r\n        this.remove_observer = (observer) => {\r\n            const observer_index = this.observers.indexOf(observer);\r\n            if (observer_index !== -1) {\r\n                this.observers.splice(observer_index, 1);\r\n            }\r\n            else {\r\n                console.error(\"No such observer exists!\");\r\n            }\r\n        };\r\n        this.notify_all = () => {\r\n            for (const o of this.observers) {\r\n                if (o.on_state_update) {\r\n                    o.on_state_update();\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT2JzZXJ2ZXIudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lLXNhbmRib3gvLi9zcmMvT2JzZXJ2ZXIudHM/Mzc5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIE9ic2VydmVyIHtcclxuICAgIG9uX3N0YXRlX3VwZGF0ZT86ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTdWJqZWN0IHtcclxuICAgIG9ic2VydmVyczogT2JzZXJ2ZXJbXSA9IFtdO1xyXG4gICAgYWRkX29ic2VydmVyID0gKG9ic2VydmVyOiBPYnNlcnZlcikgPT4ge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgfTtcclxuICAgIHJlbW92ZV9vYnNlcnZlciA9IChvYnNlcnZlcjogT2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlcl9pbmRleCA9IHRoaXMub2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmIChvYnNlcnZlcl9pbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMuc3BsaWNlKG9ic2VydmVyX2luZGV4LCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gc3VjaCBvYnNlcnZlciBleGlzdHMhXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBub3RpZnlfYWxsID0gKCkgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLm9ic2VydmVycykge1xyXG4gICAgICAgICAgICBpZiAoby5vbl9zdGF0ZV91cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIG8ub25fc3RhdGVfdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Observer.ts\n");

/***/ }),

/***/ "./src/ResourceLoader.ts":
/*!*******************************!*\
  !*** ./src/ResourceLoader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResourceController\": () => (/* binding */ ResourceController)\n/* harmony export */ });\nclass Loader {\r\n    constructor() {\r\n        this.loader = PIXI.Loader.shared;\r\n        this.getResource = (key) => {\r\n            const resource = this.resources[key];\r\n            if (!resource)\r\n                throw new Error(`There is no resource with name - {${key}}`);\r\n            return resource;\r\n        };\r\n        this.getSpineData = (key) => {\r\n            const resource = this.getResource(key);\r\n            if (resource instanceof PIXI.Texture) {\r\n                throw new Error(`Resource with name {${key}} is not a spine!`);\r\n            }\r\n            const spineData = resource.spineData;\r\n            if (!spineData) {\r\n                if (resource.data) {\r\n                    throw new Error(`Spine with name {${key}} not for version 3.8 or it\\`s not a spine!`);\r\n                }\r\n                else {\r\n                    throw new Error(`There is no spineData in resource - {${key}}!`);\r\n                }\r\n            }\r\n            return spineData;\r\n        };\r\n        this.getSpine = (key) => {\r\n            const spineData = this.getSpineData(key);\r\n            return new PIXI.spine.Spine(spineData);\r\n        };\r\n        this.addResources = (ANIMATIONS) => {\r\n        };\r\n        this.loadResources = () => {\r\n            return new Promise((resolve) => {\r\n                this.loader.load(() => {\r\n                    resolve();\r\n                });\r\n            });\r\n        };\r\n    }\r\n    get resources() {\r\n        return this.loader.resources;\r\n    }\r\n}\r\nconst ResourceController = new Loader();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUmVzb3VyY2VMb2FkZXIudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQTtBQUNBO0FBQ0E7QUF1REE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lLXNhbmRib3gvLi9zcmMvUmVzb3VyY2VMb2FkZXIudHM/M2ZkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJUmVzb3VyY2VEaWN0aW9uYXJ5IH0gZnJvbSBcInBpeGkuanNcIjtcblxuY2xhc3MgTG9hZGVyIHtcbiAgICBsb2FkZXIgPSBQSVhJLkxvYWRlci5zaGFyZWQ7XG5cbiAgICBwdWJsaWMgZ2V0IHJlc291cmNlcygpOiBJUmVzb3VyY2VEaWN0aW9uYXJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnJlc291cmNlcztcbiAgICB9XG5cbiAgICBnZXRSZXNvdXJjZSA9IChrZXk6IHN0cmluZyk6IFBJWEkuTG9hZGVyUmVzb3VyY2UgPT4ge1xuICAgICAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2VzW2tleV07XG5cbiAgICAgICAgaWYgKCFyZXNvdXJjZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gcmVzb3VyY2Ugd2l0aCBuYW1lIC0geyR7a2V5fX1gKTtcblxuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfTtcblxuICAgIGdldFNwaW5lRGF0YSA9IChrZXk6IHN0cmluZyk6IFBJWEkuc3BpbmUuY29yZS5Ta2VsZXRvbkRhdGEgPT4ge1xuICAgICAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuZ2V0UmVzb3VyY2Uoa2V5KTtcblxuICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBQSVhJLlRleHR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBuYW1lIHske2tleX19IGlzIG5vdCBhIHNwaW5lIWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BpbmVEYXRhID0gcmVzb3VyY2Uuc3BpbmVEYXRhO1xuXG4gICAgICAgIGlmICghc3BpbmVEYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UuZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXNvdXJjZS5kYXRhO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFNwaW5lIHdpdGggbmFtZSB7JHtrZXl9fSBub3QgZm9yIHZlcnNpb24gMy44IG9yIGl0XFxgcyBub3QgYSBzcGluZSFgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVGhlcmUgaXMgbm8gc3BpbmVEYXRhIGluIHJlc291cmNlIC0geyR7a2V5fX0hYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BpbmVEYXRhO1xuICAgIH07XG5cbiAgICBnZXRTcGluZSA9IChrZXk6IHN0cmluZyk6IFBJWEkuc3BpbmUuU3BpbmUgPT4ge1xuICAgICAgICBjb25zdCBzcGluZURhdGEgPSB0aGlzLmdldFNwaW5lRGF0YShrZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFBJWEkuc3BpbmUuU3BpbmUoc3BpbmVEYXRhKTtcbiAgICB9O1xuXG4gICAgYWRkUmVzb3VyY2VzID0gKEFOSU1BVElPTlM6IGFueSkgPT4ge1xuICAgICAgICAvLyB0aGlzLmxvYWRlci5hZGQoXG4gICAgICAgIC8vICAgICBhc3NldC5rZXksXG4gICAgICAgIC8vICAgICBgJHtTZXNzaW9uQ29uZmlnLkFTU0VUU19BRERSRVNTfSR7YXNzZXRMaXN0LmRlZmF1bHRQYXRofSR7YXNzZXQucGF0aH1gXG4gICAgICAgIC8vICk7XG4gICAgfTtcblxuICAgIGxvYWRSZXNvdXJjZXMgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBSZXNvdXJjZUNvbnRyb2xsZXIgPSBuZXcgTG9hZGVyKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ResourceLoader.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi-spine */ \"./node_modules/pixi-spine/dist/pixi-spine.js\");\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_spine__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App */ \"./src/App.ts\");\n\r\n\r\n\r\n\r\nfunction init() {\r\n    document.getElementById(\"root\").onmousedown = () => {\r\n        return false;\r\n    };\r\n    const game_name = \"Spine Sandbox\";\r\n    const full_game_name = `${game_name} v${_package_json__WEBPACK_IMPORTED_MODULE_2__.version}`;\r\n    console.log(full_game_name);\r\n    document.title = full_game_name;\r\n    new _App__WEBPACK_IMPORTED_MODULE_3__.App();\r\n}\r\nif (document.readyState !== \"loading\") {\r\n    init();\r\n}\r\nelse {\r\n    document.addEventListener(\"DOMContentLoaded\", init);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZS1zYW5kYm94Ly4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwicGl4aS1zcGluZVwiO1xyXG5pbXBvcnQgXCJwaXhpLmpzXCI7XHJcbmltcG9ydCBwYWNrYWdlSW5mbyBmcm9tIFwiLi4vcGFja2FnZS5qc29uXCI7XHJcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL0FwcFwiO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEub25tb3VzZWRvd24gPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBnYW1lX25hbWUgPSBcIlNwaW5lIFNhbmRib3hcIjtcclxuICAgIGNvbnN0IGZ1bGxfZ2FtZV9uYW1lID0gYCR7Z2FtZV9uYW1lfSB2JHtwYWNrYWdlSW5mby52ZXJzaW9ufWA7XHJcblxyXG4gICAgY29uc29sZS5sb2coZnVsbF9nYW1lX25hbWUpO1xyXG5cclxuICAgIGRvY3VtZW50LnRpdGxlID0gZnVsbF9nYW1lX25hbWU7XHJcblxyXG4gICAgbmV3IEFwcCgpO1xyXG59XHJcblxyXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcclxuICAgIGluaXQoKTtcclxufSBlbHNlIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGluaXQpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BpbmUtc2FuZGJveC8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/OWFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "pixi.js":
/*!***********************!*\
  !*** external "PIXI" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = PIXI;

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"spine-sandbox","version":"1.0.2","description":"Sandbox for spine 3.8 animations","main":"src/index.ts","scripts":{"test":"npm run test","local":"webpack serve --config-name local","build":"webpack --config-name dev","deploy":"npm run build && gh-pages -d dist"},"repository":{"type":"git","url":"spine-sandbox"},"keywords":["spine","pixijs","sandbox"],"author":"Vlad Kyiashko","license":"ISC","devDependencies":{"@pixi/core":"^5.3.10","@types/dat.gui":"^0.7.7","@typescript-eslint/eslint-plugin":"^4.27.0","@typescript-eslint/parser":"^4.27.0","clean-webpack-plugin":"^3.0.0","copy-webpack-plugin":"^9.0.0","dat.gui":"^0.7.9","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","eslint-plugin-prettier":"^3.4.0","pixi-spine":"^2.1.10","pixi.js":"^5.3.3","prettier":"^2.3.1","ts-loader":"^9.2.3","tslib":"^2.3.1","typescript":"^4.3.2","url-loader":"^4.1.1","webpack":"^5.39.0","webpack-cli":"^4.7.2","webpack-dev-server":"^4.9.3"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;