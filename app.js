/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GUI\": () => (/* binding */ GUI$1),\n/* harmony export */   \"color\": () => (/* binding */ color),\n/* harmony export */   \"controllers\": () => (/* binding */ controllers),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"dom\": () => (/* binding */ dom$1),\n/* harmony export */   \"gui\": () => (/* binding */ gui)\n/* harmony export */ });\n/**\n * dat-gui JavaScript Controller Library\n * https://github.com/dataarts/dat.gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction ___$insertStyle(css) {\n  if (!css) {\n    return;\n  }\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  var style = document.createElement('style');\n\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n\n  return css;\n}\n\nfunction colorToString (color, forceCSSHex) {\n  var colorFormat = color.__state.conversionName.toString();\n  var r = Math.round(color.r);\n  var g = Math.round(color.g);\n  var b = Math.round(color.b);\n  var a = color.a;\n  var h = Math.round(color.h);\n  var s = color.s.toFixed(1);\n  var v = color.v.toFixed(1);\n  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {\n    var str = color.hex.toString(16);\n    while (str.length < 6) {\n      str = '0' + str;\n    }\n    return '#' + str;\n  } else if (colorFormat === 'CSS_RGB') {\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\n  } else if (colorFormat === 'CSS_RGBA') {\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  } else if (colorFormat === 'HEX') {\n    return '0x' + color.hex.toString(16);\n  } else if (colorFormat === 'RGB_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ']';\n  } else if (colorFormat === 'RGBA_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ',' + a + ']';\n  } else if (colorFormat === 'RGB_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + '}';\n  } else if (colorFormat === 'RGBA_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';\n  } else if (colorFormat === 'HSV_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + '}';\n  } else if (colorFormat === 'HSVA_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';\n  }\n  return 'unknown format';\n}\n\nvar ARR_EACH = Array.prototype.forEach;\nvar ARR_SLICE = Array.prototype.slice;\nvar Common = {\n  BREAK: {},\n  extend: function extend(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (!this.isUndefined(obj[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  defaults: function defaults(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (this.isUndefined(target[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  compose: function compose() {\n    var toCall = ARR_SLICE.call(arguments);\n    return function () {\n      var args = ARR_SLICE.call(arguments);\n      for (var i = toCall.length - 1; i >= 0; i--) {\n        args = [toCall[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  },\n  each: function each(obj, itr, scope) {\n    if (!obj) {\n      return;\n    }\n    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {\n      obj.forEach(itr, scope);\n    } else if (obj.length === obj.length + 0) {\n      var key = void 0;\n      var l = void 0;\n      for (key = 0, l = obj.length; key < l; key++) {\n        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {\n          return;\n        }\n      }\n    } else {\n      for (var _key in obj) {\n        if (itr.call(scope, obj[_key], _key) === this.BREAK) {\n          return;\n        }\n      }\n    }\n  },\n  defer: function defer(fnc) {\n    setTimeout(fnc, 0);\n  },\n  debounce: function debounce(func, threshold, callImmediately) {\n    var timeout = void 0;\n    return function () {\n      var obj = this;\n      var args = arguments;\n      function delayed() {\n        timeout = null;\n        if (!callImmediately) func.apply(obj, args);\n      }\n      var callNow = callImmediately || !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(delayed, threshold);\n      if (callNow) {\n        func.apply(obj, args);\n      }\n    };\n  },\n  toArray: function toArray(obj) {\n    if (obj.toArray) return obj.toArray();\n    return ARR_SLICE.call(obj);\n  },\n  isUndefined: function isUndefined(obj) {\n    return obj === undefined;\n  },\n  isNull: function isNull(obj) {\n    return obj === null;\n  },\n  isNaN: function (_isNaN) {\n    function isNaN(_x) {\n      return _isNaN.apply(this, arguments);\n    }\n    isNaN.toString = function () {\n      return _isNaN.toString();\n    };\n    return isNaN;\n  }(function (obj) {\n    return isNaN(obj);\n  }),\n  isArray: Array.isArray || function (obj) {\n    return obj.constructor === Array;\n  },\n  isObject: function isObject(obj) {\n    return obj === Object(obj);\n  },\n  isNumber: function isNumber(obj) {\n    return obj === obj + 0;\n  },\n  isString: function isString(obj) {\n    return obj === obj + '';\n  },\n  isBoolean: function isBoolean(obj) {\n    return obj === false || obj === true;\n  },\n  isFunction: function isFunction(obj) {\n    return obj instanceof Function;\n  }\n};\n\nvar INTERPRETATIONS = [\n{\n  litmus: Common.isString,\n  conversions: {\n    THREE_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    SIX_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9]{6})$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGB: {\n      read: function read(original) {\n        var test = original.match(/^rgb\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3])\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGBA: {\n      read: function read(original) {\n        var test = original.match(/^rgba\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3]),\n          a: parseFloat(test[4])\n        };\n      },\n      write: colorToString\n    }\n  }\n},\n{\n  litmus: Common.isNumber,\n  conversions: {\n    HEX: {\n      read: function read(original) {\n        return {\n          space: 'HEX',\n          hex: original,\n          conversionName: 'HEX'\n        };\n      },\n      write: function write(color) {\n        return color.hex;\n      }\n    }\n  }\n},\n{\n  litmus: Common.isArray,\n  conversions: {\n    RGB_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 3) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b];\n      }\n    },\n    RGBA_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 4) return false;\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2],\n          a: original[3]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b, color.a];\n      }\n    }\n  }\n},\n{\n  litmus: Common.isObject,\n  conversions: {\n    RGBA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b,\n          a: color.a\n        };\n      }\n    },\n    RGB_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b\n        };\n      }\n    },\n    HSVA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v,\n          a: color.a\n        };\n      }\n    },\n    HSV_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v\n        };\n      }\n    }\n  }\n}];\nvar result = void 0;\nvar toReturn = void 0;\nvar interpret = function interpret() {\n  toReturn = false;\n  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];\n  Common.each(INTERPRETATIONS, function (family) {\n    if (family.litmus(original)) {\n      Common.each(family.conversions, function (conversion, conversionName) {\n        result = conversion.read(original);\n        if (toReturn === false && result !== false) {\n          toReturn = result;\n          result.conversionName = conversionName;\n          result.conversion = conversion;\n          return Common.BREAK;\n        }\n      });\n      return Common.BREAK;\n    }\n  });\n  return toReturn;\n};\n\nvar tmpComponent = void 0;\nvar ColorMath = {\n  hsv_to_rgb: function hsv_to_rgb(h, s, v) {\n    var hi = Math.floor(h / 60) % 6;\n    var f = h / 60 - Math.floor(h / 60);\n    var p = v * (1.0 - s);\n    var q = v * (1.0 - f * s);\n    var t = v * (1.0 - (1.0 - f) * s);\n    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];\n    return {\n      r: c[0] * 255,\n      g: c[1] * 255,\n      b: c[2] * 255\n    };\n  },\n  rgb_to_hsv: function rgb_to_hsv(r, g, b) {\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var h = void 0;\n    var s = void 0;\n    if (max !== 0) {\n      s = delta / max;\n    } else {\n      return {\n        h: NaN,\n        s: 0,\n        v: 0\n      };\n    }\n    if (r === max) {\n      h = (g - b) / delta;\n    } else if (g === max) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n    h /= 6;\n    if (h < 0) {\n      h += 1;\n    }\n    return {\n      h: h * 360,\n      s: s,\n      v: max / 255\n    };\n  },\n  rgb_to_hex: function rgb_to_hex(r, g, b) {\n    var hex = this.hex_with_component(0, 2, r);\n    hex = this.hex_with_component(hex, 1, g);\n    hex = this.hex_with_component(hex, 0, b);\n    return hex;\n  },\n  component_from_hex: function component_from_hex(hex, componentIndex) {\n    return hex >> componentIndex * 8 & 0xFF;\n  },\n  hex_with_component: function hex_with_component(hex, componentIndex, value) {\n    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);\n  }\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Color = function () {\n  function Color() {\n    classCallCheck(this, Color);\n    this.__state = interpret.apply(this, arguments);\n    if (this.__state === false) {\n      throw new Error('Failed to interpret color arguments');\n    }\n    this.__state.a = this.__state.a || 1;\n  }\n  createClass(Color, [{\n    key: 'toString',\n    value: function toString() {\n      return colorToString(this);\n    }\n  }, {\n    key: 'toHexString',\n    value: function toHexString() {\n      return colorToString(this, true);\n    }\n  }, {\n    key: 'toOriginal',\n    value: function toOriginal() {\n      return this.__state.conversion.write(this);\n    }\n  }]);\n  return Color;\n}();\nfunction defineRGBComponent(target, component, componentHexIndex) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'RGB') {\n        return this.__state[component];\n      }\n      Color.recalculateRGB(this, component, componentHexIndex);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'RGB') {\n        Color.recalculateRGB(this, component, componentHexIndex);\n        this.__state.space = 'RGB';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nfunction defineHSVComponent(target, component) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'HSV') {\n        return this.__state[component];\n      }\n      Color.recalculateHSV(this);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'HSV') {\n        Color.recalculateHSV(this);\n        this.__state.space = 'HSV';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nColor.recalculateRGB = function (color, component, componentHexIndex) {\n  if (color.__state.space === 'HEX') {\n    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);\n  } else if (color.__state.space === 'HSV') {\n    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n  } else {\n    throw new Error('Corrupted color state');\n  }\n};\nColor.recalculateHSV = function (color) {\n  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);\n  Common.extend(color.__state, {\n    s: result.s,\n    v: result.v\n  });\n  if (!Common.isNaN(result.h)) {\n    color.__state.h = result.h;\n  } else if (Common.isUndefined(color.__state.h)) {\n    color.__state.h = 0;\n  }\n};\nColor.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];\ndefineRGBComponent(Color.prototype, 'r', 2);\ndefineRGBComponent(Color.prototype, 'g', 1);\ndefineRGBComponent(Color.prototype, 'b', 0);\ndefineHSVComponent(Color.prototype, 'h');\ndefineHSVComponent(Color.prototype, 's');\ndefineHSVComponent(Color.prototype, 'v');\nObject.defineProperty(Color.prototype, 'a', {\n  get: function get$$1() {\n    return this.__state.a;\n  },\n  set: function set$$1(v) {\n    this.__state.a = v;\n  }\n});\nObject.defineProperty(Color.prototype, 'hex', {\n  get: function get$$1() {\n    if (this.__state.space !== 'HEX') {\n      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);\n      this.__state.space = 'HEX';\n    }\n    return this.__state.hex;\n  },\n  set: function set$$1(v) {\n    this.__state.space = 'HEX';\n    this.__state.hex = v;\n  }\n});\n\nvar Controller = function () {\n  function Controller(object, property) {\n    classCallCheck(this, Controller);\n    this.initialValue = object[property];\n    this.domElement = document.createElement('div');\n    this.object = object;\n    this.property = property;\n    this.__onChange = undefined;\n    this.__onFinishChange = undefined;\n  }\n  createClass(Controller, [{\n    key: 'onChange',\n    value: function onChange(fnc) {\n      this.__onChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'onFinishChange',\n    value: function onFinishChange(fnc) {\n      this.__onFinishChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'setValue',\n    value: function setValue(newValue) {\n      this.object[this.property] = newValue;\n      if (this.__onChange) {\n        this.__onChange.call(this, newValue);\n      }\n      this.updateDisplay();\n      return this;\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.object[this.property];\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      return this;\n    }\n  }, {\n    key: 'isModified',\n    value: function isModified() {\n      return this.initialValue !== this.getValue();\n    }\n  }]);\n  return Controller;\n}();\n\nvar EVENT_MAP = {\n  HTMLEvents: ['change'],\n  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],\n  KeyboardEvents: ['keydown']\n};\nvar EVENT_MAP_INV = {};\nCommon.each(EVENT_MAP, function (v, k) {\n  Common.each(v, function (e) {\n    EVENT_MAP_INV[e] = k;\n  });\n});\nvar CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\nfunction cssValueToPixels(val) {\n  if (val === '0' || Common.isUndefined(val)) {\n    return 0;\n  }\n  var match = val.match(CSS_VALUE_PIXELS);\n  if (!Common.isNull(match)) {\n    return parseFloat(match[1]);\n  }\n  return 0;\n}\nvar dom = {\n  makeSelectable: function makeSelectable(elem, selectable) {\n    if (elem === undefined || elem.style === undefined) return;\n    elem.onselectstart = selectable ? function () {\n      return false;\n    } : function () {};\n    elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n    elem.unselectable = selectable ? 'on' : 'off';\n  },\n  makeFullscreen: function makeFullscreen(elem, hor, vert) {\n    var vertical = vert;\n    var horizontal = hor;\n    if (Common.isUndefined(horizontal)) {\n      horizontal = true;\n    }\n    if (Common.isUndefined(vertical)) {\n      vertical = true;\n    }\n    elem.style.position = 'absolute';\n    if (horizontal) {\n      elem.style.left = 0;\n      elem.style.right = 0;\n    }\n    if (vertical) {\n      elem.style.top = 0;\n      elem.style.bottom = 0;\n    }\n  },\n  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {\n    var params = pars || {};\n    var className = EVENT_MAP_INV[eventType];\n    if (!className) {\n      throw new Error('Event type ' + eventType + ' not supported.');\n    }\n    var evt = document.createEvent(className);\n    switch (className) {\n      case 'MouseEvents':\n        {\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,\n          0,\n          clientX,\n          clientY,\n          false, false, false, false, 0, null);\n          break;\n        }\n      case 'KeyboardEvents':\n        {\n          var init = evt.initKeyboardEvent || evt.initKeyEvent;\n          Common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);\n          break;\n        }\n      default:\n        {\n          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);\n          break;\n        }\n    }\n    Common.defaults(evt, aux);\n    elem.dispatchEvent(evt);\n  },\n  bind: function bind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.addEventListener) {\n      elem.addEventListener(event, func, bool);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  unbind: function unbind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.removeEventListener) {\n      elem.removeEventListener(event, func, bool);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  addClass: function addClass(elem, className) {\n    if (elem.className === undefined) {\n      elem.className = className;\n    } else if (elem.className !== className) {\n      var classes = elem.className.split(/ +/);\n      if (classes.indexOf(className) === -1) {\n        classes.push(className);\n        elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n      }\n    }\n    return dom;\n  },\n  removeClass: function removeClass(elem, className) {\n    if (className) {\n      if (elem.className === className) {\n        elem.removeAttribute('class');\n      } else {\n        var classes = elem.className.split(/ +/);\n        var index = classes.indexOf(className);\n        if (index !== -1) {\n          classes.splice(index, 1);\n          elem.className = classes.join(' ');\n        }\n      }\n    } else {\n      elem.className = undefined;\n    }\n    return dom;\n  },\n  hasClass: function hasClass(elem, className) {\n    return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n  },\n  getWidth: function getWidth(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);\n  },\n  getHeight: function getHeight(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);\n  },\n  getOffset: function getOffset(el) {\n    var elem = el;\n    var offset = { left: 0, top: 0 };\n    if (elem.offsetParent) {\n      do {\n        offset.left += elem.offsetLeft;\n        offset.top += elem.offsetTop;\n        elem = elem.offsetParent;\n      } while (elem);\n    }\n    return offset;\n  },\n  isActive: function isActive(elem) {\n    return elem === document.activeElement && (elem.type || elem.href);\n  }\n};\n\nvar BooleanController = function (_Controller) {\n  inherits(BooleanController, _Controller);\n  function BooleanController(object, property) {\n    classCallCheck(this, BooleanController);\n    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__prev = _this2.getValue();\n    _this2.__checkbox = document.createElement('input');\n    _this2.__checkbox.setAttribute('type', 'checkbox');\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n    dom.bind(_this2.__checkbox, 'change', onChange, false);\n    _this2.domElement.appendChild(_this2.__checkbox);\n    _this2.updateDisplay();\n    return _this2;\n  }\n  createClass(BooleanController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      this.__prev = this.getValue();\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (this.getValue() === true) {\n        this.__checkbox.setAttribute('checked', 'checked');\n        this.__checkbox.checked = true;\n        this.__prev = true;\n      } else {\n        this.__checkbox.checked = false;\n        this.__prev = false;\n      }\n      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return BooleanController;\n}(Controller);\n\nvar OptionController = function (_Controller) {\n  inherits(OptionController, _Controller);\n  function OptionController(object, property, opts) {\n    classCallCheck(this, OptionController);\n    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));\n    var options = opts;\n    var _this = _this2;\n    _this2.__select = document.createElement('select');\n    if (Common.isArray(options)) {\n      var map = {};\n      Common.each(options, function (element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n    Common.each(options, function (value, key) {\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n    });\n    _this2.updateDisplay();\n    dom.bind(_this2.__select, 'change', function () {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n    _this2.domElement.appendChild(_this2.__select);\n    return _this2;\n  }\n  createClass(OptionController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (dom.isActive(this.__select)) return this;\n      this.__select.value = this.getValue();\n      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return OptionController;\n}(Controller);\n\nvar StringController = function (_Controller) {\n  inherits(StringController, _Controller);\n  function StringController(object, property) {\n    classCallCheck(this, StringController);\n    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));\n    var _this = _this2;\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'keyup', onChange);\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(StringController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (!dom.isActive(this.__input)) {\n        this.__input.value = this.getValue();\n      }\n      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return StringController;\n}(Controller);\n\nfunction numDecimals(x) {\n  var _x = x.toString();\n  if (_x.indexOf('.') > -1) {\n    return _x.length - _x.indexOf('.') - 1;\n  }\n  return 0;\n}\nvar NumberController = function (_Controller) {\n  inherits(NumberController, _Controller);\n  function NumberController(object, property, params) {\n    classCallCheck(this, NumberController);\n    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));\n    var _params = params || {};\n    _this.__min = _params.min;\n    _this.__max = _params.max;\n    _this.__step = _params.step;\n    if (Common.isUndefined(_this.__step)) {\n      if (_this.initialValue === 0) {\n        _this.__impliedStep = 1;\n      } else {\n        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;\n      }\n    } else {\n      _this.__impliedStep = _this.__step;\n    }\n    _this.__precision = numDecimals(_this.__impliedStep);\n    return _this;\n  }\n  createClass(NumberController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var _v = v;\n      if (this.__min !== undefined && _v < this.__min) {\n        _v = this.__min;\n      } else if (this.__max !== undefined && _v > this.__max) {\n        _v = this.__max;\n      }\n      if (this.__step !== undefined && _v % this.__step !== 0) {\n        _v = Math.round(_v / this.__step) * this.__step;\n      }\n      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);\n    }\n  }, {\n    key: 'min',\n    value: function min(minValue) {\n      this.__min = minValue;\n      return this;\n    }\n  }, {\n    key: 'max',\n    value: function max(maxValue) {\n      this.__max = maxValue;\n      return this;\n    }\n  }, {\n    key: 'step',\n    value: function step(stepValue) {\n      this.__step = stepValue;\n      this.__impliedStep = stepValue;\n      this.__precision = numDecimals(stepValue);\n      return this;\n    }\n  }]);\n  return NumberController;\n}(Controller);\n\nfunction roundToDecimal(value, decimals) {\n  var tenTo = Math.pow(10, decimals);\n  return Math.round(value * tenTo) / tenTo;\n}\nvar NumberControllerBox = function (_NumberController) {\n  inherits(NumberControllerBox, _NumberController);\n  function NumberControllerBox(object, property, params) {\n    classCallCheck(this, NumberControllerBox);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));\n    _this2.__truncationSuspended = false;\n    var _this = _this2;\n    var prevY = void 0;\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!Common.isNaN(attempted)) {\n        _this.setValue(attempted);\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onBlur() {\n      onFinish();\n    }\n    function onMouseDrag(e) {\n      var diff = prevY - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n      prevY = e.clientY;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      onFinish();\n    }\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prevY = e.clientY;\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'mousedown', onMouseDown);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n        onFinish();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(NumberControllerBox, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerBox;\n}(NumberController);\n\nfunction map(v, i1, i2, o1, o2) {\n  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n}\nvar NumberControllerSlider = function (_NumberController) {\n  inherits(NumberControllerSlider, _NumberController);\n  function NumberControllerSlider(object, property, min, max, step) {\n    classCallCheck(this, NumberControllerSlider);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));\n    var _this = _this2;\n    _this2.__background = document.createElement('div');\n    _this2.__foreground = document.createElement('div');\n    dom.bind(_this2.__background, 'mousedown', onMouseDown);\n    dom.bind(_this2.__background, 'touchstart', onTouchStart);\n    dom.addClass(_this2.__background, 'slider');\n    dom.addClass(_this2.__foreground, 'slider-fg');\n    function onMouseDown(e) {\n      document.activeElement.blur();\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      onMouseDrag(e);\n    }\n    function onMouseDrag(e) {\n      e.preventDefault();\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n      return false;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onTouchStart(e) {\n      if (e.touches.length !== 1) {\n        return;\n      }\n      dom.bind(window, 'touchmove', onTouchMove);\n      dom.bind(window, 'touchend', onTouchEnd);\n      onTouchMove(e);\n    }\n    function onTouchMove(e) {\n      var clientX = e.touches[0].clientX;\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n    }\n    function onTouchEnd() {\n      dom.unbind(window, 'touchmove', onTouchMove);\n      dom.unbind(window, 'touchend', onTouchEnd);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.updateDisplay();\n    _this2.__background.appendChild(_this2.__foreground);\n    _this2.domElement.appendChild(_this2.__background);\n    return _this2;\n  }\n  createClass(NumberControllerSlider, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);\n      this.__foreground.style.width = pct * 100 + '%';\n      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerSlider;\n}(NumberController);\n\nvar FunctionController = function (_Controller) {\n  inherits(FunctionController, _Controller);\n  function FunctionController(object, property, text) {\n    classCallCheck(this, FunctionController);\n    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__button = document.createElement('div');\n    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(_this2.__button, 'click', function (e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n    dom.addClass(_this2.__button, 'button');\n    _this2.domElement.appendChild(_this2.__button);\n    return _this2;\n  }\n  createClass(FunctionController, [{\n    key: 'fire',\n    value: function fire() {\n      if (this.__onChange) {\n        this.__onChange.call(this);\n      }\n      this.getValue().call(this.object);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n    }\n  }]);\n  return FunctionController;\n}(Controller);\n\nvar ColorController = function (_Controller) {\n  inherits(ColorController, _Controller);\n  function ColorController(object, property) {\n    classCallCheck(this, ColorController);\n    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));\n    _this2.__color = new Color(_this2.getValue());\n    _this2.__temp = new Color(0);\n    var _this = _this2;\n    _this2.domElement = document.createElement('div');\n    dom.makeSelectable(_this2.domElement, false);\n    _this2.__selector = document.createElement('div');\n    _this2.__selector.className = 'selector';\n    _this2.__saturation_field = document.createElement('div');\n    _this2.__saturation_field.className = 'saturation-field';\n    _this2.__field_knob = document.createElement('div');\n    _this2.__field_knob.className = 'field-knob';\n    _this2.__field_knob_border = '2px solid ';\n    _this2.__hue_knob = document.createElement('div');\n    _this2.__hue_knob.className = 'hue-knob';\n    _this2.__hue_field = document.createElement('div');\n    _this2.__hue_field.className = 'hue-field';\n    _this2.__input = document.createElement('input');\n    _this2.__input.type = 'text';\n    _this2.__input_textShadow = '0 1px 1px ';\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        onBlur.call(this);\n      }\n    });\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__selector, 'mousedown', function () {\n      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    dom.bind(_this2.__selector, 'touchstart', function () {\n      dom.addClass(this, 'drag').bind(window, 'touchend', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    var valueField = document.createElement('div');\n    Common.extend(_this2.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n    Common.extend(_this2.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    Common.extend(_this2.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n    Common.extend(_this2.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n    Common.extend(valueField.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');\n    Common.extend(_this2.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      border: '1px solid #555',\n      cursor: 'ns-resize',\n      position: 'absolute',\n      top: '3px',\n      right: '3px'\n    });\n    hueGradient(_this2.__hue_field);\n    Common.extend(_this2.__input.style, {\n      outline: 'none',\n      textAlign: 'center',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);\n    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);\n    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);\n    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);\n    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);\n    function fieldDown(e) {\n      setSV(e);\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'touchmove', setSV);\n      dom.bind(window, 'mouseup', fieldUpSV);\n      dom.bind(window, 'touchend', fieldUpSV);\n    }\n    function fieldDownH(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'touchmove', setH);\n      dom.bind(window, 'mouseup', fieldUpH);\n      dom.bind(window, 'touchend', fieldUpH);\n    }\n    function fieldUpSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'touchmove', setSV);\n      dom.unbind(window, 'mouseup', fieldUpSV);\n      dom.unbind(window, 'touchend', fieldUpSV);\n      onFinish();\n    }\n    function fieldUpH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'touchmove', setH);\n      dom.unbind(window, 'mouseup', fieldUpH);\n      dom.unbind(window, 'touchend', fieldUpH);\n      onFinish();\n    }\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.__color.toOriginal());\n      }\n    }\n    _this2.__saturation_field.appendChild(valueField);\n    _this2.__selector.appendChild(_this2.__field_knob);\n    _this2.__selector.appendChild(_this2.__saturation_field);\n    _this2.__selector.appendChild(_this2.__hue_field);\n    _this2.__hue_field.appendChild(_this2.__hue_knob);\n    _this2.domElement.appendChild(_this2.__input);\n    _this2.domElement.appendChild(_this2.__selector);\n    _this2.updateDisplay();\n    function setSV(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__saturation_field.getBoundingClientRect();\n      var _ref = e.touches && e.touches[0] || e,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);\n      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (v > 1) {\n        v = 1;\n      } else if (v < 0) {\n        v = 0;\n      }\n      if (s > 1) {\n        s = 1;\n      } else if (s < 0) {\n        s = 0;\n      }\n      _this.__color.v = v;\n      _this.__color.s = s;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    function setH(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__hue_field.getBoundingClientRect();\n      var _ref2 = e.touches && e.touches[0] || e,\n          clientY = _ref2.clientY;\n      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (h > 1) {\n        h = 1;\n      } else if (h < 0) {\n        h = 0;\n      }\n      _this.__color.h = h * 360;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    return _this2;\n  }\n  createClass(ColorController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var i = interpret(this.getValue());\n      if (i !== false) {\n        var mismatch = false;\n        Common.each(Color.COMPONENTS, function (component) {\n          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {\n            mismatch = true;\n            return {};\n          }\n        }, this);\n        if (mismatch) {\n          Common.extend(this.__color.__state, i);\n        }\n      }\n      Common.extend(this.__temp.__state, this.__color.__state);\n      this.__temp.a = 1;\n      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;\n      var _flip = 255 - flip;\n      Common.extend(this.__field_knob.style, {\n        marginLeft: 100 * this.__color.s - 7 + 'px',\n        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n        backgroundColor: this.__temp.toHexString(),\n        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'\n      });\n      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';\n      this.__temp.s = 1;\n      this.__temp.v = 1;\n      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());\n      this.__input.value = this.__color.toString();\n      Common.extend(this.__input.style, {\n        backgroundColor: this.__color.toHexString(),\n        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',\n        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'\n      });\n    }\n  }]);\n  return ColorController;\n}(Controller);\nvar vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];\nfunction linearGradient(elem, x, a, b) {\n  elem.style.background = '';\n  Common.each(vendors, function (vendor) {\n    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';\n  });\n}\nfunction hueGradient(elem) {\n  elem.style.background = '';\n  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';\n  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n}\n\nvar css = {\n  load: function load(url, indoc) {\n    var doc = indoc || document;\n    var link = doc.createElement('link');\n    link.type = 'text/css';\n    link.rel = 'stylesheet';\n    link.href = url;\n    doc.getElementsByTagName('head')[0].appendChild(link);\n  },\n  inject: function inject(cssContent, indoc) {\n    var doc = indoc || document;\n    var injected = document.createElement('style');\n    injected.type = 'text/css';\n    injected.innerHTML = cssContent;\n    var head = doc.getElementsByTagName('head')[0];\n    try {\n      head.appendChild(injected);\n    } catch (e) {\n    }\n  }\n};\n\nvar saveDialogContents = \"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n\\n    </div>\\n\\n  </div>\\n\\n</div>\";\n\nvar ControllerFactory = function ControllerFactory(object, property) {\n  var initialValue = object[property];\n  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {\n    return new OptionController(object, property, arguments[2]);\n  }\n  if (Common.isNumber(initialValue)) {\n    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {\n      if (Common.isNumber(arguments[4])) {\n        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);\n      }\n      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n    }\n    if (Common.isNumber(arguments[4])) {\n      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });\n    }\n    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n  }\n  if (Common.isString(initialValue)) {\n    return new StringController(object, property);\n  }\n  if (Common.isFunction(initialValue)) {\n    return new FunctionController(object, property, '');\n  }\n  if (Common.isBoolean(initialValue)) {\n    return new BooleanController(object, property);\n  }\n  return null;\n};\n\nfunction requestAnimationFrame(callback) {\n  setTimeout(callback, 1000 / 60);\n}\nvar requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;\n\nvar CenteredDiv = function () {\n  function CenteredDiv() {\n    classCallCheck(this, CenteredDiv);\n    this.backgroundElement = document.createElement('div');\n    Common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear',\n      transition: 'opacity 0.2s linear'\n    });\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n    this.domElement = document.createElement('div');\n    Common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',\n      transition: 'transform 0.2s ease-out, opacity 0.2s linear'\n    });\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function () {\n      _this.hide();\n    });\n  }\n  createClass(CenteredDiv, [{\n    key: 'show',\n    value: function show() {\n      var _this = this;\n      this.backgroundElement.style.display = 'block';\n      this.domElement.style.display = 'block';\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n      this.layout();\n      Common.defer(function () {\n        _this.backgroundElement.style.opacity = 1;\n        _this.domElement.style.opacity = 1;\n        _this.domElement.style.webkitTransform = 'scale(1)';\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      var _this = this;\n      var hide = function hide() {\n        _this.domElement.style.display = 'none';\n        _this.backgroundElement.style.display = 'none';\n        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n        dom.unbind(_this.domElement, 'transitionend', hide);\n        dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n      };\n      dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n      dom.bind(this.domElement, 'transitionend', hide);\n      dom.bind(this.domElement, 'oTransitionEnd', hide);\n      this.backgroundElement.style.opacity = 0;\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n    }\n  }, {\n    key: 'layout',\n    value: function layout() {\n      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';\n      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';\n    }\n  }]);\n  return CenteredDiv;\n}();\n\nvar styleSheet = ___$insertStyle(\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\");\n\ncss.inject(styleSheet);\nvar CSS_NAMESPACE = 'dg';\nvar HIDE_KEY_CODE = 72;\nvar CLOSE_BUTTON_HEIGHT = 20;\nvar DEFAULT_DEFAULT_PRESET_NAME = 'Default';\nvar SUPPORTS_LOCAL_STORAGE = function () {\n  try {\n    return !!window.localStorage;\n  } catch (e) {\n    return false;\n  }\n}();\nvar SAVE_DIALOGUE = void 0;\nvar autoPlaceVirgin = true;\nvar autoPlaceContainer = void 0;\nvar hide = false;\nvar hideableGuis = [];\nvar GUI = function GUI(pars) {\n  var _this = this;\n  var params = pars || {};\n  this.domElement = document.createElement('div');\n  this.__ul = document.createElement('ul');\n  this.domElement.appendChild(this.__ul);\n  dom.addClass(this.domElement, CSS_NAMESPACE);\n  this.__folders = {};\n  this.__controllers = [];\n  this.__rememberedObjects = [];\n  this.__rememberedObjectIndecesToControllers = [];\n  this.__listening = [];\n  params = Common.defaults(params, {\n    closeOnTop: false,\n    autoPlace: true,\n    width: GUI.DEFAULT_WIDTH\n  });\n  params = Common.defaults(params, {\n    resizable: params.autoPlace,\n    hideable: params.autoPlace\n  });\n  if (!Common.isUndefined(params.load)) {\n    if (params.preset) {\n      params.load.preset = params.preset;\n    }\n  } else {\n    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n  }\n  if (Common.isUndefined(params.parent) && params.hideable) {\n    hideableGuis.push(this);\n  }\n  params.resizable = Common.isUndefined(params.parent) && params.resizable;\n  if (params.autoPlace && Common.isUndefined(params.scrollable)) {\n    params.scrollable = true;\n  }\n  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n  var saveToLocalStorage = void 0;\n  var titleRow = void 0;\n  Object.defineProperties(this,\n  {\n    parent: {\n      get: function get$$1() {\n        return params.parent;\n      }\n    },\n    scrollable: {\n      get: function get$$1() {\n        return params.scrollable;\n      }\n    },\n    autoPlace: {\n      get: function get$$1() {\n        return params.autoPlace;\n      }\n    },\n    closeOnTop: {\n      get: function get$$1() {\n        return params.closeOnTop;\n      }\n    },\n    preset: {\n      get: function get$$1() {\n        if (_this.parent) {\n          return _this.getRoot().preset;\n        }\n        return params.load.preset;\n      },\n      set: function set$$1(v) {\n        if (_this.parent) {\n          _this.getRoot().preset = v;\n        } else {\n          params.load.preset = v;\n        }\n        setPresetSelectIndex(this);\n        _this.revert();\n      }\n    },\n    width: {\n      get: function get$$1() {\n        return params.width;\n      },\n      set: function set$$1(v) {\n        params.width = v;\n        setWidth(_this, v);\n      }\n    },\n    name: {\n      get: function get$$1() {\n        return params.name;\n      },\n      set: function set$$1(v) {\n        params.name = v;\n        if (titleRow) {\n          titleRow.innerHTML = params.name;\n        }\n      }\n    },\n    closed: {\n      get: function get$$1() {\n        return params.closed;\n      },\n      set: function set$$1(v) {\n        params.closed = v;\n        if (params.closed) {\n          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n        } else {\n          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n        }\n        this.onResize();\n        if (_this.__closeButton) {\n          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n        }\n      }\n    },\n    load: {\n      get: function get$$1() {\n        return params.load;\n      }\n    },\n    useLocalStorage: {\n      get: function get$$1() {\n        return useLocalStorage;\n      },\n      set: function set$$1(bool) {\n        if (SUPPORTS_LOCAL_STORAGE) {\n          useLocalStorage = bool;\n          if (bool) {\n            dom.bind(window, 'unload', saveToLocalStorage);\n          } else {\n            dom.unbind(window, 'unload', saveToLocalStorage);\n          }\n          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n        }\n      }\n    }\n  });\n  if (Common.isUndefined(params.parent)) {\n    this.closed = params.closed || false;\n    dom.addClass(this.domElement, GUI.CLASS_MAIN);\n    dom.makeSelectable(this.domElement, false);\n    if (SUPPORTS_LOCAL_STORAGE) {\n      if (useLocalStorage) {\n        _this.useLocalStorage = true;\n        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n        if (savedGui) {\n          params.load = JSON.parse(savedGui);\n        }\n      }\n    }\n    this.__closeButton = document.createElement('div');\n    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n    if (params.closeOnTop) {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);\n      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);\n    } else {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);\n      this.domElement.appendChild(this.__closeButton);\n    }\n    dom.bind(this.__closeButton, 'click', function () {\n      _this.closed = !_this.closed;\n    });\n  } else {\n    if (params.closed === undefined) {\n      params.closed = true;\n    }\n    var titleRowName = document.createTextNode(params.name);\n    dom.addClass(titleRowName, 'controller-name');\n    titleRow = addRow(_this, titleRowName);\n    var onClickTitle = function onClickTitle(e) {\n      e.preventDefault();\n      _this.closed = !_this.closed;\n      return false;\n    };\n    dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n    dom.addClass(titleRow, 'title');\n    dom.bind(titleRow, 'click', onClickTitle);\n    if (!params.closed) {\n      this.closed = false;\n    }\n  }\n  if (params.autoPlace) {\n    if (Common.isUndefined(params.parent)) {\n      if (autoPlaceVirgin) {\n        autoPlaceContainer = document.createElement('div');\n        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);\n        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);\n        document.body.appendChild(autoPlaceContainer);\n        autoPlaceVirgin = false;\n      }\n      autoPlaceContainer.appendChild(this.domElement);\n      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n    }\n    if (!this.parent) {\n      setWidth(_this, params.width);\n    }\n  }\n  this.__resizeHandler = function () {\n    _this.onResizeDebounced();\n  };\n  dom.bind(window, 'resize', this.__resizeHandler);\n  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);\n  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);\n  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);\n  this.onResize();\n  if (params.resizable) {\n    addResizeHandle(this);\n  }\n  saveToLocalStorage = function saveToLocalStorage() {\n    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n  };\n  this.saveToLocalStorageIfPossible = saveToLocalStorage;\n  function resetWidth() {\n    var root = _this.getRoot();\n    root.width += 1;\n    Common.defer(function () {\n      root.width -= 1;\n    });\n  }\n  if (!params.parent) {\n    resetWidth();\n  }\n};\nGUI.toggleHide = function () {\n  hide = !hide;\n  Common.each(hideableGuis, function (gui) {\n    gui.domElement.style.display = hide ? 'none' : '';\n  });\n};\nGUI.CLASS_AUTO_PLACE = 'a';\nGUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\nGUI.CLASS_MAIN = 'main';\nGUI.CLASS_CONTROLLER_ROW = 'cr';\nGUI.CLASS_TOO_TALL = 'taller-than-window';\nGUI.CLASS_CLOSED = 'closed';\nGUI.CLASS_CLOSE_BUTTON = 'close-button';\nGUI.CLASS_CLOSE_TOP = 'close-top';\nGUI.CLASS_CLOSE_BOTTOM = 'close-bottom';\nGUI.CLASS_DRAG = 'drag';\nGUI.DEFAULT_WIDTH = 245;\nGUI.TEXT_CLOSED = 'Close Controls';\nGUI.TEXT_OPEN = 'Open Controls';\nGUI._keydownHandler = function (e) {\n  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {\n    GUI.toggleHide();\n  }\n};\ndom.bind(window, 'keydown', GUI._keydownHandler, false);\nCommon.extend(GUI.prototype,\n{\n  add: function add(object, property) {\n    return _add(this, object, property, {\n      factoryArgs: Array.prototype.slice.call(arguments, 2)\n    });\n  },\n  addColor: function addColor(object, property) {\n    return _add(this, object, property, {\n      color: true\n    });\n  },\n  remove: function remove(controller) {\n    this.__ul.removeChild(controller.__li);\n    this.__controllers.splice(this.__controllers.indexOf(controller), 1);\n    var _this = this;\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  destroy: function destroy() {\n    if (this.parent) {\n      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');\n    }\n    if (this.autoPlace) {\n      autoPlaceContainer.removeChild(this.domElement);\n    }\n    var _this = this;\n    Common.each(this.__folders, function (subfolder) {\n      _this.removeFolder(subfolder);\n    });\n    dom.unbind(window, 'keydown', GUI._keydownHandler, false);\n    removeListeners(this);\n  },\n  addFolder: function addFolder(name) {\n    if (this.__folders[name] !== undefined) {\n      throw new Error('You already have a folder in this GUI by the' + ' name \"' + name + '\"');\n    }\n    var newGuiParams = { name: name, parent: this };\n    newGuiParams.autoPlace = this.autoPlace;\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[name]) {\n      newGuiParams.closed = this.load.folders[name].closed;\n      newGuiParams.load = this.load.folders[name];\n    }\n    var gui = new GUI(newGuiParams);\n    this.__folders[name] = gui;\n    var li = addRow(this, gui.domElement);\n    dom.addClass(li, 'folder');\n    return gui;\n  },\n  removeFolder: function removeFolder(folder) {\n    this.__ul.removeChild(folder.domElement.parentElement);\n    delete this.__folders[folder.name];\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[folder.name]) {\n      delete this.load.folders[folder.name];\n    }\n    removeListeners(folder);\n    var _this = this;\n    Common.each(folder.__folders, function (subfolder) {\n      folder.removeFolder(subfolder);\n    });\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  open: function open() {\n    this.closed = false;\n  },\n  close: function close() {\n    this.closed = true;\n  },\n  hide: function hide() {\n    this.domElement.style.display = 'none';\n  },\n  show: function show() {\n    this.domElement.style.display = '';\n  },\n  onResize: function onResize() {\n    var root = this.getRoot();\n    if (root.scrollable) {\n      var top = dom.getOffset(root.__ul).top;\n      var h = 0;\n      Common.each(root.__ul.childNodes, function (node) {\n        if (!(root.autoPlace && node === root.__save_row)) {\n          h += dom.getHeight(node);\n        }\n      });\n      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n      } else {\n        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = 'auto';\n      }\n    }\n    if (root.__resize_handle) {\n      Common.defer(function () {\n        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n      });\n    }\n    if (root.__closeButton) {\n      root.__closeButton.style.width = root.width + 'px';\n    }\n  },\n  onResizeDebounced: Common.debounce(function () {\n    this.onResize();\n  }, 50),\n  remember: function remember() {\n    if (Common.isUndefined(SAVE_DIALOGUE)) {\n      SAVE_DIALOGUE = new CenteredDiv();\n      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;\n    }\n    if (this.parent) {\n      throw new Error('You can only call remember on a top level GUI.');\n    }\n    var _this = this;\n    Common.each(Array.prototype.slice.call(arguments), function (object) {\n      if (_this.__rememberedObjects.length === 0) {\n        addSaveMenu(_this);\n      }\n      if (_this.__rememberedObjects.indexOf(object) === -1) {\n        _this.__rememberedObjects.push(object);\n      }\n    });\n    if (this.autoPlace) {\n      setWidth(this, this.width);\n    }\n  },\n  getRoot: function getRoot() {\n    var gui = this;\n    while (gui.parent) {\n      gui = gui.parent;\n    }\n    return gui;\n  },\n  getSaveObject: function getSaveObject() {\n    var toReturn = this.load;\n    toReturn.closed = this.closed;\n    if (this.__rememberedObjects.length > 0) {\n      toReturn.preset = this.preset;\n      if (!toReturn.remembered) {\n        toReturn.remembered = {};\n      }\n      toReturn.remembered[this.preset] = getCurrentPreset(this);\n    }\n    toReturn.folders = {};\n    Common.each(this.__folders, function (element, key) {\n      toReturn.folders[key] = element.getSaveObject();\n    });\n    return toReturn;\n  },\n  save: function save() {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n    }\n    this.load.remembered[this.preset] = getCurrentPreset(this);\n    markPresetModified(this, false);\n    this.saveToLocalStorageIfPossible();\n  },\n  saveAs: function saveAs(presetName) {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n    }\n    this.load.remembered[presetName] = getCurrentPreset(this);\n    this.preset = presetName;\n    addPresetOption(this, presetName, true);\n    this.saveToLocalStorageIfPossible();\n  },\n  revert: function revert(gui) {\n    Common.each(this.__controllers, function (controller) {\n      if (!this.getRoot().load.remembered) {\n        controller.setValue(controller.initialValue);\n      } else {\n        recallSavedValue(gui || this.getRoot(), controller);\n      }\n      if (controller.__onFinishChange) {\n        controller.__onFinishChange.call(controller, controller.getValue());\n      }\n    }, this);\n    Common.each(this.__folders, function (folder) {\n      folder.revert(folder);\n    });\n    if (!gui) {\n      markPresetModified(this.getRoot(), false);\n    }\n  },\n  listen: function listen(controller) {\n    var init = this.__listening.length === 0;\n    this.__listening.push(controller);\n    if (init) {\n      updateDisplays(this.__listening);\n    }\n  },\n  updateDisplay: function updateDisplay() {\n    Common.each(this.__controllers, function (controller) {\n      controller.updateDisplay();\n    });\n    Common.each(this.__folders, function (folder) {\n      folder.updateDisplay();\n    });\n  }\n});\nfunction addRow(gui, newDom, liBefore) {\n  var li = document.createElement('li');\n  if (newDom) {\n    li.appendChild(newDom);\n  }\n  if (liBefore) {\n    gui.__ul.insertBefore(li, liBefore);\n  } else {\n    gui.__ul.appendChild(li);\n  }\n  gui.onResize();\n  return li;\n}\nfunction removeListeners(gui) {\n  dom.unbind(window, 'resize', gui.__resizeHandler);\n  if (gui.saveToLocalStorageIfPossible) {\n    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);\n  }\n}\nfunction markPresetModified(gui, modified) {\n  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n  if (modified) {\n    opt.innerHTML = opt.value + '*';\n  } else {\n    opt.innerHTML = opt.value;\n  }\n}\nfunction augmentController(gui, li, controller) {\n  controller.__li = li;\n  controller.__gui = gui;\n  Common.extend(controller, {\n    options: function options(_options) {\n      if (arguments.length > 1) {\n        var nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: nextSibling,\n          factoryArgs: [Common.toArray(arguments)]\n        });\n      }\n      if (Common.isArray(_options) || Common.isObject(_options)) {\n        var _nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: _nextSibling,\n          factoryArgs: [_options]\n        });\n      }\n    },\n    name: function name(_name) {\n      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;\n      return controller;\n    },\n    listen: function listen() {\n      controller.__gui.listen(controller);\n      return controller;\n    },\n    remove: function remove() {\n      controller.__gui.remove(controller);\n      return controller;\n    }\n  });\n  if (controller instanceof NumberControllerSlider) {\n    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });\n    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {\n      var pc = controller[method];\n      var pb = box[method];\n      controller[method] = box[method] = function () {\n        var args = Array.prototype.slice.call(arguments);\n        pb.apply(box, args);\n        return pc.apply(controller, args);\n      };\n    });\n    dom.addClass(li, 'has-slider');\n    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n  } else if (controller instanceof NumberControllerBox) {\n    var r = function r(returned) {\n      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {\n        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;\n        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;\n        controller.remove();\n        var newController = _add(gui, controller.object, controller.property, {\n          before: controller.__li.nextElementSibling,\n          factoryArgs: [controller.__min, controller.__max, controller.__step]\n        });\n        newController.name(oldName);\n        if (wasListening) newController.listen();\n        return newController;\n      }\n      return returned;\n    };\n    controller.min = Common.compose(r, controller.min);\n    controller.max = Common.compose(r, controller.max);\n  } else if (controller instanceof BooleanController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__checkbox, 'click');\n    });\n    dom.bind(controller.__checkbox, 'click', function (e) {\n      e.stopPropagation();\n    });\n  } else if (controller instanceof FunctionController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__button, 'click');\n    });\n    dom.bind(li, 'mouseover', function () {\n      dom.addClass(controller.__button, 'hover');\n    });\n    dom.bind(li, 'mouseout', function () {\n      dom.removeClass(controller.__button, 'hover');\n    });\n  } else if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n    controller.updateDisplay = Common.compose(function (val) {\n      li.style.borderLeftColor = controller.__color.toString();\n      return val;\n    }, controller.updateDisplay);\n    controller.updateDisplay();\n  }\n  controller.setValue = Common.compose(function (val) {\n    if (gui.getRoot().__preset_select && controller.isModified()) {\n      markPresetModified(gui.getRoot(), true);\n    }\n    return val;\n  }, controller.setValue);\n}\nfunction recallSavedValue(gui, controller) {\n  var root = gui.getRoot();\n  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);\n  if (matchedIndex !== -1) {\n    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];\n    if (controllerMap === undefined) {\n      controllerMap = {};\n      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;\n    }\n    controllerMap[controller.property] = controller;\n    if (root.load && root.load.remembered) {\n      var presetMap = root.load.remembered;\n      var preset = void 0;\n      if (presetMap[gui.preset]) {\n        preset = presetMap[gui.preset];\n      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {\n        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];\n      } else {\n        return;\n      }\n      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {\n        var value = preset[matchedIndex][controller.property];\n        controller.initialValue = value;\n        controller.setValue(value);\n      }\n    }\n  }\n}\nfunction _add(gui, object, property, params) {\n  if (object[property] === undefined) {\n    throw new Error('Object \"' + object + '\" has no property \"' + property + '\"');\n  }\n  var controller = void 0;\n  if (params.color) {\n    controller = new ColorController(object, property);\n  } else {\n    var factoryArgs = [object, property].concat(params.factoryArgs);\n    controller = ControllerFactory.apply(gui, factoryArgs);\n  }\n  if (params.before instanceof Controller) {\n    params.before = params.before.__li;\n  }\n  recallSavedValue(gui, controller);\n  dom.addClass(controller.domElement, 'c');\n  var name = document.createElement('span');\n  dom.addClass(name, 'property-name');\n  name.innerHTML = controller.property;\n  var container = document.createElement('div');\n  container.appendChild(name);\n  container.appendChild(controller.domElement);\n  var li = addRow(gui, container, params.before);\n  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n  if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n  } else {\n    dom.addClass(li, _typeof(controller.getValue()));\n  }\n  augmentController(gui, li, controller);\n  gui.__controllers.push(controller);\n  return controller;\n}\nfunction getLocalStorageHash(gui, key) {\n  return document.location.href + '.' + key;\n}\nfunction addPresetOption(gui, name, setSelected) {\n  var opt = document.createElement('option');\n  opt.innerHTML = name;\n  opt.value = name;\n  gui.__preset_select.appendChild(opt);\n  if (setSelected) {\n    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n  }\n}\nfunction showHideExplain(gui, explain) {\n  explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n}\nfunction addSaveMenu(gui) {\n  var div = gui.__save_row = document.createElement('li');\n  dom.addClass(gui.domElement, 'has-save');\n  gui.__ul.insertBefore(div, gui.__ul.firstChild);\n  dom.addClass(div, 'save-row');\n  var gears = document.createElement('span');\n  gears.innerHTML = '&nbsp;';\n  dom.addClass(gears, 'button gears');\n  var button = document.createElement('span');\n  button.innerHTML = 'Save';\n  dom.addClass(button, 'button');\n  dom.addClass(button, 'save');\n  var button2 = document.createElement('span');\n  button2.innerHTML = 'New';\n  dom.addClass(button2, 'button');\n  dom.addClass(button2, 'save-as');\n  var button3 = document.createElement('span');\n  button3.innerHTML = 'Revert';\n  dom.addClass(button3, 'button');\n  dom.addClass(button3, 'revert');\n  var select = gui.__preset_select = document.createElement('select');\n  if (gui.load && gui.load.remembered) {\n    Common.each(gui.load.remembered, function (value, key) {\n      addPresetOption(gui, key, key === gui.preset);\n    });\n  } else {\n    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n  }\n  dom.bind(select, 'change', function () {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n    }\n    gui.preset = this.value;\n  });\n  div.appendChild(select);\n  div.appendChild(gears);\n  div.appendChild(button);\n  div.appendChild(button2);\n  div.appendChild(button3);\n  if (SUPPORTS_LOCAL_STORAGE) {\n    var explain = document.getElementById('dg-local-explain');\n    var localStorageCheckBox = document.getElementById('dg-local-storage');\n    var saveLocally = document.getElementById('dg-save-locally');\n    saveLocally.style.display = 'block';\n    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n      localStorageCheckBox.setAttribute('checked', 'checked');\n    }\n    showHideExplain(gui, explain);\n    dom.bind(localStorageCheckBox, 'change', function () {\n      gui.useLocalStorage = !gui.useLocalStorage;\n      showHideExplain(gui, explain);\n    });\n  }\n  var newConstructorTextArea = document.getElementById('dg-new-constructor');\n  dom.bind(newConstructorTextArea, 'keydown', function (e) {\n    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {\n      SAVE_DIALOGUE.hide();\n    }\n  });\n  dom.bind(gears, 'click', function () {\n    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n    SAVE_DIALOGUE.show();\n    newConstructorTextArea.focus();\n    newConstructorTextArea.select();\n  });\n  dom.bind(button, 'click', function () {\n    gui.save();\n  });\n  dom.bind(button2, 'click', function () {\n    var presetName = prompt('Enter a new preset name.');\n    if (presetName) {\n      gui.saveAs(presetName);\n    }\n  });\n  dom.bind(button3, 'click', function () {\n    gui.revert();\n  });\n}\nfunction addResizeHandle(gui) {\n  var pmouseX = void 0;\n  gui.__resize_handle = document.createElement('div');\n  Common.extend(gui.__resize_handle.style, {\n    width: '6px',\n    marginLeft: '-3px',\n    height: '200px',\n    cursor: 'ew-resize',\n    position: 'absolute'\n  });\n  function drag(e) {\n    e.preventDefault();\n    gui.width += pmouseX - e.clientX;\n    gui.onResize();\n    pmouseX = e.clientX;\n    return false;\n  }\n  function dragStop() {\n    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.unbind(window, 'mousemove', drag);\n    dom.unbind(window, 'mouseup', dragStop);\n  }\n  function dragStart(e) {\n    e.preventDefault();\n    pmouseX = e.clientX;\n    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.bind(window, 'mousemove', drag);\n    dom.bind(window, 'mouseup', dragStop);\n    return false;\n  }\n  dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n  dom.bind(gui.__closeButton, 'mousedown', dragStart);\n  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n}\nfunction setWidth(gui, w) {\n  gui.domElement.style.width = w + 'px';\n  if (gui.__save_row && gui.autoPlace) {\n    gui.__save_row.style.width = w + 'px';\n  }\n  if (gui.__closeButton) {\n    gui.__closeButton.style.width = w + 'px';\n  }\n}\nfunction getCurrentPreset(gui, useInitialValues) {\n  var toReturn = {};\n  Common.each(gui.__rememberedObjects, function (val, index) {\n    var savedValues = {};\n    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];\n    Common.each(controllerMap, function (controller, property) {\n      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();\n    });\n    toReturn[index] = savedValues;\n  });\n  return toReturn;\n}\nfunction setPresetSelectIndex(gui) {\n  for (var index = 0; index < gui.__preset_select.length; index++) {\n    if (gui.__preset_select[index].value === gui.preset) {\n      gui.__preset_select.selectedIndex = index;\n    }\n  }\n}\nfunction updateDisplays(controllerArray) {\n  if (controllerArray.length !== 0) {\n    requestAnimationFrame$1.call(window, function () {\n      updateDisplays(controllerArray);\n    });\n  }\n  Common.each(controllerArray, function (c) {\n    c.updateDisplay();\n  });\n}\n\nvar color = {\n  Color: Color,\n  math: ColorMath,\n  interpret: interpret\n};\nvar controllers = {\n  Controller: Controller,\n  BooleanController: BooleanController,\n  OptionController: OptionController,\n  StringController: StringController,\n  NumberController: NumberController,\n  NumberControllerBox: NumberControllerBox,\n  NumberControllerSlider: NumberControllerSlider,\n  FunctionController: FunctionController,\n  ColorController: ColorController\n};\nvar dom$1 = { dom: dom };\nvar gui = { GUI: GUI };\nvar GUI$1 = GUI;\nvar index = {\n  color: color,\n  controllers: controllers,\n  dom: dom$1,\n  gui: gui,\n  GUI: GUI$1\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceMappingURL=dat.gui.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLm1vZHVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lc2FuZGJveC8uL25vZGVfbW9kdWxlcy9kYXQuZ3VpL2J1aWxkL2RhdC5ndWkubW9kdWxlLmpzPzg5OTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF0YWFydHMvZGF0Lmd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc0FycmF5LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQl9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JBX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzT2JqZWN0LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV07XG52YXIgcmVzdWx0ID0gdm9pZCAwO1xudmFyIHRvUmV0dXJuID0gdm9pZCAwO1xudmFyIGludGVycHJldCA9IGZ1bmN0aW9uIGludGVycHJldCgpIHtcbiAgdG9SZXR1cm4gPSBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBDb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICBDb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcbiAgICAgIENvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufTtcblxudmFyIHRtcENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBDb2xvck1hdGggPSB7XG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xuICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG4gICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgIHZhciBxID0gdiAqICgxLjAgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICBiOiBjWzJdICogMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hzdjogZnVuY3Rpb24gcmdiX3RvX2hzdihyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSB2b2lkIDA7XG4gICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgaWYgKG1heCAhPT0gMCkge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBOYU4sXG4gICAgICAgIHM6IDAsXG4gICAgICAgIHY6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAvPSA2O1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCAqIDM2MCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiBtYXggLyAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcbiAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgIHJldHVybiBoZXg7XG4gIH0sXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG4gIH0sXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgaGV4ICYgfigweEZGIDw8IHRtcENvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yKTtcbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3IsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSGV4U3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09yaWdpbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcmlnaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yO1xufSgpO1xuZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuQ29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG4gICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gQ29sb3JNYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3JydXB0ZWQgY29sb3Igc3RhdGUnKTtcbiAgfVxufTtcbkNvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCB7XG4gICAgczogcmVzdWx0LnMsXG4gICAgdjogcmVzdWx0LnZcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICB9IGVsc2UgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgfVxufTtcbkNvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCAnZycsICdiJywgJ2gnLCAncycsICd2JywgJ2hleCcsICdhJ107XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gQ29sb3JNYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcbiAgfVxufSk7XG5cbnZhciBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbmlzaENoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTW9kaWZpZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250cm9sbGVyO1xufSgpO1xuXG52YXIgRVZFTlRfTUFQID0ge1xuICBIVE1MRXZlbnRzOiBbJ2NoYW5nZSddLFxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxufTtcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XG5Db21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uICh2LCBrKSB7XG4gIENvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uIChlKSB7XG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gIH0pO1xufSk7XG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJzAnIHx8IENvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGRvbSA9IHtcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcbiAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgfSxcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xuICAgIHZhciB2ZXJ0aWNhbCA9IHZlcnQ7XG4gICAgdmFyIGhvcml6b250YWwgPSBob3I7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xuICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cbiAgfSxcbiAgZmFrZUV2ZW50OiBmdW5jdGlvbiBmYWtlRXZlbnQoZWxlbSwgZXZlbnRUeXBlLCBwYXJzLCBhdXgpIHtcbiAgICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7XG4gICAgICAgICAgQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9LFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS5oZWlnaHQpO1xuICB9LFxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuICB9XG59O1xuXG52YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEJvb2xlYW5Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhPcHRpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcHRpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cbiAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gIHZhciBfeCA9IHgudG9TdHJpbmcoKTtcbiAgaWYgKF94LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBfdGhpcy5fX21pbiA9IF9wYXJhbXMubWluO1xuICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxWYWx1ZSA9PT0gMCkge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhfdGhpcy5pbml0aWFsVmFsdWUpKSAvIE1hdGguTE4xMCkpIC8gMTA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBfdGhpcy5fX3N0ZXA7XG4gICAgfVxuICAgIF90aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgX3YgPSB2O1xuICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiBfdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgX3YgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21heDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIF92ICUgdGhpcy5fX3N0ZXAgIT09IDApIHtcbiAgICAgICAgX3YgPSBNYXRoLnJvdW5kKF92IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIF92KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4obWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21heCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChtYXhWYWx1ZSkge1xuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoc3RlcFZhbHVlKSB7XG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhzdGVwVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG59XG52YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyQm94LCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlckJveCk7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJCb3guX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94KSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpKTtcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFDb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkge1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJCb3gsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xufShOdW1iZXJDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgb25Ub3VjaE1vdmUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKSAvICh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCAqIDEwMCArICclJztcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZ1bmN0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhGdW5jdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICBfdGhpczIuX19jb2xvciA9IG5ldyBDb2xvcihfdGhpczIuZ2V0VmFsdWUoKSk7XG4gICAgX3RoaXMyLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcbiAgICBfdGhpczIuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xuXG5jc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xudmFyIEhJREVfS0VZX0NPREUgPSA3MjtcbnZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xudmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIFNBVkVfRElBTE9HVUUgPSB2b2lkIDA7XG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcbnZhciBhdXRvUGxhY2VDb250YWluZXIgPSB2b2lkIDA7XG52YXIgaGlkZSA9IGZhbHNlO1xudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xudmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG4gIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgY2xvc2VPblRvcDogZmFsc2UsXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICB9KTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG4gICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuICB9XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XG4gIH1cbiAgcGFyYW1zLnJlc2l6YWJsZSA9IENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICB9XG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcbiAgdmFyIHNhdmVUb0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbiAgdmFyIHRpdGxlUm93ID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuICB7XG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b1BsYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZU9uVG9wOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZU9uVG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2V0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICBpZiAodGl0bGVSb3cpIHtcbiAgICAgICAgICB0aXRsZVJvdy5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShib29sKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgaWYgKHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG4gICAgICAgIGlmIChzYXZlZEd1aSkge1xuICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9UT1ApO1xuICAgICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sIHRoaXMuZG9tRWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcbiAgICB9XG4gICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGl0bGVSb3dOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcbiAgICB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVSb3dOYW1lKTtcbiAgICB2YXIgb25DbGlja1RpdGxlID0gZnVuY3Rpb24gb25DbGlja1RpdGxlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3csICd0aXRsZScpO1xuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xuICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgICBpZiAoYXV0b1BsYWNlVmlyZ2luKSB7XG4gICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvUGxhY2VDb250YWluZXIpO1xuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub25SZXNpemVEZWJvdW5jZWQoKTtcbiAgfTtcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgfVxuICBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcbiAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICByb290LndpZHRoICs9IDE7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICByZXNldFdpZHRoKCk7XG4gIH1cbn07XG5HVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaGlkZSA9ICFoaWRlO1xuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/ICdub25lJyA6ICcnO1xuICB9KTtcbn07XG5HVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbkdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbkdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5HVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbkdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbkdVSS5DTEFTU19DTE9TRV9UT1AgPSAnY2xvc2UtdG9wJztcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcbkdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcbkdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xuICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gIH1cbn07XG5kb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuQ29tbW9uLmV4dGVuZChHVUkucHJvdG90eXBlLFxue1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIF90aGlzLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcnModGhpcyk7XG4gIH0sXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgKyAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cbiAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcbiAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHtcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG4gICAgICBuZXdHdWlQYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGZvbGRlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLl9fZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoZm9sZGVyKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKGZvbGRlci5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcbiAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgdmFyIGggPSAwO1xuICAgICAgQ29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpIHtcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgfVxuICB9LFxuICBvblJlc2l6ZURlYm91bmNlZDogQ29tbW9uLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH0sIDUwKSxcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKCkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9nQ29udGVudHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICB9XG4gIH0sXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XG4gICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG4gICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgfVxuICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIH1cbiAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgfSxcbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChndWkpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgIH0pO1xuICAgIGlmICghZ3VpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcbiAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaWYgKG5ld0RvbSkge1xuICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG4gIH1cbiAgaWYgKGxpQmVmb3JlKSB7XG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBsaUJlZm9yZSk7XG4gIH0gZWxzZSB7XG4gICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICB9XG4gIGd1aS5vblJlc2l6ZSgpO1xuICByZXR1cm4gbGk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XG4gIGRvbS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ3VpLl9fcmVzaXplSGFuZGxlcik7XG4gIGlmIChndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICBpZiAobW9kaWZpZWQpIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xuICB9IGVsc2Uge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG4gIENvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0IHsgY29sb3IsIGNvbnRyb2xsZXJzLCBkb20kMSBhcyBkb20sIGd1aSwgR1VJJDEgYXMgR1VJIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdC5ndWkubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/dat.gui/build/dat.gui.module.js\n");

/***/ }),

/***/ "./node_modules/pixi-spine/dist/pixi-spine.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi-spine/dist/pixi-spine.js ***!
  \****************************************************/
/***/ (function() {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Animation = (function () {\r\n            function Animation(name, timelines, duration) {\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                if (timelines == null)\r\n                    throw new Error(\"timelines cannot be null.\");\r\n                this.name = name;\r\n                this.timelines = timelines;\r\n                this.timelineIds = [];\r\n                for (var i = 0; i < timelines.length; i++)\r\n                    this.timelineIds[timelines[i].getPropertyId()] = true;\r\n                this.duration = duration;\r\n            }\r\n            Animation.prototype.hasTimeline = function (id) {\r\n                return this.timelineIds[id] == true;\r\n            };\r\n            Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                if (loop && this.duration != 0) {\r\n                    time %= this.duration;\r\n                    if (lastTime > 0)\r\n                        lastTime %= this.duration;\r\n                }\r\n                var timelines = this.timelines;\r\n                for (var i = 0, n = timelines.length; i < n; i++)\r\n                    timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n            };\r\n            Animation.binarySearch = function (values, target, step) {\r\n                if (step === void 0) { step = 1; }\r\n                var low = 0;\r\n                var high = values.length / step - 2;\r\n                if (high == 0)\r\n                    return step;\r\n                var current = high >>> 1;\r\n                while (true) {\r\n                    if (values[(current + 1) * step] <= target)\r\n                        low = current + 1;\r\n                    else\r\n                        high = current;\r\n                    if (low == high)\r\n                        return (low + 1) * step;\r\n                    current = (low + high) >>> 1;\r\n                }\r\n            };\r\n            Animation.linearSearch = function (values, target, step) {\r\n                for (var i = 0, last = values.length - step; i <= last; i += step)\r\n                    if (values[i] > target)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            return Animation;\r\n        }());\r\n        core.Animation = Animation;\r\n        var MixBlend;\r\n        (function (MixBlend) {\r\n            MixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\r\n            MixBlend[MixBlend[\"first\"] = 1] = \"first\";\r\n            MixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\r\n            MixBlend[MixBlend[\"add\"] = 3] = \"add\";\r\n        })(MixBlend = core.MixBlend || (core.MixBlend = {}));\r\n        var MixDirection;\r\n        (function (MixDirection) {\r\n            MixDirection[MixDirection[\"mixIn\"] = 0] = \"mixIn\";\r\n            MixDirection[MixDirection[\"mixOut\"] = 1] = \"mixOut\";\r\n        })(MixDirection = core.MixDirection || (core.MixDirection = {}));\r\n        var TimelineType;\r\n        (function (TimelineType) {\r\n            TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n            TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n            TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n            TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n            TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n            TimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n            TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n            TimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n            TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n            TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n            TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n            TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n            TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n            TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n            TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n        })(TimelineType = core.TimelineType || (core.TimelineType = {}));\r\n        var CurveTimeline = (function () {\r\n            function CurveTimeline(frameCount) {\r\n                if (frameCount <= 0)\r\n                    throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n            }\r\n            CurveTimeline.prototype.getFrameCount = function () {\r\n                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n            };\r\n            CurveTimeline.prototype.setLinear = function (frameIndex) {\r\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n            };\r\n            CurveTimeline.prototype.setStepped = function (frameIndex) {\r\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n            };\r\n            CurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n                var index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                if (index == this.curves.length)\r\n                    return CurveTimeline.LINEAR;\r\n                var type = this.curves[index];\r\n                if (type == CurveTimeline.LINEAR)\r\n                    return CurveTimeline.LINEAR;\r\n                if (type == CurveTimeline.STEPPED)\r\n                    return CurveTimeline.STEPPED;\r\n                return CurveTimeline.BEZIER;\r\n            };\r\n            CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n                var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n                var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                var curves = this.curves;\r\n                curves[i++] = CurveTimeline.BEZIER;\r\n                var x = dfx, y = dfy;\r\n                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                    curves[i] = x;\r\n                    curves[i + 1] = y;\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    x += dfx;\r\n                    y += dfy;\r\n                }\r\n            };\r\n            CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n                percent = core.MathUtils.clamp(percent, 0, 1);\r\n                var curves = this.curves;\r\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n                var type = curves[i];\r\n                if (type == CurveTimeline.LINEAR)\r\n                    return percent;\r\n                if (type == CurveTimeline.STEPPED)\r\n                    return 0;\r\n                i++;\r\n                var x = 0;\r\n                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                    x = curves[i];\r\n                    if (x >= percent) {\r\n                        var prevX = void 0, prevY = void 0;\r\n                        if (i == start) {\r\n                            prevX = 0;\r\n                            prevY = 0;\r\n                        }\r\n                        else {\r\n                            prevX = curves[i - 2];\r\n                            prevY = curves[i - 1];\r\n                        }\r\n                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n                    }\r\n                }\r\n                var y = curves[i - 1];\r\n                return y + (1 - y) * (percent - x) / (1 - x);\r\n            };\r\n            CurveTimeline.LINEAR = 0;\r\n            CurveTimeline.STEPPED = 1;\r\n            CurveTimeline.BEZIER = 2;\r\n            CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n            return CurveTimeline;\r\n        }());\r\n        core.CurveTimeline = CurveTimeline;\r\n        var RotateTimeline = (function (_super) {\r\n            __extends(RotateTimeline, _super);\r\n            function RotateTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount << 1);\r\n                return _this;\r\n            }\r\n            RotateTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.rotate << 24) + this.boneIndex;\r\n            };\r\n            RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n                frameIndex <<= 1;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n            };\r\n            RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var r_1 = bone.data.rotation - bone.rotation;\r\n                            bone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n                    var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation + r_2 * alpha;\r\n                            break;\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            r_2 += bone.data.rotation - bone.rotation;\r\n                            r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n                        case MixBlend.add:\r\n                            bone.rotation += r_2 * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n                r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        r += bone.data.rotation - bone.rotation;\r\n                    case MixBlend.add:\r\n                        bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                }\r\n            };\r\n            RotateTimeline.ENTRIES = 2;\r\n            RotateTimeline.PREV_TIME = -2;\r\n            RotateTimeline.PREV_ROTATION = -1;\r\n            RotateTimeline.ROTATION = 1;\r\n            return RotateTimeline;\r\n        }(CurveTimeline));\r\n        core.RotateTimeline = RotateTimeline;\r\n        var TranslateTimeline = (function (_super) {\r\n            __extends(TranslateTimeline, _super);\r\n            function TranslateTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TranslateTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.translate << 24) + this.boneIndex;\r\n            };\r\n            TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n                frameIndex *= TranslateTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TranslateTimeline.X] = x;\r\n                this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n            };\r\n            TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.x = bone.data.x;\r\n                            bone.y = bone.data.y;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.x += (bone.data.x - bone.x) * alpha;\r\n                            bone.y += (bone.data.y - bone.y) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + TranslateTimeline.PREV_X];\r\n                    y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n                    x = frames[frame + TranslateTimeline.PREV_X];\r\n                    y = frames[frame + TranslateTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n                    x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n                }\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.x = bone.data.x + x * alpha;\r\n                        bone.y = bone.data.y + y * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                        bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.x += x * alpha;\r\n                        bone.y += y * alpha;\r\n                }\r\n            };\r\n            TranslateTimeline.ENTRIES = 3;\r\n            TranslateTimeline.PREV_TIME = -3;\r\n            TranslateTimeline.PREV_X = -2;\r\n            TranslateTimeline.PREV_Y = -1;\r\n            TranslateTimeline.X = 1;\r\n            TranslateTimeline.Y = 2;\r\n            return TranslateTimeline;\r\n        }(CurveTimeline));\r\n        core.TranslateTimeline = TranslateTimeline;\r\n        var ScaleTimeline = (function (_super) {\r\n            __extends(ScaleTimeline, _super);\r\n            function ScaleTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            ScaleTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.scale << 24) + this.boneIndex;\r\n            };\r\n            ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.scaleX = bone.data.scaleX;\r\n                            bone.scaleY = bone.data.scaleY;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n                    x = frames[frame + ScaleTimeline.PREV_X];\r\n                    y = frames[frame + ScaleTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n                }\r\n                if (alpha == 1) {\r\n                    if (blend == MixBlend.add) {\r\n                        bone.scaleX += x - bone.data.scaleX;\r\n                        bone.scaleY += y - bone.data.scaleY;\r\n                    }\r\n                    else {\r\n                        bone.scaleX = x;\r\n                        bone.scaleY = y;\r\n                    }\r\n                }\r\n                else {\r\n                    var bx = 0, by = 0;\r\n                    if (direction == MixDirection.mixOut) {\r\n                        switch (blend) {\r\n                            case MixBlend.setup:\r\n                                bx = bone.data.scaleX;\r\n                                by = bone.data.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\r\n                                break;\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                bx = bone.scaleX;\r\n                                by = bone.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                bx = bone.scaleX;\r\n                                by = bone.scaleY;\r\n                                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (blend) {\r\n                            case MixBlend.setup:\r\n                                bx = Math.abs(bone.data.scaleX) * core.MathUtils.signum(x);\r\n                                by = Math.abs(bone.data.scaleY) * core.MathUtils.signum(y);\r\n                                bone.scaleX = bx + (x - bx) * alpha;\r\n                                bone.scaleY = by + (y - by) * alpha;\r\n                                break;\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                bx = Math.abs(bone.scaleX) * core.MathUtils.signum(x);\r\n                                by = Math.abs(bone.scaleY) * core.MathUtils.signum(y);\r\n                                bone.scaleX = bx + (x - bx) * alpha;\r\n                                bone.scaleY = by + (y - by) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                bx = core.MathUtils.signum(x);\r\n                                by = core.MathUtils.signum(y);\r\n                                bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                                bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            return ScaleTimeline;\r\n        }(TranslateTimeline));\r\n        core.ScaleTimeline = ScaleTimeline;\r\n        var ShearTimeline = (function (_super) {\r\n            __extends(ShearTimeline, _super);\r\n            function ShearTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            ShearTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.shear << 24) + this.boneIndex;\r\n            };\r\n            ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var bone = skeleton.bones[this.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bone.shearX = bone.data.shearX;\r\n                            bone.shearY = bone.data.shearY;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var x = 0, y = 0;\r\n                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n                    x = frames[frames.length + ShearTimeline.PREV_X];\r\n                    y = frames[frames.length + ShearTimeline.PREV_Y];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n                    x = frames[frame + ShearTimeline.PREV_X];\r\n                    y = frames[frame + ShearTimeline.PREV_Y];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n                }\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.shearX = bone.data.shearX + x * alpha;\r\n                        bone.shearY = bone.data.shearY + y * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.shearX += x * alpha;\r\n                        bone.shearY += y * alpha;\r\n                }\r\n            };\r\n            return ShearTimeline;\r\n        }(TranslateTimeline));\r\n        core.ShearTimeline = ShearTimeline;\r\n        var ColorTimeline = (function (_super) {\r\n            __extends(ColorTimeline, _super);\r\n            function ColorTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            ColorTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.color << 24) + this.slotIndex;\r\n            };\r\n            ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n                frameIndex *= ColorTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + ColorTimeline.R] = r;\r\n                this.frames[frameIndex + ColorTimeline.G] = g;\r\n                this.frames[frameIndex + ColorTimeline.B] = b;\r\n                this.frames[frameIndex + ColorTimeline.A] = a;\r\n            };\r\n            ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            slot.color.setFromColor(slot.data.color);\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var color = slot.color, setup = slot.data.color;\r\n                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n                    }\r\n                    return;\r\n                }\r\n                var r = 0, g = 0, b = 0, a = 0;\r\n                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    r = frames[i + ColorTimeline.PREV_R];\r\n                    g = frames[i + ColorTimeline.PREV_G];\r\n                    b = frames[i + ColorTimeline.PREV_B];\r\n                    a = frames[i + ColorTimeline.PREV_A];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n                    r = frames[frame + ColorTimeline.PREV_R];\r\n                    g = frames[frame + ColorTimeline.PREV_G];\r\n                    b = frames[frame + ColorTimeline.PREV_B];\r\n                    a = frames[frame + ColorTimeline.PREV_A];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n                    r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n                    g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n                    b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n                    a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n                }\r\n                if (alpha == 1)\r\n                    slot.color.set(r, g, b, a);\r\n                else {\r\n                    var color = slot.color;\r\n                    if (blend == MixBlend.setup)\r\n                        color.setFromColor(slot.data.color);\r\n                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n                }\r\n            };\r\n            ColorTimeline.ENTRIES = 5;\r\n            ColorTimeline.PREV_TIME = -5;\r\n            ColorTimeline.PREV_R = -4;\r\n            ColorTimeline.PREV_G = -3;\r\n            ColorTimeline.PREV_B = -2;\r\n            ColorTimeline.PREV_A = -1;\r\n            ColorTimeline.R = 1;\r\n            ColorTimeline.G = 2;\r\n            ColorTimeline.B = 3;\r\n            ColorTimeline.A = 4;\r\n            return ColorTimeline;\r\n        }(CurveTimeline));\r\n        core.ColorTimeline = ColorTimeline;\r\n        var TwoColorTimeline = (function (_super) {\r\n            __extends(TwoColorTimeline, _super);\r\n            function TwoColorTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TwoColorTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.twoColor << 24) + this.slotIndex;\r\n            };\r\n            TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n                frameIndex *= TwoColorTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n                this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n                this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n                this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n                this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n                this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n                this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n            };\r\n            TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            slot.color.setFromColor(slot.data.color);\r\n                            slot.darkColor.setFromColor(slot.data.darkColor);\r\n                            return;\r\n                        case MixBlend.first:\r\n                            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n                    }\r\n                    return;\r\n                }\r\n                var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    r = frames[i + TwoColorTimeline.PREV_R];\r\n                    g = frames[i + TwoColorTimeline.PREV_G];\r\n                    b = frames[i + TwoColorTimeline.PREV_B];\r\n                    a = frames[i + TwoColorTimeline.PREV_A];\r\n                    r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n                    g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n                    b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n                    r = frames[frame + TwoColorTimeline.PREV_R];\r\n                    g = frames[frame + TwoColorTimeline.PREV_G];\r\n                    b = frames[frame + TwoColorTimeline.PREV_B];\r\n                    a = frames[frame + TwoColorTimeline.PREV_A];\r\n                    r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n                    g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n                    b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n                }\r\n                if (alpha == 1) {\r\n                    slot.color.set(r, g, b, a);\r\n                    slot.darkColor.set(r2, g2, b2, 1);\r\n                }\r\n                else {\r\n                    var light = slot.color, dark = slot.darkColor;\r\n                    if (blend == MixBlend.setup) {\r\n                        light.setFromColor(slot.data.color);\r\n                        dark.setFromColor(slot.data.darkColor);\r\n                    }\r\n                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n                }\r\n            };\r\n            TwoColorTimeline.ENTRIES = 8;\r\n            TwoColorTimeline.PREV_TIME = -8;\r\n            TwoColorTimeline.PREV_R = -7;\r\n            TwoColorTimeline.PREV_G = -6;\r\n            TwoColorTimeline.PREV_B = -5;\r\n            TwoColorTimeline.PREV_A = -4;\r\n            TwoColorTimeline.PREV_R2 = -3;\r\n            TwoColorTimeline.PREV_G2 = -2;\r\n            TwoColorTimeline.PREV_B2 = -1;\r\n            TwoColorTimeline.R = 1;\r\n            TwoColorTimeline.G = 2;\r\n            TwoColorTimeline.B = 3;\r\n            TwoColorTimeline.A = 4;\r\n            TwoColorTimeline.R2 = 5;\r\n            TwoColorTimeline.G2 = 6;\r\n            TwoColorTimeline.B2 = 7;\r\n            return TwoColorTimeline;\r\n        }(CurveTimeline));\r\n        core.TwoColorTimeline = TwoColorTimeline;\r\n        var AttachmentTimeline = (function () {\r\n            function AttachmentTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.attachmentNames = new Array(frameCount);\r\n            }\r\n            AttachmentTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.attachment << 24) + this.slotIndex;\r\n            };\r\n            AttachmentTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n                this.frames[frameIndex] = time;\r\n                this.attachmentNames[frameIndex] = attachmentName;\r\n            };\r\n            AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                if (direction == MixDirection.mixOut) {\r\n                    if (blend == MixBlend.setup)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n                    return;\r\n                }\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n                    return;\r\n                }\r\n                var frameIndex = 0;\r\n                if (time >= frames[frames.length - 1])\r\n                    frameIndex = frames.length - 1;\r\n                else\r\n                    frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n                var attachmentName = this.attachmentNames[frameIndex];\r\n                skeleton.slots[this.slotIndex]\r\n                    .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n            };\r\n            AttachmentTimeline.prototype.setAttachment = function (skeleton, slot, attachmentName) {\r\n                slot.attachment = attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName);\r\n            };\r\n            return AttachmentTimeline;\r\n        }());\r\n        core.AttachmentTimeline = AttachmentTimeline;\r\n        var zeros = null;\r\n        var DeformTimeline = (function (_super) {\r\n            __extends(DeformTimeline, _super);\r\n            function DeformTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount);\r\n                _this.frameVertices = new Array(frameCount);\r\n                if (zeros == null)\r\n                    zeros = core.Utils.newFloatArray(64);\r\n                return _this;\r\n            }\r\n            DeformTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n            };\r\n            DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n                this.frames[frameIndex] = time;\r\n                this.frameVertices[frameIndex] = vertices;\r\n            };\r\n            DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var slot = skeleton.slots[this.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var slotAttachment = slot.getAttachment();\r\n                if (!(slotAttachment instanceof core.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\r\n                    return;\r\n                var deformArray = slot.deform;\r\n                if (deformArray.length == 0)\r\n                    blend = MixBlend.setup;\r\n                var frameVertices = this.frameVertices;\r\n                var vertexCount = frameVertices[0].length;\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    var vertexAttachment = slotAttachment;\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            deformArray.length = 0;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            if (alpha == 1) {\r\n                                deformArray.length = 0;\r\n                                break;\r\n                            }\r\n                            var deform_1 = core.Utils.setArraySize(deformArray, vertexCount);\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i = 0; i < vertexCount; i++)\r\n                                    deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;\r\n                            }\r\n                            else {\r\n                                alpha = 1 - alpha;\r\n                                for (var i = 0; i < vertexCount; i++)\r\n                                    deform_1[i] *= alpha;\r\n                            }\r\n                    }\r\n                    return;\r\n                }\r\n                var deform = core.Utils.setArraySize(deformArray, vertexCount);\r\n                if (time >= frames[frames.length - 1]) {\r\n                    var lastVertices = frameVertices[frames.length - 1];\r\n                    if (alpha == 1) {\r\n                        if (blend == MixBlend.add) {\r\n                            var vertexAttachment = slotAttachment;\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n                                    deform[i_1] += lastVertices[i_1] - setupVertices[i_1];\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n                                    deform[i_2] += lastVertices[i_2];\r\n                            }\r\n                        }\r\n                        else {\r\n                            core.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                        }\r\n                    }\r\n                    else {\r\n                        switch (blend) {\r\n                            case MixBlend.setup: {\r\n                                var vertexAttachment_1 = slotAttachment;\r\n                                if (vertexAttachment_1.bones == null) {\r\n                                    var setupVertices = vertexAttachment_1.vertices;\r\n                                    for (var i_3 = 0; i_3 < vertexCount; i_3++) {\r\n                                        var setup = setupVertices[i_3];\r\n                                        deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var i_4 = 0; i_4 < vertexCount; i_4++)\r\n                                        deform[i_4] = lastVertices[i_4] * alpha;\r\n                                }\r\n                                break;\r\n                            }\r\n                            case MixBlend.first:\r\n                            case MixBlend.replace:\r\n                                for (var i_5 = 0; i_5 < vertexCount; i_5++)\r\n                                    deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;\r\n                                break;\r\n                            case MixBlend.add:\r\n                                var vertexAttachment = slotAttachment;\r\n                                if (vertexAttachment.bones == null) {\r\n                                    var setupVertices = vertexAttachment.vertices;\r\n                                    for (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n                                        deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var i_7 = 0; i_7 < vertexCount; i_7++)\r\n                                        deform[i_7] += lastVertices[i_7] * alpha;\r\n                                }\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time);\r\n                var prevVertices = frameVertices[frame - 1];\r\n                var nextVertices = frameVertices[frame];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n                if (alpha == 1) {\r\n                    if (blend == MixBlend.add) {\r\n                        var vertexAttachment = slotAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            var setupVertices = vertexAttachment.vertices;\r\n                            for (var i_8 = 0; i_8 < vertexCount; i_8++) {\r\n                                var prev = prevVertices[i_8];\r\n                                deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i_9 = 0; i_9 < vertexCount; i_9++) {\r\n                                var prev = prevVertices[i_9];\r\n                                deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i_10 = 0; i_10 < vertexCount; i_10++) {\r\n                            var prev = prevVertices[i_10];\r\n                            deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    switch (blend) {\r\n                        case MixBlend.setup: {\r\n                            var vertexAttachment_2 = slotAttachment;\r\n                            if (vertexAttachment_2.bones == null) {\r\n                                var setupVertices = vertexAttachment_2.vertices;\r\n                                for (var i_11 = 0; i_11 < vertexCount; i_11++) {\r\n                                    var prev = prevVertices[i_11], setup = setupVertices[i_11];\r\n                                    deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_12 = 0; i_12 < vertexCount; i_12++) {\r\n                                    var prev = prevVertices[i_12];\r\n                                    deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            for (var i_13 = 0; i_13 < vertexCount; i_13++) {\r\n                                var prev = prevVertices[i_13];\r\n                                deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;\r\n                            }\r\n                            break;\r\n                        case MixBlend.add:\r\n                            var vertexAttachment = slotAttachment;\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i_14 = 0; i_14 < vertexCount; i_14++) {\r\n                                    var prev = prevVertices[i_14];\r\n                                    deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_15 = 0; i_15 < vertexCount; i_15++) {\r\n                                    var prev = prevVertices[i_15];\r\n                                    deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\r\n                                }\r\n                            }\r\n                    }\r\n                }\r\n            };\r\n            return DeformTimeline;\r\n        }(CurveTimeline));\r\n        core.DeformTimeline = DeformTimeline;\r\n        var EventTimeline = (function () {\r\n            function EventTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.events = new Array(frameCount);\r\n            }\r\n            EventTimeline.prototype.getPropertyId = function () {\r\n                return TimelineType.event << 24;\r\n            };\r\n            EventTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            EventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n                this.frames[frameIndex] = event.time;\r\n                this.events[frameIndex] = event;\r\n            };\r\n            EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                if (firedEvents == null)\r\n                    return;\r\n                var frames = this.frames;\r\n                var frameCount = this.frames.length;\r\n                if (lastTime > time) {\r\n                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n                    lastTime = -1;\r\n                }\r\n                else if (lastTime >= frames[frameCount - 1])\r\n                    return;\r\n                if (time < frames[0])\r\n                    return;\r\n                var frame = 0;\r\n                if (lastTime < frames[0])\r\n                    frame = 0;\r\n                else {\r\n                    frame = Animation.binarySearch(frames, lastTime);\r\n                    var frameTime = frames[frame];\r\n                    while (frame > 0) {\r\n                        if (frames[frame - 1] != frameTime)\r\n                            break;\r\n                        frame--;\r\n                    }\r\n                }\r\n                for (; frame < frameCount && time >= frames[frame]; frame++)\r\n                    firedEvents.push(this.events[frame]);\r\n            };\r\n            return EventTimeline;\r\n        }());\r\n        core.EventTimeline = EventTimeline;\r\n        var DrawOrderTimeline = (function () {\r\n            function DrawOrderTimeline(frameCount) {\r\n                this.frames = core.Utils.newFloatArray(frameCount);\r\n                this.drawOrders = new Array(frameCount);\r\n            }\r\n            DrawOrderTimeline.prototype.getPropertyId = function () {\r\n                return TimelineType.drawOrder << 24;\r\n            };\r\n            DrawOrderTimeline.prototype.getFrameCount = function () {\r\n                return this.frames.length;\r\n            };\r\n            DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n                this.frames[frameIndex] = time;\r\n                this.drawOrders[frameIndex] = drawOrder;\r\n            };\r\n            DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var drawOrder = skeleton.drawOrder;\r\n                var slots = skeleton.slots;\r\n                if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                    return;\r\n                }\r\n                var frames = this.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                        core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                    return;\r\n                }\r\n                var frame = 0;\r\n                if (time >= frames[frames.length - 1])\r\n                    frame = frames.length - 1;\r\n                else\r\n                    frame = Animation.binarySearch(frames, time) - 1;\r\n                var drawOrderToSetupIndex = this.drawOrders[frame];\r\n                if (drawOrderToSetupIndex == null)\r\n                    core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n                else {\r\n                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n                }\r\n            };\r\n            return DrawOrderTimeline;\r\n        }());\r\n        core.DrawOrderTimeline = DrawOrderTimeline;\r\n        var IkConstraintTimeline = (function (_super) {\r\n            __extends(IkConstraintTimeline, _super);\r\n            function IkConstraintTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            IkConstraintTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n            };\r\n            IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {\r\n                frameIndex *= IkConstraintTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n                this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n                this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n                this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n            };\r\n            IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.mix = constraint.data.mix;\r\n                            constraint.softness = constraint.data.softness;\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                    }\r\n                    return;\r\n                }\r\n                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n                    if (blend == MixBlend.setup) {\r\n                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                        constraint.softness = constraint.data.softness\r\n                            + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                        if (direction == MixDirection.mixOut) {\r\n                            constraint.bendDirection = constraint.data.bendDirection;\r\n                            constraint.compress = constraint.data.compress;\r\n                            constraint.stretch = constraint.data.stretch;\r\n                        }\r\n                        else {\r\n                            constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                            constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                            constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                        constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                        if (direction == MixDirection.mixIn) {\r\n                            constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                            constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                            constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n                var softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n                if (blend == MixBlend.setup) {\r\n                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n                    constraint.softness = constraint.data.softness\r\n                        + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n                    if (direction == MixDirection.mixOut) {\r\n                        constraint.bendDirection = constraint.data.bendDirection;\r\n                        constraint.compress = constraint.data.compress;\r\n                        constraint.stretch = constraint.data.stretch;\r\n                    }\r\n                    else {\r\n                        constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n                else {\r\n                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n                    constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n                    if (direction == MixDirection.mixIn) {\r\n                        constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n            };\r\n            IkConstraintTimeline.ENTRIES = 6;\r\n            IkConstraintTimeline.PREV_TIME = -6;\r\n            IkConstraintTimeline.PREV_MIX = -5;\r\n            IkConstraintTimeline.PREV_SOFTNESS = -4;\r\n            IkConstraintTimeline.PREV_BEND_DIRECTION = -3;\r\n            IkConstraintTimeline.PREV_COMPRESS = -2;\r\n            IkConstraintTimeline.PREV_STRETCH = -1;\r\n            IkConstraintTimeline.MIX = 1;\r\n            IkConstraintTimeline.SOFTNESS = 2;\r\n            IkConstraintTimeline.BEND_DIRECTION = 3;\r\n            IkConstraintTimeline.COMPRESS = 4;\r\n            IkConstraintTimeline.STRETCH = 5;\r\n            return IkConstraintTimeline;\r\n        }(CurveTimeline));\r\n        core.IkConstraintTimeline = IkConstraintTimeline;\r\n        var TransformConstraintTimeline = (function (_super) {\r\n            __extends(TransformConstraintTimeline, _super);\r\n            function TransformConstraintTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            TransformConstraintTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n            };\r\n            TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n                frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n            };\r\n            TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    var data = constraint.data;\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.rotateMix = data.rotateMix;\r\n                            constraint.translateMix = data.translateMix;\r\n                            constraint.scaleMix = data.scaleMix;\r\n                            constraint.shearMix = data.shearMix;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var rotate = 0, translate = 0, scale = 0, shear = 0;\r\n                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n                    var i = frames.length;\r\n                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n                }\r\n                if (blend == MixBlend.setup) {\r\n                    var data = constraint.data;\r\n                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n                }\r\n                else {\r\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n                    constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n                }\r\n            };\r\n            TransformConstraintTimeline.ENTRIES = 5;\r\n            TransformConstraintTimeline.PREV_TIME = -5;\r\n            TransformConstraintTimeline.PREV_ROTATE = -4;\r\n            TransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n            TransformConstraintTimeline.PREV_SCALE = -2;\r\n            TransformConstraintTimeline.PREV_SHEAR = -1;\r\n            TransformConstraintTimeline.ROTATE = 1;\r\n            TransformConstraintTimeline.TRANSLATE = 2;\r\n            TransformConstraintTimeline.SCALE = 3;\r\n            TransformConstraintTimeline.SHEAR = 4;\r\n            return TransformConstraintTimeline;\r\n        }(CurveTimeline));\r\n        core.TransformConstraintTimeline = TransformConstraintTimeline;\r\n        var PathConstraintPositionTimeline = (function (_super) {\r\n            __extends(PathConstraintPositionTimeline, _super);\r\n            function PathConstraintPositionTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            PathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n                frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n            };\r\n            PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.position = constraint.data.position;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var position = 0;\r\n                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n                    position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n                }\r\n                if (blend == MixBlend.setup)\r\n                    constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n                else\r\n                    constraint.position += (position - constraint.position) * alpha;\r\n            };\r\n            PathConstraintPositionTimeline.ENTRIES = 2;\r\n            PathConstraintPositionTimeline.PREV_TIME = -2;\r\n            PathConstraintPositionTimeline.PREV_VALUE = -1;\r\n            PathConstraintPositionTimeline.VALUE = 1;\r\n            return PathConstraintPositionTimeline;\r\n        }(CurveTimeline));\r\n        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n        var PathConstraintSpacingTimeline = (function (_super) {\r\n            __extends(PathConstraintSpacingTimeline, _super);\r\n            function PathConstraintSpacingTimeline(frameCount) {\r\n                return _super.call(this, frameCount) || this;\r\n            }\r\n            PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.spacing = constraint.data.spacing;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var spacing = 0;\r\n                if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n                    spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n                }\r\n                if (blend == MixBlend.setup)\r\n                    constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n                else\r\n                    constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n            };\r\n            return PathConstraintSpacingTimeline;\r\n        }(PathConstraintPositionTimeline));\r\n        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n        var PathConstraintMixTimeline = (function (_super) {\r\n            __extends(PathConstraintMixTimeline, _super);\r\n            function PathConstraintMixTimeline(frameCount) {\r\n                var _this = _super.call(this, frameCount) || this;\r\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n                return _this;\r\n            }\r\n            PathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n                return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n            };\r\n            PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n                frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n                this.frames[frameIndex] = time;\r\n                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n            };\r\n            PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n                var frames = this.frames;\r\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n                if (!constraint.active)\r\n                    return;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            constraint.rotateMix = constraint.data.rotateMix;\r\n                            constraint.translateMix = constraint.data.translateMix;\r\n                            return;\r\n                        case MixBlend.first:\r\n                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n                    }\r\n                    return;\r\n                }\r\n                var rotate = 0, translate = 0;\r\n                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n                }\r\n                else {\r\n                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n                    var frameTime = frames[frame];\r\n                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n                }\r\n                if (blend == MixBlend.setup) {\r\n                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n                }\r\n                else {\r\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n                }\r\n            };\r\n            PathConstraintMixTimeline.ENTRIES = 3;\r\n            PathConstraintMixTimeline.PREV_TIME = -3;\r\n            PathConstraintMixTimeline.PREV_ROTATE = -2;\r\n            PathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n            PathConstraintMixTimeline.ROTATE = 1;\r\n            PathConstraintMixTimeline.TRANSLATE = 2;\r\n            return PathConstraintMixTimeline;\r\n        }(CurveTimeline));\r\n        core.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AnimationState = (function () {\r\n            function AnimationState(data) {\r\n                this.tracks = new Array();\r\n                this.timeScale = 1;\r\n                this.unkeyedState = 0;\r\n                this.events = new Array();\r\n                this.listeners = new Array();\r\n                this.queue = new EventQueue(this);\r\n                this.propertyIDs = new core.IntSet();\r\n                this.animationsChanged = false;\r\n                this.trackEntryPool = new core.Pool(function () { return new TrackEntry(); });\r\n                this.data = data;\r\n            }\r\n            AnimationState.prototype.update = function (delta) {\r\n                delta *= this.timeScale;\r\n                var tracks = this.tracks;\r\n                for (var i = 0, n = tracks.length; i < n; i++) {\r\n                    var current = tracks[i];\r\n                    if (current == null)\r\n                        continue;\r\n                    current.animationLast = current.nextAnimationLast;\r\n                    current.trackLast = current.nextTrackLast;\r\n                    var currentDelta = delta * current.timeScale;\r\n                    if (current.delay > 0) {\r\n                        current.delay -= currentDelta;\r\n                        if (current.delay > 0)\r\n                            continue;\r\n                        currentDelta = -current.delay;\r\n                        current.delay = 0;\r\n                    }\r\n                    var next = current.next;\r\n                    if (next != null) {\r\n                        var nextTime = current.trackLast - next.delay;\r\n                        if (nextTime >= 0) {\r\n                            next.delay = 0;\r\n                            next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                            current.trackTime += currentDelta;\r\n                            this.setCurrent(i, next, true);\r\n                            while (next.mixingFrom != null) {\r\n                                next.mixTime += delta;\r\n                                next = next.mixingFrom;\r\n                            }\r\n                            continue;\r\n                        }\r\n                    }\r\n                    else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                        tracks[i] = null;\r\n                        this.queue.end(current);\r\n                        this.disposeNext(current);\r\n                        continue;\r\n                    }\r\n                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                        var from = current.mixingFrom;\r\n                        current.mixingFrom = null;\r\n                        if (from != null)\r\n                            from.mixingTo = null;\r\n                        while (from != null) {\r\n                            this.queue.end(from);\r\n                            from = from.mixingFrom;\r\n                        }\r\n                    }\r\n                    current.trackTime += currentDelta;\r\n                }\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n                var from = to.mixingFrom;\r\n                if (from == null)\r\n                    return true;\r\n                var finished = this.updateMixingFrom(from, delta);\r\n                from.animationLast = from.nextAnimationLast;\r\n                from.trackLast = from.nextTrackLast;\r\n                if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n                    if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                        to.mixingFrom = from.mixingFrom;\r\n                        if (from.mixingFrom != null)\r\n                            from.mixingFrom.mixingTo = to;\r\n                        to.interruptAlpha = from.interruptAlpha;\r\n                        this.queue.end(from);\r\n                    }\r\n                    return finished;\r\n                }\r\n                from.trackTime += delta * from.timeScale;\r\n                to.mixTime += delta;\r\n                return false;\r\n            };\r\n            AnimationState.prototype.apply = function (skeleton) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                if (this.animationsChanged)\r\n                    this._animationsChanged();\r\n                var events = this.events;\r\n                var tracks = this.tracks;\r\n                var applied = false;\r\n                for (var i_16 = 0, n_1 = tracks.length; i_16 < n_1; i_16++) {\r\n                    var current = tracks[i_16];\r\n                    if (current == null || current.delay > 0)\r\n                        continue;\r\n                    applied = true;\r\n                    var blend = i_16 == 0 ? core.MixBlend.first : current.mixBlend;\r\n                    var mix = current.alpha;\r\n                    if (current.mixingFrom != null)\r\n                        mix *= this.applyMixingFrom(current, skeleton, blend);\r\n                    else if (current.trackTime >= current.trackEnd && current.next == null)\r\n                        mix = 0;\r\n                    var animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n                    var timelineCount = current.animation.timelines.length;\r\n                    var timelines = current.animation.timelines;\r\n                    if ((i_16 == 0 && mix == 1) || blend == core.MixBlend.add) {\r\n                        for (var ii = 0; ii < timelineCount; ii++) {\r\n                            core.Utils.webkit602BugfixHelper(mix, blend);\r\n                            var timeline = timelines[ii];\r\n                            if (timeline instanceof core.AttachmentTimeline)\r\n                                this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\r\n                            else\r\n                                timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, core.MixDirection.mixIn);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var timelineMode = current.timelineMode;\r\n                        var firstFrame = current.timelinesRotation.length == 0;\r\n                        if (firstFrame)\r\n                            core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                        var timelinesRotation = current.timelinesRotation;\r\n                        for (var ii = 0; ii < timelineCount; ii++) {\r\n                            var timeline_1 = timelines[ii];\r\n                            var timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : core.MixBlend.setup;\r\n                            if (timeline_1 instanceof core.RotateTimeline) {\r\n                                this.applyRotateTimeline(timeline_1, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                            }\r\n                            else if (timeline_1 instanceof core.AttachmentTimeline) {\r\n                                this.applyAttachmentTimeline(timeline_1, skeleton, animationTime, blend, true);\r\n                            }\r\n                            else {\r\n                                core.Utils.webkit602BugfixHelper(mix, blend);\r\n                                timeline_1.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, core.MixDirection.mixIn);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.queueEvents(current, animationTime);\r\n                    events.length = 0;\r\n                    current.nextAnimationLast = animationTime;\r\n                    current.nextTrackLast = current.trackTime;\r\n                }\r\n                var setupState = this.unkeyedState + AnimationState.SETUP;\r\n                var slots = skeleton.slots;\r\n                for (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.attachmentState == setupState) {\r\n                        var attachmentName = slot.data.attachmentName;\r\n                        slot.attachment = (attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n                    }\r\n                }\r\n                this.unkeyedState += 2;\r\n                this.queue.drain();\r\n                return applied;\r\n            };\r\n            AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\r\n                var from = to.mixingFrom;\r\n                if (from.mixingFrom != null)\r\n                    this.applyMixingFrom(from, skeleton, blend);\r\n                var mix = 0;\r\n                if (to.mixDuration == 0) {\r\n                    mix = 1;\r\n                    if (blend == core.MixBlend.first)\r\n                        blend = core.MixBlend.setup;\r\n                }\r\n                else {\r\n                    mix = to.mixTime / to.mixDuration;\r\n                    if (mix > 1)\r\n                        mix = 1;\r\n                    if (blend != core.MixBlend.first)\r\n                        blend = from.mixBlend;\r\n                }\r\n                var events = mix < from.eventThreshold ? this.events : null;\r\n                var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n                var animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n                var timelineCount = from.animation.timelines.length;\r\n                var timelines = from.animation.timelines;\r\n                var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n                if (blend == core.MixBlend.add) {\r\n                    for (var i = 0; i < timelineCount; i++)\r\n                        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, core.MixDirection.mixOut);\r\n                }\r\n                else {\r\n                    var timelineMode = from.timelineMode;\r\n                    var timelineHoldMix = from.timelineHoldMix;\r\n                    var firstFrame = from.timelinesRotation.length == 0;\r\n                    if (firstFrame)\r\n                        core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n                    var timelinesRotation = from.timelinesRotation;\r\n                    from.totalAlpha = 0;\r\n                    for (var i = 0; i < timelineCount; i++) {\r\n                        var timeline = timelines[i];\r\n                        var direction = core.MixDirection.mixOut;\r\n                        var timelineBlend = void 0;\r\n                        var alpha = 0;\r\n                        switch (timelineMode[i]) {\r\n                            case AnimationState.SUBSEQUENT:\r\n                                if (!drawOrder && timeline instanceof core.DrawOrderTimeline)\r\n                                    continue;\r\n                                timelineBlend = blend;\r\n                                alpha = alphaMix;\r\n                                break;\r\n                            case AnimationState.FIRST:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                alpha = alphaMix;\r\n                                break;\r\n                            case AnimationState.HOLD_SUBSEQUENT:\r\n                                timelineBlend = blend;\r\n                                alpha = alphaHold;\r\n                                break;\r\n                            case AnimationState.HOLD_FIRST:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                alpha = alphaHold;\r\n                                break;\r\n                            default:\r\n                                timelineBlend = core.MixBlend.setup;\r\n                                var holdMix = timelineHoldMix[i];\r\n                                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                                break;\r\n                        }\r\n                        from.totalAlpha += alpha;\r\n                        if (timeline instanceof core.RotateTimeline)\r\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                        else if (timeline instanceof core.AttachmentTimeline)\r\n                            this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\r\n                        else {\r\n                            core.Utils.webkit602BugfixHelper(alpha, blend);\r\n                            if (drawOrder && timeline instanceof core.DrawOrderTimeline && timelineBlend == core.MixBlend.setup)\r\n                                direction = core.MixDirection.mixIn;\r\n                            timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                        }\r\n                    }\r\n                }\r\n                if (to.mixDuration > 0)\r\n                    this.queueEvents(from, animationTime);\r\n                this.events.length = 0;\r\n                from.nextAnimationLast = animationTime;\r\n                from.nextTrackLast = from.trackTime;\r\n                return mix;\r\n            };\r\n            AnimationState.prototype.applyAttachmentTimeline = function (timeline, skeleton, time, blend, attachments) {\r\n                var slot = skeleton.slots[timeline.slotIndex];\r\n                if (!slot.bone.active)\r\n                    return;\r\n                var frames = timeline.frames;\r\n                if (time < frames[0]) {\r\n                    if (blend == core.MixBlend.setup || blend == core.MixBlend.first)\r\n                        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n                }\r\n                else {\r\n                    var frameIndex;\r\n                    if (time >= frames[frames.length - 1])\r\n                        frameIndex = frames.length - 1;\r\n                    else\r\n                        frameIndex = core.Animation.binarySearch(frames, time) - 1;\r\n                    this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\r\n                }\r\n                if (slot.attachmentState <= this.unkeyedState)\r\n                    slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\r\n            };\r\n            AnimationState.prototype.setAttachment = function (skeleton, slot, attachmentName, attachments) {\r\n                slot.attachment = attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName);\r\n                if (attachments)\r\n                    slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\r\n            };\r\n            AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\r\n                if (firstFrame)\r\n                    timelinesRotation[i] = 0;\r\n                if (alpha == 1) {\r\n                    timeline.apply(skeleton, 0, time, null, 1, blend, core.MixDirection.mixIn);\r\n                    return;\r\n                }\r\n                var rotateTimeline = timeline;\r\n                var frames = rotateTimeline.frames;\r\n                var bone = skeleton.bones[rotateTimeline.boneIndex];\r\n                if (!bone.active)\r\n                    return;\r\n                var r1 = 0, r2 = 0;\r\n                if (time < frames[0]) {\r\n                    switch (blend) {\r\n                        case core.MixBlend.setup:\r\n                            bone.rotation = bone.data.rotation;\r\n                        default:\r\n                            return;\r\n                        case core.MixBlend.first:\r\n                            r1 = bone.rotation;\r\n                            r2 = bone.data.rotation;\r\n                    }\r\n                }\r\n                else {\r\n                    r1 = blend == core.MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n                    if (time >= frames[frames.length - core.RotateTimeline.ENTRIES])\r\n                        r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];\r\n                    else {\r\n                        var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);\r\n                        var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];\r\n                        var frameTime = frames[frame];\r\n                        var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));\r\n                        r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;\r\n                        r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                        r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                        r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                    }\r\n                }\r\n                var total = 0, diff = r2 - r1;\r\n                diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n                if (diff == 0) {\r\n                    total = timelinesRotation[i];\r\n                }\r\n                else {\r\n                    var lastTotal = 0, lastDiff = 0;\r\n                    if (firstFrame) {\r\n                        lastTotal = 0;\r\n                        lastDiff = diff;\r\n                    }\r\n                    else {\r\n                        lastTotal = timelinesRotation[i];\r\n                        lastDiff = timelinesRotation[i + 1];\r\n                    }\r\n                    var current = diff > 0, dir = lastTotal >= 0;\r\n                    if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                        if (Math.abs(lastTotal) > 180)\r\n                            lastTotal += 360 * core.MathUtils.signum(lastTotal);\r\n                        dir = current;\r\n                    }\r\n                    total = diff + lastTotal - lastTotal % 360;\r\n                    if (dir != current)\r\n                        total += 360 * core.MathUtils.signum(lastTotal);\r\n                    timelinesRotation[i] = total;\r\n                }\r\n                timelinesRotation[i + 1] = diff;\r\n                r1 += total * alpha;\r\n                bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n            };\r\n            AnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n                var duration = animationEnd - animationStart;\r\n                var trackLastWrapped = entry.trackLast % duration;\r\n                var events = this.events;\r\n                var i = 0, n = events.length;\r\n                for (; i < n; i++) {\r\n                    var event_1 = events[i];\r\n                    if (event_1.time < trackLastWrapped)\r\n                        break;\r\n                    if (event_1.time > animationEnd)\r\n                        continue;\r\n                    this.queue.event(entry, event_1);\r\n                }\r\n                var complete = false;\r\n                if (entry.loop)\r\n                    complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n                else\r\n                    complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n                if (complete)\r\n                    this.queue.complete(entry);\r\n                for (; i < n; i++) {\r\n                    var event_2 = events[i];\r\n                    if (event_2.time < animationStart)\r\n                        continue;\r\n                    this.queue.event(entry, events[i]);\r\n                }\r\n            };\r\n            AnimationState.prototype.clearTracks = function () {\r\n                var oldDrainDisabled = this.queue.drainDisabled;\r\n                this.queue.drainDisabled = true;\r\n                for (var i = 0, n = this.tracks.length; i < n; i++)\r\n                    this.clearTrack(i);\r\n                this.tracks.length = 0;\r\n                this.queue.drainDisabled = oldDrainDisabled;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.clearTrack = function (trackIndex) {\r\n                if (trackIndex >= this.tracks.length)\r\n                    return;\r\n                var current = this.tracks[trackIndex];\r\n                if (current == null)\r\n                    return;\r\n                this.queue.end(current);\r\n                this.disposeNext(current);\r\n                var entry = current;\r\n                while (true) {\r\n                    var from = entry.mixingFrom;\r\n                    if (from == null)\r\n                        break;\r\n                    this.queue.end(from);\r\n                    entry.mixingFrom = null;\r\n                    entry.mixingTo = null;\r\n                    entry = from;\r\n                }\r\n                this.tracks[current.trackIndex] = null;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n                var from = this.expandToIndex(index);\r\n                this.tracks[index] = current;\r\n                if (from != null) {\r\n                    if (interrupt)\r\n                        this.queue.interrupt(from);\r\n                    current.mixingFrom = from;\r\n                    from.mixingTo = current;\r\n                    current.mixTime = 0;\r\n                    if (from.mixingFrom != null && from.mixDuration > 0)\r\n                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n                    from.timelinesRotation.length = 0;\r\n                }\r\n                this.queue.start(current);\r\n            };\r\n            AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                if (animation == null)\r\n                    throw new Error(\"Animation not found: \" + animationName);\r\n                return this.setAnimationWith(trackIndex, animation, loop);\r\n            };\r\n            AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n                if (animation == null)\r\n                    throw new Error(\"animation cannot be null.\");\r\n                var interrupt = true;\r\n                var current = this.expandToIndex(trackIndex);\r\n                if (current != null) {\r\n                    if (current.nextTrackLast == -1) {\r\n                        this.tracks[trackIndex] = current.mixingFrom;\r\n                        this.queue.interrupt(current);\r\n                        this.queue.end(current);\r\n                        this.disposeNext(current);\r\n                        current = current.mixingFrom;\r\n                        interrupt = false;\r\n                    }\r\n                    else\r\n                        this.disposeNext(current);\r\n                }\r\n                var entry = this.trackEntry(trackIndex, animation, loop, current);\r\n                this.setCurrent(trackIndex, entry, interrupt);\r\n                this.queue.drain();\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                if (animation == null)\r\n                    throw new Error(\"Animation not found: \" + animationName);\r\n                return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n            };\r\n            AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n                if (animation == null)\r\n                    throw new Error(\"animation cannot be null.\");\r\n                var last = this.expandToIndex(trackIndex);\r\n                if (last != null) {\r\n                    while (last.next != null)\r\n                        last = last.next;\r\n                }\r\n                var entry = this.trackEntry(trackIndex, animation, loop, last);\r\n                if (last == null) {\r\n                    this.setCurrent(trackIndex, entry, true);\r\n                    this.queue.drain();\r\n                }\r\n                else {\r\n                    last.next = entry;\r\n                    if (delay <= 0) {\r\n                        var duration = last.animationEnd - last.animationStart;\r\n                        if (duration != 0) {\r\n                            if (last.loop)\r\n                                delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                            else\r\n                                delay += Math.max(duration, last.trackTime);\r\n                            delay -= this.data.getMix(last.animation, animation);\r\n                        }\r\n                        else\r\n                            delay = last.trackTime;\r\n                    }\r\n                }\r\n                entry.delay = delay;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n                entry.mixDuration = mixDuration;\r\n                entry.trackEnd = mixDuration;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n                if (delay <= 0)\r\n                    delay -= mixDuration;\r\n                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n                entry.mixDuration = mixDuration;\r\n                entry.trackEnd = mixDuration;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n                var oldDrainDisabled = this.queue.drainDisabled;\r\n                this.queue.drainDisabled = true;\r\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                    var current = this.tracks[i];\r\n                    if (current != null)\r\n                        this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n                }\r\n                this.queue.drainDisabled = oldDrainDisabled;\r\n                this.queue.drain();\r\n            };\r\n            AnimationState.prototype.expandToIndex = function (index) {\r\n                if (index < this.tracks.length)\r\n                    return this.tracks[index];\r\n                core.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n                this.tracks.length = index + 1;\r\n                return null;\r\n            };\r\n            AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n                var entry = this.trackEntryPool.obtain();\r\n                entry.trackIndex = trackIndex;\r\n                entry.animation = animation;\r\n                entry.loop = loop;\r\n                entry.holdPrevious = false;\r\n                entry.eventThreshold = 0;\r\n                entry.attachmentThreshold = 0;\r\n                entry.drawOrderThreshold = 0;\r\n                entry.animationStart = 0;\r\n                entry.animationEnd = animation.duration;\r\n                entry.animationLast = -1;\r\n                entry.nextAnimationLast = -1;\r\n                entry.delay = 0;\r\n                entry.trackTime = 0;\r\n                entry.trackLast = -1;\r\n                entry.nextTrackLast = -1;\r\n                entry.trackEnd = Number.MAX_VALUE;\r\n                entry.timeScale = 1;\r\n                entry.alpha = 1;\r\n                entry.interruptAlpha = 1;\r\n                entry.mixTime = 0;\r\n                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n                entry.mixBlend = core.MixBlend.replace;\r\n                return entry;\r\n            };\r\n            AnimationState.prototype.disposeNext = function (entry) {\r\n                var next = entry.next;\r\n                while (next != null) {\r\n                    this.queue.dispose(next);\r\n                    next = next.next;\r\n                }\r\n                entry.next = null;\r\n            };\r\n            AnimationState.prototype._animationsChanged = function () {\r\n                this.animationsChanged = false;\r\n                this.propertyIDs.clear();\r\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                    var entry = this.tracks[i];\r\n                    if (entry == null)\r\n                        continue;\r\n                    while (entry.mixingFrom != null)\r\n                        entry = entry.mixingFrom;\r\n                    do {\r\n                        if (entry.mixingFrom == null || entry.mixBlend != core.MixBlend.add)\r\n                            this.computeHold(entry);\r\n                        entry = entry.mixingTo;\r\n                    } while (entry != null);\r\n                }\r\n            };\r\n            AnimationState.prototype.computeHold = function (entry) {\r\n                var to = entry.mixingTo;\r\n                var timelines = entry.animation.timelines;\r\n                var timelinesCount = entry.animation.timelines.length;\r\n                var timelineMode = core.Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n                entry.timelineHoldMix.length = 0;\r\n                var timelineDipMix = core.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n                var propertyIDs = this.propertyIDs;\r\n                if (to != null && to.holdPrevious) {\r\n                    for (var i = 0; i < timelinesCount; i++) {\r\n                        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\r\n                    }\r\n                    return;\r\n                }\r\n                outer: for (var i = 0; i < timelinesCount; i++) {\r\n                    var timeline = timelines[i];\r\n                    var id = timeline.getPropertyId();\r\n                    if (!propertyIDs.add(id))\r\n                        timelineMode[i] = AnimationState.SUBSEQUENT;\r\n                    else if (to == null || timeline instanceof core.AttachmentTimeline || timeline instanceof core.DrawOrderTimeline\r\n                        || timeline instanceof core.EventTimeline || !to.animation.hasTimeline(id)) {\r\n                        timelineMode[i] = AnimationState.FIRST;\r\n                    }\r\n                    else {\r\n                        for (var next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                            if (next.animation.hasTimeline(id))\r\n                                continue;\r\n                            if (entry.mixDuration > 0) {\r\n                                timelineMode[i] = AnimationState.HOLD_MIX;\r\n                                timelineDipMix[i] = next;\r\n                                continue outer;\r\n                            }\r\n                            break;\r\n                        }\r\n                        timelineMode[i] = AnimationState.HOLD_FIRST;\r\n                    }\r\n                }\r\n            };\r\n            AnimationState.prototype.getCurrent = function (trackIndex) {\r\n                if (trackIndex >= this.tracks.length)\r\n                    return null;\r\n                return this.tracks[trackIndex];\r\n            };\r\n            AnimationState.prototype.addListener = function (listener) {\r\n                if (listener == null)\r\n                    throw new Error(\"listener cannot be null.\");\r\n                this.listeners.push(listener);\r\n            };\r\n            AnimationState.prototype.removeListener = function (listener) {\r\n                var index = this.listeners.indexOf(listener);\r\n                if (index >= 0)\r\n                    this.listeners.splice(index, 1);\r\n            };\r\n            AnimationState.prototype.clearListeners = function () {\r\n                this.listeners.length = 0;\r\n            };\r\n            AnimationState.prototype.clearListenerNotifications = function () {\r\n                this.queue.clear();\r\n            };\r\n            AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {\r\n                if (!AnimationState.deprecatedWarning1) {\r\n                    AnimationState.deprecatedWarning1 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n                }\r\n                this.setAnimation(trackIndex, animationName, loop);\r\n            };\r\n            AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {\r\n                if (!AnimationState.deprecatedWarning2) {\r\n                    AnimationState.deprecatedWarning2 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n                }\r\n                this.addAnimation(trackIndex, animationName, loop, delay);\r\n            };\r\n            AnimationState.prototype.hasAnimation = function (animationName) {\r\n                var animation = this.data.skeletonData.findAnimation(animationName);\r\n                return animation !== null;\r\n            };\r\n            AnimationState.prototype.hasAnimationByName = function (animationName) {\r\n                if (!AnimationState.deprecatedWarning3) {\r\n                    AnimationState.deprecatedWarning3 = true;\r\n                    console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n                }\r\n                return this.hasAnimation(animationName);\r\n            };\r\n            AnimationState.emptyAnimation = new core.Animation(\"<empty>\", [], 0);\r\n            AnimationState.SUBSEQUENT = 0;\r\n            AnimationState.FIRST = 1;\r\n            AnimationState.HOLD_SUBSEQUENT = 2;\r\n            AnimationState.HOLD_FIRST = 3;\r\n            AnimationState.HOLD_MIX = 4;\r\n            AnimationState.SETUP = 1;\r\n            AnimationState.CURRENT = 2;\r\n            AnimationState.deprecatedWarning1 = false;\r\n            AnimationState.deprecatedWarning2 = false;\r\n            AnimationState.deprecatedWarning3 = false;\r\n            return AnimationState;\r\n        }());\r\n        core.AnimationState = AnimationState;\r\n        var TrackEntry = (function () {\r\n            function TrackEntry() {\r\n                this.mixBlend = core.MixBlend.replace;\r\n                this.timelineMode = new Array();\r\n                this.timelineHoldMix = new Array();\r\n                this.timelinesRotation = new Array();\r\n            }\r\n            TrackEntry.prototype.reset = function () {\r\n                this.next = null;\r\n                this.mixingFrom = null;\r\n                this.mixingTo = null;\r\n                this.animation = null;\r\n                this.listener = null;\r\n                this.timelineMode.length = 0;\r\n                this.timelineHoldMix.length = 0;\r\n                this.timelinesRotation.length = 0;\r\n            };\r\n            TrackEntry.prototype.getAnimationTime = function () {\r\n                if (this.loop) {\r\n                    var duration = this.animationEnd - this.animationStart;\r\n                    if (duration == 0)\r\n                        return this.animationStart;\r\n                    return (this.trackTime % duration) + this.animationStart;\r\n                }\r\n                return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n            };\r\n            TrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n                this.animationLast = animationLast;\r\n                this.nextAnimationLast = animationLast;\r\n            };\r\n            TrackEntry.prototype.isComplete = function () {\r\n                return this.trackTime >= this.animationEnd - this.animationStart;\r\n            };\r\n            TrackEntry.prototype.resetRotationDirections = function () {\r\n                this.timelinesRotation.length = 0;\r\n            };\r\n            Object.defineProperty(TrackEntry.prototype, \"time\", {\r\n                get: function () {\r\n                    if (!TrackEntry.deprecatedWarning1) {\r\n                        TrackEntry.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n                    }\r\n                    return this.trackTime;\r\n                },\r\n                set: function (value) {\r\n                    if (!TrackEntry.deprecatedWarning1) {\r\n                        TrackEntry.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n                    }\r\n                    this.trackTime = value;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TrackEntry.prototype, \"endTime\", {\r\n                get: function () {\r\n                    if (!TrackEntry.deprecatedWarning2) {\r\n                        TrackEntry.deprecatedWarning2 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n                    }\r\n                    return this.trackTime;\r\n                },\r\n                set: function (value) {\r\n                    if (!TrackEntry.deprecatedWarning2) {\r\n                        TrackEntry.deprecatedWarning2 = true;\r\n                        console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n                    }\r\n                    this.trackTime = value;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            TrackEntry.prototype.loopsCount = function () {\r\n                return Math.floor(this.trackTime / this.trackEnd);\r\n            };\r\n            TrackEntry.deprecatedWarning1 = false;\r\n            TrackEntry.deprecatedWarning2 = false;\r\n            return TrackEntry;\r\n        }());\r\n        core.TrackEntry = TrackEntry;\r\n        var EventQueue = (function () {\r\n            function EventQueue(animState) {\r\n                this.objects = [];\r\n                this.drainDisabled = false;\r\n                this.animState = animState;\r\n            }\r\n            EventQueue.prototype.start = function (entry) {\r\n                this.objects.push(EventType.start);\r\n                this.objects.push(entry);\r\n                this.animState.animationsChanged = true;\r\n            };\r\n            EventQueue.prototype.interrupt = function (entry) {\r\n                this.objects.push(EventType.interrupt);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.end = function (entry) {\r\n                this.objects.push(EventType.end);\r\n                this.objects.push(entry);\r\n                this.animState.animationsChanged = true;\r\n            };\r\n            EventQueue.prototype.dispose = function (entry) {\r\n                this.objects.push(EventType.dispose);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.complete = function (entry) {\r\n                this.objects.push(EventType.complete);\r\n                this.objects.push(entry);\r\n            };\r\n            EventQueue.prototype.event = function (entry, event) {\r\n                this.objects.push(EventType.event);\r\n                this.objects.push(entry);\r\n                this.objects.push(event);\r\n            };\r\n            EventQueue.prototype.deprecateStuff = function () {\r\n                if (!EventQueue.deprecatedWarning1) {\r\n                    EventQueue.deprecatedWarning1 = true;\r\n                    console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\r\n                }\r\n                return true;\r\n            };\r\n            EventQueue.prototype.drain = function () {\r\n                if (this.drainDisabled)\r\n                    return;\r\n                this.drainDisabled = true;\r\n                var objects = this.objects;\r\n                var listeners = this.animState.listeners;\r\n                for (var i = 0; i < objects.length; i += 2) {\r\n                    var type = objects[i];\r\n                    var entry = objects[i + 1];\r\n                    switch (type) {\r\n                        case EventType.start:\r\n                            if (entry.listener != null && entry.listener.start)\r\n                                entry.listener.start(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].start)\r\n                                    listeners[ii].start(entry);\r\n                            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\r\n                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\r\n                            break;\r\n                        case EventType.interrupt:\r\n                            if (entry.listener != null && entry.listener.interrupt)\r\n                                entry.listener.interrupt(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].interrupt)\r\n                                    listeners[ii].interrupt(entry);\r\n                            break;\r\n                        case EventType.end:\r\n                            if (entry.listener != null && entry.listener.end)\r\n                                entry.listener.end(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].end)\r\n                                    listeners[ii].end(entry);\r\n                            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\r\n                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\r\n                        case EventType.dispose:\r\n                            if (entry.listener != null && entry.listener.dispose)\r\n                                entry.listener.dispose(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].dispose)\r\n                                    listeners[ii].dispose(entry);\r\n                            this.animState.trackEntryPool.free(entry);\r\n                            break;\r\n                        case EventType.complete:\r\n                            if (entry.listener != null && entry.listener.complete)\r\n                                entry.listener.complete(entry);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].complete)\r\n                                    listeners[ii].complete(entry);\r\n                            var count = core.MathUtils.toInt(entry.loopsCount());\r\n                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\r\n                            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\r\n                            break;\r\n                        case EventType.event:\r\n                            var event_3 = objects[i++ + 2];\r\n                            if (entry.listener != null && entry.listener.event)\r\n                                entry.listener.event(entry, event_3);\r\n                            for (var ii = 0; ii < listeners.length; ii++)\r\n                                if (listeners[ii].event)\r\n                                    listeners[ii].event(entry, event_3);\r\n                            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);\r\n                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);\r\n                            break;\r\n                    }\r\n                }\r\n                this.clear();\r\n                this.drainDisabled = false;\r\n            };\r\n            EventQueue.prototype.clear = function () {\r\n                this.objects.length = 0;\r\n            };\r\n            EventQueue.deprecatedWarning1 = false;\r\n            return EventQueue;\r\n        }());\r\n        core.EventQueue = EventQueue;\r\n        var EventType;\r\n        (function (EventType) {\r\n            EventType[EventType[\"start\"] = 0] = \"start\";\r\n            EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n            EventType[EventType[\"end\"] = 2] = \"end\";\r\n            EventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n            EventType[EventType[\"complete\"] = 4] = \"complete\";\r\n            EventType[EventType[\"event\"] = 5] = \"event\";\r\n        })(EventType = core.EventType || (core.EventType = {}));\r\n        var AnimationStateAdapter = (function () {\r\n            function AnimationStateAdapter() {\r\n            }\r\n            AnimationStateAdapter.prototype.start = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.interrupt = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.end = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.dispose = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.complete = function (entry) {\r\n            };\r\n            AnimationStateAdapter.prototype.event = function (entry, event) {\r\n            };\r\n            return AnimationStateAdapter;\r\n        }());\r\n        core.AnimationStateAdapter = AnimationStateAdapter;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AnimationStateData = (function () {\r\n            function AnimationStateData(skeletonData) {\r\n                this.animationToMixTime = {};\r\n                this.defaultMix = 0;\r\n                if (skeletonData == null)\r\n                    throw new Error(\"skeletonData cannot be null.\");\r\n                this.skeletonData = skeletonData;\r\n            }\r\n            AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n                var from = this.skeletonData.findAnimation(fromName);\r\n                if (from == null)\r\n                    throw new Error(\"Animation not found: \" + fromName);\r\n                var to = this.skeletonData.findAnimation(toName);\r\n                if (to == null)\r\n                    throw new Error(\"Animation not found: \" + toName);\r\n                this.setMixWith(from, to, duration);\r\n            };\r\n            AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {\r\n                if (!AnimationStateData.deprecatedWarning1) {\r\n                    AnimationStateData.deprecatedWarning1 = true;\r\n                    console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\r\n                }\r\n                this.setMix(fromName, toName, duration);\r\n            };\r\n            AnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n                if (from == null)\r\n                    throw new Error(\"from cannot be null.\");\r\n                if (to == null)\r\n                    throw new Error(\"to cannot be null.\");\r\n                var key = from.name + \".\" + to.name;\r\n                this.animationToMixTime[key] = duration;\r\n            };\r\n            AnimationStateData.prototype.getMix = function (from, to) {\r\n                var key = from.name + \".\" + to.name;\r\n                var value = this.animationToMixTime[key];\r\n                return value === undefined ? this.defaultMix : value;\r\n            };\r\n            AnimationStateData.deprecatedWarning1 = false;\r\n            return AnimationStateData;\r\n        }());\r\n        core.AnimationStateData = AnimationStateData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AtlasAttachmentLoader = (function () {\r\n            function AtlasAttachmentLoader(atlas) {\r\n                this.atlas = atlas;\r\n            }\r\n            AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n                var region = this.atlas.findRegion(path);\r\n                if (region == null)\r\n                    throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n                var attachment = new core.RegionAttachment(name);\r\n                attachment.region = region;\r\n                return attachment;\r\n            };\r\n            AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n                var region = this.atlas.findRegion(path);\r\n                if (region == null)\r\n                    throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n                var attachment = new core.MeshAttachment(name);\r\n                attachment.region = region;\r\n                return attachment;\r\n            };\r\n            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n                return new core.BoundingBoxAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n                return new core.PathAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n                return new core.PointAttachment(name);\r\n            };\r\n            AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n                return new core.ClippingAttachment(name);\r\n            };\r\n            return AtlasAttachmentLoader;\r\n        }());\r\n        core.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BlendMode;\r\n        (function (BlendMode) {\r\n            BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n            BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n            BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n            BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n        })(BlendMode = core.BlendMode || (core.BlendMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Bone = (function () {\r\n            function Bone(data, skeleton, parent) {\r\n                this.matrix = new PIXI.Matrix();\r\n                this.children = new Array();\r\n                this.x = 0;\r\n                this.y = 0;\r\n                this.rotation = 0;\r\n                this.scaleX = 0;\r\n                this.scaleY = 0;\r\n                this.shearX = 0;\r\n                this.shearY = 0;\r\n                this.ax = 0;\r\n                this.ay = 0;\r\n                this.arotation = 0;\r\n                this.ascaleX = 0;\r\n                this.ascaleY = 0;\r\n                this.ashearX = 0;\r\n                this.ashearY = 0;\r\n                this.appliedValid = false;\r\n                this.sorted = false;\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.skeleton = skeleton;\r\n                this.parent = parent;\r\n                this.setToSetupPose();\r\n            }\r\n            Object.defineProperty(Bone.prototype, \"worldX\", {\r\n                get: function () {\r\n                    return this.matrix.tx;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(Bone.prototype, \"worldY\", {\r\n                get: function () {\r\n                    return this.matrix.ty;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Bone.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            Bone.prototype.update = function () {\r\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n            };\r\n            Bone.prototype.updateWorldTransform = function () {\r\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n            };\r\n            Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n                this.ax = x;\r\n                this.ay = y;\r\n                this.arotation = rotation;\r\n                this.ascaleX = scaleX;\r\n                this.ascaleY = scaleY;\r\n                this.ashearX = shearX;\r\n                this.ashearY = shearY;\r\n                this.appliedValid = true;\r\n                var parent = this.parent;\r\n                var m = this.matrix;\r\n                var sx = this.skeleton.scaleX;\r\n                var sy = Bone.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n                if (parent == null) {\r\n                    var skeleton = this.skeleton;\r\n                    var rotationY = rotation + 90 + shearY;\r\n                    m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n                    m.c = core.MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n                    m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n                    m.d = core.MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n                    m.tx = x * sx + skeleton.x;\r\n                    m.ty = y * sy + skeleton.y;\r\n                    return;\r\n                }\r\n                var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n                m.tx = pa * x + pb * y + parent.matrix.tx;\r\n                m.ty = pc * x + pd * y + parent.matrix.ty;\r\n                switch (this.data.transformMode) {\r\n                    case core.TransformMode.Normal: {\r\n                        var rotationY = rotation + 90 + shearY;\r\n                        var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\r\n                        m.a = pa * la + pb * lc;\r\n                        m.c = pa * lb + pb * ld;\r\n                        m.b = pc * la + pd * lc;\r\n                        m.d = pc * lb + pd * ld;\r\n                        return;\r\n                    }\r\n                    case core.TransformMode.OnlyTranslation: {\r\n                        var rotationY = rotation + 90 + shearY;\r\n                        m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                        m.c = core.MathUtils.cosDeg(rotationY) * scaleY;\r\n                        m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                        m.d = core.MathUtils.sinDeg(rotationY) * scaleY;\r\n                        break;\r\n                    }\r\n                    case core.TransformMode.NoRotationOrReflection: {\r\n                        var s = pa * pa + pc * pc;\r\n                        var prx = 0;\r\n                        if (s > 0.0001) {\r\n                            s = Math.abs(pa * pd - pb * pc) / s;\r\n                            pa /= this.skeleton.scaleX;\r\n                            pc /= this.skeleton.scaleY;\r\n                            pb = pc * s;\r\n                            pd = pa * s;\r\n                            prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;\r\n                        }\r\n                        else {\r\n                            pa = 0;\r\n                            pc = 0;\r\n                            prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;\r\n                        }\r\n                        var rx = rotation + shearX - prx;\r\n                        var ry = rotation + shearY - prx + 90;\r\n                        var la = core.MathUtils.cosDeg(rx) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(ry) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(rx) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(ry) * scaleY;\r\n                        m.a = pa * la - pb * lc;\r\n                        m.c = pa * lb - pb * ld;\r\n                        m.b = pc * la + pd * lc;\r\n                        m.d = pc * lb + pd * ld;\r\n                        break;\r\n                    }\r\n                    case core.TransformMode.NoScale:\r\n                    case core.TransformMode.NoScaleOrReflection: {\r\n                        var cos = core.MathUtils.cosDeg(rotation);\r\n                        var sin = core.MathUtils.sinDeg(rotation);\r\n                        var za = (pa * cos + pb * sin) / sx;\r\n                        var zc = (pc * cos + pd * sin) / sy;\r\n                        var s = Math.sqrt(za * za + zc * zc);\r\n                        if (s > 0.00001)\r\n                            s = 1 / s;\r\n                        za *= s;\r\n                        zc *= s;\r\n                        s = Math.sqrt(za * za + zc * zc);\r\n                        if (this.data.transformMode == core.TransformMode.NoScale\r\n                            && (pa * pd - pb * pc < 0) != (Bone.yDown ?\r\n                                (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\r\n                                (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)))\r\n                            s = -s;\r\n                        var r = Math.PI / 2 + Math.atan2(zc, za);\r\n                        var zb = Math.cos(r) * s;\r\n                        var zd = Math.sin(r) * s;\r\n                        var la = core.MathUtils.cosDeg(shearX) * scaleX;\r\n                        var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                        var lc = core.MathUtils.sinDeg(shearX) * scaleX;\r\n                        var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                        m.a = za * la + zb * lc;\r\n                        m.c = za * lb + zb * ld;\r\n                        m.b = zc * la + zd * lc;\r\n                        m.d = zc * lb + zd * ld;\r\n                        break;\r\n                    }\r\n                }\r\n                m.a *= sx;\r\n                m.c *= sx;\r\n                m.b *= sy;\r\n                m.d *= sy;\r\n            };\r\n            Bone.prototype.setToSetupPose = function () {\r\n                var data = this.data;\r\n                this.x = data.x;\r\n                this.y = data.y;\r\n                this.rotation = data.rotation;\r\n                this.scaleX = data.scaleX;\r\n                this.scaleY = data.scaleY;\r\n                this.shearX = data.shearX;\r\n                this.shearY = data.shearY;\r\n            };\r\n            Bone.prototype.getWorldRotationX = function () {\r\n                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.getWorldRotationY = function () {\r\n                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.getWorldScaleX = function () {\r\n                var m = this.matrix;\r\n                return Math.sqrt(m.a * m.a + m.c * m.c);\r\n            };\r\n            Bone.prototype.getWorldScaleY = function () {\r\n                var m = this.matrix;\r\n                return Math.sqrt(m.b * m.b + m.d * m.d);\r\n            };\r\n            Bone.prototype.updateAppliedTransform = function () {\r\n                this.appliedValid = true;\r\n                var parent = this.parent;\r\n                var m = this.matrix;\r\n                if (parent == null) {\r\n                    this.ax = m.tx;\r\n                    this.ay = m.ty;\r\n                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;\r\n                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n                    this.ashearX = 0;\r\n                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;\r\n                    return;\r\n                }\r\n                var pm = parent.matrix;\r\n                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n                var dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n                this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n                this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n                var ia = pid * pm.d;\r\n                var id = pid * pm.a;\r\n                var ib = pid * pm.c;\r\n                var ic = pid * pm.b;\r\n                var ra = ia * m.a - ib * m.b;\r\n                var rb = ia * m.c - ib * m.d;\r\n                var rc = id * m.b - ic * m.a;\r\n                var rd = id * m.d - ic * m.c;\r\n                this.ashearX = 0;\r\n                this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n                if (this.ascaleX > 0.0001) {\r\n                    var det = ra * rd - rb * rc;\r\n                    this.ascaleY = det / this.ascaleX;\r\n                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;\r\n                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;\r\n                }\r\n                else {\r\n                    this.ascaleX = 0;\r\n                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n                    this.ashearY = 0;\r\n                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;\r\n                }\r\n            };\r\n            Bone.prototype.worldToLocal = function (world) {\r\n                var m = this.matrix;\r\n                var a = m.a, b = m.c, c = m.b, d = m.d;\r\n                var invDet = 1 / (a * d - b * c);\r\n                var x = world.x - m.tx, y = world.y - m.ty;\r\n                world.x = (x * d * invDet - y * b * invDet);\r\n                world.y = (y * a * invDet - x * c * invDet);\r\n                return world;\r\n            };\r\n            Bone.prototype.localToWorld = function (local) {\r\n                var m = this.matrix;\r\n                var x = local.x, y = local.y;\r\n                local.x = x * m.a + y * m.c + m.tx;\r\n                local.y = x * m.b + y * m.d + m.ty;\r\n                return local;\r\n            };\r\n            Bone.prototype.worldToLocalRotation = function (worldRotation) {\r\n                var sin = core.MathUtils.sinDeg(worldRotation), cos = core.MathUtils.cosDeg(worldRotation);\r\n                var mat = this.matrix;\r\n                return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.localToWorldRotation = function (localRotation) {\r\n                var sin = core.MathUtils.sinDeg(localRotation), cos = core.MathUtils.cosDeg(localRotation);\r\n                var mat = this.matrix;\r\n                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;\r\n            };\r\n            Bone.prototype.rotateWorld = function (degrees) {\r\n                var mat = this.matrix;\r\n                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                var cos = core.MathUtils.cosDeg(degrees), sin = core.MathUtils.sinDeg(degrees);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n                this.appliedValid = false;\r\n            };\r\n            Bone.yDown = false;\r\n            return Bone;\r\n        }());\r\n        core.Bone = Bone;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BoneData = (function () {\r\n            function BoneData(index, name, parent) {\r\n                this.x = 0;\r\n                this.y = 0;\r\n                this.rotation = 0;\r\n                this.scaleX = 1;\r\n                this.scaleY = 1;\r\n                this.shearX = 0;\r\n                this.shearY = 0;\r\n                this.transformMode = TransformMode.Normal;\r\n                this.skinRequired = false;\r\n                this.color = new core.Color();\r\n                if (index < 0)\r\n                    throw new Error(\"index must be >= 0.\");\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.index = index;\r\n                this.name = name;\r\n                this.parent = parent;\r\n            }\r\n            return BoneData;\r\n        }());\r\n        core.BoneData = BoneData;\r\n        var TransformMode;\r\n        (function (TransformMode) {\r\n            TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n            TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n            TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n            TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n            TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n        })(TransformMode = core.TransformMode || (core.TransformMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var ConstraintData = (function () {\r\n            function ConstraintData(name, order, skinRequired) {\r\n                this.name = name;\r\n                this.order = order;\r\n                this.skinRequired = skinRequired;\r\n            }\r\n            return ConstraintData;\r\n        }());\r\n        core.ConstraintData = ConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Event = (function () {\r\n            function Event(time, data) {\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                this.time = time;\r\n                this.data = data;\r\n            }\r\n            return Event;\r\n        }());\r\n        core.Event = Event;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var EventData = (function () {\r\n            function EventData(name) {\r\n                this.name = name;\r\n            }\r\n            return EventData;\r\n        }());\r\n        core.EventData = EventData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IkConstraint = (function () {\r\n            function IkConstraint(data, skeleton) {\r\n                this.bendDirection = 0;\r\n                this.compress = false;\r\n                this.stretch = false;\r\n                this.mix = 1;\r\n                this.softness = 0;\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.mix = data.mix;\r\n                this.softness = data.softness;\r\n                this.bendDirection = data.bendDirection;\r\n                this.compress = data.compress;\r\n                this.stretch = data.stretch;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findBone(data.target.name);\r\n            }\r\n            IkConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            IkConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            IkConstraint.prototype.update = function () {\r\n                var target = this.target;\r\n                var bones = this.bones;\r\n                switch (bones.length) {\r\n                    case 1:\r\n                        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                        break;\r\n                    case 2:\r\n                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n                        break;\r\n                }\r\n            };\r\n            IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\r\n                if (!bone.appliedValid)\r\n                    bone.updateAppliedTransform();\r\n                var p = bone.parent.matrix;\r\n                var pa = p.a, pb = p.c, pc = p.b, pd = p.d;\r\n                var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n                switch (bone.data.transformMode) {\r\n                    case core.TransformMode.OnlyTranslation:\r\n                        tx = targetX - bone.worldX;\r\n                        ty = targetY - bone.worldY;\r\n                        break;\r\n                    case core.TransformMode.NoRotationOrReflection:\r\n                        var s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                        var sa = pa / bone.skeleton.scaleX;\r\n                        var sc = pc / bone.skeleton.scaleY;\r\n                        pb = -sc * s * bone.skeleton.scaleX;\r\n                        pd = sa * s * bone.skeleton.scaleY;\r\n                        rotationIK += Math.atan2(sc, sa) * core.MathUtils.radDeg;\r\n                    default:\r\n                        var x = targetX - p.tx, y = targetY - p.ty;\r\n                        var d = pa * pd - pb * pc;\r\n                        tx = (x * pd - y * pb) / d - bone.ax;\r\n                        ty = (y * pa - x * pc) / d - bone.ay;\r\n                }\r\n                rotationIK += Math.atan2(ty, tx) * core.MathUtils.radDeg;\r\n                if (bone.ascaleX < 0)\r\n                    rotationIK += 180;\r\n                if (rotationIK > 180)\r\n                    rotationIK -= 360;\r\n                else if (rotationIK < -180)\r\n                    rotationIK += 360;\r\n                var sx = bone.ascaleX, sy = bone.ascaleY;\r\n                if (compress || stretch) {\r\n                    switch (bone.data.transformMode) {\r\n                        case core.TransformMode.NoScale:\r\n                        case core.TransformMode.NoScaleOrReflection:\r\n                            tx = targetX - bone.worldX;\r\n                            ty = targetY - bone.worldY;\r\n                    }\r\n                    var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n                    if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                        var s = (dd / b - 1) * alpha + 1;\r\n                        sx *= s;\r\n                        if (uniform)\r\n                            sy *= s;\r\n                    }\r\n                }\r\n                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n            };\r\n            IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\r\n                if (alpha == 0) {\r\n                    child.updateWorldTransform();\r\n                    return;\r\n                }\r\n                if (!parent.appliedValid)\r\n                    parent.updateAppliedTransform();\r\n                if (!child.appliedValid)\r\n                    child.updateAppliedTransform();\r\n                var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n                var pmat = parent.matrix;\r\n                var os1 = 0, os2 = 0, s2 = 0;\r\n                if (psx < 0) {\r\n                    psx = -psx;\r\n                    os1 = 180;\r\n                    s2 = -1;\r\n                }\r\n                else {\r\n                    os1 = 0;\r\n                    s2 = 1;\r\n                }\r\n                if (psy < 0) {\r\n                    psy = -psy;\r\n                    s2 = -s2;\r\n                }\r\n                if (csx < 0) {\r\n                    csx = -csx;\r\n                    os2 = 180;\r\n                }\r\n                else\r\n                    os2 = 0;\r\n                var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n                var u = Math.abs(psx - psy) <= 0.0001;\r\n                if (!u) {\r\n                    cy = 0;\r\n                    cwx = a * cx + pmat.tx;\r\n                    cwy = c * cx + pmat.ty;\r\n                }\r\n                else {\r\n                    cy = child.ay;\r\n                    cwx = a * cx + b * cy + pmat.tx;\r\n                    cwy = c * cx + d * cy + pmat.ty;\r\n                }\r\n                var pp = parent.parent.matrix;\r\n                a = pp.a;\r\n                b = pp.c;\r\n                c = pp.b;\r\n                d = pp.d;\r\n                var id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\r\n                var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n                var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n                if (l1 < 0.0001) {\r\n                    this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n                    child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n                    return;\r\n                }\r\n                x = targetX - pp.tx;\r\n                y = targetY - pp.ty;\r\n                var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n                var dd = tx * tx + ty * ty;\r\n                if (softness != 0) {\r\n                    softness *= psx * (csx + 1) / 2;\r\n                    var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n                    if (sd > 0) {\r\n                        var p = Math.min(1, sd / (softness * 2)) - 1;\r\n                        p = (sd - softness * (1 - p * p)) / td;\r\n                        tx -= p * tx;\r\n                        ty -= p * ty;\r\n                        dd = tx * tx + ty * ty;\r\n                    }\r\n                }\r\n                outer: if (u) {\r\n                    l2 *= psx;\r\n                    var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                    if (cos < -1)\r\n                        cos = -1;\r\n                    else if (cos > 1) {\r\n                        cos = 1;\r\n                        if (stretch)\r\n                            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                    }\r\n                    a2 = Math.acos(cos) * bendDir;\r\n                    a = l1 + l2 * cos;\r\n                    b = l2 * Math.sin(a2);\r\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n                }\r\n                else {\r\n                    a = psx * l2;\r\n                    b = psy * l2;\r\n                    var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                    var c1 = -2 * bb * l1, c2 = bb - aa;\r\n                    d = c1 * c1 - 4 * c2 * c;\r\n                    if (d >= 0) {\r\n                        var q = Math.sqrt(d);\r\n                        if (c1 < 0)\r\n                            q = -q;\r\n                        q = -(c1 + q) / 2;\r\n                        var r0 = q / c2, r1 = c / q;\r\n                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                        if (r * r <= dd) {\r\n                            y = Math.sqrt(dd - r * r) * bendDir;\r\n                            a1 = ta - Math.atan2(y, r);\r\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                            break outer;\r\n                        }\r\n                    }\r\n                    var minAngle = core.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                    var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                    c = -a * l1 / (aa - bb);\r\n                    if (c >= -1 && c <= 1) {\r\n                        c = Math.acos(c);\r\n                        x = a * Math.cos(c) + l1;\r\n                        y = b * Math.sin(c);\r\n                        d = x * x + y * y;\r\n                        if (d < minDist) {\r\n                            minAngle = c;\r\n                            minDist = d;\r\n                            minX = x;\r\n                            minY = y;\r\n                        }\r\n                        if (d > maxDist) {\r\n                            maxAngle = c;\r\n                            maxDist = d;\r\n                            maxX = x;\r\n                            maxY = y;\r\n                        }\r\n                    }\r\n                    if (dd <= (minDist + maxDist) / 2) {\r\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                        a2 = minAngle * bendDir;\r\n                    }\r\n                    else {\r\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                        a2 = maxAngle * bendDir;\r\n                    }\r\n                }\r\n                var os = Math.atan2(cy, cx) * s2;\r\n                var rotation = parent.arotation;\r\n                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;\r\n                if (a1 > 180)\r\n                    a1 -= 360;\r\n                else if (a1 < -180)\r\n                    a1 += 360;\r\n                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n                rotation = child.arotation;\r\n                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n                if (a2 > 180)\r\n                    a2 -= 360;\r\n                else if (a2 < -180)\r\n                    a2 += 360;\r\n                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n            };\r\n            return IkConstraint;\r\n        }());\r\n        core.IkConstraint = IkConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IkConstraintData = (function (_super) {\r\n            __extends(IkConstraintData, _super);\r\n            function IkConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                _this.bendDirection = 1;\r\n                _this.compress = false;\r\n                _this.stretch = false;\r\n                _this.uniform = false;\r\n                _this.mix = 1;\r\n                _this.softness = 0;\r\n                return _this;\r\n            }\r\n            return IkConstraintData;\r\n        }(core.ConstraintData));\r\n        core.IkConstraintData = IkConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathConstraint = (function () {\r\n            function PathConstraint(data, skeleton) {\r\n                this.position = 0;\r\n                this.spacing = 0;\r\n                this.rotateMix = 0;\r\n                this.translateMix = 0;\r\n                this.spaces = new Array();\r\n                this.positions = new Array();\r\n                this.world = new Array();\r\n                this.curves = new Array();\r\n                this.lengths = new Array();\r\n                this.segments = new Array();\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.bones = new Array();\r\n                for (var i = 0, n = data.bones.length; i < n; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findSlot(data.target.name);\r\n                this.position = data.position;\r\n                this.spacing = data.spacing;\r\n                this.rotateMix = data.rotateMix;\r\n                this.translateMix = data.translateMix;\r\n            }\r\n            PathConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            PathConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            PathConstraint.prototype.update = function () {\r\n                var attachment = this.target.getAttachment();\r\n                if (!(attachment instanceof core.PathAttachment))\r\n                    return;\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n                var translate = translateMix > 0, rotate = rotateMix > 0;\r\n                if (!translate && !rotate)\r\n                    return;\r\n                var data = this.data;\r\n                var spacingMode = data.spacingMode;\r\n                var lengthSpacing = spacingMode == core.SpacingMode.Length;\r\n                var rotateMode = data.rotateMode;\r\n                var tangents = rotateMode == core.RotateMode.Tangent, scale = rotateMode == core.RotateMode.ChainScale;\r\n                var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n                var bones = this.bones;\r\n                var spaces = core.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n                var spacing = this.spacing;\r\n                if (scale || lengthSpacing) {\r\n                    if (scale)\r\n                        lengths = core.Utils.setArraySize(this.lengths, boneCount);\r\n                    for (var i = 0, n = spacesCount - 1; i < n;) {\r\n                        var bone = bones[i];\r\n                        var setupLength = bone.data.length;\r\n                        if (setupLength < PathConstraint.epsilon) {\r\n                            if (scale)\r\n                                lengths[i] = 0;\r\n                            spaces[++i] = 0;\r\n                        }\r\n                        else {\r\n                            var x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                            var length_1 = Math.sqrt(x * x + y * y);\r\n                            if (scale)\r\n                                lengths[i] = length_1;\r\n                            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 1; i < spacesCount; i++)\r\n                        spaces[i] = spacing;\r\n                }\r\n                var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);\r\n                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n                var tip = false;\r\n                if (offsetRotation == 0)\r\n                    tip = rotateMode == core.RotateMode.Chain;\r\n                else {\r\n                    tip = false;\r\n                    var p = this.target.bone.matrix;\r\n                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                }\r\n                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n                    var bone = bones[i];\r\n                    var mat = bone.matrix;\r\n                    mat.tx += (boneX - mat.tx) * translateMix;\r\n                    mat.ty += (boneY - mat.ty) * translateMix;\r\n                    var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n                    if (scale) {\r\n                        var length_2 = lengths[i];\r\n                        if (length_2 != 0) {\r\n                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\r\n                            mat.a *= s;\r\n                            mat.b *= s;\r\n                        }\r\n                    }\r\n                    boneX = x;\r\n                    boneY = y;\r\n                    if (rotate) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                        if (tangents)\r\n                            r = positions[p - 1];\r\n                        else if (spaces[i + 1] == 0)\r\n                            r = positions[p + 2];\r\n                        else\r\n                            r = Math.atan2(dy, dx);\r\n                        r -= Math.atan2(c, a);\r\n                        if (tip) {\r\n                            cos = Math.cos(r);\r\n                            sin = Math.sin(r);\r\n                            var length_3 = bone.data.length;\r\n                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\r\n                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\r\n                        }\r\n                        else {\r\n                            r += offsetRotation;\r\n                        }\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        cos = Math.cos(r);\r\n                        sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                    }\r\n                    bone.appliedValid = false;\r\n                }\r\n            };\r\n            PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n                var target = this.target;\r\n                var position = this.position;\r\n                var spaces = this.spaces, out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n                var closed = path.closed;\r\n                var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n                if (!path.constantSpeed) {\r\n                    var lengths = path.lengths;\r\n                    curveCount -= closed ? 1 : 2;\r\n                    var pathLength_1 = lengths[curveCount];\r\n                    if (percentPosition)\r\n                        position *= pathLength_1;\r\n                    if (percentSpacing) {\r\n                        for (var i = 0; i < spacesCount; i++)\r\n                            spaces[i] *= pathLength_1;\r\n                    }\r\n                    world = core.Utils.setArraySize(this.world, 8);\r\n                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                        var space = spaces[i];\r\n                        position += space;\r\n                        var p = position;\r\n                        if (closed) {\r\n                            p %= pathLength_1;\r\n                            if (p < 0)\r\n                                p += pathLength_1;\r\n                            curve = 0;\r\n                        }\r\n                        else if (p < 0) {\r\n                            if (prevCurve != PathConstraint.BEFORE) {\r\n                                prevCurve = PathConstraint.BEFORE;\r\n                                path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                            }\r\n                            this.addBeforePosition(p, world, 0, out, o);\r\n                            continue;\r\n                        }\r\n                        else if (p > pathLength_1) {\r\n                            if (prevCurve != PathConstraint.AFTER) {\r\n                                prevCurve = PathConstraint.AFTER;\r\n                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                            }\r\n                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n                            continue;\r\n                        }\r\n                        for (;; curve++) {\r\n                            var length_4 = lengths[curve];\r\n                            if (p > length_4)\r\n                                continue;\r\n                            if (curve == 0)\r\n                                p /= length_4;\r\n                            else {\r\n                                var prev = lengths[curve - 1];\r\n                                p = (p - prev) / (length_4 - prev);\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (curve != prevCurve) {\r\n                            prevCurve = curve;\r\n                            if (closed && curve == curveCount) {\r\n                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                                path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                            }\r\n                            else\r\n                                path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                        }\r\n                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n                    }\r\n                    return out;\r\n                }\r\n                if (closed) {\r\n                    verticesLength += 2;\r\n                    world = core.Utils.setArraySize(this.world, verticesLength);\r\n                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n                    world[verticesLength - 2] = world[0];\r\n                    world[verticesLength - 1] = world[1];\r\n                }\r\n                else {\r\n                    curveCount--;\r\n                    verticesLength -= 4;\r\n                    world = core.Utils.setArraySize(this.world, verticesLength);\r\n                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n                }\r\n                var curves = core.Utils.setArraySize(this.curves, curveCount);\r\n                var pathLength = 0;\r\n                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n                var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n                    cx1 = world[w];\r\n                    cy1 = world[w + 1];\r\n                    cx2 = world[w + 2];\r\n                    cy2 = world[w + 3];\r\n                    x2 = world[w + 4];\r\n                    y2 = world[w + 5];\r\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n                    ddfx = tmpx * 2 + dddfx;\r\n                    ddfy = tmpy * 2 + dddfy;\r\n                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    dfx += ddfx + dddfx;\r\n                    dfy += ddfy + dddfy;\r\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    curves[i] = pathLength;\r\n                    x1 = x2;\r\n                    y1 = y2;\r\n                }\r\n                if (percentPosition)\r\n                    position *= pathLength;\r\n                if (percentSpacing) {\r\n                    for (var i = 0; i < spacesCount; i++)\r\n                        spaces[i] *= pathLength;\r\n                }\r\n                var segments = this.segments;\r\n                var curveLength = 0;\r\n                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n                    var space = spaces[i];\r\n                    position += space;\r\n                    var p = position;\r\n                    if (closed) {\r\n                        p %= pathLength;\r\n                        if (p < 0)\r\n                            p += pathLength;\r\n                        curve = 0;\r\n                    }\r\n                    else if (p < 0) {\r\n                        this.addBeforePosition(p, world, 0, out, o);\r\n                        continue;\r\n                    }\r\n                    else if (p > pathLength) {\r\n                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                        continue;\r\n                    }\r\n                    for (;; curve++) {\r\n                        var length_5 = curves[curve];\r\n                        if (p > length_5)\r\n                            continue;\r\n                        if (curve == 0)\r\n                            p /= length_5;\r\n                        else {\r\n                            var prev = curves[curve - 1];\r\n                            p = (p - prev) / (length_5 - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (curve != prevCurve) {\r\n                        prevCurve = curve;\r\n                        var ii = curve * 6;\r\n                        x1 = world[ii];\r\n                        y1 = world[ii + 1];\r\n                        cx1 = world[ii + 2];\r\n                        cy1 = world[ii + 3];\r\n                        cx2 = world[ii + 4];\r\n                        cy2 = world[ii + 5];\r\n                        x2 = world[ii + 6];\r\n                        y2 = world[ii + 7];\r\n                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                        ddfx = tmpx * 2 + dddfx;\r\n                        ddfy = tmpy * 2 + dddfy;\r\n                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[0] = curveLength;\r\n                        for (ii = 1; ii < 8; ii++) {\r\n                            dfx += ddfx;\r\n                            dfy += ddfy;\r\n                            ddfx += dddfx;\r\n                            ddfy += dddfy;\r\n                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                            segments[ii] = curveLength;\r\n                        }\r\n                        dfx += ddfx;\r\n                        dfy += ddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[8] = curveLength;\r\n                        dfx += ddfx + dddfx;\r\n                        dfy += ddfy + dddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[9] = curveLength;\r\n                        segment = 0;\r\n                    }\r\n                    p *= curveLength;\r\n                    for (;; segment++) {\r\n                        var length_6 = segments[segment];\r\n                        if (p > length_6)\r\n                            continue;\r\n                        if (segment == 0)\r\n                            p /= length_6;\r\n                        else {\r\n                            var prev = segments[segment - 1];\r\n                            p = segment + (p - prev) / (length_6 - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n                }\r\n                return out;\r\n            };\r\n            PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n                var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n                out[o] = x1 + p * Math.cos(r);\r\n                out[o + 1] = y1 + p * Math.sin(r);\r\n                out[o + 2] = r;\r\n            };\r\n            PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n                var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n                out[o] = x1 + p * Math.cos(r);\r\n                out[o + 1] = y1 + p * Math.sin(r);\r\n                out[o + 2] = r;\r\n            };\r\n            PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n                if (p == 0 || isNaN(p))\r\n                    p = 0.0001;\r\n                var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n                var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n                out[o] = x;\r\n                out[o + 1] = y;\r\n                if (tangents)\r\n                    out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n            };\r\n            PathConstraint.NONE = -1;\r\n            PathConstraint.BEFORE = -2;\r\n            PathConstraint.AFTER = -3;\r\n            PathConstraint.epsilon = 0.00001;\r\n            return PathConstraint;\r\n        }());\r\n        core.PathConstraint = PathConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathConstraintData = (function (_super) {\r\n            __extends(PathConstraintData, _super);\r\n            function PathConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                return _this;\r\n            }\r\n            return PathConstraintData;\r\n        }(core.ConstraintData));\r\n        core.PathConstraintData = PathConstraintData;\r\n        var PositionMode;\r\n        (function (PositionMode) {\r\n            PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n            PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n        })(PositionMode = core.PositionMode || (core.PositionMode = {}));\r\n        var SpacingMode;\r\n        (function (SpacingMode) {\r\n            SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n            SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n            SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));\r\n        var RotateMode;\r\n        (function (RotateMode) {\r\n            RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n            RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n            RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n        })(RotateMode = core.RotateMode || (core.RotateMode = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Skeleton = (function () {\r\n            function Skeleton(data) {\r\n                this._updateCache = new Array();\r\n                this.updateCacheReset = new Array();\r\n                this.time = 0;\r\n                this.scaleX = 1;\r\n                this.scaleY = 1;\r\n                this.x = 0;\r\n                this.y = 0;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                this.data = data;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++) {\r\n                    var boneData = data.bones[i];\r\n                    var bone = void 0;\r\n                    if (boneData.parent == null)\r\n                        bone = new core.Bone(boneData, this, null);\r\n                    else {\r\n                        var parent_1 = this.bones[boneData.parent.index];\r\n                        bone = new core.Bone(boneData, this, parent_1);\r\n                        parent_1.children.push(bone);\r\n                    }\r\n                    this.bones.push(bone);\r\n                }\r\n                this.slots = new Array();\r\n                this.drawOrder = new Array();\r\n                for (var i = 0; i < data.slots.length; i++) {\r\n                    var slotData = data.slots[i];\r\n                    var bone = this.bones[slotData.boneData.index];\r\n                    var slot = new core.Slot(slotData, bone);\r\n                    this.slots.push(slot);\r\n                    this.drawOrder.push(slot);\r\n                }\r\n                this.ikConstraints = new Array();\r\n                for (var i = 0; i < data.ikConstraints.length; i++) {\r\n                    var ikConstraintData = data.ikConstraints[i];\r\n                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));\r\n                }\r\n                this.transformConstraints = new Array();\r\n                for (var i = 0; i < data.transformConstraints.length; i++) {\r\n                    var transformConstraintData = data.transformConstraints[i];\r\n                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));\r\n                }\r\n                this.pathConstraints = new Array();\r\n                for (var i = 0; i < data.pathConstraints.length; i++) {\r\n                    var pathConstraintData = data.pathConstraints[i];\r\n                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));\r\n                }\r\n                this.color = new core.Color(1, 1, 1, 1);\r\n                this.updateCache();\r\n            }\r\n            Skeleton.prototype.updateCache = function () {\r\n                var updateCache = this._updateCache;\r\n                updateCache.length = 0;\r\n                this.updateCacheReset.length = 0;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    bone.sorted = bone.data.skinRequired;\r\n                    bone.active = !bone.sorted;\r\n                }\r\n                if (this.skin != null) {\r\n                    var skinBones = this.skin.bones;\r\n                    for (var i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                        var bone = this.bones[skinBones[i].index];\r\n                        do {\r\n                            bone.sorted = false;\r\n                            bone.active = true;\r\n                            bone = bone.parent;\r\n                        } while (bone != null);\r\n                    }\r\n                }\r\n                var ikConstraints = this.ikConstraints;\r\n                var transformConstraints = this.transformConstraints;\r\n                var pathConstraints = this.pathConstraints;\r\n                var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n                var constraintCount = ikCount + transformCount + pathCount;\r\n                outer: for (var i = 0; i < constraintCount; i++) {\r\n                    for (var ii = 0; ii < ikCount; ii++) {\r\n                        var constraint = ikConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortIkConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (var ii = 0; ii < transformCount; ii++) {\r\n                        var constraint = transformConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortTransformConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (var ii = 0; ii < pathCount; ii++) {\r\n                        var constraint = pathConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortPathConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    this.sortBone(bones[i]);\r\n            };\r\n            Skeleton.prototype.sortIkConstraint = function (constraint) {\r\n                constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                var target = constraint.target;\r\n                this.sortBone(target);\r\n                var constrained = constraint.bones;\r\n                var parent = constrained[0];\r\n                this.sortBone(parent);\r\n                if (constrained.length > 1) {\r\n                    var child = constrained[constrained.length - 1];\r\n                    if (!(this._updateCache.indexOf(child) > -1))\r\n                        this.updateCacheReset.push(child);\r\n                }\r\n                this._updateCache.push(constraint);\r\n                this.sortReset(parent.children);\r\n                constrained[constrained.length - 1].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortPathConstraint = function (constraint) {\r\n                constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                var slot = constraint.target;\r\n                var slotIndex = slot.data.index;\r\n                var slotBone = slot.bone;\r\n                if (this.skin != null)\r\n                    this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n                    this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n                for (var i = 0, n = this.data.skins.length; i < n; i++)\r\n                    this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n                var attachment = slot.getAttachment();\r\n                if (attachment instanceof core.PathAttachment)\r\n                    this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n                var constrained = constraint.bones;\r\n                var boneCount = constrained.length;\r\n                for (var i = 0; i < boneCount; i++)\r\n                    this.sortBone(constrained[i]);\r\n                this._updateCache.push(constraint);\r\n                for (var i = 0; i < boneCount; i++)\r\n                    this.sortReset(constrained[i].children);\r\n                for (var i = 0; i < boneCount; i++)\r\n                    constrained[i].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortTransformConstraint = function (constraint) {\r\n                constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && core.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n                if (!constraint.active)\r\n                    return;\r\n                this.sortBone(constraint.target);\r\n                var constrained = constraint.bones;\r\n                var boneCount = constrained.length;\r\n                if (constraint.data.local) {\r\n                    for (var i = 0; i < boneCount; i++) {\r\n                        var child = constrained[i];\r\n                        this.sortBone(child.parent);\r\n                        if (!(this._updateCache.indexOf(child) > -1))\r\n                            this.updateCacheReset.push(child);\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 0; i < boneCount; i++) {\r\n                        this.sortBone(constrained[i]);\r\n                    }\r\n                }\r\n                this._updateCache.push(constraint);\r\n                for (var ii = 0; ii < boneCount; ii++)\r\n                    this.sortReset(constrained[ii].children);\r\n                for (var ii = 0; ii < boneCount; ii++)\r\n                    constrained[ii].sorted = true;\r\n            };\r\n            Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n                var attachments = skin.attachments[slotIndex];\r\n                if (!attachments)\r\n                    return;\r\n                for (var key in attachments) {\r\n                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n                }\r\n            };\r\n            Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n                if (!(attachment instanceof core.PathAttachment))\r\n                    return;\r\n                var pathBones = attachment.bones;\r\n                if (pathBones == null)\r\n                    this.sortBone(slotBone);\r\n                else {\r\n                    var bones = this.bones;\r\n                    var i = 0;\r\n                    while (i < pathBones.length) {\r\n                        var boneCount = pathBones[i++];\r\n                        for (var n = i + boneCount; i < n; i++) {\r\n                            var boneIndex = pathBones[i];\r\n                            this.sortBone(bones[boneIndex]);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            Skeleton.prototype.sortBone = function (bone) {\r\n                if (bone.sorted)\r\n                    return;\r\n                var parent = bone.parent;\r\n                if (parent != null)\r\n                    this.sortBone(parent);\r\n                bone.sorted = true;\r\n                this._updateCache.push(bone);\r\n            };\r\n            Skeleton.prototype.sortReset = function (bones) {\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.active)\r\n                        continue;\r\n                    if (bone.sorted)\r\n                        this.sortReset(bone.children);\r\n                    bone.sorted = false;\r\n                }\r\n            };\r\n            Skeleton.prototype.updateWorldTransform = function () {\r\n                var updateCacheReset = this.updateCacheReset;\r\n                for (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n                    var bone = updateCacheReset[i];\r\n                    bone.ax = bone.x;\r\n                    bone.ay = bone.y;\r\n                    bone.arotation = bone.rotation;\r\n                    bone.ascaleX = bone.scaleX;\r\n                    bone.ascaleY = bone.scaleY;\r\n                    bone.ashearX = bone.shearX;\r\n                    bone.ashearY = bone.shearY;\r\n                    bone.appliedValid = true;\r\n                }\r\n                var updateCache = this._updateCache;\r\n                for (var i = 0, n = updateCache.length; i < n; i++)\r\n                    updateCache[i].update();\r\n            };\r\n            Skeleton.prototype.setToSetupPose = function () {\r\n                this.setBonesToSetupPose();\r\n                this.setSlotsToSetupPose();\r\n            };\r\n            Skeleton.prototype.setBonesToSetupPose = function () {\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    bones[i].setToSetupPose();\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var constraint = ikConstraints[i];\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                }\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    var data = constraint.data;\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                    constraint.scaleMix = data.scaleMix;\r\n                    constraint.shearMix = data.shearMix;\r\n                }\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    var data = constraint.data;\r\n                    constraint.position = data.position;\r\n                    constraint.spacing = data.spacing;\r\n                    constraint.rotateMix = data.rotateMix;\r\n                    constraint.translateMix = data.translateMix;\r\n                }\r\n            };\r\n            Skeleton.prototype.setSlotsToSetupPose = function () {\r\n                var slots = this.slots;\r\n                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    slots[i].setToSetupPose();\r\n            };\r\n            Skeleton.prototype.getRootBone = function () {\r\n                if (this.bones.length == 0)\r\n                    return null;\r\n                return this.bones[0];\r\n            };\r\n            Skeleton.prototype.findBone = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (bone.data.name == boneName)\r\n                        return bone;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findBoneIndex = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    if (bones[i].data.name == boneName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            Skeleton.prototype.findSlot = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.data.name == slotName)\r\n                        return slot;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findSlotIndex = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    if (slots[i].data.name == slotName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            Skeleton.prototype.setSkinByName = function (skinName) {\r\n                var skin = this.data.findSkin(skinName);\r\n                if (skin == null)\r\n                    throw new Error(\"Skin not found: \" + skinName);\r\n                this.setSkin(skin);\r\n            };\r\n            Skeleton.prototype.setSkin = function (newSkin) {\r\n                if (newSkin == this.skin)\r\n                    return;\r\n                if (newSkin != null) {\r\n                    if (this.skin != null)\r\n                        newSkin.attachAll(this, this.skin);\r\n                    else {\r\n                        var slots = this.slots;\r\n                        for (var i = 0, n = slots.length; i < n; i++) {\r\n                            var slot = slots[i];\r\n                            var name_1 = slot.data.attachmentName;\r\n                            if (name_1 != null) {\r\n                                var attachment = newSkin.getAttachment(i, name_1);\r\n                                if (attachment != null)\r\n                                    slot.setAttachment(attachment);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.skin = newSkin;\r\n                this.updateCache();\r\n            };\r\n            Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n            };\r\n            Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n                if (attachmentName == null)\r\n                    throw new Error(\"attachmentName cannot be null.\");\r\n                if (this.skin != null) {\r\n                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n                    if (attachment != null)\r\n                        return attachment;\r\n                }\r\n                if (this.data.defaultSkin != null)\r\n                    return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n                return null;\r\n            };\r\n            Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.data.name == slotName) {\r\n                        var attachment = null;\r\n                        if (attachmentName != null) {\r\n                            attachment = this.getAttachment(i, attachmentName);\r\n                            if (attachment == null)\r\n                                throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                        }\r\n                        slot.setAttachment(attachment);\r\n                        return;\r\n                    }\r\n                }\r\n                throw new Error(\"Slot not found: \" + slotName);\r\n            };\r\n            Skeleton.prototype.findIkConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var ikConstraint = ikConstraints[i];\r\n                    if (ikConstraint.data.name == constraintName)\r\n                        return ikConstraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findTransformConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    if (constraint.data.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.findPathConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    if (constraint.data.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            Skeleton.prototype.getBounds = function (offset, size, temp) {\r\n                if (temp === void 0) { temp = new Array(2); }\r\n                if (offset == null)\r\n                    throw new Error(\"offset cannot be null.\");\r\n                if (size == null)\r\n                    throw new Error(\"size cannot be null.\");\r\n                var drawOrder = this.drawOrder;\r\n                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                    var slot = drawOrder[i];\r\n                    if (!slot.bone.active)\r\n                        continue;\r\n                    var verticesLength = 0;\r\n                    var vertices = null;\r\n                    var attachment = slot.getAttachment();\r\n                    if (attachment instanceof core.RegionAttachment) {\r\n                        verticesLength = 8;\r\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\r\n                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n                    }\r\n                    else if (attachment instanceof core.MeshAttachment) {\r\n                        var mesh = attachment;\r\n                        verticesLength = mesh.worldVerticesLength;\r\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\r\n                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n                    }\r\n                    if (vertices != null) {\r\n                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                            var x = vertices[ii], y = vertices[ii + 1];\r\n                            minX = Math.min(minX, x);\r\n                            minY = Math.min(minY, y);\r\n                            maxX = Math.max(maxX, x);\r\n                            maxY = Math.max(maxY, y);\r\n                        }\r\n                    }\r\n                }\r\n                offset.set(minX, minY);\r\n                size.set(maxX - minX, maxY - minY);\r\n            };\r\n            Skeleton.prototype.update = function (delta) {\r\n                this.time += delta;\r\n            };\r\n            Object.defineProperty(Skeleton.prototype, \"flipX\", {\r\n                get: function () {\r\n                    return this.scaleX == -1;\r\n                },\r\n                set: function (value) {\r\n                    if (!Skeleton.deprecatedWarning1) {\r\n                        Skeleton.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n                    }\r\n                    this.scaleX = value ? 1.0 : -1.0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(Skeleton.prototype, \"flipY\", {\r\n                get: function () {\r\n                    return this.scaleY == -1;\r\n                },\r\n                set: function (value) {\r\n                    if (!Skeleton.deprecatedWarning1) {\r\n                        Skeleton.deprecatedWarning1 = true;\r\n                        console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n                    }\r\n                    this.scaleY = value ? 1.0 : -1.0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Skeleton.deprecatedWarning1 = false;\r\n            return Skeleton;\r\n        }());\r\n        core.Skeleton = Skeleton;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonBinary = (function () {\r\n            function SkeletonBinary(attachmentLoader) {\r\n                this.scale = 1;\r\n                this.linkedMeshes = new Array();\r\n                this.attachmentLoader = attachmentLoader;\r\n            }\r\n            SkeletonBinary.prototype.readSkeletonData = function (binary) {\r\n                var scale = this.scale;\r\n                var skeletonData = new core.SkeletonData();\r\n                skeletonData.name = \"\";\r\n                var input = new BinaryInput(binary);\r\n                skeletonData.hash = input.readString();\r\n                skeletonData.version = input.readString();\r\n                if (skeletonData.version === '3.8.75') {\r\n                    var error = \"Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.\";\r\n                    console.error(error);\r\n                }\r\n                skeletonData.x = input.readFloat();\r\n                skeletonData.y = input.readFloat();\r\n                skeletonData.width = input.readFloat();\r\n                skeletonData.height = input.readFloat();\r\n                var nonessential = input.readBoolean();\r\n                if (nonessential) {\r\n                    skeletonData.fps = input.readFloat();\r\n                    skeletonData.imagesPath = input.readString();\r\n                    skeletonData.audioPath = input.readString();\r\n                }\r\n                var n = 0;\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++)\r\n                    input.strings.push(input.readString());\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var name_2 = input.readString();\r\n                    var parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n                    var data = new core.BoneData(i, name_2, parent_2);\r\n                    data.rotation = input.readFloat();\r\n                    data.x = input.readFloat() * scale;\r\n                    data.y = input.readFloat() * scale;\r\n                    data.scaleX = input.readFloat();\r\n                    data.scaleY = input.readFloat();\r\n                    data.shearX = input.readFloat();\r\n                    data.shearY = input.readFloat();\r\n                    data.length = input.readFloat() * scale;\r\n                    data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n                    data.skinRequired = input.readBoolean();\r\n                    if (nonessential)\r\n                        core.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                    skeletonData.bones.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var slotName = input.readString();\r\n                    var boneData = skeletonData.bones[input.readInt(true)];\r\n                    var data = new core.SlotData(i, slotName, boneData);\r\n                    core.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                    var darkColor = input.readInt32();\r\n                    if (darkColor != -1)\r\n                        core.Color.rgb888ToColor(data.darkColor = new core.Color(), darkColor);\r\n                    data.attachmentName = input.readStringRef();\r\n                    data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n                    skeletonData.slots.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.IkConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.bones[input.readInt(true)];\r\n                    data.mix = input.readFloat();\r\n                    data.softness = input.readFloat() * scale;\r\n                    data.bendDirection = input.readByte();\r\n                    data.compress = input.readBoolean();\r\n                    data.stretch = input.readBoolean();\r\n                    data.uniform = input.readBoolean();\r\n                    skeletonData.ikConstraints.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.TransformConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.bones[input.readInt(true)];\r\n                    data.local = input.readBoolean();\r\n                    data.relative = input.readBoolean();\r\n                    data.offsetRotation = input.readFloat();\r\n                    data.offsetX = input.readFloat() * scale;\r\n                    data.offsetY = input.readFloat() * scale;\r\n                    data.offsetScaleX = input.readFloat();\r\n                    data.offsetScaleY = input.readFloat();\r\n                    data.offsetShearY = input.readFloat();\r\n                    data.rotateMix = input.readFloat();\r\n                    data.translateMix = input.readFloat();\r\n                    data.scaleMix = input.readFloat();\r\n                    data.shearMix = input.readFloat();\r\n                    skeletonData.transformConstraints.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0, nn = void 0; i < n; i++) {\r\n                    var data = new core.PathConstraintData(input.readString());\r\n                    data.order = input.readInt(true);\r\n                    data.skinRequired = input.readBoolean();\r\n                    nn = input.readInt(true);\r\n                    for (var ii = 0; ii < nn; ii++)\r\n                        data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                    data.target = skeletonData.slots[input.readInt(true)];\r\n                    data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n                    data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n                    data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n                    data.offsetRotation = input.readFloat();\r\n                    data.position = input.readFloat();\r\n                    if (data.positionMode == core.PositionMode.Fixed)\r\n                        data.position *= scale;\r\n                    data.spacing = input.readFloat();\r\n                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                        data.spacing *= scale;\r\n                    data.rotateMix = input.readFloat();\r\n                    data.translateMix = input.readFloat();\r\n                    skeletonData.pathConstraints.push(data);\r\n                }\r\n                var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n                if (defaultSkin != null) {\r\n                    skeletonData.defaultSkin = defaultSkin;\r\n                    skeletonData.skins.push(defaultSkin);\r\n                }\r\n                {\r\n                    var i = skeletonData.skins.length;\r\n                    core.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n                    for (; i < n; i++)\r\n                        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n                }\r\n                n = this.linkedMeshes.length;\r\n                for (var i = 0; i < n; i++) {\r\n                    var linkedMesh = this.linkedMeshes[i];\r\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                    if (skin == null)\r\n                        throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                    if (parent_3 == null)\r\n                        throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;\r\n                    linkedMesh.mesh.setParentMesh(parent_3);\r\n                }\r\n                this.linkedMeshes.length = 0;\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++) {\r\n                    var data = new core.EventData(input.readStringRef());\r\n                    data.intValue = input.readInt(false);\r\n                    data.floatValue = input.readFloat();\r\n                    data.stringValue = input.readString();\r\n                    data.audioPath = input.readString();\r\n                    if (data.audioPath != null) {\r\n                        data.volume = input.readFloat();\r\n                        data.balance = input.readFloat();\r\n                    }\r\n                    skeletonData.events.push(data);\r\n                }\r\n                n = input.readInt(true);\r\n                for (var i = 0; i < n; i++)\r\n                    skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n                return skeletonData;\r\n            };\r\n            SkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {\r\n                var skin = null;\r\n                var slotCount = 0;\r\n                if (defaultSkin) {\r\n                    slotCount = input.readInt(true);\r\n                    if (slotCount == 0)\r\n                        return null;\r\n                    skin = new core.Skin(\"default\");\r\n                }\r\n                else {\r\n                    skin = new core.Skin(input.readStringRef());\r\n                    skin.bones.length = input.readInt(true);\r\n                    for (var i = 0, n = skin.bones.length; i < n; i++)\r\n                        skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n                    for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n                    slotCount = input.readInt(true);\r\n                }\r\n                for (var i = 0; i < slotCount; i++) {\r\n                    var slotIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var name_3 = input.readStringRef();\r\n                        var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);\r\n                        if (attachment != null)\r\n                            skin.setAttachment(slotIndex, name_3, attachment);\r\n                    }\r\n                }\r\n                return skin;\r\n            };\r\n            SkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\r\n                var scale = this.scale;\r\n                var name = input.readStringRef();\r\n                if (name == null)\r\n                    name = attachmentName;\r\n                var typeIndex = input.readByte();\r\n                var type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n                switch (type) {\r\n                    case core.AttachmentType.Region: {\r\n                        var path = input.readStringRef();\r\n                        var rotation = input.readFloat();\r\n                        var x = input.readFloat();\r\n                        var y = input.readFloat();\r\n                        var scaleX = input.readFloat();\r\n                        var scaleY = input.readFloat();\r\n                        var width = input.readFloat();\r\n                        var height = input.readFloat();\r\n                        var color = input.readInt32();\r\n                        if (path == null)\r\n                            path = name;\r\n                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                        if (region == null)\r\n                            return null;\r\n                        region.path = path;\r\n                        region.x = x * scale;\r\n                        region.y = y * scale;\r\n                        region.scaleX = scaleX;\r\n                        region.scaleY = scaleY;\r\n                        region.rotation = rotation;\r\n                        region.width = width * scale;\r\n                        region.height = height * scale;\r\n                        core.Color.rgba8888ToColor(region.color, color);\r\n                        return region;\r\n                    }\r\n                    case core.AttachmentType.BoundingBox: {\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                        if (box == null)\r\n                            return null;\r\n                        box.worldVerticesLength = vertexCount << 1;\r\n                        box.vertices = vertices.vertices;\r\n                        box.bones = vertices.bones;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(box.color, color);\r\n                        return box;\r\n                    }\r\n                    case core.AttachmentType.Mesh: {\r\n                        var path = input.readStringRef();\r\n                        var color = input.readInt32();\r\n                        var vertexCount = input.readInt(true);\r\n                        var uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                        var triangles = this.readShortArray(input);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var hullLength = input.readInt(true);\r\n                        var edges = null;\r\n                        var width = 0, height = 0;\r\n                        if (nonessential) {\r\n                            edges = this.readShortArray(input);\r\n                            width = input.readFloat();\r\n                            height = input.readFloat();\r\n                        }\r\n                        if (path == null)\r\n                            path = name;\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        core.Color.rgba8888ToColor(mesh.color, color);\r\n                        mesh.bones = vertices.bones;\r\n                        mesh.vertices = vertices.vertices;\r\n                        mesh.worldVerticesLength = vertexCount << 1;\r\n                        mesh.triangles = triangles;\r\n                        mesh.regionUVs = new Float32Array(uvs);\r\n                        mesh.hullLength = hullLength << 1;\r\n                        if (nonessential) {\r\n                            mesh.edges = edges;\r\n                            mesh.width = width * scale;\r\n                            mesh.height = height * scale;\r\n                        }\r\n                        return mesh;\r\n                    }\r\n                    case core.AttachmentType.LinkedMesh: {\r\n                        var path = input.readStringRef();\r\n                        var color = input.readInt32();\r\n                        var skinName = input.readStringRef();\r\n                        var parent_4 = input.readStringRef();\r\n                        var inheritDeform = input.readBoolean();\r\n                        var width = 0, height = 0;\r\n                        if (nonessential) {\r\n                            width = input.readFloat();\r\n                            height = input.readFloat();\r\n                        }\r\n                        if (path == null)\r\n                            path = name;\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        core.Color.rgba8888ToColor(mesh.color, color);\r\n                        if (nonessential) {\r\n                            mesh.width = width * scale;\r\n                            mesh.height = height * scale;\r\n                        }\r\n                        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));\r\n                        return mesh;\r\n                    }\r\n                    case core.AttachmentType.Path: {\r\n                        var closed_1 = input.readBoolean();\r\n                        var constantSpeed = input.readBoolean();\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var lengths = core.Utils.newArray(vertexCount / 3, 0);\r\n                        for (var i = 0, n = lengths.length; i < n; i++)\r\n                            lengths[i] = input.readFloat() * scale;\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                        if (path == null)\r\n                            return null;\r\n                        path.closed = closed_1;\r\n                        path.constantSpeed = constantSpeed;\r\n                        path.worldVerticesLength = vertexCount << 1;\r\n                        path.vertices = vertices.vertices;\r\n                        path.bones = vertices.bones;\r\n                        path.lengths = lengths;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(path.color, color);\r\n                        return path;\r\n                    }\r\n                    case core.AttachmentType.Point: {\r\n                        var rotation = input.readFloat();\r\n                        var x = input.readFloat();\r\n                        var y = input.readFloat();\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                        if (point == null)\r\n                            return null;\r\n                        point.x = x * scale;\r\n                        point.y = y * scale;\r\n                        point.rotation = rotation;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(point.color, color);\r\n                        return point;\r\n                    }\r\n                    case core.AttachmentType.Clipping: {\r\n                        var endSlotIndex = input.readInt(true);\r\n                        var vertexCount = input.readInt(true);\r\n                        var vertices = this.readVertices(input, vertexCount);\r\n                        var color = nonessential ? input.readInt32() : 0;\r\n                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                        if (clip == null)\r\n                            return null;\r\n                        clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                        clip.worldVerticesLength = vertexCount << 1;\r\n                        clip.vertices = vertices.vertices;\r\n                        clip.bones = vertices.bones;\r\n                        if (nonessential)\r\n                            core.Color.rgba8888ToColor(clip.color, color);\r\n                        return clip;\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonBinary.prototype.readVertices = function (input, vertexCount) {\r\n                var verticesLength = vertexCount << 1;\r\n                var vertices = new Vertices();\r\n                var scale = this.scale;\r\n                if (!input.readBoolean()) {\r\n                    vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n                    return vertices;\r\n                }\r\n                var weights = new Array();\r\n                var bonesArray = new Array();\r\n                for (var i = 0; i < vertexCount; i++) {\r\n                    var boneCount = input.readInt(true);\r\n                    bonesArray.push(boneCount);\r\n                    for (var ii = 0; ii < boneCount; ii++) {\r\n                        bonesArray.push(input.readInt(true));\r\n                        weights.push(input.readFloat() * scale);\r\n                        weights.push(input.readFloat() * scale);\r\n                        weights.push(input.readFloat());\r\n                    }\r\n                }\r\n                vertices.vertices = core.Utils.toFloatArray(weights);\r\n                vertices.bones = bonesArray;\r\n                return vertices;\r\n            };\r\n            SkeletonBinary.prototype.readFloatArray = function (input, n, scale) {\r\n                var array = new Array(n);\r\n                if (scale == 1) {\r\n                    for (var i = 0; i < n; i++)\r\n                        array[i] = input.readFloat();\r\n                }\r\n                else {\r\n                    for (var i = 0; i < n; i++)\r\n                        array[i] = input.readFloat() * scale;\r\n                }\r\n                return array;\r\n            };\r\n            SkeletonBinary.prototype.readShortArray = function (input) {\r\n                var n = input.readInt(true);\r\n                var array = new Array(n);\r\n                for (var i = 0; i < n; i++)\r\n                    array[i] = input.readShort();\r\n                return array;\r\n            };\r\n            SkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {\r\n                var timelines = new Array();\r\n                var scale = this.scale;\r\n                var duration = 0;\r\n                var tempColor1 = new core.Color();\r\n                var tempColor2 = new core.Color();\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var slotIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                                var timeline = new core.AttachmentTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.SLOT_COLOR: {\r\n                                var timeline = new core.ColorTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    var time = input.readFloat();\r\n                                    core.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                    timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.ColorTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.SLOT_TWO_COLOR: {\r\n                                var timeline = new core.TwoColorTimeline(frameCount);\r\n                                timeline.slotIndex = slotIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    var time = input.readFloat();\r\n                                    core.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                    core.Color.rgb888ToColor(tempColor2, input.readInt32());\r\n                                    timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TwoColorTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var boneIndex = input.readInt(true);\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.BONE_ROTATE: {\r\n                                var timeline = new core.RotateTimeline(frameCount);\r\n                                timeline.boneIndex = boneIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.RotateTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.BONE_TRANSLATE:\r\n                            case SkeletonBinary.BONE_SCALE:\r\n                            case SkeletonBinary.BONE_SHEAR: {\r\n                                var timeline = void 0;\r\n                                var timelineScale = 1;\r\n                                if (timelineType == SkeletonBinary.BONE_SCALE)\r\n                                    timeline = new core.ScaleTimeline(frameCount);\r\n                                else if (timelineType == SkeletonBinary.BONE_SHEAR)\r\n                                    timeline = new core.ShearTimeline(frameCount);\r\n                                else {\r\n                                    timeline = new core.TranslateTimeline(frameCount);\r\n                                    timelineScale = scale;\r\n                                }\r\n                                timeline.boneIndex = boneIndex;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TranslateTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var frameCount = input.readInt(true);\r\n                    var timeline = new core.IkConstraintTimeline(frameCount);\r\n                    timeline.ikConstraintIndex = index;\r\n                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                        if (frameIndex < frameCount - 1)\r\n                            this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.IkConstraintTimeline.ENTRIES]);\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var frameCount = input.readInt(true);\r\n                    var timeline = new core.TransformConstraintTimeline(frameCount);\r\n                    timeline.transformConstraintIndex = index;\r\n                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                        if (frameIndex < frameCount - 1)\r\n                            this.readCurve(input, frameIndex, timeline);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.TransformConstraintTimeline.ENTRIES]);\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var index = input.readInt(true);\r\n                    var data = skeletonData.pathConstraints[index];\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var timelineType = input.readByte();\r\n                        var frameCount = input.readInt(true);\r\n                        switch (timelineType) {\r\n                            case SkeletonBinary.PATH_POSITION:\r\n                            case SkeletonBinary.PATH_SPACING: {\r\n                                var timeline = void 0;\r\n                                var timelineScale = 1;\r\n                                if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                                    timeline = new core.PathConstraintSpacingTimeline(frameCount);\r\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                else {\r\n                                    timeline = new core.PathConstraintPositionTimeline(frameCount);\r\n                                    if (data.positionMode == core.PositionMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                timeline.pathConstraintIndex = index;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                            case SkeletonBinary.PATH_MIX: {\r\n                                var timeline = new core.PathConstraintMixTimeline(frameCount);\r\n                                timeline.pathConstraintIndex = index;\r\n                                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n                                    if (frameIndex < frameCount - 1)\r\n                                        this.readCurve(input, frameIndex, timeline);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(frameCount - 1) * core.PathConstraintMixTimeline.ENTRIES]);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                    var skin = skeletonData.skins[input.readInt(true)];\r\n                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                        var slotIndex = input.readInt(true);\r\n                        for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                            var attachment = skin.getAttachment(slotIndex, input.readStringRef());\r\n                            var weighted = attachment.bones != null;\r\n                            var vertices = attachment.vertices;\r\n                            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                            var frameCount = input.readInt(true);\r\n                            var timeline = new core.DeformTimeline(frameCount);\r\n                            timeline.slotIndex = slotIndex;\r\n                            timeline.attachment = attachment;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                var time = input.readFloat();\r\n                                var deform = void 0;\r\n                                var end = input.readInt(true);\r\n                                if (end == 0)\r\n                                    deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = core.Utils.newFloatArray(deformLength);\r\n                                    var start = input.readInt(true);\r\n                                    end += start;\r\n                                    if (scale == 1) {\r\n                                        for (var v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat();\r\n                                    }\r\n                                    else {\r\n                                        for (var v = start; v < end; v++)\r\n                                            deform[v] = input.readFloat() * scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (var v = 0, vn = deform.length; v < vn; v++)\r\n                                            deform[v] += vertices[v];\r\n                                    }\r\n                                }\r\n                                timeline.setFrame(frameIndex, time, deform);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                        }\r\n                    }\r\n                }\r\n                var drawOrderCount = input.readInt(true);\r\n                if (drawOrderCount > 0) {\r\n                    var timeline = new core.DrawOrderTimeline(drawOrderCount);\r\n                    var slotCount = skeletonData.slots.length;\r\n                    for (var i = 0; i < drawOrderCount; i++) {\r\n                        var time = input.readFloat();\r\n                        var offsetCount = input.readInt(true);\r\n                        var drawOrder = core.Utils.newArray(slotCount, 0);\r\n                        for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                            drawOrder[ii] = -1;\r\n                        var unchanged = core.Utils.newArray(slotCount - offsetCount, 0);\r\n                        var originalIndex = 0, unchangedIndex = 0;\r\n                        for (var ii = 0; ii < offsetCount; ii++) {\r\n                            var slotIndex = input.readInt(true);\r\n                            while (originalIndex != slotIndex)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                        }\r\n                        while (originalIndex < slotCount)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                            if (drawOrder[ii] == -1)\r\n                                drawOrder[ii] = unchanged[--unchangedIndex];\r\n                        timeline.setFrame(i, time, drawOrder);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n                }\r\n                var eventCount = input.readInt(true);\r\n                if (eventCount > 0) {\r\n                    var timeline = new core.EventTimeline(eventCount);\r\n                    for (var i = 0; i < eventCount; i++) {\r\n                        var time = input.readFloat();\r\n                        var eventData = skeletonData.events[input.readInt(true)];\r\n                        var event_4 = new core.Event(time, eventData);\r\n                        event_4.intValue = input.readInt(false);\r\n                        event_4.floatValue = input.readFloat();\r\n                        event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                        if (event_4.data.audioPath != null) {\r\n                            event_4.volume = input.readFloat();\r\n                            event_4.balance = input.readFloat();\r\n                        }\r\n                        timeline.setFrame(i, event_4);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n                }\r\n                return new core.Animation(name, timelines, duration);\r\n            };\r\n            SkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {\r\n                switch (input.readByte()) {\r\n                    case SkeletonBinary.CURVE_STEPPED:\r\n                        timeline.setStepped(frameIndex);\r\n                        break;\r\n                    case SkeletonBinary.CURVE_BEZIER:\r\n                        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                        break;\r\n                }\r\n            };\r\n            SkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {\r\n                timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n            };\r\n            SkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];\r\n            SkeletonBinary.TransformModeValues = [core.TransformMode.Normal, core.TransformMode.OnlyTranslation, core.TransformMode.NoRotationOrReflection, core.TransformMode.NoScale, core.TransformMode.NoScaleOrReflection];\r\n            SkeletonBinary.PositionModeValues = [core.PositionMode.Fixed, core.PositionMode.Percent];\r\n            SkeletonBinary.SpacingModeValues = [core.SpacingMode.Length, core.SpacingMode.Fixed, core.SpacingMode.Percent];\r\n            SkeletonBinary.RotateModeValues = [core.RotateMode.Tangent, core.RotateMode.Chain, core.RotateMode.ChainScale];\r\n            SkeletonBinary.BlendModeValues = [core.BlendMode.Normal, core.BlendMode.Additive, core.BlendMode.Multiply, core.BlendMode.Screen];\r\n            SkeletonBinary.BONE_ROTATE = 0;\r\n            SkeletonBinary.BONE_TRANSLATE = 1;\r\n            SkeletonBinary.BONE_SCALE = 2;\r\n            SkeletonBinary.BONE_SHEAR = 3;\r\n            SkeletonBinary.SLOT_ATTACHMENT = 0;\r\n            SkeletonBinary.SLOT_COLOR = 1;\r\n            SkeletonBinary.SLOT_TWO_COLOR = 2;\r\n            SkeletonBinary.PATH_POSITION = 0;\r\n            SkeletonBinary.PATH_SPACING = 1;\r\n            SkeletonBinary.PATH_MIX = 2;\r\n            SkeletonBinary.CURVE_LINEAR = 0;\r\n            SkeletonBinary.CURVE_STEPPED = 1;\r\n            SkeletonBinary.CURVE_BEZIER = 2;\r\n            return SkeletonBinary;\r\n        }());\r\n        core.SkeletonBinary = SkeletonBinary;\r\n        var BinaryInput = (function () {\r\n            function BinaryInput(data, strings, index, buffer) {\r\n                if (strings === void 0) { strings = new Array(); }\r\n                if (index === void 0) { index = 0; }\r\n                if (buffer === void 0) { buffer = new DataView(data.buffer); }\r\n                this.strings = strings;\r\n                this.index = index;\r\n                this.buffer = buffer;\r\n            }\r\n            BinaryInput.prototype.readByte = function () {\r\n                return this.buffer.getInt8(this.index++);\r\n            };\r\n            BinaryInput.prototype.readShort = function () {\r\n                var value = this.buffer.getInt16(this.index);\r\n                this.index += 2;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readInt32 = function () {\r\n                var value = this.buffer.getInt32(this.index);\r\n                this.index += 4;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readInt = function (optimizePositive) {\r\n                var b = this.readByte();\r\n                var result = b & 0x7F;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 7;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 14;\r\n                        if ((b & 0x80) != 0) {\r\n                            b = this.readByte();\r\n                            result |= (b & 0x7F) << 21;\r\n                            if ((b & 0x80) != 0) {\r\n                                b = this.readByte();\r\n                                result |= (b & 0x7F) << 28;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n            };\r\n            BinaryInput.prototype.readStringRef = function () {\r\n                var index = this.readInt(true);\r\n                return index == 0 ? null : this.strings[index - 1];\r\n            };\r\n            BinaryInput.prototype.readString = function () {\r\n                var byteCount = this.readInt(true);\r\n                switch (byteCount) {\r\n                    case 0:\r\n                        return null;\r\n                    case 1:\r\n                        return \"\";\r\n                }\r\n                byteCount--;\r\n                var chars = \"\";\r\n                var charCount = 0;\r\n                for (var i = 0; i < byteCount;) {\r\n                    var b = this.readByte();\r\n                    switch (b >> 4) {\r\n                        case 12:\r\n                        case 13:\r\n                            chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                            i += 2;\r\n                            break;\r\n                        case 14:\r\n                            chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                            i += 3;\r\n                            break;\r\n                        default:\r\n                            chars += String.fromCharCode(b);\r\n                            i++;\r\n                    }\r\n                }\r\n                return chars;\r\n            };\r\n            BinaryInput.prototype.readFloat = function () {\r\n                var value = this.buffer.getFloat32(this.index);\r\n                this.index += 4;\r\n                return value;\r\n            };\r\n            BinaryInput.prototype.readBoolean = function () {\r\n                return this.readByte() != 0;\r\n            };\r\n            return BinaryInput;\r\n        }());\r\n        var LinkedMesh = (function () {\r\n            function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n                this.mesh = mesh;\r\n                this.skin = skin;\r\n                this.slotIndex = slotIndex;\r\n                this.parent = parent;\r\n                this.inheritDeform = inheritDeform;\r\n            }\r\n            return LinkedMesh;\r\n        }());\r\n        var Vertices = (function () {\r\n            function Vertices(bones, vertices) {\r\n                if (bones === void 0) { bones = null; }\r\n                if (vertices === void 0) { vertices = null; }\r\n                this.bones = bones;\r\n                this.vertices = vertices;\r\n            }\r\n            return Vertices;\r\n        }());\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonBounds = (function () {\r\n            function SkeletonBounds() {\r\n                this.minX = 0;\r\n                this.minY = 0;\r\n                this.maxX = 0;\r\n                this.maxY = 0;\r\n                this.boundingBoxes = new Array();\r\n                this.polygons = new Array();\r\n                this.polygonPool = new core.Pool(function () {\r\n                    return core.Utils.newFloatArray(16);\r\n                });\r\n            }\r\n            SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                var boundingBoxes = this.boundingBoxes;\r\n                var polygons = this.polygons;\r\n                var polygonPool = this.polygonPool;\r\n                var slots = skeleton.slots;\r\n                var slotCount = slots.length;\r\n                boundingBoxes.length = 0;\r\n                polygonPool.freeAll(polygons);\r\n                polygons.length = 0;\r\n                for (var i = 0; i < slotCount; i++) {\r\n                    var slot = slots[i];\r\n                    if (!slot.bone.active)\r\n                        continue;\r\n                    var attachment = slot.getAttachment();\r\n                    if (attachment instanceof core.BoundingBoxAttachment) {\r\n                        var boundingBox = attachment;\r\n                        boundingBoxes.push(boundingBox);\r\n                        var polygon = polygonPool.obtain();\r\n                        if (polygon.length != boundingBox.worldVerticesLength) {\r\n                            polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                        }\r\n                        polygons.push(polygon);\r\n                        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n                    }\r\n                }\r\n                if (updateAabb) {\r\n                    this.aabbCompute();\r\n                }\r\n                else {\r\n                    this.minX = Number.POSITIVE_INFINITY;\r\n                    this.minY = Number.POSITIVE_INFINITY;\r\n                    this.maxX = Number.NEGATIVE_INFINITY;\r\n                    this.maxY = Number.NEGATIVE_INFINITY;\r\n                }\r\n            };\r\n            SkeletonBounds.prototype.aabbCompute = function () {\r\n                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++) {\r\n                    var polygon = polygons[i];\r\n                    var vertices = polygon;\r\n                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                        var x = vertices[ii];\r\n                        var y = vertices[ii + 1];\r\n                        minX = Math.min(minX, x);\r\n                        minY = Math.min(minY, y);\r\n                        maxX = Math.max(maxX, x);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                }\r\n                this.minX = minX;\r\n                this.minY = minY;\r\n                this.maxX = maxX;\r\n                this.maxY = maxY;\r\n            };\r\n            SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n            };\r\n            SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n                var minX = this.minX;\r\n                var minY = this.minY;\r\n                var maxX = this.maxX;\r\n                var maxY = this.maxY;\r\n                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n                    return false;\r\n                var m = (y2 - y1) / (x2 - x1);\r\n                var y = m * (minX - x1) + y1;\r\n                if (y > minY && y < maxY)\r\n                    return true;\r\n                y = m * (maxX - x1) + y1;\r\n                if (y > minY && y < maxY)\r\n                    return true;\r\n                var x = (minY - y1) / m + x1;\r\n                if (x > minX && x < maxX)\r\n                    return true;\r\n                x = (maxY - y1) / m + x1;\r\n                if (x > minX && x < maxX)\r\n                    return true;\r\n                return false;\r\n            };\r\n            SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n            };\r\n            SkeletonBounds.prototype.containsPoint = function (x, y) {\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++)\r\n                    if (this.containsPointPolygon(polygons[i], x, y))\r\n                        return this.boundingBoxes[i];\r\n                return null;\r\n            };\r\n            SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n                var vertices = polygon;\r\n                var nn = polygon.length;\r\n                var prevIndex = nn - 2;\r\n                var inside = false;\r\n                for (var ii = 0; ii < nn; ii += 2) {\r\n                    var vertexY = vertices[ii + 1];\r\n                    var prevY = vertices[prevIndex + 1];\r\n                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                        var vertexX = vertices[ii];\r\n                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n                            inside = !inside;\r\n                    }\r\n                    prevIndex = ii;\r\n                }\r\n                return inside;\r\n            };\r\n            SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n                var polygons = this.polygons;\r\n                for (var i = 0, n = polygons.length; i < n; i++)\r\n                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n                        return this.boundingBoxes[i];\r\n                return null;\r\n            };\r\n            SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n                var vertices = polygon;\r\n                var nn = polygon.length;\r\n                var width12 = x1 - x2, height12 = y1 - y2;\r\n                var det1 = x1 * y2 - y1 * x2;\r\n                var x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n                for (var ii = 0; ii < nn; ii += 2) {\r\n                    var x4 = vertices[ii], y4 = vertices[ii + 1];\r\n                    var det2 = x3 * y4 - y3 * x4;\r\n                    var width34 = x3 - x4, height34 = y3 - y4;\r\n                    var det3 = width12 * height34 - height12 * width34;\r\n                    var x = (det1 * width34 - width12 * det2) / det3;\r\n                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                        var y = (det1 * height34 - height12 * det2) / det3;\r\n                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n                            return true;\r\n                    }\r\n                    x3 = x4;\r\n                    y3 = y4;\r\n                }\r\n                return false;\r\n            };\r\n            SkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n                if (boundingBox == null)\r\n                    throw new Error(\"boundingBox cannot be null.\");\r\n                var index = this.boundingBoxes.indexOf(boundingBox);\r\n                return index == -1 ? null : this.polygons[index];\r\n            };\r\n            SkeletonBounds.prototype.getWidth = function () {\r\n                return this.maxX - this.minX;\r\n            };\r\n            SkeletonBounds.prototype.getHeight = function () {\r\n                return this.maxY - this.minY;\r\n            };\r\n            return SkeletonBounds;\r\n        }());\r\n        core.SkeletonBounds = SkeletonBounds;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonClipping = (function () {\r\n            function SkeletonClipping() {\r\n                this.triangulator = new core.Triangulator();\r\n                this.clippingPolygon = new Array();\r\n                this.clipOutput = new Array();\r\n                this.clippedVertices = new Array();\r\n                this.clippedTriangles = new Array();\r\n                this.scratch = new Array();\r\n            }\r\n            SkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n                if (this.clipAttachment != null)\r\n                    return 0;\r\n                this.clipAttachment = clip;\r\n                var n = clip.worldVerticesLength;\r\n                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);\r\n                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n                var clippingPolygon = this.clippingPolygon;\r\n                SkeletonClipping.makeClockwise(clippingPolygon);\r\n                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n                for (var i = 0, n_2 = clippingPolygons.length; i < n_2; i++) {\r\n                    var polygon = clippingPolygons[i];\r\n                    SkeletonClipping.makeClockwise(polygon);\r\n                    polygon.push(polygon[0]);\r\n                    polygon.push(polygon[1]);\r\n                }\r\n                return clippingPolygons.length;\r\n            };\r\n            SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n                if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n                    this.clipEnd();\r\n            };\r\n            SkeletonClipping.prototype.clipEnd = function () {\r\n                if (this.clipAttachment == null)\r\n                    return;\r\n                this.clipAttachment = null;\r\n                this.clippingPolygons = null;\r\n                this.clippedVertices.length = 0;\r\n                this.clippedTriangles.length = 0;\r\n                this.clippingPolygon.length = 0;\r\n            };\r\n            SkeletonClipping.prototype.isClipping = function () {\r\n                return this.clipAttachment != null;\r\n            };\r\n            SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n                var clippedTriangles = this.clippedTriangles;\r\n                var polygons = this.clippingPolygons;\r\n                var polygonsCount = this.clippingPolygons.length;\r\n                var vertexSize = twoColor ? 12 : 8;\r\n                var index = 0;\r\n                clippedVertices.length = 0;\r\n                clippedTriangles.length = 0;\r\n                outer: for (var i = 0; i < trianglesLength; i += 3) {\r\n                    var vertexOffset = triangles[i] << 1;\r\n                    var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n                    var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n                    vertexOffset = triangles[i + 1] << 1;\r\n                    var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n                    var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n                    vertexOffset = triangles[i + 2] << 1;\r\n                    var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n                    var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n                    for (var p = 0; p < polygonsCount; p++) {\r\n                        var s = clippedVertices.length;\r\n                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n                            var clipOutputLength = clipOutput.length;\r\n                            if (clipOutputLength == 0)\r\n                                continue;\r\n                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n                            var clipOutputCount = clipOutputLength >> 1;\r\n                            var clipOutputItems = this.clipOutput;\r\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n                            for (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n                                var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n                                clippedVerticesItems[s] = x;\r\n                                clippedVerticesItems[s + 1] = y;\r\n                                clippedVerticesItems[s + 2] = light.r;\r\n                                clippedVerticesItems[s + 3] = light.g;\r\n                                clippedVerticesItems[s + 4] = light.b;\r\n                                clippedVerticesItems[s + 5] = light.a;\r\n                                var c0 = x - x3, c1 = y - y3;\r\n                                var a = (d0 * c0 + d1 * c1) * d;\r\n                                var b = (d4 * c0 + d2 * c1) * d;\r\n                                var c = 1 - a - b;\r\n                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n                                if (twoColor) {\r\n                                    clippedVerticesItems[s + 8] = dark.r;\r\n                                    clippedVerticesItems[s + 9] = dark.g;\r\n                                    clippedVerticesItems[s + 10] = dark.b;\r\n                                    clippedVerticesItems[s + 11] = dark.a;\r\n                                }\r\n                                s += vertexSize;\r\n                            }\r\n                            s = clippedTriangles.length;\r\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n                            clipOutputCount--;\r\n                            for (var ii = 1; ii < clipOutputCount; ii++) {\r\n                                clippedTrianglesItems[s] = index;\r\n                                clippedTrianglesItems[s + 1] = (index + ii);\r\n                                clippedTrianglesItems[s + 2] = (index + ii + 1);\r\n                                s += 3;\r\n                            }\r\n                            index += clipOutputCount + 1;\r\n                        }\r\n                        else {\r\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n                            clippedVerticesItems[s] = x1;\r\n                            clippedVerticesItems[s + 1] = y1;\r\n                            clippedVerticesItems[s + 2] = light.r;\r\n                            clippedVerticesItems[s + 3] = light.g;\r\n                            clippedVerticesItems[s + 4] = light.b;\r\n                            clippedVerticesItems[s + 5] = light.a;\r\n                            if (!twoColor) {\r\n                                clippedVerticesItems[s + 6] = u1;\r\n                                clippedVerticesItems[s + 7] = v1;\r\n                                clippedVerticesItems[s + 8] = x2;\r\n                                clippedVerticesItems[s + 9] = y2;\r\n                                clippedVerticesItems[s + 10] = light.r;\r\n                                clippedVerticesItems[s + 11] = light.g;\r\n                                clippedVerticesItems[s + 12] = light.b;\r\n                                clippedVerticesItems[s + 13] = light.a;\r\n                                clippedVerticesItems[s + 14] = u2;\r\n                                clippedVerticesItems[s + 15] = v2;\r\n                                clippedVerticesItems[s + 16] = x3;\r\n                                clippedVerticesItems[s + 17] = y3;\r\n                                clippedVerticesItems[s + 18] = light.r;\r\n                                clippedVerticesItems[s + 19] = light.g;\r\n                                clippedVerticesItems[s + 20] = light.b;\r\n                                clippedVerticesItems[s + 21] = light.a;\r\n                                clippedVerticesItems[s + 22] = u3;\r\n                                clippedVerticesItems[s + 23] = v3;\r\n                            }\r\n                            else {\r\n                                clippedVerticesItems[s + 6] = u1;\r\n                                clippedVerticesItems[s + 7] = v1;\r\n                                clippedVerticesItems[s + 8] = dark.r;\r\n                                clippedVerticesItems[s + 9] = dark.g;\r\n                                clippedVerticesItems[s + 10] = dark.b;\r\n                                clippedVerticesItems[s + 11] = dark.a;\r\n                                clippedVerticesItems[s + 12] = x2;\r\n                                clippedVerticesItems[s + 13] = y2;\r\n                                clippedVerticesItems[s + 14] = light.r;\r\n                                clippedVerticesItems[s + 15] = light.g;\r\n                                clippedVerticesItems[s + 16] = light.b;\r\n                                clippedVerticesItems[s + 17] = light.a;\r\n                                clippedVerticesItems[s + 18] = u2;\r\n                                clippedVerticesItems[s + 19] = v2;\r\n                                clippedVerticesItems[s + 20] = dark.r;\r\n                                clippedVerticesItems[s + 21] = dark.g;\r\n                                clippedVerticesItems[s + 22] = dark.b;\r\n                                clippedVerticesItems[s + 23] = dark.a;\r\n                                clippedVerticesItems[s + 24] = x3;\r\n                                clippedVerticesItems[s + 25] = y3;\r\n                                clippedVerticesItems[s + 26] = light.r;\r\n                                clippedVerticesItems[s + 27] = light.g;\r\n                                clippedVerticesItems[s + 28] = light.b;\r\n                                clippedVerticesItems[s + 29] = light.a;\r\n                                clippedVerticesItems[s + 30] = u3;\r\n                                clippedVerticesItems[s + 31] = v3;\r\n                                clippedVerticesItems[s + 32] = dark.r;\r\n                                clippedVerticesItems[s + 33] = dark.g;\r\n                                clippedVerticesItems[s + 34] = dark.b;\r\n                                clippedVerticesItems[s + 35] = dark.a;\r\n                            }\r\n                            s = clippedTriangles.length;\r\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);\r\n                            clippedTrianglesItems[s] = index;\r\n                            clippedTrianglesItems[s + 1] = (index + 1);\r\n                            clippedTrianglesItems[s + 2] = (index + 2);\r\n                            index += 3;\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n                var originalOutput = output;\r\n                var clipped = false;\r\n                var input = null;\r\n                if (clippingArea.length % 4 >= 2) {\r\n                    input = output;\r\n                    output = this.scratch;\r\n                }\r\n                else\r\n                    input = this.scratch;\r\n                input.length = 0;\r\n                input.push(x1);\r\n                input.push(y1);\r\n                input.push(x2);\r\n                input.push(y2);\r\n                input.push(x3);\r\n                input.push(y3);\r\n                input.push(x1);\r\n                input.push(y1);\r\n                output.length = 0;\r\n                var clippingVertices = clippingArea;\r\n                var clippingVerticesLast = clippingArea.length - 4;\r\n                for (var i = 0;; i += 2) {\r\n                    var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n                    var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n                    var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n                    var inputVertices = input;\r\n                    var inputVerticesLength = input.length - 2, outputStart = output.length;\r\n                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n                        var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n                        var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n                            if (side2) {\r\n                                output.push(inputX2);\r\n                                output.push(inputY2);\r\n                                continue;\r\n                            }\r\n                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                        }\r\n                        else if (side2) {\r\n                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                            output.push(inputX2);\r\n                            output.push(inputY2);\r\n                        }\r\n                        clipped = true;\r\n                    }\r\n                    if (outputStart == output.length) {\r\n                        originalOutput.length = 0;\r\n                        return true;\r\n                    }\r\n                    output.push(output[0]);\r\n                    output.push(output[1]);\r\n                    if (i == clippingVerticesLast)\r\n                        break;\r\n                    var temp = output;\r\n                    output = input;\r\n                    output.length = 0;\r\n                    input = temp;\r\n                }\r\n                if (originalOutput != output) {\r\n                    originalOutput.length = 0;\r\n                    for (var i = 0, n = output.length - 2; i < n; i++)\r\n                        originalOutput[i] = output[i];\r\n                }\r\n                else\r\n                    originalOutput.length = originalOutput.length - 2;\r\n                return clipped;\r\n            };\r\n            SkeletonClipping.makeClockwise = function (polygon) {\r\n                var vertices = polygon;\r\n                var verticeslength = polygon.length;\r\n                var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n                for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n                    p1x = vertices[i];\r\n                    p1y = vertices[i + 1];\r\n                    p2x = vertices[i + 2];\r\n                    p2y = vertices[i + 3];\r\n                    area += p1x * p2y - p2x * p1y;\r\n                }\r\n                if (area < 0)\r\n                    return;\r\n                for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n                    var x = vertices[i], y = vertices[i + 1];\r\n                    var other = lastX - i;\r\n                    vertices[i] = vertices[other];\r\n                    vertices[i + 1] = vertices[other + 1];\r\n                    vertices[other] = x;\r\n                    vertices[other + 1] = y;\r\n                }\r\n            };\r\n            return SkeletonClipping;\r\n        }());\r\n        core.SkeletonClipping = SkeletonClipping;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkeletonData = (function () {\r\n            function SkeletonData() {\r\n                this.bones = new Array();\r\n                this.slots = new Array();\r\n                this.skins = new Array();\r\n                this.events = new Array();\r\n                this.animations = new Array();\r\n                this.ikConstraints = new Array();\r\n                this.transformConstraints = new Array();\r\n                this.pathConstraints = new Array();\r\n                this.fps = 0;\r\n            }\r\n            SkeletonData.prototype.findBone = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (bone.name == boneName)\r\n                        return bone;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findBoneIndex = function (boneName) {\r\n                if (boneName == null)\r\n                    throw new Error(\"boneName cannot be null.\");\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++)\r\n                    if (bones[i].name == boneName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            SkeletonData.prototype.findSlot = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++) {\r\n                    var slot = slots[i];\r\n                    if (slot.name == slotName)\r\n                        return slot;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findSlotIndex = function (slotName) {\r\n                if (slotName == null)\r\n                    throw new Error(\"slotName cannot be null.\");\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                    if (slots[i].name == slotName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            SkeletonData.prototype.findSkin = function (skinName) {\r\n                if (skinName == null)\r\n                    throw new Error(\"skinName cannot be null.\");\r\n                var skins = this.skins;\r\n                for (var i = 0, n = skins.length; i < n; i++) {\r\n                    var skin = skins[i];\r\n                    if (skin.name == skinName)\r\n                        return skin;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findEvent = function (eventDataName) {\r\n                if (eventDataName == null)\r\n                    throw new Error(\"eventDataName cannot be null.\");\r\n                var events = this.events;\r\n                for (var i = 0, n = events.length; i < n; i++) {\r\n                    var event_5 = events[i];\r\n                    if (event_5.name == eventDataName)\r\n                        return event_5;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findAnimation = function (animationName) {\r\n                if (animationName == null)\r\n                    throw new Error(\"animationName cannot be null.\");\r\n                var animations = this.animations;\r\n                for (var i = 0, n = animations.length; i < n; i++) {\r\n                    var animation = animations[i];\r\n                    if (animation.name == animationName)\r\n                        return animation;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var ikConstraints = this.ikConstraints;\r\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                    var constraint = ikConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var transformConstraints = this.transformConstraints;\r\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                    var constraint = transformConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n                if (constraintName == null)\r\n                    throw new Error(\"constraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                    var constraint = pathConstraints[i];\r\n                    if (constraint.name == constraintName)\r\n                        return constraint;\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n                if (pathConstraintName == null)\r\n                    throw new Error(\"pathConstraintName cannot be null.\");\r\n                var pathConstraints = this.pathConstraints;\r\n                for (var i = 0, n = pathConstraints.length; i < n; i++)\r\n                    if (pathConstraints[i].name == pathConstraintName)\r\n                        return i;\r\n                return -1;\r\n            };\r\n            return SkeletonData;\r\n        }());\r\n        core.SkeletonData = SkeletonData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        core.FAIL_ON_NON_EXISTING_SKIN = false;\r\n        var SkeletonJson = (function () {\r\n            function SkeletonJson(attachmentLoader) {\r\n                this.scale = 1;\r\n                this.linkedMeshes = new Array();\r\n                this.attachmentLoader = attachmentLoader;\r\n            }\r\n            SkeletonJson.prototype.readSkeletonData = function (json) {\r\n                var scale = this.scale;\r\n                var skeletonData = new core.SkeletonData();\r\n                var root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n                var skeletonMap = root.skeleton;\r\n                if (skeletonMap != null) {\r\n                    skeletonData.hash = skeletonMap.hash;\r\n                    skeletonData.version = skeletonMap.spine;\r\n                    if (skeletonData.version.substr(0, 3) !== '3.8') {\r\n                        var error = \"PixiJS Spine plugin supports only format for Spine 3.8. Your model has version \" + skeletonMap.spine + \". Please look in pixi-spine repository README for another branch.\";\r\n                        console.error(error);\r\n                    }\r\n                    if (skeletonData.version === '3.8.75') {\r\n                        var error = \"Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.\";\r\n                        console.error(error);\r\n                    }\r\n                    skeletonData.x = skeletonMap.x;\r\n                    skeletonData.y = skeletonMap.y;\r\n                    skeletonData.width = skeletonMap.width;\r\n                    skeletonData.height = skeletonMap.height;\r\n                    skeletonData.fps = skeletonMap.fps;\r\n                    skeletonData.imagesPath = skeletonMap.images;\r\n                }\r\n                if (root.bones) {\r\n                    for (var i = 0; i < root.bones.length; i++) {\r\n                        var boneMap = root.bones[i];\r\n                        var parent_5 = null;\r\n                        var parentName = this.getValue(boneMap, \"parent\", null);\r\n                        if (parentName != null) {\r\n                            parent_5 = skeletonData.findBone(parentName);\r\n                            if (parent_5 == null)\r\n                                throw new Error(\"Parent bone not found: \" + parentName);\r\n                        }\r\n                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_5);\r\n                        data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                        data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                        data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                        data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                        data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                        data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n                        data.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n                        skeletonData.bones.push(data);\r\n                    }\r\n                }\r\n                if (root.slots) {\r\n                    for (var i = 0; i < root.slots.length; i++) {\r\n                        var slotMap = root.slots[i];\r\n                        var slotName = slotMap.name;\r\n                        var boneName = slotMap.bone;\r\n                        var boneData = skeletonData.findBone(boneName);\r\n                        if (boneData == null)\r\n                            throw new Error(\"Slot bone not found: \" + boneName);\r\n                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);\r\n                        var color = this.getValue(slotMap, \"color\", null);\r\n                        if (color != null)\r\n                            data.color.setFromString(color);\r\n                        var dark = this.getValue(slotMap, \"dark\", null);\r\n                        if (dark != null) {\r\n                            data.darkColor = new core.Color(1, 1, 1, 1);\r\n                            data.darkColor.setFromString(dark);\r\n                        }\r\n                        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                        skeletonData.slots.push(data);\r\n                    }\r\n                }\r\n                if (root.ik) {\r\n                    for (var i = 0; i < root.ik.length; i++) {\r\n                        var constraintMap = root.ik[i];\r\n                        var data = new core.IkConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"IK bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findBone(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"IK target bone not found: \" + targetName);\r\n                        data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n                        data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n                        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                        data.compress = this.getValue(constraintMap, \"compress\", false);\r\n                        data.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n                        data.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n                        skeletonData.ikConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.transform) {\r\n                    for (var i = 0; i < root.transform.length; i++) {\r\n                        var constraintMap = root.transform[i];\r\n                        var data = new core.TransformConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findBone(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n                        data.local = this.getValue(constraintMap, \"local\", false);\r\n                        data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n                        skeletonData.transformConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.path) {\r\n                    for (var i = 0; i < root.path.length; i++) {\r\n                        var constraintMap = root.path[i];\r\n                        var data = new core.PathConstraintData(constraintMap.name);\r\n                        data.order = this.getValue(constraintMap, \"order\", 0);\r\n                        data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                            var boneName = constraintMap.bones[j];\r\n                            var bone = skeletonData.findBone(boneName);\r\n                            if (bone == null)\r\n                                throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                            data.bones.push(bone);\r\n                        }\r\n                        var targetName = constraintMap.target;\r\n                        data.target = skeletonData.findSlot(targetName);\r\n                        if (data.target == null)\r\n                            throw new Error(\"Path target slot not found: \" + targetName);\r\n                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                        data.position = this.getValue(constraintMap, \"position\", 0);\r\n                        if (data.positionMode == core.PositionMode.Fixed)\r\n                            data.position *= scale;\r\n                        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                            data.spacing *= scale;\r\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                        skeletonData.pathConstraints.push(data);\r\n                    }\r\n                }\r\n                if (root.skins) {\r\n                    for (var i = 0; i < root.skins.length; i++) {\r\n                        var skinMap = root.skins[i];\r\n                        var skin = new core.Skin(skinMap.name);\r\n                        if (skinMap.bones) {\r\n                            for (var ii = 0; ii < skinMap.bones.length; ii++) {\r\n                                var bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                                if (bone == null)\r\n                                    throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                                skin.bones.push(bone);\r\n                            }\r\n                        }\r\n                        if (skinMap.ik) {\r\n                            for (var ii = 0; ii < skinMap.ik.length; ii++) {\r\n                                var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        if (skinMap.transform) {\r\n                            for (var ii = 0; ii < skinMap.transform.length; ii++) {\r\n                                var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        if (skinMap.path) {\r\n                            for (var ii = 0; ii < skinMap.path.length; ii++) {\r\n                                var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                                if (constraint == null)\r\n                                    throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                                skin.constraints.push(constraint);\r\n                            }\r\n                        }\r\n                        for (var slotName in skinMap.attachments) {\r\n                            var slot = skeletonData.findSlot(slotName);\r\n                            if (slot == null)\r\n                                throw new Error(\"Slot not found: \" + slotName);\r\n                            var slotMap = skinMap.attachments[slotName];\r\n                            for (var entryName in slotMap) {\r\n                                var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                                if (attachment != null)\r\n                                    skin.setAttachment(slot.index, entryName, attachment);\r\n                            }\r\n                        }\r\n                        skeletonData.skins.push(skin);\r\n                        if (skin.name == \"default\")\r\n                            skeletonData.defaultSkin = skin;\r\n                    }\r\n                }\r\n                for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n                    var linkedMesh = this.linkedMeshes[i];\r\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                    if (skin == null)\r\n                        throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                    var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                    if (parent_6 == null)\r\n                        throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;\r\n                    linkedMesh.mesh.setParentMesh(parent_6);\r\n                }\r\n                this.linkedMeshes.length = 0;\r\n                if (root.events) {\r\n                    for (var eventName in root.events) {\r\n                        var eventMap = root.events[eventName];\r\n                        var data = new core.EventData(eventName);\r\n                        data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                        data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                        data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                        data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                        if (data.audioPath != null) {\r\n                            data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                            data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                        }\r\n                        skeletonData.events.push(data);\r\n                    }\r\n                }\r\n                if (root.animations) {\r\n                    for (var animationName in root.animations) {\r\n                        var animationMap = root.animations[animationName];\r\n                        this.readAnimation(animationMap, animationName, skeletonData);\r\n                    }\r\n                }\r\n                return skeletonData;\r\n            };\r\n            SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n                var scale = this.scale;\r\n                name = this.getValue(map, \"name\", name);\r\n                var type = this.getValue(map, \"type\", \"region\");\r\n                switch (type) {\r\n                    case \"region\": {\r\n                        var path = this.getValue(map, \"path\", name);\r\n                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                        if (region == null)\r\n                            return null;\r\n                        region.path = path;\r\n                        region.x = this.getValue(map, \"x\", 0) * scale;\r\n                        region.y = this.getValue(map, \"y\", 0) * scale;\r\n                        region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                        region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                        region.rotation = this.getValue(map, \"rotation\", 0);\r\n                        region.width = map.width * scale;\r\n                        region.height = map.height * scale;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            region.color.setFromString(color);\r\n                        return region;\r\n                    }\r\n                    case \"boundingbox\": {\r\n                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                        if (box == null)\r\n                            return null;\r\n                        this.readVertices(map, box, map.vertexCount << 1);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            box.color.setFromString(color);\r\n                        return box;\r\n                    }\r\n                    case \"mesh\":\r\n                    case \"linkedmesh\": {\r\n                        var path = this.getValue(map, \"path\", name);\r\n                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                        if (mesh == null)\r\n                            return null;\r\n                        mesh.path = path;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            mesh.color.setFromString(color);\r\n                        mesh.width = this.getValue(map, \"width\", 0) * scale;\r\n                        mesh.height = this.getValue(map, \"height\", 0) * scale;\r\n                        var parent_7 = this.getValue(map, \"parent\", null);\r\n                        if (parent_7 != null) {\r\n                            this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_7, this.getValue(map, \"deform\", true)));\r\n                            return mesh;\r\n                        }\r\n                        var uvs = map.uvs;\r\n                        this.readVertices(map, mesh, uvs.length);\r\n                        mesh.triangles = map.triangles;\r\n                        mesh.regionUVs = new Float32Array(uvs);\r\n                        mesh.edges = this.getValue(map, \"edges\", null);\r\n                        mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                        return mesh;\r\n                    }\r\n                    case \"path\": {\r\n                        var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                        if (path == null)\r\n                            return null;\r\n                        path.closed = this.getValue(map, \"closed\", false);\r\n                        path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n                        var vertexCount = map.vertexCount;\r\n                        this.readVertices(map, path, vertexCount << 1);\r\n                        var lengths = core.Utils.newArray(vertexCount / 3, 0);\r\n                        for (var i = 0; i < map.lengths.length; i++)\r\n                            lengths[i] = map.lengths[i] * scale;\r\n                        path.lengths = lengths;\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            path.color.setFromString(color);\r\n                        return path;\r\n                    }\r\n                    case \"point\": {\r\n                        var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                        if (point == null)\r\n                            return null;\r\n                        point.x = this.getValue(map, \"x\", 0) * scale;\r\n                        point.y = this.getValue(map, \"y\", 0) * scale;\r\n                        point.rotation = this.getValue(map, \"rotation\", 0);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            point.color.setFromString(color);\r\n                        return point;\r\n                    }\r\n                    case \"clipping\": {\r\n                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                        if (clip == null)\r\n                            return null;\r\n                        var end = this.getValue(map, \"end\", null);\r\n                        if (end != null) {\r\n                            var slot = skeletonData.findSlot(end);\r\n                            if (slot == null)\r\n                                throw new Error(\"Clipping end slot not found: \" + end);\r\n                            clip.endSlot = slot;\r\n                        }\r\n                        var vertexCount = map.vertexCount;\r\n                        this.readVertices(map, clip, vertexCount << 1);\r\n                        var color = this.getValue(map, \"color\", null);\r\n                        if (color != null)\r\n                            clip.color.setFromString(color);\r\n                        return clip;\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n                var scale = this.scale;\r\n                attachment.worldVerticesLength = verticesLength;\r\n                var vertices = map.vertices;\r\n                if (verticesLength == vertices.length) {\r\n                    var scaledVertices = core.Utils.toFloatArray(vertices);\r\n                    if (scale != 1) {\r\n                        for (var i = 0, n = vertices.length; i < n; i++)\r\n                            scaledVertices[i] *= scale;\r\n                    }\r\n                    attachment.vertices = scaledVertices;\r\n                    return;\r\n                }\r\n                var weights = new Array();\r\n                var bones = new Array();\r\n                for (var i = 0, n = vertices.length; i < n;) {\r\n                    var boneCount = vertices[i++];\r\n                    bones.push(boneCount);\r\n                    for (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n                        bones.push(vertices[i]);\r\n                        weights.push(vertices[i + 1] * scale);\r\n                        weights.push(vertices[i + 2] * scale);\r\n                        weights.push(vertices[i + 3]);\r\n                    }\r\n                }\r\n                attachment.bones = bones;\r\n                attachment.vertices = core.Utils.toFloatArray(weights);\r\n            };\r\n            SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n                var scale = this.scale;\r\n                var timelines = new Array();\r\n                var duration = 0;\r\n                if (map.slots) {\r\n                    for (var slotName in map.slots) {\r\n                        var slotMap = map.slots[slotName];\r\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                        if (slotIndex == -1)\r\n                            throw new Error(\"Slot not found: \" + slotName);\r\n                        for (var timelineName in slotMap) {\r\n                            var timelineMap = slotMap[timelineName];\r\n                            if (timelineName == \"attachment\") {\r\n                                var timeline = new core.AttachmentTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                            }\r\n                            else if (timelineName == \"color\") {\r\n                                var timeline = new core.ColorTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var color = new core.Color();\r\n                                    color.setFromString(valueMap.color || \"ffffffff\");\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName == \"twoColor\") {\r\n                                var timeline = new core.TwoColorTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var light = new core.Color();\r\n                                    var dark = new core.Color();\r\n                                    light.setFromString(valueMap.light);\r\n                                    dark.setFromString(valueMap.dark);\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);\r\n                            }\r\n                            else\r\n                                throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                        }\r\n                    }\r\n                }\r\n                if (map.bones) {\r\n                    for (var boneName in map.bones) {\r\n                        var boneMap = map.bones[boneName];\r\n                        var boneIndex = skeletonData.findBoneIndex(boneName);\r\n                        if (boneIndex == -1)\r\n                            throw new Error(\"Bone not found: \" + boneName);\r\n                        for (var timelineName in boneMap) {\r\n                            var timelineMap = boneMap[timelineName];\r\n                            if (timelineName === \"rotate\") {\r\n                                var timeline = new core.RotateTimeline(timelineMap.length);\r\n                                timeline.boneIndex = boneIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                                var timeline = null;\r\n                                var timelineScale = 1, defaultValue = 0;\r\n                                if (timelineName === \"scale\") {\r\n                                    timeline = new core.ScaleTimeline(timelineMap.length);\r\n                                    defaultValue = 1;\r\n                                }\r\n                                else if (timelineName === \"shear\")\r\n                                    timeline = new core.ShearTimeline(timelineMap.length);\r\n                                else {\r\n                                    timeline = new core.TranslateTimeline(timelineMap.length);\r\n                                    timelineScale = scale;\r\n                                }\r\n                                timeline.boneIndex = boneIndex;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    var x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);\r\n                            }\r\n                            else\r\n                                throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                        }\r\n                    }\r\n                }\r\n                if (map.ik) {\r\n                    for (var constraintName in map.ik) {\r\n                        var constraintMap = map.ik[constraintName];\r\n                        var constraint = skeletonData.findIkConstraint(constraintName);\r\n                        var timeline = new core.IkConstraintTimeline(constraintMap.length);\r\n                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                        var frameIndex = 0;\r\n                        for (var i = 0; i < constraintMap.length; i++) {\r\n                            var valueMap = constraintMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale, this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n                if (map.transform) {\r\n                    for (var constraintName in map.transform) {\r\n                        var constraintMap = map.transform[constraintName];\r\n                        var constraint = skeletonData.findTransformConstraint(constraintName);\r\n                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);\r\n                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                        var frameIndex = 0;\r\n                        for (var i = 0; i < constraintMap.length; i++) {\r\n                            var valueMap = constraintMap[i];\r\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n                if (map.path) {\r\n                    for (var constraintName in map.path) {\r\n                        var constraintMap = map.path[constraintName];\r\n                        var index = skeletonData.findPathConstraintIndex(constraintName);\r\n                        if (index == -1)\r\n                            throw new Error(\"Path constraint not found: \" + constraintName);\r\n                        var data = skeletonData.pathConstraints[index];\r\n                        for (var timelineName in constraintMap) {\r\n                            var timelineMap = constraintMap[timelineName];\r\n                            if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                                var timeline = null;\r\n                                var timelineScale = 1;\r\n                                if (timelineName === \"spacing\") {\r\n                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);\r\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                else {\r\n                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);\r\n                                    if (data.positionMode == core.PositionMode.Fixed)\r\n                                        timelineScale = scale;\r\n                                }\r\n                                timeline.pathConstraintIndex = index;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\r\n                            }\r\n                            else if (timelineName === \"mix\") {\r\n                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);\r\n                                timeline.pathConstraintIndex = index;\r\n                                var frameIndex = 0;\r\n                                for (var i = 0; i < timelineMap.length; i++) {\r\n                                    var valueMap = timelineMap[i];\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (map.deform) {\r\n                    for (var deformName in map.deform) {\r\n                        var deformMap = map.deform[deformName];\r\n                        var skin = skeletonData.findSkin(deformName);\r\n                        if (skin == null) {\r\n                            if (core.FAIL_ON_NON_EXISTING_SKIN) {\r\n                                throw new Error(\"Skin not found: \" + deformName);\r\n                            }\r\n                            else {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        for (var slotName in deformMap) {\r\n                            var slotMap = deformMap[slotName];\r\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                            if (slotIndex == -1)\r\n                                throw new Error(\"Slot not found: \" + slotMap.name);\r\n                            for (var timelineName in slotMap) {\r\n                                var timelineMap = slotMap[timelineName];\r\n                                var attachment = skin.getAttachment(slotIndex, timelineName);\r\n                                if (attachment == null)\r\n                                    throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                                var weighted = attachment.bones != null;\r\n                                var vertices = attachment.vertices;\r\n                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                                var timeline = new core.DeformTimeline(timelineMap.length);\r\n                                timeline.slotIndex = slotIndex;\r\n                                timeline.attachment = attachment;\r\n                                var frameIndex = 0;\r\n                                for (var j = 0; j < timelineMap.length; j++) {\r\n                                    var valueMap = timelineMap[j];\r\n                                    var deform = void 0;\r\n                                    var verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n                                    if (verticesValue == null)\r\n                                        deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;\r\n                                    else {\r\n                                        deform = core.Utils.newFloatArray(deformLength);\r\n                                        var start = this.getValue(valueMap, \"offset\", 0);\r\n                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                        if (scale != 1) {\r\n                                            for (var i = start, n = i + verticesValue.length; i < n; i++)\r\n                                                deform[i] *= scale;\r\n                                        }\r\n                                        if (!weighted) {\r\n                                            for (var i = 0; i < deformLength; i++)\r\n                                                deform[i] += vertices[i];\r\n                                        }\r\n                                    }\r\n                                    timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n                                    this.readCurve(valueMap, timeline, frameIndex);\r\n                                    frameIndex++;\r\n                                }\r\n                                timelines.push(timeline);\r\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var drawOrderNode = map.drawOrder;\r\n                if (drawOrderNode == null)\r\n                    drawOrderNode = map.draworder;\r\n                if (drawOrderNode != null) {\r\n                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);\r\n                    var slotCount = skeletonData.slots.length;\r\n                    var frameIndex = 0;\r\n                    for (var j = 0; j < drawOrderNode.length; j++) {\r\n                        var drawOrderMap = drawOrderNode[j];\r\n                        var drawOrder = null;\r\n                        var offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                        if (offsets != null) {\r\n                            drawOrder = core.Utils.newArray(slotCount, -1);\r\n                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);\r\n                            var originalIndex = 0, unchangedIndex = 0;\r\n                            for (var i = 0; i < offsets.length; i++) {\r\n                                var offsetMap = offsets[i];\r\n                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                                if (slotIndex == -1)\r\n                                    throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                                while (originalIndex != slotIndex)\r\n                                    unchanged[unchangedIndex++] = originalIndex++;\r\n                                drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                            }\r\n                            while (originalIndex < slotCount)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            for (var i = slotCount - 1; i >= 0; i--)\r\n                                if (drawOrder[i] == -1)\r\n                                    drawOrder[i] = unchanged[--unchangedIndex];\r\n                        }\r\n                        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n                if (map.events) {\r\n                    var timeline = new core.EventTimeline(map.events.length);\r\n                    var frameIndex = 0;\r\n                    for (var i = 0; i < map.events.length; i++) {\r\n                        var eventMap = map.events[i];\r\n                        var eventData = skeletonData.findEvent(eventMap.name);\r\n                        if (eventData == null)\r\n                            throw new Error(\"Event not found: \" + eventMap.name);\r\n                        var event_6 = new core.Event(core.Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n                        event_6.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                        event_6.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                        event_6.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                        if (event_6.data.audioPath != null) {\r\n                            event_6.volume = this.getValue(eventMap, \"volume\", 1);\r\n                            event_6.balance = this.getValue(eventMap, \"balance\", 0);\r\n                        }\r\n                        timeline.setFrame(frameIndex++, event_6);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n                if (isNaN(duration)) {\r\n                    throw new Error(\"Error while parsing animation, duration is NaN\");\r\n                }\r\n                skeletonData.animations.push(new core.Animation(name, timelines, duration));\r\n            };\r\n            SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n                if (!map.hasOwnProperty(\"curve\"))\r\n                    return;\r\n                if (map.curve === \"stepped\")\r\n                    timeline.setStepped(frameIndex);\r\n                else {\r\n                    var curve = map.curve;\r\n                    timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n                }\r\n            };\r\n            SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n                return map[prop] !== undefined ? map[prop] : defaultValue;\r\n            };\r\n            SkeletonJson.blendModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"normal\")\r\n                    return core.BlendMode.Normal;\r\n                if (str == \"additive\")\r\n                    return core.BlendMode.Additive;\r\n                if (str == \"multiply\")\r\n                    return core.BlendMode.Multiply;\r\n                if (str == \"screen\")\r\n                    return core.BlendMode.Screen;\r\n                throw new Error(\"Unknown blend mode: \" + str);\r\n            };\r\n            SkeletonJson.positionModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"fixed\")\r\n                    return core.PositionMode.Fixed;\r\n                if (str == \"percent\")\r\n                    return core.PositionMode.Percent;\r\n                throw new Error(\"Unknown position mode: \" + str);\r\n            };\r\n            SkeletonJson.spacingModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"length\")\r\n                    return core.SpacingMode.Length;\r\n                if (str == \"fixed\")\r\n                    return core.SpacingMode.Fixed;\r\n                if (str == \"percent\")\r\n                    return core.SpacingMode.Percent;\r\n                throw new Error(\"Unknown position mode: \" + str);\r\n            };\r\n            SkeletonJson.rotateModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"tangent\")\r\n                    return core.RotateMode.Tangent;\r\n                if (str == \"chain\")\r\n                    return core.RotateMode.Chain;\r\n                if (str == \"chainscale\")\r\n                    return core.RotateMode.ChainScale;\r\n                throw new Error(\"Unknown rotate mode: \" + str);\r\n            };\r\n            SkeletonJson.transformModeFromString = function (str) {\r\n                str = str.toLowerCase();\r\n                if (str == \"normal\")\r\n                    return core.TransformMode.Normal;\r\n                if (str == \"onlytranslation\")\r\n                    return core.TransformMode.OnlyTranslation;\r\n                if (str == \"norotationorreflection\")\r\n                    return core.TransformMode.NoRotationOrReflection;\r\n                if (str == \"noscale\")\r\n                    return core.TransformMode.NoScale;\r\n                if (str == \"noscaleorreflection\")\r\n                    return core.TransformMode.NoScaleOrReflection;\r\n                throw new Error(\"Unknown transform mode: \" + str);\r\n            };\r\n            return SkeletonJson;\r\n        }());\r\n        core.SkeletonJson = SkeletonJson;\r\n        var LinkedMesh = (function () {\r\n            function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n                this.mesh = mesh;\r\n                this.skin = skin;\r\n                this.slotIndex = slotIndex;\r\n                this.parent = parent;\r\n                this.inheritDeform = inheritDeform;\r\n            }\r\n            return LinkedMesh;\r\n        }());\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SkinEntry = (function () {\r\n            function SkinEntry(slotIndex, name, attachment) {\r\n                this.slotIndex = slotIndex;\r\n                this.name = name;\r\n                this.attachment = attachment;\r\n            }\r\n            return SkinEntry;\r\n        }());\r\n        core.SkinEntry = SkinEntry;\r\n        var Skin = (function () {\r\n            function Skin(name) {\r\n                this.attachments = new Array();\r\n                this.bones = Array();\r\n                this.constraints = new Array();\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.name = name;\r\n            }\r\n            Skin.prototype.setAttachment = function (slotIndex, name, attachment) {\r\n                if (attachment == null)\r\n                    throw new Error(\"attachment cannot be null.\");\r\n                var attachments = this.attachments;\r\n                if (slotIndex >= attachments.length)\r\n                    attachments.length = slotIndex + 1;\r\n                if (!attachments[slotIndex])\r\n                    attachments[slotIndex] = {};\r\n                attachments[slotIndex][name] = attachment;\r\n            };\r\n            Skin.prototype.addSkin = function (skin) {\r\n                for (var i = 0; i < skin.bones.length; i++) {\r\n                    var bone = skin.bones[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.bones.length; j++) {\r\n                        if (this.bones[j] == bone) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.bones.push(bone);\r\n                }\r\n                for (var i = 0; i < skin.constraints.length; i++) {\r\n                    var constraint = skin.constraints[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.constraints.length; j++) {\r\n                        if (this.constraints[j] == constraint) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.constraints.push(constraint);\r\n                }\r\n                var attachments = skin.getAttachments();\r\n                for (var i = 0; i < attachments.length; i++) {\r\n                    var attachment = attachments[i];\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                }\r\n            };\r\n            Skin.prototype.copySkin = function (skin) {\r\n                for (var i = 0; i < skin.bones.length; i++) {\r\n                    var bone = skin.bones[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.bones.length; j++) {\r\n                        if (this.bones[j] == bone) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.bones.push(bone);\r\n                }\r\n                for (var i = 0; i < skin.constraints.length; i++) {\r\n                    var constraint = skin.constraints[i];\r\n                    var contained = false;\r\n                    for (var j = 0; j < this.constraints.length; j++) {\r\n                        if (this.constraints[j] == constraint) {\r\n                            contained = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!contained)\r\n                        this.constraints.push(constraint);\r\n                }\r\n                var attachments = skin.getAttachments();\r\n                for (var i = 0; i < attachments.length; i++) {\r\n                    var attachment = attachments[i];\r\n                    if (attachment.attachment == null)\r\n                        continue;\r\n                    if (attachment.attachment instanceof core.MeshAttachment) {\r\n                        attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                    }\r\n                    else {\r\n                        attachment.attachment = attachment.attachment.copy();\r\n                        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                    }\r\n                }\r\n            };\r\n            Skin.prototype.getAttachment = function (slotIndex, name) {\r\n                var dictionary = this.attachments[slotIndex];\r\n                return dictionary ? dictionary[name] : null;\r\n            };\r\n            Skin.prototype.removeAttachment = function (slotIndex, name) {\r\n                var dictionary = this.attachments[slotIndex];\r\n                if (dictionary)\r\n                    dictionary[name] = null;\r\n            };\r\n            Skin.prototype.getAttachments = function () {\r\n                var entries = new Array();\r\n                for (var i = 0; i < this.attachments.length; i++) {\r\n                    var slotAttachments = this.attachments[i];\r\n                    if (slotAttachments) {\r\n                        for (var name_4 in slotAttachments) {\r\n                            var attachment = slotAttachments[name_4];\r\n                            if (attachment)\r\n                                entries.push(new SkinEntry(i, name_4, attachment));\r\n                        }\r\n                    }\r\n                }\r\n                return entries;\r\n            };\r\n            Skin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {\r\n                var slotAttachments = this.attachments[slotIndex];\r\n                if (slotAttachments) {\r\n                    for (var name_5 in slotAttachments) {\r\n                        var attachment = slotAttachments[name_5];\r\n                        if (attachment)\r\n                            attachments.push(new SkinEntry(slotIndex, name_5, attachment));\r\n                    }\r\n                }\r\n            };\r\n            Skin.prototype.clear = function () {\r\n                this.attachments.length = 0;\r\n                this.bones.length = 0;\r\n                this.constraints.length = 0;\r\n            };\r\n            Skin.prototype.attachAll = function (skeleton, oldSkin) {\r\n                var slotIndex = 0;\r\n                for (var i = 0; i < skeleton.slots.length; i++) {\r\n                    var slot = skeleton.slots[i];\r\n                    var slotAttachment = slot.getAttachment();\r\n                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                        var dictionary = oldSkin.attachments[slotIndex];\r\n                        for (var key in dictionary) {\r\n                            var skinAttachment = dictionary[key];\r\n                            if (slotAttachment == skinAttachment) {\r\n                                var attachment = this.getAttachment(slotIndex, key);\r\n                                if (attachment != null)\r\n                                    slot.setAttachment(attachment);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    slotIndex++;\r\n                }\r\n            };\r\n            return Skin;\r\n        }());\r\n        core.Skin = Skin;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Slot = (function () {\r\n            function Slot(data, bone) {\r\n                this.deform = new Array();\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (bone == null)\r\n                    throw new Error(\"bone cannot be null.\");\r\n                this.data = data;\r\n                this.bone = bone;\r\n                this.color = new core.Color();\r\n                this.darkColor = data.darkColor == null ? null : new core.Color();\r\n                this.setToSetupPose();\r\n                this.blendMode = this.data.blendMode;\r\n            }\r\n            Slot.prototype.getAttachment = function () {\r\n                return this.attachment;\r\n            };\r\n            Slot.prototype.setAttachment = function (attachment) {\r\n                if (this.attachment == attachment)\r\n                    return;\r\n                this.attachment = attachment;\r\n                this.attachmentTime = this.bone.skeleton.time;\r\n                this.deform.length = 0;\r\n            };\r\n            Slot.prototype.setAttachmentTime = function (time) {\r\n                this.attachmentTime = this.bone.skeleton.time - time;\r\n            };\r\n            Slot.prototype.getAttachmentTime = function () {\r\n                return this.bone.skeleton.time - this.attachmentTime;\r\n            };\r\n            Slot.prototype.setToSetupPose = function () {\r\n                this.color.setFromColor(this.data.color);\r\n                if (this.darkColor != null)\r\n                    this.darkColor.setFromColor(this.data.darkColor);\r\n                if (this.data.attachmentName == null)\r\n                    this.attachment = null;\r\n                else {\r\n                    this.attachment = null;\r\n                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n                }\r\n            };\r\n            return Slot;\r\n        }());\r\n        core.Slot = Slot;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SlotData = (function () {\r\n            function SlotData(index, name, boneData) {\r\n                this.color = new core.Color(1, 1, 1, 1);\r\n                if (index < 0)\r\n                    throw new Error(\"index must be >= 0.\");\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                if (boneData == null)\r\n                    throw new Error(\"boneData cannot be null.\");\r\n                this.index = index;\r\n                this.name = name;\r\n                this.boneData = boneData;\r\n            }\r\n            return SlotData;\r\n        }());\r\n        core.SlotData = SlotData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Texture = (function () {\r\n            function Texture(image) {\r\n                this._image = image;\r\n            }\r\n            Texture.prototype.getImage = function () {\r\n                return this._image;\r\n            };\r\n            Texture.filterFromString = function (text) {\r\n                switch (text.toLowerCase()) {\r\n                    case \"nearest\": return TextureFilter.Nearest;\r\n                    case \"linear\": return TextureFilter.Linear;\r\n                    case \"mipmap\": return TextureFilter.MipMap;\r\n                    case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n                    case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n                    case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n                    case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n                    default: throw new Error(\"Unknown texture filter \" + text);\r\n                }\r\n            };\r\n            Texture.wrapFromString = function (text) {\r\n                switch (text.toLowerCase()) {\r\n                    case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n                    case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n                    case \"repeat\": return TextureWrap.Repeat;\r\n                    default: throw new Error(\"Unknown texture wrap \" + text);\r\n                }\r\n            };\r\n            return Texture;\r\n        }());\r\n        core.Texture = Texture;\r\n        var TextureFilter;\r\n        (function (TextureFilter) {\r\n            TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n            TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n            TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n            TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n            TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n            TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n            TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n        })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));\r\n        var TextureWrap;\r\n        (function (TextureWrap) {\r\n            TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n            TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n            TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));\r\n        var TextureRegion = (function () {\r\n            function TextureRegion() {\r\n                this.size = null;\r\n            }\r\n            Object.defineProperty(TextureRegion.prototype, \"width\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        return tex.crop.width;\r\n                    }\r\n                    if (tex.trim) {\r\n                        return tex.trim.width;\r\n                    }\r\n                    return tex.orig.width;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"height\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        return tex.crop.height;\r\n                    }\r\n                    if (tex.trim) {\r\n                        return tex.trim.height;\r\n                    }\r\n                    return tex.orig.height;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"u\", {\r\n                get: function () {\r\n                    return this.texture._uvs.x0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"v\", {\r\n                get: function () {\r\n                    return this.texture._uvs.y0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"u2\", {\r\n                get: function () {\r\n                    return this.texture._uvs.x2;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"v2\", {\r\n                get: function () {\r\n                    return this.texture._uvs.y2;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"offsetX\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return tex.trim ? tex.trim.x : 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"offsetY\", {\r\n                get: function () {\r\n                    console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n                    return this.spineOffsetY;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"pixiOffsetY\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return tex.trim ? tex.trim.y : 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"spineOffsetY\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"originalWidth\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        if (tex.trim) {\r\n                            return tex.trim.width;\r\n                        }\r\n                        return tex.crop.width;\r\n                    }\r\n                    return tex.orig.width;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"originalHeight\", {\r\n                get: function () {\r\n                    var tex = this.texture;\r\n                    if (PIXI.VERSION[0] == '3') {\r\n                        if (tex.trim) {\r\n                            return tex.trim.height;\r\n                        }\r\n                        return tex.crop.height;\r\n                    }\r\n                    return tex.orig.height;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"x\", {\r\n                get: function () {\r\n                    return this.texture.frame.x;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"y\", {\r\n                get: function () {\r\n                    return this.texture.frame.y;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            Object.defineProperty(TextureRegion.prototype, \"rotate\", {\r\n                get: function () {\r\n                    return this.texture.rotate !== 0;\r\n                },\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n            return TextureRegion;\r\n        }());\r\n        core.TextureRegion = TextureRegion;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TextureAtlas = (function () {\r\n            function TextureAtlas(atlasText, textureLoader, callback) {\r\n                this.pages = new Array();\r\n                this.regions = new Array();\r\n                if (atlasText) {\r\n                    this.addSpineAtlas(atlasText, textureLoader, callback);\r\n                }\r\n            }\r\n            TextureAtlas.prototype.addTexture = function (name, texture) {\r\n                var pages = this.pages;\r\n                var page = null;\r\n                for (var i = 0; i < pages.length; i++) {\r\n                    if (pages[i].baseTexture === texture.baseTexture) {\r\n                        page = pages[i];\r\n                        break;\r\n                    }\r\n                }\r\n                if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = 'texturePage';\r\n                    var baseTexture = texture.baseTexture;\r\n                    page.width = baseTexture.realWidth;\r\n                    page.height = baseTexture.realHeight;\r\n                    page.baseTexture = baseTexture;\r\n                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;\r\n                    page.uWrap = core.TextureWrap.ClampToEdge;\r\n                    page.vWrap = core.TextureWrap.ClampToEdge;\r\n                    pages.push(page);\r\n                }\r\n                var region = new TextureAtlasRegion();\r\n                region.name = name;\r\n                region.page = page;\r\n                region.texture = texture;\r\n                region.index = -1;\r\n                this.regions.push(region);\r\n                return region;\r\n            };\r\n            TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {\r\n                for (var key in textures) {\r\n                    if (textures.hasOwnProperty(key)) {\r\n                        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n                    }\r\n                }\r\n            };\r\n            TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {\r\n                return this.load(atlasText, textureLoader, callback);\r\n            };\r\n            TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {\r\n                var _this = this;\r\n                if (textureLoader == null)\r\n                    throw new Error(\"textureLoader cannot be null.\");\r\n                var reader = new TextureAtlasReader(atlasText);\r\n                var tuple = new Array(4);\r\n                var page = null;\r\n                var iterateParser = function () {\r\n                    while (true) {\r\n                        var line = reader.readLine();\r\n                        if (line == null) {\r\n                            return callback && callback(_this);\r\n                        }\r\n                        line = line.trim();\r\n                        if (line.length == 0)\r\n                            page = null;\r\n                        else if (!page) {\r\n                            page = new TextureAtlasPage();\r\n                            page.name = line;\r\n                            if (reader.readTuple(tuple) == 2) {\r\n                                page.width = parseInt(tuple[0]);\r\n                                page.height = parseInt(tuple[1]);\r\n                                reader.readTuple(tuple);\r\n                            }\r\n                            reader.readTuple(tuple);\r\n                            page.minFilter = core.Texture.filterFromString(tuple[0]);\r\n                            page.magFilter = core.Texture.filterFromString(tuple[1]);\r\n                            var direction = reader.readValue();\r\n                            page.uWrap = core.TextureWrap.ClampToEdge;\r\n                            page.vWrap = core.TextureWrap.ClampToEdge;\r\n                            if (direction == \"x\")\r\n                                page.uWrap = core.TextureWrap.Repeat;\r\n                            else if (direction == \"y\")\r\n                                page.vWrap = core.TextureWrap.Repeat;\r\n                            else if (direction == \"xy\")\r\n                                page.uWrap = page.vWrap = core.TextureWrap.Repeat;\r\n                            textureLoader(line, function (texture) {\r\n                                if (texture === null) {\r\n                                    _this.pages.splice(_this.pages.indexOf(page), 1);\r\n                                    return callback && callback(null);\r\n                                }\r\n                                page.baseTexture = texture;\r\n                                if (!texture.valid) {\r\n                                    texture.setSize(page.width, page.height);\r\n                                }\r\n                                _this.pages.push(page);\r\n                                page.setFilters();\r\n                                if (!page.width || !page.height) {\r\n                                    page.width = texture.realWidth;\r\n                                    page.height = texture.realHeight;\r\n                                    if (!page.width || !page.height) {\r\n                                        console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                                    }\r\n                                }\r\n                                iterateParser();\r\n                            });\r\n                            _this.pages.push(page);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            var region = new TextureAtlasRegion();\r\n                            region.name = line;\r\n                            region.page = page;\r\n                            var rotateValue = reader.readValue();\r\n                            var rotate = 0;\r\n                            if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                                rotate = 6;\r\n                            }\r\n                            else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                                rotate = 0;\r\n                            }\r\n                            else {\r\n                                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n                            }\r\n                            reader.readTuple(tuple);\r\n                            var x = parseInt(tuple[0]);\r\n                            var y = parseInt(tuple[1]);\r\n                            reader.readTuple(tuple);\r\n                            var width = parseInt(tuple[0]);\r\n                            var height = parseInt(tuple[1]);\r\n                            var resolution = page.baseTexture.resolution;\r\n                            x /= resolution;\r\n                            y /= resolution;\r\n                            width /= resolution;\r\n                            height /= resolution;\r\n                            var swapWH = rotate % 4 != 0;\r\n                            var frame = new PIXI.Rectangle(x, y, swapWH ? height : width, swapWH ? width : height);\r\n                            if (reader.readTuple(tuple) == 4) {\r\n                                if (reader.readTuple(tuple) == 4) {\r\n                                    reader.readTuple(tuple);\r\n                                }\r\n                            }\r\n                            var originalWidth = parseInt(tuple[0]) / resolution;\r\n                            var originalHeight = parseInt(tuple[1]) / resolution;\r\n                            reader.readTuple(tuple);\r\n                            var offsetX = parseInt(tuple[0]) / resolution;\r\n                            var offsetY = parseInt(tuple[1]) / resolution;\r\n                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                            var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n                            if (PIXI.VERSION[0] != '3') {\r\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\r\n                            }\r\n                            else {\r\n                                var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                                var crop = frame2.clone();\r\n                                trim.width = originalWidth;\r\n                                trim.height = originalHeight;\r\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\r\n                            }\r\n                            region.index = parseInt(reader.readValue());\r\n                            region.texture.updateUvs();\r\n                            _this.regions.push(region);\r\n                        }\r\n                    }\r\n                };\r\n                iterateParser();\r\n            };\r\n            TextureAtlas.prototype.findRegion = function (name) {\r\n                for (var i = 0; i < this.regions.length; i++) {\r\n                    if (this.regions[i].name == name) {\r\n                        return this.regions[i];\r\n                    }\r\n                }\r\n                return null;\r\n            };\r\n            TextureAtlas.prototype.dispose = function () {\r\n                for (var i = 0; i < this.pages.length; i++) {\r\n                    this.pages[i].baseTexture.dispose();\r\n                }\r\n            };\r\n            return TextureAtlas;\r\n        }());\r\n        core.TextureAtlas = TextureAtlas;\r\n        var TextureAtlasReader = (function () {\r\n            function TextureAtlasReader(text) {\r\n                this.index = 0;\r\n                this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n            }\r\n            TextureAtlasReader.prototype.readLine = function () {\r\n                if (this.index >= this.lines.length)\r\n                    return null;\r\n                return this.lines[this.index++];\r\n            };\r\n            TextureAtlasReader.prototype.readValue = function () {\r\n                var line = this.readLine();\r\n                var colon = line.indexOf(\":\");\r\n                if (colon == -1)\r\n                    throw new Error(\"Invalid line: \" + line);\r\n                return line.substring(colon + 1).trim();\r\n            };\r\n            TextureAtlasReader.prototype.readTuple = function (tuple) {\r\n                var line = this.readLine();\r\n                var colon = line.indexOf(\":\");\r\n                if (colon == -1)\r\n                    throw new Error(\"Invalid line: \" + line);\r\n                var i = 0, lastMatch = colon + 1;\r\n                for (; i < 3; i++) {\r\n                    var comma = line.indexOf(\",\", lastMatch);\r\n                    if (comma == -1)\r\n                        break;\r\n                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n                    lastMatch = comma + 1;\r\n                }\r\n                tuple[i] = line.substring(lastMatch).trim();\r\n                return i + 1;\r\n            };\r\n            return TextureAtlasReader;\r\n        }());\r\n        var TextureAtlasPage = (function () {\r\n            function TextureAtlasPage() {\r\n            }\r\n            TextureAtlasPage.prototype.setFilters = function () {\r\n                var tex = this.baseTexture;\r\n                var filter = this.minFilter;\r\n                if (filter == core.TextureFilter.Linear) {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n                }\r\n                else if (this.minFilter == core.TextureFilter.Nearest) {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n                }\r\n                else {\r\n                    tex.mipmap = PIXI.MIPMAP_MODES.POW2;\r\n                    if (filter == core.TextureFilter.MipMapNearestNearest) {\r\n                        tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n                    }\r\n                    else {\r\n                        tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n                    }\r\n                }\r\n            };\r\n            return TextureAtlasPage;\r\n        }());\r\n        core.TextureAtlasPage = TextureAtlasPage;\r\n        var TextureAtlasRegion = (function (_super) {\r\n            __extends(TextureAtlasRegion, _super);\r\n            function TextureAtlasRegion() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            return TextureAtlasRegion;\r\n        }(core.TextureRegion));\r\n        core.TextureAtlasRegion = TextureAtlasRegion;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TransformConstraint = (function () {\r\n            function TransformConstraint(data, skeleton) {\r\n                this.rotateMix = 0;\r\n                this.translateMix = 0;\r\n                this.scaleMix = 0;\r\n                this.shearMix = 0;\r\n                this.temp = new core.Vector2();\r\n                this.active = false;\r\n                if (data == null)\r\n                    throw new Error(\"data cannot be null.\");\r\n                if (skeleton == null)\r\n                    throw new Error(\"skeleton cannot be null.\");\r\n                this.data = data;\r\n                this.rotateMix = data.rotateMix;\r\n                this.translateMix = data.translateMix;\r\n                this.scaleMix = data.scaleMix;\r\n                this.shearMix = data.shearMix;\r\n                this.bones = new Array();\r\n                for (var i = 0; i < data.bones.length; i++)\r\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\r\n                this.target = skeleton.findBone(data.target.name);\r\n            }\r\n            TransformConstraint.prototype.isActive = function () {\r\n                return this.active;\r\n            };\r\n            TransformConstraint.prototype.apply = function () {\r\n                this.update();\r\n            };\r\n            TransformConstraint.prototype.update = function () {\r\n                if (this.data.local) {\r\n                    if (this.data.relative)\r\n                        this.applyRelativeLocal();\r\n                    else\r\n                        this.applyAbsoluteLocal();\r\n                }\r\n                else {\r\n                    if (this.data.relative)\r\n                        this.applyRelativeWorld();\r\n                    else\r\n                        this.applyAbsoluteWorld();\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                var targetMat = target.matrix;\r\n                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                var offsetRotation = this.data.offsetRotation * degRadReflect;\r\n                var offsetShearY = this.data.offsetShearY * degRadReflect;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    var modified = false;\r\n                    var mat = bone.matrix;\r\n                    if (rotateMix != 0) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        var cos = Math.cos(r), sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                        modified = true;\r\n                    }\r\n                    if (translateMix != 0) {\r\n                        var temp = this.temp;\r\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                        mat.tx += (temp.x - mat.tx) * translateMix;\r\n                        mat.ty += (temp.y - mat.ty) * translateMix;\r\n                        modified = true;\r\n                    }\r\n                    if (scaleMix > 0) {\r\n                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                        var ts = Math.sqrt(ta * ta + tc * tc);\r\n                        if (s > 0.00001)\r\n                            s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                        mat.a *= s;\r\n                        mat.b *= s;\r\n                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                        ts = Math.sqrt(tb * tb + td * td);\r\n                        if (s > 0.00001)\r\n                            s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                        mat.c *= s;\r\n                        mat.d *= s;\r\n                        modified = true;\r\n                    }\r\n                    if (shearMix > 0) {\r\n                        var b = mat.c, d = mat.d;\r\n                        var by = Math.atan2(d, b);\r\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r = by + (r + offsetShearY) * shearMix;\r\n                        var s = Math.sqrt(b * b + d * d);\r\n                        mat.c = Math.cos(r) * s;\r\n                        mat.d = Math.sin(r) * s;\r\n                        modified = true;\r\n                    }\r\n                    if (modified)\r\n                        bone.appliedValid = false;\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyRelativeWorld = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                var targetMat = target.matrix;\r\n                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\r\n                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    var modified = false;\r\n                    var mat = bone.matrix;\r\n                    if (rotateMix != 0) {\r\n                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                        var r = Math.atan2(tc, ta) + offsetRotation;\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        r *= rotateMix;\r\n                        var cos = Math.cos(r), sin = Math.sin(r);\r\n                        mat.a = cos * a - sin * c;\r\n                        mat.c = cos * b - sin * d;\r\n                        mat.b = sin * a + cos * c;\r\n                        mat.d = sin * b + cos * d;\r\n                        modified = true;\r\n                    }\r\n                    if (translateMix != 0) {\r\n                        var temp = this.temp;\r\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                        mat.tx += temp.x * translateMix;\r\n                        mat.ty += temp.y * translateMix;\r\n                        modified = true;\r\n                    }\r\n                    if (scaleMix > 0) {\r\n                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                        mat.a *= s;\r\n                        mat.b *= s;\r\n                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                        mat.c *= s;\r\n                        mat.d *= s;\r\n                        modified = true;\r\n                    }\r\n                    if (shearMix > 0) {\r\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                        if (r > core.MathUtils.PI)\r\n                            r -= core.MathUtils.PI2;\r\n                        else if (r < -core.MathUtils.PI)\r\n                            r += core.MathUtils.PI2;\r\n                        var b = mat.c, d = mat.d;\r\n                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                        var s = Math.sqrt(b * b + d * d);\r\n                        mat.c = Math.cos(r) * s;\r\n                        mat.d = Math.sin(r) * s;\r\n                        modified = true;\r\n                    }\r\n                    if (modified)\r\n                        bone.appliedValid = false;\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                if (!target.appliedValid)\r\n                    target.updateAppliedTransform();\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.appliedValid)\r\n                        bone.updateAppliedTransform();\r\n                    var rotation = bone.arotation;\r\n                    if (rotateMix != 0) {\r\n                        var r = target.arotation - rotation + this.data.offsetRotation;\r\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                        rotation += r * rotateMix;\r\n                    }\r\n                    var x = bone.ax, y = bone.ay;\r\n                    if (translateMix != 0) {\r\n                        x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                        y += (target.ay - y + this.data.offsetY) * translateMix;\r\n                    }\r\n                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                    if (scaleMix > 0) {\r\n                        if (scaleX > 0.00001)\r\n                            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                        if (scaleY > 0.00001)\r\n                            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n                    }\r\n                    var shearY = bone.ashearY;\r\n                    if (shearMix > 0) {\r\n                        var r = target.ashearY - shearY + this.data.offsetShearY;\r\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                        bone.shearY += r * shearMix;\r\n                    }\r\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n                }\r\n            };\r\n            TransformConstraint.prototype.applyRelativeLocal = function () {\r\n                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n                var target = this.target;\r\n                if (!target.appliedValid)\r\n                    target.updateAppliedTransform();\r\n                var bones = this.bones;\r\n                for (var i = 0, n = bones.length; i < n; i++) {\r\n                    var bone = bones[i];\r\n                    if (!bone.appliedValid)\r\n                        bone.updateAppliedTransform();\r\n                    var rotation = bone.arotation;\r\n                    if (rotateMix != 0)\r\n                        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n                    var x = bone.ax, y = bone.ay;\r\n                    if (translateMix != 0) {\r\n                        x += (target.ax + this.data.offsetX) * translateMix;\r\n                        y += (target.ay + this.data.offsetY) * translateMix;\r\n                    }\r\n                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                    if (scaleMix > 0) {\r\n                        if (scaleX > 0.00001)\r\n                            scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                        if (scaleY > 0.00001)\r\n                            scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n                    }\r\n                    var shearY = bone.ashearY;\r\n                    if (shearMix > 0)\r\n                        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n                }\r\n            };\r\n            return TransformConstraint;\r\n        }());\r\n        core.TransformConstraint = TransformConstraint;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var TransformConstraintData = (function (_super) {\r\n            __extends(TransformConstraintData, _super);\r\n            function TransformConstraintData(name) {\r\n                var _this = _super.call(this, name, 0, false) || this;\r\n                _this.bones = new Array();\r\n                _this.rotateMix = 0;\r\n                _this.translateMix = 0;\r\n                _this.scaleMix = 0;\r\n                _this.shearMix = 0;\r\n                _this.offsetRotation = 0;\r\n                _this.offsetX = 0;\r\n                _this.offsetY = 0;\r\n                _this.offsetScaleX = 0;\r\n                _this.offsetScaleY = 0;\r\n                _this.offsetShearY = 0;\r\n                _this.relative = false;\r\n                _this.local = false;\r\n                return _this;\r\n            }\r\n            return TransformConstraintData;\r\n        }(core.ConstraintData));\r\n        core.TransformConstraintData = TransformConstraintData;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Triangulator = (function () {\r\n            function Triangulator() {\r\n                this.convexPolygons = new Array();\r\n                this.convexPolygonsIndices = new Array();\r\n                this.indicesArray = new Array();\r\n                this.isConcaveArray = new Array();\r\n                this.triangles = new Array();\r\n                this.polygonPool = new core.Pool(function () {\r\n                    return new Array();\r\n                });\r\n                this.polygonIndicesPool = new core.Pool(function () {\r\n                    return new Array();\r\n                });\r\n            }\r\n            Triangulator.prototype.triangulate = function (verticesArray) {\r\n                var vertices = verticesArray;\r\n                var vertexCount = verticesArray.length >> 1;\r\n                var indices = this.indicesArray;\r\n                indices.length = 0;\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    indices[i] = i;\r\n                var isConcave = this.isConcaveArray;\r\n                isConcave.length = 0;\r\n                for (var i = 0, n = vertexCount; i < n; ++i)\r\n                    isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n                var triangles = this.triangles;\r\n                triangles.length = 0;\r\n                while (vertexCount > 3) {\r\n                    var previous = vertexCount - 1, i = 0, next = 1;\r\n                    while (true) {\r\n                        outer: if (!isConcave[i]) {\r\n                            var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n                            var p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n                            var p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n                            var p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n                                if (!isConcave[ii])\r\n                                    continue;\r\n                                var v = indices[ii] << 1;\r\n                                var vx = vertices[v], vy = vertices[v + 1];\r\n                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n                                            break outer;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (next == 0) {\r\n                            do {\r\n                                if (!isConcave[i])\r\n                                    break;\r\n                                i--;\r\n                            } while (i > 0);\r\n                            break;\r\n                        }\r\n                        previous = i;\r\n                        i = next;\r\n                        next = (next + 1) % vertexCount;\r\n                    }\r\n                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n                    triangles.push(indices[i]);\r\n                    triangles.push(indices[(i + 1) % vertexCount]);\r\n                    indices.splice(i, 1);\r\n                    isConcave.splice(i, 1);\r\n                    vertexCount--;\r\n                    var previousIndex = (vertexCount + i - 1) % vertexCount;\r\n                    var nextIndex = i == vertexCount ? 0 : i;\r\n                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n                }\r\n                if (vertexCount == 3) {\r\n                    triangles.push(indices[2]);\r\n                    triangles.push(indices[0]);\r\n                    triangles.push(indices[1]);\r\n                }\r\n                return triangles;\r\n            };\r\n            Triangulator.prototype.decompose = function (verticesArray, triangles) {\r\n                var vertices = verticesArray;\r\n                var convexPolygons = this.convexPolygons;\r\n                this.polygonPool.freeAll(convexPolygons);\r\n                convexPolygons.length = 0;\r\n                var convexPolygonsIndices = this.convexPolygonsIndices;\r\n                this.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n                convexPolygonsIndices.length = 0;\r\n                var polygonIndices = this.polygonIndicesPool.obtain();\r\n                polygonIndices.length = 0;\r\n                var polygon = this.polygonPool.obtain();\r\n                polygon.length = 0;\r\n                var fanBaseIndex = -1, lastWinding = 0;\r\n                for (var i = 0, n = triangles.length; i < n; i += 3) {\r\n                    var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n                    var x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n                    var x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n                    var x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n                    var merged = false;\r\n                    if (fanBaseIndex == t1) {\r\n                        var o = polygon.length - 4;\r\n                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n                        if (winding1 == lastWinding && winding2 == lastWinding) {\r\n                            polygon.push(x3);\r\n                            polygon.push(y3);\r\n                            polygonIndices.push(t3);\r\n                            merged = true;\r\n                        }\r\n                    }\r\n                    if (!merged) {\r\n                        if (polygon.length > 0) {\r\n                            convexPolygons.push(polygon);\r\n                            convexPolygonsIndices.push(polygonIndices);\r\n                        }\r\n                        else {\r\n                            this.polygonPool.free(polygon);\r\n                            this.polygonIndicesPool.free(polygonIndices);\r\n                        }\r\n                        polygon = this.polygonPool.obtain();\r\n                        polygon.length = 0;\r\n                        polygon.push(x1);\r\n                        polygon.push(y1);\r\n                        polygon.push(x2);\r\n                        polygon.push(y2);\r\n                        polygon.push(x3);\r\n                        polygon.push(y3);\r\n                        polygonIndices = this.polygonIndicesPool.obtain();\r\n                        polygonIndices.length = 0;\r\n                        polygonIndices.push(t1);\r\n                        polygonIndices.push(t2);\r\n                        polygonIndices.push(t3);\r\n                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n                        fanBaseIndex = t1;\r\n                    }\r\n                }\r\n                if (polygon.length > 0) {\r\n                    convexPolygons.push(polygon);\r\n                    convexPolygonsIndices.push(polygonIndices);\r\n                }\r\n                for (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n                    polygonIndices = convexPolygonsIndices[i];\r\n                    if (polygonIndices.length == 0)\r\n                        continue;\r\n                    var firstIndex = polygonIndices[0];\r\n                    var lastIndex = polygonIndices[polygonIndices.length - 1];\r\n                    polygon = convexPolygons[i];\r\n                    var o = polygon.length - 4;\r\n                    var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n                    var prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n                    var firstX = polygon[0], firstY = polygon[1];\r\n                    var secondX = polygon[2], secondY = polygon[3];\r\n                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n                    for (var ii = 0; ii < n; ii++) {\r\n                        if (ii == i)\r\n                            continue;\r\n                        var otherIndices = convexPolygonsIndices[ii];\r\n                        if (otherIndices.length != 3)\r\n                            continue;\r\n                        var otherFirstIndex = otherIndices[0];\r\n                        var otherSecondIndex = otherIndices[1];\r\n                        var otherLastIndex = otherIndices[2];\r\n                        var otherPoly = convexPolygons[ii];\r\n                        var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n                            continue;\r\n                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n                        if (winding1 == winding && winding2 == winding) {\r\n                            otherPoly.length = 0;\r\n                            otherIndices.length = 0;\r\n                            polygon.push(x3);\r\n                            polygon.push(y3);\r\n                            polygonIndices.push(otherLastIndex);\r\n                            prevPrevX = prevX;\r\n                            prevPrevY = prevY;\r\n                            prevX = x3;\r\n                            prevY = y3;\r\n                            ii = 0;\r\n                        }\r\n                    }\r\n                }\r\n                for (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n                    polygon = convexPolygons[i];\r\n                    if (polygon.length == 0) {\r\n                        convexPolygons.splice(i, 1);\r\n                        this.polygonPool.free(polygon);\r\n                        polygonIndices = convexPolygonsIndices[i];\r\n                        convexPolygonsIndices.splice(i, 1);\r\n                        this.polygonIndicesPool.free(polygonIndices);\r\n                    }\r\n                }\r\n                return convexPolygons;\r\n            };\r\n            Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n                var current = indices[index] << 1;\r\n                var next = indices[(index + 1) % vertexCount] << 1;\r\n                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n            };\r\n            Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n            };\r\n            Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n                var px = p2x - p1x, py = p2y - p1y;\r\n                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n            };\r\n            return Triangulator;\r\n        }());\r\n        core.Triangulator = Triangulator;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var IntSet = (function () {\r\n            function IntSet() {\r\n                this.array = new Array();\r\n            }\r\n            IntSet.prototype.add = function (value) {\r\n                var contains = this.contains(value);\r\n                this.array[value | 0] = value | 0;\r\n                return !contains;\r\n            };\r\n            IntSet.prototype.contains = function (value) {\r\n                return this.array[value | 0] != undefined;\r\n            };\r\n            IntSet.prototype.remove = function (value) {\r\n                this.array[value | 0] = undefined;\r\n            };\r\n            IntSet.prototype.clear = function () {\r\n                this.array.length = 0;\r\n            };\r\n            return IntSet;\r\n        }());\r\n        core.IntSet = IntSet;\r\n        var Color = (function () {\r\n            function Color(r, g, b, a) {\r\n                if (r === void 0) { r = 0; }\r\n                if (g === void 0) { g = 0; }\r\n                if (b === void 0) { b = 0; }\r\n                if (a === void 0) { a = 0; }\r\n                this.r = r;\r\n                this.g = g;\r\n                this.b = b;\r\n                this.a = a;\r\n            }\r\n            Color.prototype.set = function (r, g, b, a) {\r\n                this.r = r;\r\n                this.g = g;\r\n                this.b = b;\r\n                this.a = a;\r\n                this.clamp();\r\n                return this;\r\n            };\r\n            Color.prototype.setFromColor = function (c) {\r\n                this.r = c.r;\r\n                this.g = c.g;\r\n                this.b = c.b;\r\n                this.a = c.a;\r\n                return this;\r\n            };\r\n            Color.prototype.setFromString = function (hex) {\r\n                hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n                this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n                this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n                this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n                return this;\r\n            };\r\n            Color.prototype.add = function (r, g, b, a) {\r\n                this.r += r;\r\n                this.g += g;\r\n                this.b += b;\r\n                this.a += a;\r\n                this.clamp();\r\n                return this;\r\n            };\r\n            Color.prototype.clamp = function () {\r\n                if (this.r < 0)\r\n                    this.r = 0;\r\n                else if (this.r > 1)\r\n                    this.r = 1;\r\n                if (this.g < 0)\r\n                    this.g = 0;\r\n                else if (this.g > 1)\r\n                    this.g = 1;\r\n                if (this.b < 0)\r\n                    this.b = 0;\r\n                else if (this.b > 1)\r\n                    this.b = 1;\r\n                if (this.a < 0)\r\n                    this.a = 0;\r\n                else if (this.a > 1)\r\n                    this.a = 1;\r\n                return this;\r\n            };\r\n            Color.rgba8888ToColor = function (color, value) {\r\n                color.r = ((value & 0xff000000) >>> 24) / 255;\r\n                color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n                color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n                color.a = ((value & 0x000000ff)) / 255;\r\n            };\r\n            Color.rgb888ToColor = function (color, value) {\r\n                color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n                color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n                color.b = ((value & 0x000000ff)) / 255;\r\n            };\r\n            Color.WHITE = new Color(1, 1, 1, 1);\r\n            Color.RED = new Color(1, 0, 0, 1);\r\n            Color.GREEN = new Color(0, 1, 0, 1);\r\n            Color.BLUE = new Color(0, 0, 1, 1);\r\n            Color.MAGENTA = new Color(1, 0, 1, 1);\r\n            return Color;\r\n        }());\r\n        core.Color = Color;\r\n        var MathUtils = (function () {\r\n            function MathUtils() {\r\n            }\r\n            MathUtils.clamp = function (value, min, max) {\r\n                if (value < min)\r\n                    return min;\r\n                if (value > max)\r\n                    return max;\r\n                return value;\r\n            };\r\n            MathUtils.cosDeg = function (degrees) {\r\n                return Math.cos(degrees * MathUtils.degRad);\r\n            };\r\n            MathUtils.sinDeg = function (degrees) {\r\n                return Math.sin(degrees * MathUtils.degRad);\r\n            };\r\n            MathUtils.signum = function (value) {\r\n                return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n            };\r\n            MathUtils.toInt = function (x) {\r\n                return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n            };\r\n            MathUtils.cbrt = function (x) {\r\n                var y = Math.pow(Math.abs(x), 1 / 3);\r\n                return x < 0 ? -y : y;\r\n            };\r\n            MathUtils.randomTriangular = function (min, max) {\r\n                return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n            };\r\n            MathUtils.randomTriangularWith = function (min, max, mode) {\r\n                var u = Math.random();\r\n                var d = max - min;\r\n                if (u <= (mode - min) / d)\r\n                    return min + Math.sqrt(u * d * (mode - min));\r\n                return max - Math.sqrt((1 - u) * d * (max - mode));\r\n            };\r\n            MathUtils.PI = 3.1415927;\r\n            MathUtils.PI2 = MathUtils.PI * 2;\r\n            MathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n            MathUtils.radDeg = MathUtils.radiansToDegrees;\r\n            MathUtils.degreesToRadians = MathUtils.PI / 180;\r\n            MathUtils.degRad = MathUtils.degreesToRadians;\r\n            return MathUtils;\r\n        }());\r\n        core.MathUtils = MathUtils;\r\n        var Interpolation = (function () {\r\n            function Interpolation() {\r\n            }\r\n            Interpolation.prototype.apply = function (start, end, a) {\r\n                return start + (end - start) * this.applyInternal(a);\r\n            };\r\n            return Interpolation;\r\n        }());\r\n        core.Interpolation = Interpolation;\r\n        var Pow = (function (_super) {\r\n            __extends(Pow, _super);\r\n            function Pow(power) {\r\n                var _this = _super.call(this) || this;\r\n                _this.power = 2;\r\n                _this.power = power;\r\n                return _this;\r\n            }\r\n            Pow.prototype.applyInternal = function (a) {\r\n                if (a <= 0.5)\r\n                    return Math.pow(a * 2, this.power) / 2;\r\n                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n            };\r\n            return Pow;\r\n        }(Interpolation));\r\n        core.Pow = Pow;\r\n        var PowOut = (function (_super) {\r\n            __extends(PowOut, _super);\r\n            function PowOut(power) {\r\n                return _super.call(this, power) || this;\r\n            }\r\n            PowOut.prototype.applyInternal = function (a) {\r\n                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n            };\r\n            return PowOut;\r\n        }(Pow));\r\n        core.PowOut = PowOut;\r\n        var Utils = (function () {\r\n            function Utils() {\r\n            }\r\n            Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n                for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n                    dest[j] = source[i];\r\n                }\r\n            };\r\n            Utils.setArraySize = function (array, size, value) {\r\n                if (value === void 0) { value = 0; }\r\n                var oldSize = array.length;\r\n                if (oldSize == size)\r\n                    return array;\r\n                array.length = size;\r\n                if (oldSize < size) {\r\n                    for (var i = oldSize; i < size; i++)\r\n                        array[i] = value;\r\n                }\r\n                return array;\r\n            };\r\n            Utils.ensureArrayCapacity = function (array, size, value) {\r\n                if (value === void 0) { value = 0; }\r\n                if (array.length >= size)\r\n                    return array;\r\n                return Utils.setArraySize(array, size, value);\r\n            };\r\n            Utils.newArray = function (size, defaultValue) {\r\n                var array = new Array(size);\r\n                for (var i = 0; i < size; i++)\r\n                    array[i] = defaultValue;\r\n                return array;\r\n            };\r\n            Utils.newFloatArray = function (size) {\r\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                    return new Float32Array(size);\r\n                }\r\n                else {\r\n                    var array = new Array(size);\r\n                    for (var i = 0; i < array.length; i++)\r\n                        array[i] = 0;\r\n                    return array;\r\n                }\r\n            };\r\n            Utils.newShortArray = function (size) {\r\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                    return new Int16Array(size);\r\n                }\r\n                else {\r\n                    var array = new Array(size);\r\n                    for (var i = 0; i < array.length; i++)\r\n                        array[i] = 0;\r\n                    return array;\r\n                }\r\n            };\r\n            Utils.toFloatArray = function (array) {\r\n                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n            };\r\n            Utils.toSinglePrecision = function (value) {\r\n                return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n            };\r\n            Utils.webkit602BugfixHelper = function (alpha, blend) {\r\n            };\r\n            Utils.contains = function (array, element, identity) {\r\n                if (identity === void 0) { identity = true; }\r\n                for (var i = 0; i < array.length; i++) {\r\n                    if (array[i] == element)\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n            return Utils;\r\n        }());\r\n        core.Utils = Utils;\r\n        var DebugUtils = (function () {\r\n            function DebugUtils() {\r\n            }\r\n            DebugUtils.logBones = function (skeleton) {\r\n                for (var i = 0; i < skeleton.bones.length; i++) {\r\n                    var bone = skeleton.bones[i];\r\n                    var mat = bone.matrix;\r\n                    console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\r\n                }\r\n            };\r\n            return DebugUtils;\r\n        }());\r\n        core.DebugUtils = DebugUtils;\r\n        var Pool = (function () {\r\n            function Pool(instantiator) {\r\n                this.items = new Array();\r\n                this.instantiator = instantiator;\r\n            }\r\n            Pool.prototype.obtain = function () {\r\n                return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n            };\r\n            Pool.prototype.free = function (item) {\r\n                if (item.reset)\r\n                    item.reset();\r\n                this.items.push(item);\r\n            };\r\n            Pool.prototype.freeAll = function (items) {\r\n                for (var i = 0; i < items.length; i++) {\r\n                    this.free(items[i]);\r\n                }\r\n            };\r\n            Pool.prototype.clear = function () {\r\n                this.items.length = 0;\r\n            };\r\n            return Pool;\r\n        }());\r\n        core.Pool = Pool;\r\n        var Vector2 = (function () {\r\n            function Vector2(x, y) {\r\n                if (x === void 0) { x = 0; }\r\n                if (y === void 0) { y = 0; }\r\n                this.x = x;\r\n                this.y = y;\r\n            }\r\n            Vector2.prototype.set = function (x, y) {\r\n                this.x = x;\r\n                this.y = y;\r\n                return this;\r\n            };\r\n            Vector2.prototype.length = function () {\r\n                var x = this.x;\r\n                var y = this.y;\r\n                return Math.sqrt(x * x + y * y);\r\n            };\r\n            Vector2.prototype.normalize = function () {\r\n                var len = this.length();\r\n                if (len != 0) {\r\n                    this.x /= len;\r\n                    this.y /= len;\r\n                }\r\n                return this;\r\n            };\r\n            return Vector2;\r\n        }());\r\n        core.Vector2 = Vector2;\r\n        var TimeKeeper = (function () {\r\n            function TimeKeeper() {\r\n                this.maxDelta = 0.064;\r\n                this.framesPerSecond = 0;\r\n                this.delta = 0;\r\n                this.totalTime = 0;\r\n                this.lastTime = Date.now() / 1000;\r\n                this.frameCount = 0;\r\n                this.frameTime = 0;\r\n            }\r\n            TimeKeeper.prototype.update = function () {\r\n                var now = Date.now() / 1000;\r\n                this.delta = now - this.lastTime;\r\n                this.frameTime += this.delta;\r\n                this.totalTime += this.delta;\r\n                if (this.delta > this.maxDelta)\r\n                    this.delta = this.maxDelta;\r\n                this.lastTime = now;\r\n                this.frameCount++;\r\n                if (this.frameTime > 1) {\r\n                    this.framesPerSecond = this.frameCount / this.frameTime;\r\n                    this.frameTime = 0;\r\n                    this.frameCount = 0;\r\n                }\r\n            };\r\n            return TimeKeeper;\r\n        }());\r\n        core.TimeKeeper = TimeKeeper;\r\n        var WindowedMean = (function () {\r\n            function WindowedMean(windowSize) {\r\n                if (windowSize === void 0) { windowSize = 32; }\r\n                this.addedValues = 0;\r\n                this.lastValue = 0;\r\n                this.mean = 0;\r\n                this.dirty = true;\r\n                this.values = new Array(windowSize);\r\n            }\r\n            WindowedMean.prototype.hasEnoughData = function () {\r\n                return this.addedValues >= this.values.length;\r\n            };\r\n            WindowedMean.prototype.addValue = function (value) {\r\n                if (this.addedValues < this.values.length)\r\n                    this.addedValues++;\r\n                this.values[this.lastValue++] = value;\r\n                if (this.lastValue > this.values.length - 1)\r\n                    this.lastValue = 0;\r\n                this.dirty = true;\r\n            };\r\n            WindowedMean.prototype.getMean = function () {\r\n                if (this.hasEnoughData()) {\r\n                    if (this.dirty) {\r\n                        var mean = 0;\r\n                        for (var i = 0; i < this.values.length; i++) {\r\n                            mean += this.values[i];\r\n                        }\r\n                        this.mean = mean / this.values.length;\r\n                        this.dirty = false;\r\n                    }\r\n                    return this.mean;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n            };\r\n            return WindowedMean;\r\n        }());\r\n        core.WindowedMean = WindowedMean;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var Attachment = (function () {\r\n            function Attachment(name) {\r\n                if (name == null)\r\n                    throw new Error(\"name cannot be null.\");\r\n                this.name = name;\r\n            }\r\n            return Attachment;\r\n        }());\r\n        core.Attachment = Attachment;\r\n        var VertexAttachment = (function (_super) {\r\n            __extends(VertexAttachment, _super);\r\n            function VertexAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n                _this.worldVerticesLength = 0;\r\n                _this.deformAttachment = _this;\r\n                return _this;\r\n            }\r\n            VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {\r\n                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n            };\r\n            VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n                count = offset + (count >> 1) * stride;\r\n                var skeleton = slot.bone.skeleton;\r\n                var deformArray = slot.deform;\r\n                var vertices = this.vertices;\r\n                var bones = this.bones;\r\n                if (bones == null) {\r\n                    if (deformArray.length > 0)\r\n                        vertices = deformArray;\r\n                    var mat = slot.bone.matrix;\r\n                    var x = mat.tx;\r\n                    var y = mat.ty;\r\n                    var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n                        var vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n                        worldVertices[w] = vx * a + vy * b + x;\r\n                        worldVertices[w + 1] = vx * c + vy * d + y;\r\n                    }\r\n                    return;\r\n                }\r\n                var v = 0, skip = 0;\r\n                for (var i = 0; i < start; i += 2) {\r\n                    var n = bones[v];\r\n                    v += n + 1;\r\n                    skip += n;\r\n                }\r\n                var skeletonBones = skeleton.bones;\r\n                if (deformArray.length == 0) {\r\n                    for (var w = offset, b = skip * 3; w < count; w += stride) {\r\n                        var wx = 0, wy = 0;\r\n                        var n = bones[v++];\r\n                        n += v;\r\n                        for (; v < n; v++, b += 3) {\r\n                            var mat = skeletonBones[bones[v]].matrix;\r\n                            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                        }\r\n                        worldVertices[w] = wx;\r\n                        worldVertices[w + 1] = wy;\r\n                    }\r\n                }\r\n                else {\r\n                    var deform = deformArray;\r\n                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                        var wx = 0, wy = 0;\r\n                        var n = bones[v++];\r\n                        n += v;\r\n                        for (; v < n; v++, b += 3, f += 2) {\r\n                            var mat = skeletonBones[bones[v]].matrix;\r\n                            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                        }\r\n                        worldVertices[w] = wx;\r\n                        worldVertices[w + 1] = wy;\r\n                    }\r\n                }\r\n            };\r\n            VertexAttachment.prototype.copyTo = function (attachment) {\r\n                if (this.bones != null) {\r\n                    attachment.bones = new Array(this.bones.length);\r\n                    core.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n                }\r\n                else\r\n                    attachment.bones = null;\r\n                if (this.vertices != null) {\r\n                    attachment.vertices = core.Utils.newFloatArray(this.vertices.length);\r\n                    core.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n                }\r\n                else\r\n                    attachment.vertices = null;\r\n                attachment.worldVerticesLength = this.worldVerticesLength;\r\n                attachment.deformAttachment = this.deformAttachment;\r\n            };\r\n            VertexAttachment.nextID = 0;\r\n            return VertexAttachment;\r\n        }(Attachment));\r\n        core.VertexAttachment = VertexAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var AttachmentType;\r\n        (function (AttachmentType) {\r\n            AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n            AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n            AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n            AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n            AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n            AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n            AttachmentType[AttachmentType[\"Clipping\"] = 6] = \"Clipping\";\r\n        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var BoundingBoxAttachment = (function (_super) {\r\n            __extends(BoundingBoxAttachment, _super);\r\n            function BoundingBoxAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            BoundingBoxAttachment.prototype.copy = function () {\r\n                var copy = new BoundingBoxAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return BoundingBoxAttachment;\r\n        }(core.VertexAttachment));\r\n        core.BoundingBoxAttachment = BoundingBoxAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var ClippingAttachment = (function (_super) {\r\n            __extends(ClippingAttachment, _super);\r\n            function ClippingAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);\r\n                return _this;\r\n            }\r\n            ClippingAttachment.prototype.copy = function () {\r\n                var copy = new ClippingAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.endSlot = this.endSlot;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return ClippingAttachment;\r\n        }(core.VertexAttachment));\r\n        core.ClippingAttachment = ClippingAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var MeshAttachment = (function (_super) {\r\n            __extends(MeshAttachment, _super);\r\n            function MeshAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                _this.tempColor = new core.Color(0, 0, 0, 0);\r\n                return _this;\r\n            }\r\n            MeshAttachment.prototype.getParentMesh = function () {\r\n                return this.parentMesh;\r\n            };\r\n            MeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n                this.parentMesh = parentMesh;\r\n                if (parentMesh != null) {\r\n                    this.bones = parentMesh.bones;\r\n                    this.vertices = parentMesh.vertices;\r\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                    this.regionUVs = parentMesh.regionUVs;\r\n                    this.triangles = parentMesh.triangles;\r\n                    this.hullLength = parentMesh.hullLength;\r\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                }\r\n            };\r\n            MeshAttachment.prototype.copy = function () {\r\n                if (this.parentMesh != null)\r\n                    return this.newLinkedMesh();\r\n                var copy = new MeshAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.path = this.path;\r\n                copy.color.setFromColor(this.color);\r\n                this.copyTo(copy);\r\n                copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n                core.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n                copy.uvs = new Array(this.uvs.length);\r\n                core.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\r\n                copy.triangles = new Array(this.triangles.length);\r\n                core.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n                copy.hullLength = this.hullLength;\r\n                if (this.edges != null) {\r\n                    copy.edges = new Array(this.edges.length);\r\n                    core.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n                }\r\n                copy.width = this.width;\r\n                copy.height = this.height;\r\n                return copy;\r\n            };\r\n            MeshAttachment.prototype.newLinkedMesh = function () {\r\n                var copy = new MeshAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.path = this.path;\r\n                copy.color.setFromColor(this.color);\r\n                copy.deformAttachment = this.deformAttachment;\r\n                copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n                return copy;\r\n            };\r\n            return MeshAttachment;\r\n        }(core.VertexAttachment));\r\n        core.MeshAttachment = MeshAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PathAttachment = (function (_super) {\r\n            __extends(PathAttachment, _super);\r\n            function PathAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.closed = false;\r\n                _this.constantSpeed = false;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            PathAttachment.prototype.copy = function () {\r\n                var copy = new PathAttachment(this.name);\r\n                this.copyTo(copy);\r\n                copy.lengths = new Array(this.lengths.length);\r\n                core.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n                copy.closed = closed;\r\n                copy.constantSpeed = this.constantSpeed;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return PathAttachment;\r\n        }(core.VertexAttachment));\r\n        core.PathAttachment = PathAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var PointAttachment = (function (_super) {\r\n            __extends(PointAttachment, _super);\r\n            function PointAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.color = new core.Color(0.38, 0.94, 0, 1);\r\n                return _this;\r\n            }\r\n            PointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n                var mat = bone.matrix;\r\n                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n                return point;\r\n            };\r\n            PointAttachment.prototype.computeWorldRotation = function (bone) {\r\n                var mat = bone.matrix;\r\n                var cos = core.MathUtils.cosDeg(this.rotation), sin = core.MathUtils.sinDeg(this.rotation);\r\n                var x = cos * mat.a + sin * mat.c;\r\n                var y = cos * mat.b + sin * mat.d;\r\n                return Math.atan2(y, x) * core.MathUtils.radDeg;\r\n            };\r\n            PointAttachment.prototype.copy = function () {\r\n                var copy = new PointAttachment(this.name);\r\n                copy.x = this.x;\r\n                copy.y = this.y;\r\n                copy.rotation = this.rotation;\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            return PointAttachment;\r\n        }(core.VertexAttachment));\r\n        core.PointAttachment = PointAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var RegionAttachment = (function (_super) {\r\n            __extends(RegionAttachment, _super);\r\n            function RegionAttachment(name) {\r\n                var _this = _super.call(this, name) || this;\r\n                _this.x = 0;\r\n                _this.y = 0;\r\n                _this.scaleX = 1;\r\n                _this.scaleY = 1;\r\n                _this.rotation = 0;\r\n                _this.width = 0;\r\n                _this.height = 0;\r\n                _this.color = new core.Color(1, 1, 1, 1);\r\n                _this.offset = core.Utils.newFloatArray(8);\r\n                _this.uvs = core.Utils.newFloatArray(8);\r\n                _this.tempColor = new core.Color(1, 1, 1, 1);\r\n                return _this;\r\n            }\r\n            RegionAttachment.prototype.updateOffset = function () {\r\n                var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n                var localX2 = localX + this.region.width * regionScaleX;\r\n                var localY2 = localY + this.region.height * regionScaleY;\r\n                var radians = this.rotation * Math.PI / 180;\r\n                var cos = Math.cos(radians);\r\n                var sin = Math.sin(radians);\r\n                var localXCos = localX * cos + this.x;\r\n                var localXSin = localX * sin;\r\n                var localYCos = localY * cos + this.y;\r\n                var localYSin = localY * sin;\r\n                var localX2Cos = localX2 * cos + this.x;\r\n                var localX2Sin = localX2 * sin;\r\n                var localY2Cos = localY2 * cos + this.y;\r\n                var localY2Sin = localY2 * sin;\r\n                var offset = this.offset;\r\n                offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n                offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n                offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n                offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n                offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n                offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n            };\r\n            RegionAttachment.prototype.setRegion = function (region) {\r\n                this.region = region;\r\n                var uvs = this.uvs;\r\n                if (region.rotate) {\r\n                    uvs[2] = region.u;\r\n                    uvs[3] = region.v2;\r\n                    uvs[4] = region.u;\r\n                    uvs[5] = region.v;\r\n                    uvs[6] = region.u2;\r\n                    uvs[7] = region.v;\r\n                    uvs[0] = region.u2;\r\n                    uvs[1] = region.v2;\r\n                }\r\n                else {\r\n                    uvs[0] = region.u;\r\n                    uvs[1] = region.v2;\r\n                    uvs[2] = region.u;\r\n                    uvs[3] = region.v;\r\n                    uvs[4] = region.u2;\r\n                    uvs[5] = region.v;\r\n                    uvs[6] = region.u2;\r\n                    uvs[7] = region.v2;\r\n                }\r\n            };\r\n            RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n                var vertexOffset = this.offset;\r\n                var mat = bone.matrix;\r\n                var x = mat.tx, y = mat.ty;\r\n                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                var offsetX = 0, offsetY = 0;\r\n                offsetX = vertexOffset[RegionAttachment.OX1];\r\n                offsetY = vertexOffset[RegionAttachment.OY1];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX2];\r\n                offsetY = vertexOffset[RegionAttachment.OY2];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX3];\r\n                offsetY = vertexOffset[RegionAttachment.OY3];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n                offset += stride;\r\n                offsetX = vertexOffset[RegionAttachment.OX4];\r\n                offsetY = vertexOffset[RegionAttachment.OY4];\r\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n            };\r\n            RegionAttachment.prototype.copy = function () {\r\n                var copy = new RegionAttachment(this.name);\r\n                copy.region = this.region;\r\n                copy.rendererObject = this.rendererObject;\r\n                copy.path = this.path;\r\n                copy.x = this.x;\r\n                copy.y = this.y;\r\n                copy.scaleX = this.scaleX;\r\n                copy.scaleY = this.scaleY;\r\n                copy.rotation = this.rotation;\r\n                copy.width = this.width;\r\n                copy.height = this.height;\r\n                core.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n                core.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n                copy.color.setFromColor(this.color);\r\n                return copy;\r\n            };\r\n            RegionAttachment.OX1 = 0;\r\n            RegionAttachment.OY1 = 1;\r\n            RegionAttachment.OX2 = 2;\r\n            RegionAttachment.OY2 = 3;\r\n            RegionAttachment.OX3 = 4;\r\n            RegionAttachment.OY3 = 5;\r\n            RegionAttachment.OX4 = 6;\r\n            RegionAttachment.OY4 = 7;\r\n            RegionAttachment.X1 = 0;\r\n            RegionAttachment.Y1 = 1;\r\n            RegionAttachment.C1R = 2;\r\n            RegionAttachment.C1G = 3;\r\n            RegionAttachment.C1B = 4;\r\n            RegionAttachment.C1A = 5;\r\n            RegionAttachment.U1 = 6;\r\n            RegionAttachment.V1 = 7;\r\n            RegionAttachment.X2 = 8;\r\n            RegionAttachment.Y2 = 9;\r\n            RegionAttachment.C2R = 10;\r\n            RegionAttachment.C2G = 11;\r\n            RegionAttachment.C2B = 12;\r\n            RegionAttachment.C2A = 13;\r\n            RegionAttachment.U2 = 14;\r\n            RegionAttachment.V2 = 15;\r\n            RegionAttachment.X3 = 16;\r\n            RegionAttachment.Y3 = 17;\r\n            RegionAttachment.C3R = 18;\r\n            RegionAttachment.C3G = 19;\r\n            RegionAttachment.C3B = 20;\r\n            RegionAttachment.C3A = 21;\r\n            RegionAttachment.U3 = 22;\r\n            RegionAttachment.V3 = 23;\r\n            RegionAttachment.X4 = 24;\r\n            RegionAttachment.Y4 = 25;\r\n            RegionAttachment.C4R = 26;\r\n            RegionAttachment.C4G = 27;\r\n            RegionAttachment.C4B = 28;\r\n            RegionAttachment.C4A = 29;\r\n            RegionAttachment.U4 = 30;\r\n            RegionAttachment.V4 = 31;\r\n            return RegionAttachment;\r\n        }(core.Attachment));\r\n        core.RegionAttachment = RegionAttachment;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var JitterEffect = (function () {\r\n            function JitterEffect(jitterX, jitterY) {\r\n                this.jitterX = 0;\r\n                this.jitterY = 0;\r\n                this.jitterX = jitterX;\r\n                this.jitterY = jitterY;\r\n            }\r\n            JitterEffect.prototype.begin = function (skeleton) {\r\n            };\r\n            JitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n            };\r\n            JitterEffect.prototype.end = function () {\r\n            };\r\n            return JitterEffect;\r\n        }());\r\n        core.JitterEffect = JitterEffect;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    var core;\r\n    (function (core) {\r\n        var SwirlEffect = (function () {\r\n            function SwirlEffect(radius) {\r\n                this.centerX = 0;\r\n                this.centerY = 0;\r\n                this.radius = 0;\r\n                this.angle = 0;\r\n                this.worldX = 0;\r\n                this.worldY = 0;\r\n                this.radius = radius;\r\n            }\r\n            SwirlEffect.prototype.begin = function (skeleton) {\r\n                this.worldX = skeleton.x + this.centerX;\r\n                this.worldY = skeleton.y + this.centerY;\r\n            };\r\n            SwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n                var radAngle = this.angle * core.MathUtils.degreesToRadians;\r\n                var x = position.x - this.worldX;\r\n                var y = position.y - this.worldY;\r\n                var dist = Math.sqrt(x * x + y * y);\r\n                if (dist < this.radius) {\r\n                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n                    var cos = Math.cos(theta);\r\n                    var sin = Math.sin(theta);\r\n                    position.x = cos * x - sin * y + this.worldX;\r\n                    position.y = sin * x + cos * y + this.worldY;\r\n                }\r\n            };\r\n            SwirlEffect.prototype.end = function () {\r\n            };\r\n            SwirlEffect.interpolation = new core.PowOut(2);\r\n            return SwirlEffect;\r\n        }());\r\n        core.SwirlEffect = SwirlEffect;\r\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\r\n})(pixi_spine || (pixi_spine = {}));\r\n(function () {\r\n    if (!Math.fround) {\r\n        Math.fround = Math.fround = (function (array) {\r\n            return function (x) {\r\n                return array[0] = x, array[0];\r\n            };\r\n        })(new Float32Array(1));\r\n    }\r\n})();\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    pixi_spine.core.Bone.yDown = true;\r\n    var tempRgb = [0, 0, 0];\r\n    var SpineSprite = (function (_super) {\r\n        __extends(SpineSprite, _super);\r\n        function SpineSprite() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this.region = null;\r\n            _this.attachment = null;\r\n            return _this;\r\n        }\r\n        return SpineSprite;\r\n    }(PIXI.Sprite));\r\n    pixi_spine.SpineSprite = SpineSprite;\r\n    var gp = PIXI.GraphicsGeometry.prototype;\r\n    if (!gp.invalidate) {\r\n        var tmp_1 = [];\r\n        gp.invalidate = function () {\r\n            var t = this.graphicsData;\r\n            tmp_1.push(0);\r\n            this.graphicsData = tmp_1;\r\n            this.clear();\r\n            this.graphicsData = t;\r\n        };\r\n    }\r\n    var SpineMesh = (function (_super) {\r\n        __extends(SpineMesh, _super);\r\n        function SpineMesh(texture, vertices, uvs, indices, drawMode) {\r\n            var _this = _super.call(this, texture, vertices, uvs, indices, drawMode) || this;\r\n            _this.region = null;\r\n            _this.attachment = null;\r\n            return _this;\r\n        }\r\n        return SpineMesh;\r\n    }(PIXI.SimpleMesh));\r\n    pixi_spine.SpineMesh = SpineMesh;\r\n    var Spine = (function (_super) {\r\n        __extends(Spine, _super);\r\n        function Spine(spineData) {\r\n            var _this = _super.call(this) || this;\r\n            if (!spineData) {\r\n                throw new Error('The spineData param is required.');\r\n            }\r\n            if ((typeof spineData) === \"string\") {\r\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n            }\r\n            _this.spineData = spineData;\r\n            _this.skeleton = new pixi_spine.core.Skeleton(spineData);\r\n            _this.skeleton.updateWorldTransform();\r\n            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);\r\n            _this.state = new pixi_spine.core.AnimationState(_this.stateData);\r\n            _this.slotContainers = [];\r\n            _this.tempClipContainers = [];\r\n            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {\r\n                var slot = _this.skeleton.slots[i];\r\n                var attachment = slot.getAttachment();\r\n                var slotContainer = _this.newContainer();\r\n                _this.slotContainers.push(slotContainer);\r\n                _this.addChild(slotContainer);\r\n                _this.tempClipContainers.push(null);\r\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\r\n                    var spriteName = attachment.region.name;\r\n                    var sprite = _this.createSprite(slot, attachment, spriteName);\r\n                    slot.currentSprite = sprite;\r\n                    slot.currentSpriteName = spriteName;\r\n                    slotContainer.addChild(sprite);\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.MeshAttachment) {\r\n                    var mesh = _this.createMesh(slot, attachment);\r\n                    slot.currentMesh = mesh;\r\n                    slot.currentMeshId = attachment.id;\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\r\n                    _this.createGraphics(slot, attachment);\r\n                    slotContainer.addChild(slot.clippingContainer);\r\n                    slotContainer.addChild(slot.currentGraphics);\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            _this.tintRgb = new Float32Array([1, 1, 1]);\r\n            _this.autoUpdate = true;\r\n            _this.visible = true;\r\n            return _this;\r\n        }\r\n        Object.defineProperty(Spine.prototype, \"autoUpdate\", {\r\n            get: function () {\r\n                return this._autoUpdate;\r\n            },\r\n            set: function (value) {\r\n                if (value !== this._autoUpdate) {\r\n                    this._autoUpdate = value;\r\n                    this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n                }\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"visible\", {\r\n            get: function () {\r\n                return this._visible;\r\n            },\r\n            set: function (value) {\r\n                if (value !== this._visible) {\r\n                    this._visible = value;\r\n                    if (value) {\r\n                        this.lastTime = 0;\r\n                    }\r\n                }\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"tint\", {\r\n            get: function () {\r\n                return PIXI.utils.rgb2hex(this.tintRgb);\r\n            },\r\n            set: function (value) {\r\n                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Spine.prototype, \"delayLimit\", {\r\n            get: function () {\r\n                var limit = typeof this.localDelayLimit !== \"undefined\" ?\r\n                    this.localDelayLimit : Spine.globalDelayLimit;\r\n                return limit || Number.MAX_VALUE;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Spine.prototype.update = function (dt) {\r\n            var delayLimit = this.delayLimit;\r\n            if (dt > delayLimit)\r\n                dt = delayLimit;\r\n            this.state.update(dt);\r\n            this.state.apply(this.skeleton);\r\n            if (!this.skeleton)\r\n                return;\r\n            this.skeleton.updateWorldTransform();\r\n            var slots = this.skeleton.slots;\r\n            var globalClr = this.color;\r\n            var light = null, dark = null;\r\n            if (globalClr) {\r\n                light = globalClr.light;\r\n                dark = globalClr.dark;\r\n            }\r\n            else {\r\n                light = this.tintRgb;\r\n            }\r\n            var thack = false;\r\n            for (var i = 0, n = slots.length; i < n; i++) {\r\n                var slot = slots[i];\r\n                var attachment = slot.getAttachment();\r\n                var slotContainer = this.slotContainers[i];\r\n                if (!attachment) {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n                var spriteColor = null;\r\n                var attColor = attachment.color;\r\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\r\n                    var region = attachment.region;\r\n                    if (region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                            slot.currentMesh = null;\r\n                            slot.currentMeshId = undefined;\r\n                            slot.currentMeshName = undefined;\r\n                        }\r\n                        var ar = region;\r\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\r\n                            var spriteName = ar.name;\r\n                            if (slot.currentSprite) {\r\n                                slot.currentSprite.visible = false;\r\n                            }\r\n                            slot.sprites = slot.sprites || {};\r\n                            if (slot.sprites[spriteName] !== undefined) {\r\n                                slot.sprites[spriteName].visible = true;\r\n                            }\r\n                            else {\r\n                                var sprite = this.createSprite(slot, attachment, spriteName);\r\n                                slotContainer.addChild(sprite);\r\n                            }\r\n                            slot.currentSprite = slot.sprites[spriteName];\r\n                            slot.currentSpriteName = spriteName;\r\n                        }\r\n                        else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\r\n                            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                        }\r\n                    }\r\n                    var transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n                    if (slot.currentSprite.color) {\r\n                        spriteColor = slot.currentSprite.color;\r\n                    }\r\n                    else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.MeshAttachment) {\r\n                    if (slot.currentSprite) {\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n                        var transform = new PIXI.Transform();\r\n                        transform._parentID = -1;\r\n                        transform._worldID = slotContainer.transform._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!slot.currentMeshId || slot.currentMeshId !== attachment.id) {\r\n                        var meshId = attachment.id;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n                        slot.meshes = slot.meshes || {};\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        }\r\n                        else {\r\n                            var mesh = this.createMesh(slot, attachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        spriteColor = slot.currentMesh.color;\r\n                    }\r\n                    else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                }\r\n                else {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n                slotContainer.visible = true;\r\n                if (spriteColor) {\r\n                    var r0 = slot.color.r * attColor.r;\r\n                    var g0 = slot.color.g * attColor.g;\r\n                    var b0 = slot.color.b * attColor.b;\r\n                    spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\r\n                    if (slot.darkColor) {\r\n                        r0 = slot.darkColor.r;\r\n                        g0 = slot.darkColor.g;\r\n                        b0 = slot.darkColor.b;\r\n                    }\r\n                    else {\r\n                        r0 = 0.0;\r\n                        g0 = 0.0;\r\n                        b0 = 0.0;\r\n                    }\r\n                    spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\r\n                }\r\n                slotContainer.alpha = slot.color.a;\r\n            }\r\n            var drawOrder = this.skeleton.drawOrder;\r\n            var clippingAttachment = null;\r\n            var clippingContainer = null;\r\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                var slot = slots[drawOrder[i].data.index];\r\n                var slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n                if (!clippingContainer) {\r\n                    if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                        slotContainer.parent.removeChild(slotContainer);\r\n                        slotContainer.parent = this;\r\n                    }\r\n                }\r\n                if (slot.currentGraphics && slot.getAttachment()) {\r\n                    clippingContainer = slot.clippingContainer;\r\n                    clippingAttachment = slot.getAttachment();\r\n                    clippingContainer.children.length = 0;\r\n                    this.children[i] = slotContainer;\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingAttachment.endSlot = null;\r\n                    }\r\n                }\r\n                else {\r\n                    if (clippingContainer) {\r\n                        var c = this.tempClipContainers[i];\r\n                        if (!c) {\r\n                            c = this.tempClipContainers[i] = this.newContainer();\r\n                            c.visible = false;\r\n                        }\r\n                        this.children[i] = c;\r\n                        slotContainer.parent = null;\r\n                        clippingContainer.addChild(slotContainer);\r\n                        if (clippingAttachment.endSlot == slot.data) {\r\n                            clippingContainer.renderable = true;\r\n                            clippingContainer = null;\r\n                            clippingAttachment = null;\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.children[i] = slotContainer;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ;\r\n        Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {\r\n            if (sprite.attachment === attachment && sprite.region === region) {\r\n                return;\r\n            }\r\n            sprite.region = region;\r\n            sprite.attachment = attachment;\r\n            sprite.texture = region.texture;\r\n            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;\r\n            sprite.position.x = attachment.x;\r\n            sprite.position.y = attachment.y;\r\n            sprite.alpha = attachment.color.a;\r\n            if (!region.size) {\r\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n            }\r\n            else {\r\n                sprite.scale.x = region.size.width / region.originalWidth;\r\n                sprite.scale.y = -region.size.height / region.originalHeight;\r\n            }\r\n        };\r\n        Spine.prototype.setMeshRegion = function (attachment, mesh, region) {\r\n            if (mesh.attachment === attachment && mesh.region === region) {\r\n                return;\r\n            }\r\n            mesh.region = region;\r\n            mesh.attachment = attachment;\r\n            mesh.texture = region.texture;\r\n            region.texture.updateUvs();\r\n            mesh.uvBuffer.update(attachment.regionUVs);\r\n        };\r\n        Spine.prototype.autoUpdateTransform = function () {\r\n            if (Spine.globalAutoUpdate) {\r\n                this.lastTime = this.lastTime || Date.now();\r\n                var timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n                this.lastTime = Date.now();\r\n                this.update(timeDelta);\r\n            }\r\n            else {\r\n                this.lastTime = 0;\r\n            }\r\n            PIXI.Container.prototype.updateTransform.call(this);\r\n        };\r\n        ;\r\n        Spine.prototype.createSprite = function (slot, attachment, defName) {\r\n            var region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n            }\r\n            var texture = region.texture;\r\n            var sprite = this.newSprite(texture);\r\n            sprite.anchor.set(0.5);\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n            slot.sprites = slot.sprites || {};\r\n            slot.sprites[defName] = sprite;\r\n            return sprite;\r\n        };\r\n        ;\r\n        Spine.prototype.createMesh = function (slot, attachment) {\r\n            var region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n                slot.hackAttachment = null;\r\n                slot.hackRegion = null;\r\n            }\r\n            var strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), PIXI.DRAW_MODES.TRIANGLES);\r\n            if (typeof strip._canvasPadding !== \"undefined\") {\r\n                strip._canvasPadding = 1.5;\r\n            }\r\n            strip.alpha = attachment.color.a;\r\n            strip.region = attachment.region;\r\n            this.setMeshRegion(attachment, strip, region);\r\n            slot.meshes = slot.meshes || {};\r\n            slot.meshes[attachment.id] = strip;\r\n            return strip;\r\n        };\r\n        ;\r\n        Spine.prototype.createGraphics = function (slot, clip) {\r\n            var graphics = this.newGraphics();\r\n            var poly = new PIXI.Polygon([]);\r\n            graphics.clear();\r\n            graphics.beginFill(0xffffff, 1);\r\n            graphics.drawPolygon(poly);\r\n            graphics.renderable = false;\r\n            slot.currentGraphics = graphics;\r\n            slot.clippingContainer = this.newContainer();\r\n            slot.clippingContainer.mask = slot.currentGraphics;\r\n            return graphics;\r\n        };\r\n        Spine.prototype.updateGraphics = function (slot, clip) {\r\n            var geom = slot.currentGraphics.geometry;\r\n            var vertices = geom.graphicsData[0].shape.points;\r\n            var n = clip.worldVerticesLength;\r\n            vertices.length = n;\r\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n            geom.invalidate();\r\n        };\r\n        Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {\r\n            if (texture === void 0) { texture = null; }\r\n            if (size === void 0) { size = null; }\r\n            var slot = this.skeleton.slots[slotIndex];\r\n            if (!slot) {\r\n                return false;\r\n            }\r\n            var attachment = slot.getAttachment();\r\n            var region = attachment.region;\r\n            if (texture) {\r\n                region = new pixi_spine.core.TextureRegion();\r\n                region.texture = texture;\r\n                region.size = size;\r\n                slot.hackRegion = region;\r\n                slot.hackAttachment = attachment;\r\n            }\r\n            else {\r\n                slot.hackRegion = null;\r\n                slot.hackAttachment = null;\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                slot.currentSprite.region = region;\r\n            }\r\n            else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(attachment, slot.currentMesh, region);\r\n            }\r\n            return true;\r\n        };\r\n        Spine.prototype.hackTextureBySlotName = function (slotName, texture, size) {\r\n            if (texture === void 0) { texture = null; }\r\n            if (size === void 0) { size = null; }\r\n            var index = this.skeleton.findSlotIndex(slotName);\r\n            if (index == -1) {\r\n                return false;\r\n            }\r\n            return this.hackTextureBySlotIndex(index, texture, size);\r\n        };\r\n        Spine.prototype.hackTextureAttachment = function (slotName, attachmentName, texture, size) {\r\n            if (size === void 0) { size = null; }\r\n            var slotIndex = this.skeleton.findSlotIndex(slotName);\r\n            var attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n            attachment.region.texture = texture;\r\n            var slot = this.skeleton.slots[slotIndex];\r\n            if (!slot) {\r\n                return false;\r\n            }\r\n            var currentAttachment = slot.getAttachment();\r\n            if (attachmentName === currentAttachment.name) {\r\n                var region = attachment.region;\r\n                if (texture) {\r\n                    region = new pixi_spine.core.TextureRegion();\r\n                    region.texture = texture;\r\n                    region.size = size;\r\n                    slot.hackRegion = region;\r\n                    slot.hackAttachment = currentAttachment;\r\n                }\r\n                else {\r\n                    slot.hackRegion = null;\r\n                    slot.hackAttachment = null;\r\n                }\r\n                if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                    this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\r\n                    slot.currentSprite.region = region;\r\n                }\r\n                else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                    this.setMeshRegion(currentAttachment, slot.currentMesh, region);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        Spine.prototype.newContainer = function () {\r\n            return new PIXI.Container();\r\n        };\r\n        Spine.prototype.newSprite = function (tex) {\r\n            return new SpineSprite(tex);\r\n        };\r\n        Spine.prototype.newGraphics = function () {\r\n            return new PIXI.Graphics();\r\n        };\r\n        Spine.prototype.newMesh = function (texture, vertices, uvs, indices, drawMode) {\r\n            return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n        };\r\n        Spine.prototype.transformHack = function () {\r\n            return 1;\r\n        };\r\n        Spine.prototype.hackAttachmentGroups = function (nameSuffix, group, outGroup) {\r\n            if (!nameSuffix) {\r\n                return;\r\n            }\r\n            var list_d = [], list_n = [];\r\n            for (var i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n                var slot = this.skeleton.slots[i];\r\n                var name_6 = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n                var target = slot.currentSprite || slot.currentMesh;\r\n                if (name_6.endsWith(nameSuffix)) {\r\n                    target.parentGroup = group;\r\n                    list_n.push(target);\r\n                }\r\n                else if (outGroup && target) {\r\n                    target.parentGroup = outGroup;\r\n                    list_d.push(target);\r\n                }\r\n            }\r\n            return [list_d, list_n];\r\n        };\r\n        ;\r\n        Spine.prototype.destroy = function (options) {\r\n            for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n                var slot = this.skeleton.slots[i];\r\n                for (var name_7 in slot.meshes) {\r\n                    slot.meshes[name_7].destroy(options);\r\n                }\r\n                slot.meshes = null;\r\n                for (var name_8 in slot.sprites) {\r\n                    slot.sprites[name_8].destroy(options);\r\n                }\r\n                slot.sprites = null;\r\n            }\r\n            for (var i = 0, n = this.slotContainers.length; i < n; i++) {\r\n                this.slotContainers[i].destroy(options);\r\n            }\r\n            this.spineData = null;\r\n            this.skeleton = null;\r\n            this.slotContainers = null;\r\n            this.stateData = null;\r\n            this.state = null;\r\n            this.tempClipContainers = null;\r\n            _super.prototype.destroy.call(this, options);\r\n        };\r\n        Spine.globalAutoUpdate = true;\r\n        Spine.globalDelayLimit = 0;\r\n        Spine.clippingPolygon = [];\r\n        return Spine;\r\n    }(PIXI.Container));\r\n    pixi_spine.Spine = Spine;\r\n    function SlotContainerUpdateTransformV3() {\r\n        var pt = this.parent.worldTransform;\r\n        var wt = this.worldTransform;\r\n        var lt = this.localTransform;\r\n        wt.a = lt.a * pt.a + lt.b * pt.c;\r\n        wt.b = lt.a * pt.b + lt.b * pt.d;\r\n        wt.c = lt.c * pt.a + lt.d * pt.c;\r\n        wt.d = lt.c * pt.b + lt.d * pt.d;\r\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\r\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\r\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\r\n        this._currentBounds = null;\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    PIXI.spine = pixi_spine;\r\n    var TextureProto = PIXI.Texture.prototype;\r\n    if (!TextureProto._updateUvs) {\r\n        TextureProto._updateUvs = TextureProto.updateUvs;\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\nvar pixi_spine;\r\n(function (pixi_spine) {\r\n    function isJson(resource) {\r\n        return resource.type === PIXI.LoaderResource.TYPE.JSON;\r\n    }\r\n    function isBuffer(resource) {\r\n        return resource.xhrType === PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER;\r\n    }\r\n    PIXI.LoaderResource.setExtensionXhrType('skel', PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n    var AtlasParser = (function () {\r\n        function AtlasParser() {\r\n        }\r\n        AtlasParser.use = function (resource, next) {\r\n            if (!resource.data) {\r\n                return next();\r\n            }\r\n            var isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n            var isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata.spineMetadata);\r\n            if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                return next();\r\n            }\r\n            var parser = null;\r\n            var dataToParse = resource.data;\r\n            if (isJsonSpineModel) {\r\n                parser = new pixi_spine.core.SkeletonJson(null);\r\n            }\r\n            else {\r\n                parser = new pixi_spine.core.SkeletonBinary(null);\r\n                if (resource.data instanceof ArrayBuffer) {\r\n                    dataToParse = new Uint8Array(resource.data);\r\n                }\r\n            }\r\n            var metadata = resource.metadata || {};\r\n            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\r\n            if (metadataSkeletonScale) {\r\n                parser.scale = metadataSkeletonScale;\r\n            }\r\n            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\r\n            if (metadataAtlas === false) {\r\n                return next();\r\n            }\r\n            if (metadataAtlas && metadataAtlas.pages) {\r\n                parser.attachmentLoader = new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas);\r\n                resource.spineData = parser.readSkeletonData(dataToParse);\r\n                resource.spineAtlas = metadataAtlas;\r\n                return next();\r\n            }\r\n            var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n            var atlasPath = resource.url;\r\n            var queryStringPos = atlasPath.indexOf('?');\r\n            if (queryStringPos > 0) {\r\n                atlasPath = atlasPath.substr(0, queryStringPos);\r\n            }\r\n            atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n            if (resource.metadata && resource.metadata.spineAtlasFile) {\r\n                atlasPath = resource.metadata.spineAtlasFile;\r\n            }\r\n            atlasPath = atlasPath.replace(this.baseUrl, '');\r\n            var atlasOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                metadata: metadata.spineMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            var imageOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                metadata: metadata.imageMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n            baseUrl = baseUrl.replace(this.baseUrl, '');\r\n            var namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n            var adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                : metadata.image ? staticImageLoader({ 'default': metadata.image })\r\n                    : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                        : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n            var createSkeletonWithRawAtlas = function (rawData) {\r\n                new pixi_spine.core.TextureAtlas(rawData, adapter, function (spineAtlas) {\r\n                    if (spineAtlas) {\r\n                        parser.attachmentLoader = new pixi_spine.core.AtlasAttachmentLoader(spineAtlas);\r\n                        resource.spineData = parser.readSkeletonData(dataToParse);\r\n                        resource.spineAtlas = spineAtlas;\r\n                    }\r\n                    next();\r\n                });\r\n            };\r\n            if (resource.metadata && resource.metadata.atlasRawData) {\r\n                createSkeletonWithRawAtlas(resource.metadata.atlasRawData);\r\n            }\r\n            else {\r\n                this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\r\n                    if (!atlasResource.error) {\r\n                        createSkeletonWithRawAtlas(atlasResource.data);\r\n                    }\r\n                    else {\r\n                        next();\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        return AtlasParser;\r\n    }());\r\n    pixi_spine.AtlasParser = AtlasParser;\r\n    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line, callback) {\r\n            var name = namePrefix + line;\r\n            var url = baseUrl + line;\r\n            var cachedResource = loader.resources[name];\r\n            if (cachedResource) {\r\n                var done = function () {\r\n                    callback(cachedResource.texture.baseTexture);\r\n                };\r\n                if (cachedResource.texture) {\r\n                    done();\r\n                }\r\n                else {\r\n                    cachedResource.onAfterMiddleware.add(done);\r\n                }\r\n            }\r\n            else {\r\n                loader.add(name, url, imageOptions, function (resource) {\r\n                    if (!resource.error) {\r\n                        callback(resource.texture.baseTexture);\r\n                    }\r\n                    else {\r\n                        callback(null);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;\r\n    function syncImageLoaderAdapter(baseUrl, crossOrigin) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line, callback) {\r\n            callback(PIXI.BaseTexture.from(line, crossOrigin));\r\n        };\r\n    }\r\n    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;\r\n    function staticImageLoader(pages) {\r\n        return function (line, callback) {\r\n            var page = pages[line] || pages['default'];\r\n            if (page && page.baseTexture)\r\n                callback(page.baseTexture);\r\n            else\r\n                callback(page);\r\n        };\r\n    }\r\n    pixi_spine.staticImageLoader = staticImageLoader;\r\n    if (PIXI.Loader) {\r\n        PIXI.Loader.registerPlugin(AtlasParser);\r\n    }\r\n})(pixi_spine || (pixi_spine = {}));\r\n//# sourceMappingURL=pixi-spine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGl4aS1zcGluZS9kaXN0L3BpeGktc3BpbmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZXNhbmRib3gvLi9ub2RlX21vZHVsZXMvcGl4aS1zcGluZS9kaXN0L3BpeGktc3BpbmUuanM/MzJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGltZWxpbmVzIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lcyA9IHRpbWVsaW5lcztcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVJZHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVJZHNbdGltZWxpbmVzW2ldLmdldFByb3BlcnR5SWQoKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaGFzVGltZWxpbmUgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVsaW5lSWRzW2lkXSA9PSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgbG9vcCwgZXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvb3AgJiYgdGhpcy5kdXJhdGlvbiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZSAlPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VGltZSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lICU9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzID0gdGhpcy50aW1lbGluZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRpbWVsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzW2ldLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvbi5iaW5hcnlTZWFyY2ggPSBmdW5jdGlvbiAodmFsdWVzLCB0YXJnZXQsIHN0ZXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSB2YWx1ZXMubGVuZ3RoIC8gc3RlcCAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGlnaCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBoaWdoID4+PiAxO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzWyhjdXJyZW50ICsgMSkgKiBzdGVwXSA8PSB0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvdyA9IGN1cnJlbnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvdyA9PSBoaWdoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxvdyArIDEpICogc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gKGxvdyArIGhpZ2gpID4+PiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb24ubGluZWFyU2VhcmNoID0gZnVuY3Rpb24gKHZhbHVlcywgdGFyZ2V0LCBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGFzdCA9IHZhbHVlcy5sZW5ndGggLSBzdGVwOyBpIDw9IGxhc3Q7IGkgKz0gc3RlcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldID4gdGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEFuaW1hdGlvbjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG4gICAgICAgIHZhciBNaXhCbGVuZDtcclxuICAgICAgICAoZnVuY3Rpb24gKE1peEJsZW5kKSB7XHJcbiAgICAgICAgICAgIE1peEJsZW5kW01peEJsZW5kW1wic2V0dXBcIl0gPSAwXSA9IFwic2V0dXBcIjtcclxuICAgICAgICAgICAgTWl4QmxlbmRbTWl4QmxlbmRbXCJmaXJzdFwiXSA9IDFdID0gXCJmaXJzdFwiO1xyXG4gICAgICAgICAgICBNaXhCbGVuZFtNaXhCbGVuZFtcInJlcGxhY2VcIl0gPSAyXSA9IFwicmVwbGFjZVwiO1xyXG4gICAgICAgICAgICBNaXhCbGVuZFtNaXhCbGVuZFtcImFkZFwiXSA9IDNdID0gXCJhZGRcIjtcclxuICAgICAgICB9KShNaXhCbGVuZCA9IGNvcmUuTWl4QmxlbmQgfHwgKGNvcmUuTWl4QmxlbmQgPSB7fSkpO1xyXG4gICAgICAgIHZhciBNaXhEaXJlY3Rpb247XHJcbiAgICAgICAgKGZ1bmN0aW9uIChNaXhEaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgTWl4RGlyZWN0aW9uW01peERpcmVjdGlvbltcIm1peEluXCJdID0gMF0gPSBcIm1peEluXCI7XHJcbiAgICAgICAgICAgIE1peERpcmVjdGlvbltNaXhEaXJlY3Rpb25bXCJtaXhPdXRcIl0gPSAxXSA9IFwibWl4T3V0XCI7XHJcbiAgICAgICAgfSkoTWl4RGlyZWN0aW9uID0gY29yZS5NaXhEaXJlY3Rpb24gfHwgKGNvcmUuTWl4RGlyZWN0aW9uID0ge30pKTtcclxuICAgICAgICB2YXIgVGltZWxpbmVUeXBlO1xyXG4gICAgICAgIChmdW5jdGlvbiAoVGltZWxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJyb3RhdGVcIl0gPSAwXSA9IFwicm90YXRlXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJ0cmFuc2xhdGVcIl0gPSAxXSA9IFwidHJhbnNsYXRlXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJzY2FsZVwiXSA9IDJdID0gXCJzY2FsZVwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wic2hlYXJcIl0gPSAzXSA9IFwic2hlYXJcIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImF0dGFjaG1lbnRcIl0gPSA0XSA9IFwiYXR0YWNobWVudFwiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wiY29sb3JcIl0gPSA1XSA9IFwiY29sb3JcIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImRlZm9ybVwiXSA9IDZdID0gXCJkZWZvcm1cIjtcclxuICAgICAgICAgICAgVGltZWxpbmVUeXBlW1RpbWVsaW5lVHlwZVtcImV2ZW50XCJdID0gN10gPSBcImV2ZW50XCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJkcmF3T3JkZXJcIl0gPSA4XSA9IFwiZHJhd09yZGVyXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJpa0NvbnN0cmFpbnRcIl0gPSA5XSA9IFwiaWtDb25zdHJhaW50XCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJ0cmFuc2Zvcm1Db25zdHJhaW50XCJdID0gMTBdID0gXCJ0cmFuc2Zvcm1Db25zdHJhaW50XCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJwYXRoQ29uc3RyYWludFBvc2l0aW9uXCJdID0gMTFdID0gXCJwYXRoQ29uc3RyYWludFBvc2l0aW9uXCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJwYXRoQ29uc3RyYWludFNwYWNpbmdcIl0gPSAxMl0gPSBcInBhdGhDb25zdHJhaW50U3BhY2luZ1wiO1xyXG4gICAgICAgICAgICBUaW1lbGluZVR5cGVbVGltZWxpbmVUeXBlW1wicGF0aENvbnN0cmFpbnRNaXhcIl0gPSAxM10gPSBcInBhdGhDb25zdHJhaW50TWl4XCI7XHJcbiAgICAgICAgICAgIFRpbWVsaW5lVHlwZVtUaW1lbGluZVR5cGVbXCJ0d29Db2xvclwiXSA9IDE0XSA9IFwidHdvQ29sb3JcIjtcclxuICAgICAgICB9KShUaW1lbGluZVR5cGUgPSBjb3JlLlRpbWVsaW5lVHlwZSB8fCAoY29yZS5UaW1lbGluZVR5cGUgPSB7fSkpO1xyXG4gICAgICAgIHZhciBDdXJ2ZVRpbWVsaW5lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3VydmVUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVDb3VudCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyYW1lQ291bnQgbXVzdCBiZSA+IDA6IFwiICsgZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnZlcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheSgoZnJhbWVDb3VudCAtIDEpICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuZ2V0RnJhbWVDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnZlcy5sZW5ndGggLyBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFICsgMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuc2V0TGluZWFyID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFXSA9IEN1cnZlVGltZWxpbmUuTElORUFSO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDdXJ2ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRTdGVwcGVkID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFXSA9IEN1cnZlVGltZWxpbmUuU1RFUFBFRDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuZ2V0Q3VydmVUeXBlID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGZyYW1lSW5kZXggKiBDdXJ2ZVRpbWVsaW5lLkJFWklFUl9TSVpFO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuY3VydmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3VydmVUaW1lbGluZS5MSU5FQVI7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuY3VydmVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuTElORUFSKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDdXJ2ZVRpbWVsaW5lLkxJTkVBUjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuU1RFUFBFRClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3VydmVUaW1lbGluZS5TVEVQUEVEO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEN1cnZlVGltZWxpbmUuQkVaSUVSO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDdXJ2ZVRpbWVsaW5lLnByb3RvdHlwZS5zZXRDdXJ2ZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCBjeDEsIGN5MSwgY3gyLCBjeTIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXB4ID0gKC1jeDEgKiAyICsgY3gyKSAqIDAuMDMsIHRtcHkgPSAoLWN5MSAqIDIgKyBjeTIpICogMC4wMztcclxuICAgICAgICAgICAgICAgIHZhciBkZGRmeCA9ICgoY3gxIC0gY3gyKSAqIDMgKyAxKSAqIDAuMDA2LCBkZGRmeSA9ICgoY3kxIC0gY3kyKSAqIDMgKyAxKSAqIDAuMDA2O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRkZnggPSB0bXB4ICogMiArIGRkZGZ4LCBkZGZ5ID0gdG1weSAqIDIgKyBkZGRmeTtcclxuICAgICAgICAgICAgICAgIHZhciBkZnggPSBjeDEgKiAwLjMgKyB0bXB4ICsgZGRkZnggKiAwLjE2NjY2NjY3LCBkZnkgPSBjeTEgKiAwLjMgKyB0bXB5ICsgZGRkZnkgKiAwLjE2NjY2NjY3O1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmcmFtZUluZGV4ICogQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmN1cnZlcztcclxuICAgICAgICAgICAgICAgIGN1cnZlc1tpKytdID0gQ3VydmVUaW1lbGluZS5CRVpJRVI7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGRmeCwgeSA9IGRmeTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBpICsgQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSAtIDE7IGkgPCBuOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZXNbaV0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlc1tpICsgMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRkZnggKz0gZGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRmeSArPSBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IGRmeDtcclxuICAgICAgICAgICAgICAgICAgICB5ICs9IGRmeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5wcm90b3R5cGUuZ2V0Q3VydmVQZXJjZW50ID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBjb3JlLk1hdGhVdGlscy5jbGFtcChwZXJjZW50LCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmN1cnZlcztcclxuICAgICAgICAgICAgICAgIHZhciBpID0gZnJhbWVJbmRleCAqIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGN1cnZlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IEN1cnZlVGltZWxpbmUuTElORUFSKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gQ3VydmVUaW1lbGluZS5TVEVQUEVEKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhcnQgPSBpLCBuID0gaSArIEN1cnZlVGltZWxpbmUuQkVaSUVSX1NJWkUgLSAxOyBpIDwgbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGN1cnZlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSBwZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2WCA9IHZvaWQgMCwgcHJldlkgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WCA9IGN1cnZlc1tpIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WSA9IGN1cnZlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZZICsgKGN1cnZlc1tpICsgMV0gLSBwcmV2WSkgKiAocGVyY2VudCAtIHByZXZYKSAvICh4IC0gcHJldlgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB5ID0gY3VydmVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5ICsgKDEgLSB5KSAqIChwZXJjZW50IC0geCkgLyAoMSAtIHgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDdXJ2ZVRpbWVsaW5lLkxJTkVBUiA9IDA7XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUuU1RFUFBFRCA9IDE7XHJcbiAgICAgICAgICAgIEN1cnZlVGltZWxpbmUuQkVaSUVSID0gMjtcclxuICAgICAgICAgICAgQ3VydmVUaW1lbGluZS5CRVpJRVJfU0laRSA9IDEwICogMiAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBDdXJ2ZVRpbWVsaW5lO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5DdXJ2ZVRpbWVsaW5lID0gQ3VydmVUaW1lbGluZTtcclxuICAgICAgICB2YXIgUm90YXRlVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUm90YXRlVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJvdGF0ZVRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCA8PCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSb3RhdGVUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnJvdGF0ZSA8PCAyNCkgKyB0aGlzLmJvbmVJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm90YXRlVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIGRlZ3JlZXMpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPDw9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgUm90YXRlVGltZWxpbmUuUk9UQVRJT05dID0gZGVncmVlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm90YXRlVGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1t0aGlzLmJvbmVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvbmUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByXzEgPSBib25lLmRhdGEucm90YXRpb24gLSBib25lLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiArPSAocl8xIC0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByXzEgLyAzNjApIHwgMCkpICogMzYwKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFJvdGF0ZVRpbWVsaW5lLkVOVFJJRVNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJfMiA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgUm90YXRlVGltZWxpbmUuUFJFVl9ST1RBVElPTl07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIHJfMiAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJfMiArPSBib25lLmRhdGEucm90YXRpb24gLSBib25lLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcl8yIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gcl8yIC8gMzYwKSB8IDApKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnJvdGF0aW9uICs9IHJfMiAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgUm90YXRlVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlJvdGF0aW9uID0gZnJhbWVzW2ZyYW1lICsgUm90YXRlVGltZWxpbmUuUFJFVl9ST1RBVElPTl07XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoKGZyYW1lID4+IDEpIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBSb3RhdGVUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IGZyYW1lc1tmcmFtZSArIFJvdGF0ZVRpbWVsaW5lLlJPVEFUSU9OXSAtIHByZXZSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHIgPSBwcmV2Um90YXRpb24gKyAociAtICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gciAvIDM2MCkgfCAwKSkgKiAzNjApICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnJvdGF0aW9uID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgKHIgLSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIgLyAzNjApIHwgMCkpICogMzYwKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgciArPSBib25lLmRhdGEucm90YXRpb24gLSBib25lLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuYWRkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnJvdGF0aW9uICs9IChyIC0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByIC8gMzYwKSB8IDApKSAqIDM2MCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm90YXRlVGltZWxpbmUuRU5UUklFUyA9IDI7XHJcbiAgICAgICAgICAgIFJvdGF0ZVRpbWVsaW5lLlBSRVZfVElNRSA9IC0yO1xyXG4gICAgICAgICAgICBSb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OID0gLTE7XHJcbiAgICAgICAgICAgIFJvdGF0ZVRpbWVsaW5lLlJPVEFUSU9OID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIFJvdGF0ZVRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuUm90YXRlVGltZWxpbmUgPSBSb3RhdGVUaW1lbGluZTtcclxuICAgICAgICB2YXIgVHJhbnNsYXRlVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhbnNsYXRlVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0ZVRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUudHJhbnNsYXRlIDw8IDI0KSArIHRoaXMuYm9uZUluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCAqPSBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFRyYW5zbGF0ZVRpbWVsaW5lLlhdID0geDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2xhdGVUaW1lbGluZS5ZXSA9IHk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUueCA9IGJvbmUuZGF0YS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS55ID0gYm9uZS5kYXRhLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnggKz0gKGJvbmUuZGF0YS54IC0gYm9uZS54KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS55ICs9IChib25lLmRhdGEueSAtIGJvbmUueSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwLCB5ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1hdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyYW1lc1tmcmFtZSArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWF07XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGZyYW1lc1tmcmFtZSArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFRyYW5zbGF0ZVRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5YXSAtIHgpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICB5ICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2xhdGVUaW1lbGluZS5ZXSAtIHkpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnggPSBib25lLmRhdGEueCArIHggKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS55ID0gYm9uZS5kYXRhLnkgKyB5ICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5yZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnggKz0gKGJvbmUuZGF0YS54ICsgeCAtIGJvbmUueCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS55ICs9IChib25lLmRhdGEueSArIHkgLSBib25lLnkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuYWRkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnggKz0geCAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnkgKz0geSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTID0gMztcclxuICAgICAgICAgICAgVHJhbnNsYXRlVGltZWxpbmUuUFJFVl9USU1FID0gLTM7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLlBSRVZfWCA9IC0yO1xyXG4gICAgICAgICAgICBUcmFuc2xhdGVUaW1lbGluZS5QUkVWX1kgPSAtMTtcclxuICAgICAgICAgICAgVHJhbnNsYXRlVGltZWxpbmUuWCA9IDE7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZVRpbWVsaW5lLlkgPSAyO1xyXG4gICAgICAgICAgICByZXR1cm4gVHJhbnNsYXRlVGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5UcmFuc2xhdGVUaW1lbGluZSA9IFRyYW5zbGF0ZVRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBTY2FsZVRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFNjYWxlVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNjYWxlVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2NhbGVUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnNjYWxlIDw8IDI0KSArIHRoaXMuYm9uZUluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTY2FsZVRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbdGhpcy5ib25lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYID0gYm9uZS5kYXRhLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYm9uZS5kYXRhLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYICs9IChib25lLmRhdGEuc2NhbGVYIC0gYm9uZS5zY2FsZVgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSArPSAoYm9uZS5kYXRhLnNjYWxlWSAtIGJvbmUuc2NhbGVZKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDAsIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBTY2FsZVRpbWVsaW5lLkVOVFJJRVNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgU2NhbGVUaW1lbGluZS5QUkVWX1hdICogYm9uZS5kYXRhLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTY2FsZVRpbWVsaW5lLlBSRVZfWV0gKiBib25lLmRhdGEuc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFNjYWxlVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyYW1lc1tmcmFtZSArIFNjYWxlVGltZWxpbmUuUFJFVl9YXTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZnJhbWVzW2ZyYW1lICsgU2NhbGVUaW1lbGluZS5QUkVWX1ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBTY2FsZVRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFNjYWxlVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAoeCArIChmcmFtZXNbZnJhbWUgKyBTY2FsZVRpbWVsaW5lLlhdIC0geCkgKiBwZXJjZW50KSAqIGJvbmUuZGF0YS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9ICh5ICsgKGZyYW1lc1tmcmFtZSArIFNjYWxlVGltZWxpbmUuWV0gLSB5KSAqIHBlcmNlbnQpICogYm9uZS5kYXRhLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLmFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCArPSB4IC0gYm9uZS5kYXRhLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVkgKz0geSAtIGJvbmUuZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0geTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnggPSAwLCBieSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBNaXhEaXJlY3Rpb24ubWl4T3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnggPSBib25lLmRhdGEuc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYm9uZS5kYXRhLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCA9IGJ4ICsgKE1hdGguYWJzKHgpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGJ4KSAtIGJ4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYnkgKyAoTWF0aC5hYnMoeSkgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0oYnkpIC0gYnkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5yZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gYm9uZS5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSBib25lLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWCA9IGJ4ICsgKE1hdGguYWJzKHgpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKGJ4KSAtIGJ4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYnkgKyAoTWF0aC5hYnMoeSkgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0oYnkpIC0gYnkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieCA9IGJvbmUuc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gYm9uZS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSBieCArIChNYXRoLmFicyh4KSAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bShieCkgLSBib25lLmRhdGEuc2NhbGVYKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYnkgKyAoTWF0aC5hYnMoeSkgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0oYnkpIC0gYm9uZS5kYXRhLnNjYWxlWSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieCA9IE1hdGguYWJzKGJvbmUuZGF0YS5zY2FsZVgpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gTWF0aC5hYnMoYm9uZS5kYXRhLnNjYWxlWSkgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0oeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSBieCArICh4IC0gYngpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVkgPSBieSArICh5IC0gYnkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5yZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gTWF0aC5hYnMoYm9uZS5zY2FsZVgpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5ID0gTWF0aC5hYnMoYm9uZS5zY2FsZVkpICogY29yZS5NYXRoVXRpbHMuc2lnbnVtKHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVYID0gYnggKyAoeCAtIGJ4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2NhbGVZID0gYnkgKyAoeSAtIGJ5KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5hZGQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnggPSBjb3JlLk1hdGhVdGlscy5zaWdudW0oeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgPSBjb3JlLk1hdGhVdGlscy5zaWdudW0oeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zY2FsZVggPSBNYXRoLmFicyhib25lLnNjYWxlWCkgKiBieCArICh4IC0gTWF0aC5hYnMoYm9uZS5kYXRhLnNjYWxlWCkgKiBieCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNjYWxlWSA9IE1hdGguYWJzKGJvbmUuc2NhbGVZKSAqIGJ5ICsgKHkgLSBNYXRoLmFicyhib25lLmRhdGEuc2NhbGVZKSAqIGJ5KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2NhbGVUaW1lbGluZTtcclxuICAgICAgICB9KFRyYW5zbGF0ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5TY2FsZVRpbWVsaW5lID0gU2NhbGVUaW1lbGluZTtcclxuICAgICAgICB2YXIgU2hlYXJUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTaGVhclRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTaGVhclRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNoZWFyVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5zaGVhciA8PCAyNCkgKyB0aGlzLmJvbmVJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2hlYXJUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghYm9uZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWCA9IGJvbmUuZGF0YS5zaGVhclg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWSA9IGJvbmUuZGF0YS5zaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWCArPSAoYm9uZS5kYXRhLnNoZWFyWCAtIGJvbmUuc2hlYXJYKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclkgKz0gKGJvbmUuZGF0YS5zaGVhclkgLSBib25lLnNoZWFyWSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwLCB5ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gU2hlYXJUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFNoZWFyVGltZWxpbmUuUFJFVl9YXTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBTaGVhclRpbWVsaW5lLlBSRVZfWV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgU2hlYXJUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gZnJhbWVzW2ZyYW1lICsgU2hlYXJUaW1lbGluZS5QUkVWX1hdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBmcmFtZXNbZnJhbWUgKyBTaGVhclRpbWVsaW5lLlBSRVZfWV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAvIFNoZWFyVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgU2hlYXJUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHggKyAoZnJhbWVzW2ZyYW1lICsgU2hlYXJUaW1lbGluZS5YXSAtIHgpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0geSArIChmcmFtZXNbZnJhbWUgKyBTaGVhclRpbWVsaW5lLlldIC0geSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJYID0gYm9uZS5kYXRhLnNoZWFyWCArIHggKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclkgPSBib25lLmRhdGEuc2hlYXJZICsgeSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQucmVwbGFjZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclggKz0gKGJvbmUuZGF0YS5zaGVhclggKyB4IC0gYm9uZS5zaGVhclgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuc2hlYXJZICs9IChib25lLmRhdGEuc2hlYXJZICsgeSAtIGJvbmUuc2hlYXJZKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5zaGVhclggKz0geCAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWSArPSB5ICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTaGVhclRpbWVsaW5lO1xyXG4gICAgICAgIH0oVHJhbnNsYXRlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLlNoZWFyVGltZWxpbmUgPSBTaGVhclRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBDb2xvclRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENvbG9yVGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbG9yVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogQ29sb3JUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDb2xvclRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUuY29sb3IgPDwgMjQpICsgdGhpcy5zbG90SW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggKj0gQ29sb3JUaW1lbGluZS5FTlRSSUVTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuUl0gPSByO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuR10gPSBnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuQl0gPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIENvbG9yVGltZWxpbmUuQV0gPSBhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDb2xvclRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzbG90LmJvbmUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHNsb3QuY29sb3IsIHNldHVwID0gc2xvdC5kYXRhLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IuYWRkKChzZXR1cC5yIC0gY29sb3IucikgKiBhbHBoYSwgKHNldHVwLmcgLSBjb2xvci5nKSAqIGFscGhhLCAoc2V0dXAuYiAtIGNvbG9yLmIpICogYWxwaGEsIChzZXR1cC5hIC0gY29sb3IuYSkgKiBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gQ29sb3JUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByID0gZnJhbWVzW2kgKyBDb2xvclRpbWVsaW5lLlBSRVZfUl07XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IGZyYW1lc1tpICsgQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBmcmFtZXNbaSArIENvbG9yVGltZWxpbmUuUFJFVl9CXTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZnJhbWVzW2kgKyBDb2xvclRpbWVsaW5lLlBSRVZfQV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgQ29sb3JUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICByID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLlBSRVZfR107XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUFJFVl9CXTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBDb2xvclRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuUl0gLSByKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZyArPSAoZnJhbWVzW2ZyYW1lICsgQ29sb3JUaW1lbGluZS5HXSAtIGcpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBiICs9IChmcmFtZXNbZnJhbWUgKyBDb2xvclRpbWVsaW5lLkJdIC0gYikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGEgKz0gKGZyYW1lc1tmcmFtZSArIENvbG9yVGltZWxpbmUuQV0gLSBhKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSlcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmNvbG9yLnNldChyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHNsb3QuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvci5hZGQoKHIgLSBjb2xvci5yKSAqIGFscGhhLCAoZyAtIGNvbG9yLmcpICogYWxwaGEsIChiIC0gY29sb3IuYikgKiBhbHBoYSwgKGEgLSBjb2xvci5hKSAqIGFscGhhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5FTlRSSUVTID0gNTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5QUkVWX1RJTUUgPSAtNTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5QUkVWX1IgPSAtNDtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5QUkVWX0cgPSAtMztcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5QUkVWX0IgPSAtMjtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5QUkVWX0EgPSAtMTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5SID0gMTtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5HID0gMjtcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5CID0gMztcclxuICAgICAgICAgICAgQ29sb3JUaW1lbGluZS5BID0gNDtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yVGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5Db2xvclRpbWVsaW5lID0gQ29sb3JUaW1lbGluZTtcclxuICAgICAgICB2YXIgVHdvQ29sb3JUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUd29Db2xvclRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUd29Db2xvclRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZnJhbWVDb3VudCAqIFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnR3b0NvbG9yIDw8IDI0KSArIHRoaXMuc2xvdEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUd29Db2xvclRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByLCBnLCBiLCBhLCByMiwgZzIsIGIyKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IFR3b0NvbG9yVGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLlJdID0gcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkddID0gZztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkJdID0gYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLkFdID0gYTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUd29Db2xvclRpbWVsaW5lLlIyXSA9IHIyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFR3b0NvbG9yVGltZWxpbmUuRzJdID0gZzI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgVHdvQ29sb3JUaW1lbGluZS5CMl0gPSBiMjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmRhcmtDb2xvci5zZXRGcm9tQ29sb3Ioc2xvdC5kYXRhLmRhcmtDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHQgPSBzbG90LmNvbG9yLCBkYXJrID0gc2xvdC5kYXJrQ29sb3IsIHNldHVwTGlnaHQgPSBzbG90LmRhdGEuY29sb3IsIHNldHVwRGFyayA9IHNsb3QuZGF0YS5kYXJrQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWdodC5hZGQoKHNldHVwTGlnaHQuciAtIGxpZ2h0LnIpICogYWxwaGEsIChzZXR1cExpZ2h0LmcgLSBsaWdodC5nKSAqIGFscGhhLCAoc2V0dXBMaWdodC5iIC0gbGlnaHQuYikgKiBhbHBoYSwgKHNldHVwTGlnaHQuYSAtIGxpZ2h0LmEpICogYWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFyay5hZGQoKHNldHVwRGFyay5yIC0gZGFyay5yKSAqIGFscGhhLCAoc2V0dXBEYXJrLmcgLSBkYXJrLmcpICogYWxwaGEsIChzZXR1cERhcmsuYiAtIGRhcmsuYikgKiBhbHBoYSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMCwgcjIgPSAwLCBnMiA9IDAsIGIyID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gVHdvQ29sb3JUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfUl07XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IGZyYW1lc1tpICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CXTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZnJhbWVzW2kgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQV07XHJcbiAgICAgICAgICAgICAgICAgICAgcjIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9SMl07XHJcbiAgICAgICAgICAgICAgICAgICAgZzIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HMl07XHJcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBmcmFtZXNbaSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CMl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgVHdvQ29sb3JUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICByID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfR107XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9CXTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0FdO1xyXG4gICAgICAgICAgICAgICAgICAgIHIyID0gZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1IyXTtcclxuICAgICAgICAgICAgICAgICAgICBnMiA9IGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HMl07XHJcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLlBSRVZfQjJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBUd29Db2xvclRpbWVsaW5lLkVOVFJJRVMgLSAxLCAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUl0gLSByKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZyArPSAoZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5HXSAtIGcpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBiICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLkJdIC0gYikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGEgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuQV0gLSBhKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcjIgKz0gKGZyYW1lc1tmcmFtZSArIFR3b0NvbG9yVGltZWxpbmUuUjJdIC0gcjIpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBnMiArPSAoZnJhbWVzW2ZyYW1lICsgVHdvQ29sb3JUaW1lbGluZS5HMl0gLSBnMikgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGIyICs9IChmcmFtZXNbZnJhbWUgKyBUd29Db2xvclRpbWVsaW5lLkIyXSAtIGIyKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY29sb3Iuc2V0KHIsIGcsIGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuZGFya0NvbG9yLnNldChyMiwgZzIsIGIyLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWdodCA9IHNsb3QuY29sb3IsIGRhcmsgPSBzbG90LmRhcmtDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlnaHQuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhcmsuc2V0RnJvbUNvbG9yKHNsb3QuZGF0YS5kYXJrQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaWdodC5hZGQoKHIgLSBsaWdodC5yKSAqIGFscGhhLCAoZyAtIGxpZ2h0LmcpICogYWxwaGEsIChiIC0gbGlnaHQuYikgKiBhbHBoYSwgKGEgLSBsaWdodC5hKSAqIGFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXJrLmFkZCgocjIgLSBkYXJrLnIpICogYWxwaGEsIChnMiAtIGRhcmsuZykgKiBhbHBoYSwgKGIyIC0gZGFyay5iKSAqIGFscGhhLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5FTlRSSUVTID0gODtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1RJTUUgPSAtODtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1IgPSAtNztcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0cgPSAtNjtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0IgPSAtNTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX0EgPSAtNDtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5QUkVWX1IyID0gLTM7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuUFJFVl9HMiA9IC0yO1xyXG4gICAgICAgICAgICBUd29Db2xvclRpbWVsaW5lLlBSRVZfQjIgPSAtMTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5SID0gMTtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5HID0gMjtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5CID0gMztcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5BID0gNDtcclxuICAgICAgICAgICAgVHdvQ29sb3JUaW1lbGluZS5SMiA9IDU7XHJcbiAgICAgICAgICAgIFR3b0NvbG9yVGltZWxpbmUuRzIgPSA2O1xyXG4gICAgICAgICAgICBUd29Db2xvclRpbWVsaW5lLkIyID0gNztcclxuICAgICAgICAgICAgcmV0dXJuIFR3b0NvbG9yVGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5Ud29Db2xvclRpbWVsaW5lID0gVHdvQ29sb3JUaW1lbGluZTtcclxuICAgICAgICB2YXIgQXR0YWNobWVudFRpbWVsaW5lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQXR0YWNobWVudFRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TmFtZXMgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUuYXR0YWNobWVudCA8PCAyNCkgKyB0aGlzLnNsb3RJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5nZXRGcmFtZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBhdHRhY2htZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TmFtZXNbZnJhbWVJbmRleF0gPSBhdHRhY2htZW50TmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzbG90LmJvbmUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm1peE91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5zZXR1cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KHNrZWxldG9uLCBzbG90LCBzbG90LmRhdGEuYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLnNldHVwIHx8IGJsZW5kID09IE1peEJsZW5kLmZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoc2tlbGV0b24sIHNsb3QsIHNsb3QuZGF0YS5hdHRhY2htZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSlcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gZnJhbWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCAxKSAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudE5hbWUgPSB0aGlzLmF0dGFjaG1lbnROYW1lc1tmcmFtZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnROYW1lID09IG51bGwgPyBudWxsIDogc2tlbGV0b24uZ2V0QXR0YWNobWVudCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZS5zZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBzbG90LCBhdHRhY2htZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgc2xvdC5hdHRhY2htZW50ID0gYXR0YWNobWVudE5hbWUgPT0gbnVsbCA/IG51bGwgOiBza2VsZXRvbi5nZXRBdHRhY2htZW50KHRoaXMuc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2htZW50VGltZWxpbmU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkF0dGFjaG1lbnRUaW1lbGluZSA9IEF0dGFjaG1lbnRUaW1lbGluZTtcclxuICAgICAgICB2YXIgemVyb3MgPSBudWxsO1xyXG4gICAgICAgIHZhciBEZWZvcm1UaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhEZWZvcm1UaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRGVmb3JtVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lVmVydGljZXMgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoemVyb3MgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheSg2NCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRGVmb3JtVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5kZWZvcm0gPDwgMjcpICsgK3RoaXMuYXR0YWNobWVudC5pZCArIHRoaXMuc2xvdEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEZWZvcm1UaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgdmVydGljZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVWZXJ0aWNlc1tmcmFtZUluZGV4XSA9IHZlcnRpY2VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEZWZvcm1UaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzbG90LmJvbmUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90QXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoc2xvdEF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLlZlcnRleEF0dGFjaG1lbnQpIHx8ICEoc2xvdEF0dGFjaG1lbnQuZGVmb3JtQXR0YWNobWVudCA9PSB0aGlzLmF0dGFjaG1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBkZWZvcm1BcnJheSA9IHNsb3QuZGVmb3JtO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZm9ybUFycmF5Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kID0gTWl4QmxlbmQuc2V0dXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVWZXJ0aWNlcyA9IHRoaXMuZnJhbWVWZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IGZyYW1lVmVydGljZXNbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4QXR0YWNobWVudCA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybUFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybUFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmb3JtXzEgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShkZWZvcm1BcnJheSwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleEF0dGFjaG1lbnQuYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR1cFZlcnRpY2VzID0gdmVydGV4QXR0YWNobWVudC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybV8xW2ldICs9IChzZXR1cFZlcnRpY2VzW2ldIC0gZGVmb3JtXzFbaV0pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDEgLSBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybV8xW2ldICo9IGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmb3JtID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoZGVmb3JtQXJyYXksIHZlcnRleENvdW50KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFZlcnRpY2VzID0gZnJhbWVWZXJ0aWNlc1tmcmFtZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLmFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhBdHRhY2htZW50LmJvbmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXBWZXJ0aWNlcyA9IHZlcnRleEF0dGFjaG1lbnQudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgdmVydGV4Q291bnQ7IGlfMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzFdICs9IGxhc3RWZXJ0aWNlc1tpXzFdIC0gc2V0dXBWZXJ0aWNlc1tpXzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IHZlcnRleENvdW50OyBpXzIrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMl0gKz0gbGFzdFZlcnRpY2VzW2lfMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weShsYXN0VmVydGljZXMsIDAsIGRlZm9ybSwgMCwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnRfMSA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhBdHRhY2htZW50XzEuYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXBWZXJ0aWNlcyA9IHZlcnRleEF0dGFjaG1lbnRfMS52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8zID0gMDsgaV8zIDwgdmVydGV4Q291bnQ7IGlfMysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXAgPSBzZXR1cFZlcnRpY2VzW2lfM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8zXSA9IHNldHVwICsgKGxhc3RWZXJ0aWNlc1tpXzNdIC0gc2V0dXApICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfNCA9IDA7IGlfNCA8IHZlcnRleENvdW50OyBpXzQrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzRdID0gbGFzdFZlcnRpY2VzW2lfNF0gKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5yZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfNSA9IDA7IGlfNSA8IHZlcnRleENvdW50OyBpXzUrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfNV0gKz0gKGxhc3RWZXJ0aWNlc1tpXzVdIC0gZGVmb3JtW2lfNV0pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4QXR0YWNobWVudCA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhBdHRhY2htZW50LmJvbmVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzYgPSAwOyBpXzYgPCB2ZXJ0ZXhDb3VudDsgaV82KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzZdICs9IChsYXN0VmVydGljZXNbaV82XSAtIHNldHVwVmVydGljZXNbaV82XSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV83ID0gMDsgaV83IDwgdmVydGV4Q291bnQ7IGlfNysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfN10gKz0gbGFzdFZlcnRpY2VzW2lfN10gKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZWZXJ0aWNlcyA9IGZyYW1lVmVydGljZXNbZnJhbWUgLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0VmVydGljZXMgPSBmcmFtZVZlcnRpY2VzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnZlUGVyY2VudChmcmFtZSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lIC0gMV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kID09IE1peEJsZW5kLmFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4QXR0YWNobWVudCA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4QXR0YWNobWVudC5ib25lcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXBWZXJ0aWNlcyA9IHZlcnRleEF0dGFjaG1lbnQudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzggPSAwOyBpXzggPCB2ZXJ0ZXhDb3VudDsgaV84KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzhdICs9IHByZXYgKyAobmV4dFZlcnRpY2VzW2lfOF0gLSBwcmV2KSAqIHBlcmNlbnQgLSBzZXR1cFZlcnRpY2VzW2lfOF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzkgPSAwOyBpXzkgPCB2ZXJ0ZXhDb3VudDsgaV85KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzldICs9IHByZXYgKyAobmV4dFZlcnRpY2VzW2lfOV0gLSBwcmV2KSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTAgPSAwOyBpXzEwIDwgdmVydGV4Q291bnQ7IGlfMTArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV8xMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8xMF0gPSBwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzEwXSAtIHByZXYpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleEF0dGFjaG1lbnRfMiA9IHNsb3RBdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleEF0dGFjaG1lbnRfMi5ib25lcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50XzIudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xMSA9IDA7IGlfMTEgPCB2ZXJ0ZXhDb3VudDsgaV8xMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2lfMTFdLCBzZXR1cCA9IHNldHVwVmVydGljZXNbaV8xMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXzExXSA9IHNldHVwICsgKHByZXYgKyAobmV4dFZlcnRpY2VzW2lfMTFdIC0gcHJldikgKiBwZXJjZW50IC0gc2V0dXApICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xMiA9IDA7IGlfMTIgPCB2ZXJ0ZXhDb3VudDsgaV8xMisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2lfMTJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8xMl0gPSAocHJldiArIChuZXh0VmVydGljZXNbaV8xMl0gLSBwcmV2KSAqIHBlcmNlbnQpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5yZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xMyA9IDA7IGlfMTMgPCB2ZXJ0ZXhDb3VudDsgaV8xMysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV8xM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMTNdICs9IChwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzEzXSAtIHByZXYpICogcGVyY2VudCAtIGRlZm9ybVtpXzEzXSkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmFkZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhBdHRhY2htZW50ID0gc2xvdEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4QXR0YWNobWVudC5ib25lcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHVwVmVydGljZXMgPSB2ZXJ0ZXhBdHRhY2htZW50LnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMTQgPSAwOyBpXzE0IDwgdmVydGV4Q291bnQ7IGlfMTQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXzE0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW2lfMTRdICs9IChwcmV2ICsgKG5leHRWZXJ0aWNlc1tpXzE0XSAtIHByZXYpICogcGVyY2VudCAtIHNldHVwVmVydGljZXNbaV8xNF0pICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xNSA9IDA7IGlfMTUgPCB2ZXJ0ZXhDb3VudDsgaV8xNSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlZlcnRpY2VzW2lfMTVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV8xNV0gKz0gKHByZXYgKyAobmV4dFZlcnRpY2VzW2lfMTVdIC0gcHJldikgKiBwZXJjZW50KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBEZWZvcm1UaW1lbGluZTtcclxuICAgICAgICB9KEN1cnZlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLkRlZm9ybVRpbWVsaW5lID0gRGVmb3JtVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIEV2ZW50VGltZWxpbmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudFRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgQXJyYXkoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRXZlbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUaW1lbGluZVR5cGUuZXZlbnQgPDwgMjQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEV2ZW50VGltZWxpbmUucHJvdG90eXBlLmdldEZyYW1lQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSBldmVudC50aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbZnJhbWVJbmRleF0gPSBldmVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJlZEV2ZW50cyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUaW1lID4gdGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkoc2tlbGV0b24sIGxhc3RUaW1lLCBOdW1iZXIuTUFYX1ZBTFVFLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0VGltZSA+PSBmcmFtZXNbZnJhbWVDb3VudCAtIDFdKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWUgPCBmcmFtZXNbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgbGFzdFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChmcmFtZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tmcmFtZSAtIDFdICE9IGZyYW1lVGltZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoOyBmcmFtZSA8IGZyYW1lQ291bnQgJiYgdGltZSA+PSBmcmFtZXNbZnJhbWVdOyBmcmFtZSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVkRXZlbnRzLnB1c2godGhpcy5ldmVudHNbZnJhbWVdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50VGltZWxpbmU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkV2ZW50VGltZWxpbmUgPSBFdmVudFRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBEcmF3T3JkZXJUaW1lbGluZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXdPcmRlclRpbWVsaW5lKGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3T3JkZXJzID0gbmV3IEFycmF5KGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERyYXdPcmRlclRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRpbWVsaW5lVHlwZS5kcmF3T3JkZXIgPDwgMjQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERyYXdPcmRlclRpbWVsaW5lLnByb3RvdHlwZS5nZXRGcmFtZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRHJhd09yZGVyVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIGRyYXdPcmRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3T3JkZXJzW2ZyYW1lSW5kZXhdID0gZHJhd09yZGVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEcmF3T3JkZXJUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3T3JkZXIgPSBza2VsZXRvbi5kcmF3T3JkZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcclxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm1peE91dCAmJiBibGVuZCA9PSBNaXhCbGVuZC5zZXR1cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHNrZWxldG9uLnNsb3RzLCAwLCBza2VsZXRvbi5kcmF3T3JkZXIsIDAsIHNrZWxldG9uLnNsb3RzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXAgfHwgYmxlbmQgPT0gTWl4QmxlbmQuZmlyc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHNrZWxldG9uLnNsb3RzLCAwLCBza2VsZXRvbi5kcmF3T3JkZXIsIDAsIHNrZWxldG9uLnNsb3RzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lKSAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyVG9TZXR1cEluZGV4ID0gdGhpcy5kcmF3T3JkZXJzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXJUb1NldHVwSW5kZXggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weShzbG90cywgMCwgZHJhd09yZGVyLCAwLCBzbG90cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkcmF3T3JkZXJUb1NldHVwSW5kZXgubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3JkZXJbaV0gPSBzbG90c1tkcmF3T3JkZXJUb1NldHVwSW5kZXhbaV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRHJhd09yZGVyVGltZWxpbmU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkRyYXdPcmRlclRpbWVsaW5lID0gRHJhd09yZGVyVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIElrQ29uc3RyYWludFRpbWVsaW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKElrQ29uc3RyYWludFRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBJa0NvbnN0cmFpbnRUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLmlrQ29uc3RyYWludCA8PCAyNCkgKyB0aGlzLmlrQ29uc3RyYWludEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgbWl4LCBzb2Z0bmVzcywgYmVuZERpcmVjdGlvbiwgY29tcHJlc3MsIHN0cmV0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggKj0gSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5NSVhdID0gbWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIElrQ29uc3RyYWludFRpbWVsaW5lLlNPRlRORVNTXSA9IHNvZnRuZXNzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIElrQ29uc3RyYWludFRpbWVsaW5lLkJFTkRfRElSRUNUSU9OXSA9IGJlbmREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgSWtDb25zdHJhaW50VGltZWxpbmUuQ09NUFJFU1NdID0gY29tcHJlc3MgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5TVFJFVENIXSA9IHN0cmV0Y2ggPyAxIDogMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhLCBibGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uLmlrQ29uc3RyYWludHNbdGhpcy5pa0NvbnN0cmFpbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggPSBjb25zdHJhaW50LmRhdGEubWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zb2Z0bmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5jb21wcmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5jb21wcmVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGNvbnN0cmFpbnQuZGF0YS5zdHJldGNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggKz0gKGNvbnN0cmFpbnQuZGF0YS5taXggLSBjb25zdHJhaW50Lm1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc29mdG5lc3MgKz0gKGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzcyAtIGNvbnN0cmFpbnQuc29mdG5lc3MpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBjb25zdHJhaW50LmRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBjb25zdHJhaW50LmRhdGEuc3RyZXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5zZXR1cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50Lm1peCA9IGNvbnN0cmFpbnQuZGF0YS5taXggKyAoZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX01JWF0gLSBjb25zdHJhaW50LmRhdGEubWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNvZnRuZXNzID0gY29uc3RyYWludC5kYXRhLnNvZnRuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU09GVE5FU1NdIC0gY29uc3RyYWludC5kYXRhLnNvZnRuZXNzKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhPdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5jb21wcmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5jb21wcmVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGNvbnN0cmFpbnQuZGF0YS5zdHJldGNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQ09NUFJFU1NdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU1RSRVRDSF0gIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taXggKz0gKGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVhdIC0gY29uc3RyYWludC5taXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc29mdG5lc3MgKz0gKGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9TT0ZUTkVTU10gLSBjb25zdHJhaW50LnNvZnRuZXNzKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IE1peERpcmVjdGlvbi5taXhJbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQ09NUFJFU1NdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnN0cmV0Y2ggPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU1RSRVRDSF0gIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWl4ID0gZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9NSVhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvZnRuZXNzID0gZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9TT0ZUTkVTU107XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBJa0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50Lm1peCA9IGNvbnN0cmFpbnQuZGF0YS5taXggKyAobWl4ICsgKGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLk1JWF0gLSBtaXgpICogcGVyY2VudCAtIGNvbnN0cmFpbnQuZGF0YS5taXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zb2Z0bmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5zb2Z0bmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChzb2Z0bmVzcyArIChmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5TT0ZUTkVTU10gLSBzb2Z0bmVzcykgKiBwZXJjZW50IC0gY29uc3RyYWludC5kYXRhLnNvZnRuZXNzKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm1peE91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBjb25zdHJhaW50LmRhdGEuYmVuZERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5jb21wcmVzcyA9IGNvbnN0cmFpbnQuZGF0YS5jb21wcmVzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gY29uc3RyYWludC5kYXRhLnN0cmV0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBmcmFtZXNbZnJhbWUgKyBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX0JFTkRfRElSRUNUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5jb21wcmVzcyA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQ09NUFJFU1NdICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3RyZXRjaCA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU1RSRVRDSF0gIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50Lm1peCArPSAobWl4ICsgKGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLk1JWF0gLSBtaXgpICogcGVyY2VudCAtIGNvbnN0cmFpbnQubWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc29mdG5lc3MgKz0gKHNvZnRuZXNzICsgKGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlNPRlRORVNTXSAtIHNvZnRuZXNzKSAqIHBlcmNlbnQgLSBjb25zdHJhaW50LnNvZnRuZXNzKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gTWl4RGlyZWN0aW9uLm1peEluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGZyYW1lc1tmcmFtZSArIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQkVORF9ESVJFQ1RJT05dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNvbXByZXNzID0gZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9DT01QUkVTU10gIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gZnJhbWVzW2ZyYW1lICsgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9TVFJFVENIXSAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuRU5UUklFUyA9IDY7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVElNRSA9IC02O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX01JWCA9IC01O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NPRlRORVNTID0gLTQ7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfQkVORF9ESVJFQ1RJT04gPSAtMztcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuUFJFVl9DT01QUkVTUyA9IC0yO1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NUUkVUQ0ggPSAtMTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuTUlYID0gMTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuU09GVE5FU1MgPSAyO1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnRUaW1lbGluZS5CRU5EX0RJUkVDVElPTiA9IDM7XHJcbiAgICAgICAgICAgIElrQ29uc3RyYWludFRpbWVsaW5lLkNPTVBSRVNTID0gNDtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50VGltZWxpbmUuU1RSRVRDSCA9IDU7XHJcbiAgICAgICAgICAgIHJldHVybiBJa0NvbnN0cmFpbnRUaW1lbGluZTtcclxuICAgICAgICB9KEN1cnZlVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLklrQ29uc3RyYWludFRpbWVsaW5lID0gSWtDb25zdHJhaW50VGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChUaW1lbGluZVR5cGUudHJhbnNmb3JtQ29uc3RyYWludCA8PCAyNCkgKyB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRJbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZS5zZXRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCByb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCwgc2NhbGVNaXgsIHNoZWFyTWl4KSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5ST1RBVEVdID0gcm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5UUkFOU0xBVEVdID0gdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5TQ0FMRV0gPSBzY2FsZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0hFQVJdID0gc2hlYXJNaXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b24udHJhbnNmb3JtQ29uc3RyYWludHNbdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY29uc3RyYWludC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5zZXR1cDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCA9IGRhdGEudHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNaXhCbGVuZC5maXJzdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucm90YXRlTWl4ICs9IChkYXRhLnJvdGF0ZU1peCAtIGNvbnN0cmFpbnQucm90YXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggKz0gKGRhdGEudHJhbnNsYXRlTWl4IC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNjYWxlTWl4ICs9IChkYXRhLnNjYWxlTWl4IC0gY29uc3RyYWludC5zY2FsZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2hlYXJNaXggKz0gKGRhdGEuc2hlYXJNaXggLSBjb25zdHJhaW50LnNoZWFyTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlID0gMCwgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAwLCBzaGVhciA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSBmcmFtZXNbaSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1JPVEFURV07XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlID0gZnJhbWVzW2kgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9UUkFOU0xBVEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gZnJhbWVzW2kgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9TQ0FMRV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlYXIgPSBmcmFtZXNbaSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1NIRUFSXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfUk9UQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgPSBmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9UUkFOU0xBVEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0NBTEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWFyID0gZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0hFQVJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5ST1RBVEVdIC0gcm90YXRlKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuVFJBTlNMQVRFXSAtIHRyYW5zbGF0ZSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICs9IChmcmFtZXNbZnJhbWUgKyBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0NBTEVdIC0gc2NhbGUpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICBzaGVhciArPSAoZnJhbWVzW2ZyYW1lICsgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlNIRUFSXSAtIHNoZWFyKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnN0cmFpbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4ICsgKHJvdGF0ZSAtIGRhdGEucm90YXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXggKyAodHJhbnNsYXRlIC0gZGF0YS50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zY2FsZU1peCA9IGRhdGEuc2NhbGVNaXggKyAoc2NhbGUgLSBkYXRhLnNjYWxlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2hlYXJNaXggPSBkYXRhLnNoZWFyTWl4ICsgKHNoZWFyIC0gZGF0YS5zaGVhck1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucm90YXRlTWl4ICs9IChyb3RhdGUgLSBjb25zdHJhaW50LnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCArPSAodHJhbnNsYXRlIC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zY2FsZU1peCArPSAoc2NhbGUgLSBjb25zdHJhaW50LnNjYWxlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc2hlYXJNaXggKz0gKHNoZWFyIC0gY29uc3RyYWludC5zaGVhck1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVMgPSA1O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9USU1FID0gLTU7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5QUkVWX1JPVEFURSA9IC00O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuUFJFVl9UUkFOU0xBVEUgPSAtMztcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0NBTEUgPSAtMjtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlBSRVZfU0hFQVIgPSAtMTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLlJPVEFURSA9IDE7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5UUkFOU0xBVEUgPSAyO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0NBTEUgPSAzO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUuU0hFQVIgPSA0O1xyXG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lID0gVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnJhbWVDb3VudCkgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IGNvcmUuVXRpbHMubmV3RmxvYXRBcnJheShmcmFtZUNvdW50ICogUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoVGltZWxpbmVUeXBlLnBhdGhDb25zdHJhaW50UG9zaXRpb24gPDwgMjQpICsgdGhpcy5wYXRoQ29uc3RyYWludEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5WQUxVRV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5wYXRoQ29uc3RyYWludHNbdGhpcy5wYXRoQ29uc3RyYWludEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RyYWludC5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvc2l0aW9uID0gY29uc3RyYWludC5kYXRhLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb3NpdGlvbiArPSAoY29uc3RyYWludC5kYXRhLnBvc2l0aW9uIC0gY29uc3RyYWludC5wb3NpdGlvbikgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVNdKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuUFJFVl9WQUxVRV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVkFMVUVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWUgLyBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAoZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlZBTFVFXSAtIHBvc2l0aW9uKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5wb3NpdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5wb3NpdGlvbiArIChwb3NpdGlvbiAtIGNvbnN0cmFpbnQuZGF0YS5wb3NpdGlvbikgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnBvc2l0aW9uICs9IChwb3NpdGlvbiAtIGNvbnN0cmFpbnQucG9zaXRpb24pICogYWxwaGE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50UG9zaXRpb25UaW1lbGluZS5FTlRSSUVTID0gMjtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLlBSRVZfVElNRSA9IC0yO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuUFJFVl9WQUxVRSA9IC0xO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUuVkFMVUUgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lO1xyXG4gICAgICAgIH0oQ3VydmVUaW1lbGluZSkpO1xyXG4gICAgICAgIGNvcmUuUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lID0gUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lO1xyXG4gICAgICAgIHZhciBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUoZnJhbWVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZyYW1lQ291bnQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5wYXRoQ29uc3RyYWludFNwYWNpbmcgPDwgMjQpICsgdGhpcy5wYXRoQ29uc3RyYWludEluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEsIGJsZW5kLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b24ucGF0aENvbnN0cmFpbnRzW3RoaXMucGF0aENvbnN0cmFpbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChibGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zcGFjaW5nID0gY29uc3RyYWludC5kYXRhLnNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNwYWNpbmcgKz0gKGNvbnN0cmFpbnQuZGF0YS5zcGFjaW5nIC0gY29uc3RyYWludC5zcGFjaW5nKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLkVOVFJJRVNdKVxyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmcgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLlBSRVZfVkFMVUVdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmcgPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludFNwYWNpbmdUaW1lbGluZS5QUkVWX1ZBTFVFXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUuRU5UUklFUyAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUuUFJFVl9USU1FXSAtIGZyYW1lVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmcgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lLlZBTFVFXSAtIHNwYWNpbmcpICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBNaXhCbGVuZC5zZXR1cClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNwYWNpbmcgPSBjb25zdHJhaW50LmRhdGEuc3BhY2luZyArIChzcGFjaW5nIC0gY29uc3RyYWludC5kYXRhLnNwYWNpbmcpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zcGFjaW5nICs9IChzcGFjaW5nIC0gY29uc3RyYWludC5zcGFjaW5nKSAqIGFscGhhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmU7XHJcbiAgICAgICAgfShQYXRoQ29uc3RyYWludFBvc2l0aW9uVGltZWxpbmUpKTtcclxuICAgICAgICBjb3JlLlBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lID0gUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmU7XHJcbiAgICAgICAgdmFyIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZShmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmcmFtZUNvdW50KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGZyYW1lQ291bnQgKiBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUucHJvdG90eXBlLmdldFByb3BlcnR5SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFRpbWVsaW5lVHlwZS5wYXRoQ29uc3RyYWludE1peCA8PCAyNCkgKyB0aGlzLnBhdGhDb25zdHJhaW50SW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUucHJvdG90eXBlLnNldEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4KSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ICo9IFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlJPVEFURV0gPSByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5UUkFOU0xBVEVdID0gdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSwgYmxlbmQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbi5wYXRoQ29uc3RyYWludHNbdGhpcy5wYXRoQ29uc3RyYWludEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RyYWludC5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuc2V0dXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGNvbnN0cmFpbnQuZGF0YS5yb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCA9IGNvbnN0cmFpbnQuZGF0YS50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWl4QmxlbmQuZmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCArPSAoY29uc3RyYWludC5kYXRhLnJvdGF0ZU1peCAtIGNvbnN0cmFpbnQucm90YXRlTWl4KSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggKz0gKGNvbnN0cmFpbnQuZGF0YS50cmFuc2xhdGVNaXggLSBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IDAsIHRyYW5zbGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFU10pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9ST1RBVEVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA9IGZyYW1lc1tmcmFtZXMubGVuZ3RoICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1RSQU5TTEFURV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBBbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTKTtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfUk9UQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgPSBmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfVFJBTlNMQVRFXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lIC8gUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTIC0gMSwgMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWUgKyBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlBSRVZfVElNRV0gLSBmcmFtZVRpbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGUgKz0gKGZyYW1lc1tmcmFtZSArIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUk9UQVRFXSAtIHJvdGF0ZSkgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArPSAoZnJhbWVzW2ZyYW1lICsgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5UUkFOU0xBVEVdIC0gdHJhbnNsYXRlKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gTWl4QmxlbmQuc2V0dXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGNvbnN0cmFpbnQuZGF0YS5yb3RhdGVNaXggKyAocm90YXRlIC0gY29uc3RyYWludC5kYXRhLnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCA9IGNvbnN0cmFpbnQuZGF0YS50cmFuc2xhdGVNaXggKyAodHJhbnNsYXRlIC0gY29uc3RyYWludC5kYXRhLnRyYW5zbGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucm90YXRlTWl4ICs9IChyb3RhdGUgLSBjb25zdHJhaW50LnJvdGF0ZU1peCkgKiBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRyYW5zbGF0ZU1peCArPSAodHJhbnNsYXRlIC0gY29uc3RyYWludC50cmFuc2xhdGVNaXgpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuRU5UUklFUyA9IDM7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9USU1FID0gLTM7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuUFJFVl9ST1RBVEUgPSAtMjtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5QUkVWX1RSQU5TTEFURSA9IC0xO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludE1peFRpbWVsaW5lLlJPVEFURSA9IDE7XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUuVFJBTlNMQVRFID0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFBhdGhDb25zdHJhaW50TWl4VGltZWxpbmU7XHJcbiAgICAgICAgfShDdXJ2ZVRpbWVsaW5lKSk7XHJcbiAgICAgICAgY29yZS5QYXRoQ29uc3RyYWludE1peFRpbWVsaW5lID0gUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBBbmltYXRpb25TdGF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVua2V5ZWRTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgRXZlbnRRdWV1ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlJRHMgPSBuZXcgY29yZS5JbnRTZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tFbnRyeVBvb2wgPSBuZXcgY29yZS5Qb29sKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBUcmFja0VudHJ5KCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YSAqPSB0aGlzLnRpbWVTY2FsZTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdHJhY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYW5pbWF0aW9uTGFzdCA9IGN1cnJlbnQubmV4dEFuaW1hdGlvbkxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC50cmFja0xhc3QgPSBjdXJyZW50Lm5leHRUcmFja0xhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREZWx0YSA9IGRlbHRhICogY3VycmVudC50aW1lU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGVsYXkgLT0gY3VycmVudERlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5kZWxheSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERlbHRhID0gLWN1cnJlbnQuZGVsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGVsYXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VGltZSA9IGN1cnJlbnQudHJhY2tMYXN0IC0gbmV4dC5kZWxheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUaW1lID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuZGVsYXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50cmFja1RpbWUgKz0gY3VycmVudC50aW1lU2NhbGUgPT0gMCA/IDAgOiAobmV4dFRpbWUgLyBjdXJyZW50LnRpbWVTY2FsZSArIGRlbHRhKSAqIG5leHQudGltZVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC50cmFja1RpbWUgKz0gY3VycmVudERlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50KGksIG5leHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQubWl4aW5nRnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5taXhUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50LnRyYWNrTGFzdCA+PSBjdXJyZW50LnRyYWNrRW5kICYmIGN1cnJlbnQubWl4aW5nRnJvbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5kKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOZXh0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQubWl4aW5nRnJvbSAhPSBudWxsICYmIHRoaXMudXBkYXRlTWl4aW5nRnJvbShjdXJyZW50LCBkZWx0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSBjdXJyZW50Lm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWl4aW5nRnJvbSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLm1peGluZ1RvID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbmQoZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbS5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQudHJhY2tUaW1lICs9IGN1cnJlbnREZWx0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW4oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnVwZGF0ZU1peGluZ0Zyb20gPSBmdW5jdGlvbiAodG8sIGRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRvLm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gdGhpcy51cGRhdGVNaXhpbmdGcm9tKGZyb20sIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGZyb20uYW5pbWF0aW9uTGFzdCA9IGZyb20ubmV4dEFuaW1hdGlvbkxhc3Q7XHJcbiAgICAgICAgICAgICAgICBmcm9tLnRyYWNrTGFzdCA9IGZyb20ubmV4dFRyYWNrTGFzdDtcclxuICAgICAgICAgICAgICAgIGlmICh0by5taXhUaW1lID4gMCAmJiB0by5taXhUaW1lID49IHRvLm1peER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20udG90YWxBbHBoYSA9PSAwIHx8IHRvLm1peER1cmF0aW9uID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG8ubWl4aW5nRnJvbSA9IGZyb20ubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20ubWl4aW5nRnJvbSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbS5taXhpbmdGcm9tLm1peGluZ1RvID0gdG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLmludGVycnVwdEFscGhhID0gZnJvbS5pbnRlcnJ1cHRBbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbmQoZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZyb20udHJhY2tUaW1lICs9IGRlbHRhICogZnJvbS50aW1lU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0by5taXhUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2tlbGV0b24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnNDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnNDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBwbGllZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xNiA9IDAsIG5fMSA9IHRyYWNrcy5sZW5ndGg7IGlfMTYgPCBuXzE7IGlfMTYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdHJhY2tzW2lfMTZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09IG51bGwgfHwgY3VycmVudC5kZWxheSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibGVuZCA9IGlfMTYgPT0gMCA/IGNvcmUuTWl4QmxlbmQuZmlyc3QgOiBjdXJyZW50Lm1peEJsZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaXggPSBjdXJyZW50LmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm1peGluZ0Zyb20gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4ICo9IHRoaXMuYXBwbHlNaXhpbmdGcm9tKGN1cnJlbnQsIHNrZWxldG9uLCBibGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudC50cmFja1RpbWUgPj0gY3VycmVudC50cmFja0VuZCAmJiBjdXJyZW50Lm5leHQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uTGFzdCA9IGN1cnJlbnQuYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSA9IGN1cnJlbnQuZ2V0QW5pbWF0aW9uVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZUNvdW50ID0gY3VycmVudC5hbmltYXRpb24udGltZWxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzID0gY3VycmVudC5hbmltYXRpb24udGltZWxpbmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaV8xNiA9PSAwICYmIG1peCA9PSAxKSB8fCBibGVuZCA9PSBjb3JlLk1peEJsZW5kLmFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGltZWxpbmVDb3VudDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy53ZWJraXQ2MDJCdWdmaXhIZWxwZXIobWl4LCBibGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSB0aW1lbGluZXNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5BdHRhY2htZW50VGltZWxpbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUF0dGFjaG1lbnRUaW1lbGluZSh0aW1lbGluZSwgc2tlbGV0b24sIGFuaW1hdGlvblRpbWUsIGJsZW5kLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5hcHBseShza2VsZXRvbiwgYW5pbWF0aW9uTGFzdCwgYW5pbWF0aW9uVGltZSwgZXZlbnRzLCBtaXgsIGJsZW5kLCBjb3JlLk1peERpcmVjdGlvbi5taXhJbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGUgPSBjdXJyZW50LnRpbWVsaW5lTW9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0RnJhbWUgPSBjdXJyZW50LnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RGcmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKGN1cnJlbnQudGltZWxpbmVzUm90YXRpb24sIHRpbWVsaW5lQ291bnQgPDwgMSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZXNSb3RhdGlvbiA9IGN1cnJlbnQudGltZWxpbmVzUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0aW1lbGluZUNvdW50OyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVfMSA9IHRpbWVsaW5lc1tpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVCbGVuZCA9IHRpbWVsaW5lTW9kZVtpaV0gPT0gQW5pbWF0aW9uU3RhdGUuU1VCU0VRVUVOVCA/IGJsZW5kIDogY29yZS5NaXhCbGVuZC5zZXR1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZV8xIGluc3RhbmNlb2YgY29yZS5Sb3RhdGVUaW1lbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlSb3RhdGVUaW1lbGluZSh0aW1lbGluZV8xLCBza2VsZXRvbiwgYW5pbWF0aW9uVGltZSwgbWl4LCB0aW1lbGluZUJsZW5kLCB0aW1lbGluZXNSb3RhdGlvbiwgaWkgPDwgMSwgZmlyc3RGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lbGluZV8xIGluc3RhbmNlb2YgY29yZS5BdHRhY2htZW50VGltZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXR0YWNobWVudFRpbWVsaW5lKHRpbWVsaW5lXzEsIHNrZWxldG9uLCBhbmltYXRpb25UaW1lLCBibGVuZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLndlYmtpdDYwMkJ1Z2ZpeEhlbHBlcihtaXgsIGJsZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZV8xLmFwcGx5KHNrZWxldG9uLCBhbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lLCBldmVudHMsIG1peCwgdGltZWxpbmVCbGVuZCwgY29yZS5NaXhEaXJlY3Rpb24ubWl4SW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWVFdmVudHMoY3VycmVudCwgYW5pbWF0aW9uVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0QW5pbWF0aW9uTGFzdCA9IGFuaW1hdGlvblRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0VHJhY2tMYXN0ID0gY3VycmVudC50cmFja1RpbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0dXBTdGF0ZSA9IHRoaXMudW5rZXllZFN0YXRlICsgQW5pbWF0aW9uU3RhdGUuU0VUVVA7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBza2VsZXRvbi5zbG90cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5hdHRhY2htZW50U3RhdGUgPT0gc2V0dXBTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudE5hbWUgPSBzbG90LmRhdGEuYXR0YWNobWVudE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuYXR0YWNobWVudCA9IChhdHRhY2htZW50TmFtZSA9PSBudWxsID8gbnVsbCA6IHNrZWxldG9uLmdldEF0dGFjaG1lbnQoc2xvdC5kYXRhLmluZGV4LCBhdHRhY2htZW50TmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudW5rZXllZFN0YXRlICs9IDI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbGllZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFwcGx5TWl4aW5nRnJvbSA9IGZ1bmN0aW9uICh0bywgc2tlbGV0b24sIGJsZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRvLm1peGluZ0Zyb207XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5taXhpbmdGcm9tICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseU1peGluZ0Zyb20oZnJvbSwgc2tlbGV0b24sIGJsZW5kKTtcclxuICAgICAgICAgICAgICAgIHZhciBtaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvLm1peER1cmF0aW9uID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBtaXggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibGVuZCA9PSBjb3JlLk1peEJsZW5kLmZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuZCA9IGNvcmUuTWl4QmxlbmQuc2V0dXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtaXggPSB0by5taXhUaW1lIC8gdG8ubWl4RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1peCA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsZW5kICE9IGNvcmUuTWl4QmxlbmQuZmlyc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kID0gZnJvbS5taXhCbGVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBtaXggPCBmcm9tLmV2ZW50VGhyZXNob2xkID8gdGhpcy5ldmVudHMgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnRzID0gbWl4IDwgZnJvbS5hdHRhY2htZW50VGhyZXNob2xkLCBkcmF3T3JkZXIgPSBtaXggPCBmcm9tLmRyYXdPcmRlclRocmVzaG9sZDtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25MYXN0ID0gZnJvbS5hbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lID0gZnJvbS5nZXRBbmltYXRpb25UaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVDb3VudCA9IGZyb20uYW5pbWF0aW9uLnRpbWVsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzID0gZnJvbS5hbmltYXRpb24udGltZWxpbmVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFscGhhSG9sZCA9IGZyb20uYWxwaGEgKiB0by5pbnRlcnJ1cHRBbHBoYSwgYWxwaGFNaXggPSBhbHBoYUhvbGQgKiAoMSAtIG1peCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5hZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzW2ldLmFwcGx5KHNrZWxldG9uLCBhbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lLCBldmVudHMsIGFscGhhTWl4LCBibGVuZCwgY29yZS5NaXhEaXJlY3Rpb24ubWl4T3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGUgPSBmcm9tLnRpbWVsaW5lTW9kZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVIb2xkTWl4ID0gZnJvbS50aW1lbGluZUhvbGRNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0RnJhbWUgPSBmcm9tLnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEZyYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShmcm9tLnRpbWVsaW5lc1JvdGF0aW9uLCB0aW1lbGluZUNvdW50IDw8IDEsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZXNSb3RhdGlvbiA9IGZyb20udGltZWxpbmVzUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbS50b3RhbEFscGhhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSB0aW1lbGluZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBjb3JlLk1peERpcmVjdGlvbi5taXhPdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZUJsZW5kID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRpbWVsaW5lTW9kZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdGF0ZS5TVUJTRVFVRU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhd09yZGVyICYmIHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5EcmF3T3JkZXJUaW1lbGluZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVCbGVuZCA9IGJsZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYWxwaGFNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0YXRlLkZJUlNUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lQmxlbmQgPSBjb3JlLk1peEJsZW5kLnNldHVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYWxwaGFNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0YXRlLkhPTERfU1VCU0VRVUVOVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZUJsZW5kID0gYmxlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBhbHBoYUhvbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0YXRlLkhPTERfRklSU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVCbGVuZCA9IGNvcmUuTWl4QmxlbmQuc2V0dXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBhbHBoYUhvbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lQmxlbmQgPSBjb3JlLk1peEJsZW5kLnNldHVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob2xkTWl4ID0gdGltZWxpbmVIb2xkTWl4W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYWxwaGFIb2xkICogTWF0aC5tYXgoMCwgMSAtIGhvbGRNaXgubWl4VGltZSAvIGhvbGRNaXgubWl4RHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20udG90YWxBbHBoYSArPSBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5Sb3RhdGVUaW1lbGluZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlSb3RhdGVUaW1lbGluZSh0aW1lbGluZSwgc2tlbGV0b24sIGFuaW1hdGlvblRpbWUsIGFscGhhLCB0aW1lbGluZUJsZW5kLCB0aW1lbGluZXNSb3RhdGlvbiwgaSA8PCAxLCBmaXJzdEZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmUgaW5zdGFuY2VvZiBjb3JlLkF0dGFjaG1lbnRUaW1lbGluZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRhY2htZW50VGltZWxpbmUodGltZWxpbmUsIHNrZWxldG9uLCBhbmltYXRpb25UaW1lLCB0aW1lbGluZUJsZW5kLCBhdHRhY2htZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy53ZWJraXQ2MDJCdWdmaXhIZWxwZXIoYWxwaGEsIGJsZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXIgJiYgdGltZWxpbmUgaW5zdGFuY2VvZiBjb3JlLkRyYXdPcmRlclRpbWVsaW5lICYmIHRpbWVsaW5lQmxlbmQgPT0gY29yZS5NaXhCbGVuZC5zZXR1cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBjb3JlLk1peERpcmVjdGlvbi5taXhJbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5KHNrZWxldG9uLCBhbmltYXRpb25MYXN0LCBhbmltYXRpb25UaW1lLCBldmVudHMsIGFscGhhLCB0aW1lbGluZUJsZW5kLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvLm1peER1cmF0aW9uID4gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlRXZlbnRzKGZyb20sIGFuaW1hdGlvblRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZyb20ubmV4dEFuaW1hdGlvbkxhc3QgPSBhbmltYXRpb25UaW1lO1xyXG4gICAgICAgICAgICAgICAgZnJvbS5uZXh0VHJhY2tMYXN0ID0gZnJvbS50cmFja1RpbWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWl4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYXBwbHlBdHRhY2htZW50VGltZWxpbmUgPSBmdW5jdGlvbiAodGltZWxpbmUsIHNrZWxldG9uLCB0aW1lLCBibGVuZCwgYXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGltZWxpbmUuc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gdGltZWxpbmUuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxlbmQgPT0gY29yZS5NaXhCbGVuZC5zZXR1cCB8fCBibGVuZCA9PSBjb3JlLk1peEJsZW5kLmZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoc2tlbGV0b24sIHNsb3QsIHNsb3QuZGF0YS5hdHRhY2htZW50TmFtZSwgYXR0YWNobWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IGZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IGNvcmUuQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoc2tlbGV0b24sIHNsb3QsIHRpbWVsaW5lLmF0dGFjaG1lbnROYW1lc1tmcmFtZUluZGV4XSwgYXR0YWNobWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3QuYXR0YWNobWVudFN0YXRlIDw9IHRoaXMudW5rZXllZFN0YXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuYXR0YWNobWVudFN0YXRlID0gdGhpcy51bmtleWVkU3RhdGUgKyBBbmltYXRpb25TdGF0ZS5TRVRVUDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2tlbGV0b24sIHNsb3QsIGF0dGFjaG1lbnROYW1lLCBhdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICAgICAgc2xvdC5hdHRhY2htZW50ID0gYXR0YWNobWVudE5hbWUgPT0gbnVsbCA/IG51bGwgOiBza2VsZXRvbi5nZXRBdHRhY2htZW50KHNsb3QuZGF0YS5pbmRleCwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuYXR0YWNobWVudFN0YXRlID0gdGhpcy51bmtleWVkU3RhdGUgKyBBbmltYXRpb25TdGF0ZS5DVVJSRU5UO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYXBwbHlSb3RhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICh0aW1lbGluZSwgc2tlbGV0b24sIHRpbWUsIGFscGhhLCBibGVuZCwgdGltZWxpbmVzUm90YXRpb24sIGksIGZpcnN0RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdEZyYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lc1JvdGF0aW9uW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYXBwbHkoc2tlbGV0b24sIDAsIHRpbWUsIG51bGwsIDEsIGJsZW5kLCBjb3JlLk1peERpcmVjdGlvbi5taXhJbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZVRpbWVsaW5lID0gdGltZWxpbmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzID0gcm90YXRlVGltZWxpbmUuZnJhbWVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1tyb3RhdGVUaW1lbGluZS5ib25lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgcjEgPSAwLCByMiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLk1peEJsZW5kLnNldHVwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5yb3RhdGlvbiA9IGJvbmUuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLk1peEJsZW5kLmZpcnN0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjEgPSBib25lLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjIgPSBib25lLmRhdGEucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcjEgPSBibGVuZCA9PSBjb3JlLk1peEJsZW5kLnNldHVwID8gYm9uZS5kYXRhLnJvdGF0aW9uIDogYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIGNvcmUuUm90YXRlVGltZWxpbmUuRU5UUklFU10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyID0gYm9uZS5kYXRhLnJvdGF0aW9uICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggKyBjb3JlLlJvdGF0ZVRpbWVsaW5lLlBSRVZfUk9UQVRJT05dO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBjb3JlLkFuaW1hdGlvbi5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCBjb3JlLlJvdGF0ZVRpbWVsaW5lLkVOVFJJRVMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlJvdGF0aW9uID0gZnJhbWVzW2ZyYW1lICsgY29yZS5Sb3RhdGVUaW1lbGluZS5QUkVWX1JPVEFUSU9OXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gcm90YXRlVGltZWxpbmUuZ2V0Q3VydmVQZXJjZW50KChmcmFtZSA+PiAxKSAtIDEsIDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lICsgY29yZS5Sb3RhdGVUaW1lbGluZS5QUkVWX1RJTUVdIC0gZnJhbWVUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyID0gZnJhbWVzW2ZyYW1lICsgY29yZS5Sb3RhdGVUaW1lbGluZS5ST1RBVElPTl0gLSBwcmV2Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIyIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gcjIgLyAzNjApIHwgMCkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByMiA9IHByZXZSb3RhdGlvbiArIHIyICogcGVyY2VudCArIGJvbmUuZGF0YS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjIgLT0gKDE2Mzg0IC0gKCgxNjM4NC40OTk5OTk5OTk5OTYgLSByMiAvIDM2MCkgfCAwKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMCwgZGlmZiA9IHIyIC0gcjE7XHJcbiAgICAgICAgICAgICAgICBkaWZmIC09ICgxNjM4NCAtICgoMTYzODQuNDk5OTk5OTk5OTk2IC0gZGlmZiAvIDM2MCkgfCAwKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgPSB0aW1lbGluZXNSb3RhdGlvbltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VG90YWwgPSAwLCBsYXN0RGlmZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRvdGFsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERpZmYgPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRvdGFsID0gdGltZWxpbmVzUm90YXRpb25baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REaWZmID0gdGltZWxpbmVzUm90YXRpb25baSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGRpZmYgPiAwLCBkaXIgPSBsYXN0VG90YWwgPj0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29yZS5NYXRoVXRpbHMuc2lnbnVtKGxhc3REaWZmKSAhPSBjb3JlLk1hdGhVdGlscy5zaWdudW0oZGlmZikgJiYgTWF0aC5hYnMobGFzdERpZmYpIDw9IDkwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsYXN0VG90YWwpID4gMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRvdGFsICs9IDM2MCAqIGNvcmUuTWF0aFV0aWxzLnNpZ251bShsYXN0VG90YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IGRpZmYgKyBsYXN0VG90YWwgLSBsYXN0VG90YWwgJSAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciAhPSBjdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSAzNjAgKiBjb3JlLk1hdGhVdGlscy5zaWdudW0obGFzdFRvdGFsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXNSb3RhdGlvbltpXSA9IHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGltZWxpbmVzUm90YXRpb25baSArIDFdID0gZGlmZjtcclxuICAgICAgICAgICAgICAgIHIxICs9IHRvdGFsICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICBib25lLnJvdGF0aW9uID0gcjEgLSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIxIC8gMzYwKSB8IDApKSAqIDM2MDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnF1ZXVlRXZlbnRzID0gZnVuY3Rpb24gKGVudHJ5LCBhbmltYXRpb25UaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uU3RhcnQgPSBlbnRyeS5hbmltYXRpb25TdGFydCwgYW5pbWF0aW9uRW5kID0gZW50cnkuYW5pbWF0aW9uRW5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0aW9uRW5kIC0gYW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tMYXN0V3JhcHBlZCA9IGVudHJ5LnRyYWNrTGFzdCAlIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBuID0gZXZlbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzEudGltZSA8IHRyYWNrTGFzdFdyYXBwZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudF8xLnRpbWUgPiBhbmltYXRpb25FbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZXZlbnQoZW50cnksIGV2ZW50XzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkubG9vcClcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGR1cmF0aW9uID09IDAgfHwgdHJhY2tMYXN0V3JhcHBlZCA+IGVudHJ5LnRyYWNrVGltZSAlIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gYW5pbWF0aW9uVGltZSA+PSBhbmltYXRpb25FbmQgJiYgZW50cnkuYW5pbWF0aW9uTGFzdCA8IGFuaW1hdGlvbkVuZDtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmNvbXBsZXRlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzIudGltZSA8IGFuaW1hdGlvblN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmV2ZW50KGVudHJ5LCBldmVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuY2xlYXJUcmFja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkRHJhaW5EaXNhYmxlZCA9IHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMudHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVHJhY2soaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5kcmFpbkRpc2FibGVkID0gb2xkRHJhaW5EaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW4oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmNsZWFyVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrSW5kZXggPj0gdGhpcy50cmFja3MubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy50cmFja3NbdHJhY2tJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5kKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlTmV4dChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gZW50cnkubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVuZChmcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5taXhpbmdGcm9tID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5taXhpbmdUbyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBmcm9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFja3NbY3VycmVudC50cmFja0luZGV4XSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRDdXJyZW50ID0gZnVuY3Rpb24gKGluZGV4LCBjdXJyZW50LCBpbnRlcnJ1cHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5leHBhbmRUb0luZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzW2luZGV4XSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVycnVwdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5pbnRlcnJ1cHQoZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5taXhpbmdGcm9tID0gZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tLm1peGluZ1RvID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1peFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tLm1peGluZ0Zyb20gIT0gbnVsbCAmJiBmcm9tLm1peER1cmF0aW9uID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5pbnRlcnJ1cHRBbHBoYSAqPSBNYXRoLm1pbigxLCBmcm9tLm1peFRpbWUgLyBmcm9tLm1peER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tLnRpbWVsaW5lc1JvdGF0aW9uLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnN0YXJ0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuc2V0QW5pbWF0aW9uID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbk5hbWUsIGxvb3ApIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmRhdGEuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEFuaW1hdGlvbldpdGgodHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEFuaW1hdGlvbldpdGggPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYW5pbWF0aW9uIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnJ1cHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmV4cGFuZFRvSW5kZXgodHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQubmV4dFRyYWNrTGFzdCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja0luZGV4XSA9IGN1cnJlbnQubWl4aW5nRnJvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5pbnRlcnJ1cHQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5kKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOZXh0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VOZXh0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cmFja0VudHJ5KHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQodHJhY2tJbmRleCwgZW50cnksIGludGVycnVwdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRBbmltYXRpb24gPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmRhdGEuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFuaW1hdGlvbldpdGgodHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRBbmltYXRpb25XaXRoID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbmltYXRpb24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmV4cGFuZFRvSW5kZXgodHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxhc3QubmV4dCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cmFja0VudHJ5KHRyYWNrSW5kZXgsIGFuaW1hdGlvbiwgbG9vcCwgbGFzdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50KHRyYWNrSW5kZXgsIGVudHJ5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Lm5leHQgPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBsYXN0LmFuaW1hdGlvbkVuZCAtIGxhc3QuYW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdC5sb29wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICs9IGR1cmF0aW9uICogKDEgKyAoKGxhc3QudHJhY2tUaW1lIC8gZHVyYXRpb24pIHwgMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICs9IE1hdGgubWF4KGR1cmF0aW9uLCBsYXN0LnRyYWNrVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheSAtPSB0aGlzLmRhdGEuZ2V0TWl4KGxhc3QuYW5pbWF0aW9uLCBhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gbGFzdC50cmFja1RpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZW50cnkuZGVsYXkgPSBkZWxheTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLnNldEVtcHR5QW5pbWF0aW9uID0gZnVuY3Rpb24gKHRyYWNrSW5kZXgsIG1peER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnNldEFuaW1hdGlvbldpdGgodHJhY2tJbmRleCwgQW5pbWF0aW9uU3RhdGUuZW1wdHlBbmltYXRpb24sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm1peER1cmF0aW9uID0gbWl4RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50cmFja0VuZCA9IG1peER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuYWRkRW1wdHlBbmltYXRpb24gPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgbWl4RHVyYXRpb24sIGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkgPD0gMClcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSAtPSBtaXhEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuYWRkQW5pbWF0aW9uV2l0aCh0cmFja0luZGV4LCBBbmltYXRpb25TdGF0ZS5lbXB0eUFuaW1hdGlvbiwgZmFsc2UsIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm1peER1cmF0aW9uID0gbWl4RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50cmFja0VuZCA9IG1peER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuc2V0RW1wdHlBbmltYXRpb25zID0gZnVuY3Rpb24gKG1peER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkRHJhaW5EaXNhYmxlZCA9IHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMudHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy50cmFja3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbXB0eUFuaW1hdGlvbihjdXJyZW50LnRyYWNrSW5kZXgsIG1peER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZHJhaW5EaXNhYmxlZCA9IG9sZERyYWluRGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5leHBhbmRUb0luZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLnRyYWNrcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuZW5zdXJlQXJyYXlDYXBhY2l0eSh0aGlzLnRyYWNrcywgaW5kZXggKyAxLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUudHJhY2tFbnRyeSA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJhY2tFbnRyeVBvb2wub2J0YWluKCk7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50cmFja0luZGV4ID0gdHJhY2tJbmRleDtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lmxvb3AgPSBsb29wO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuaG9sZFByZXZpb3VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5ldmVudFRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hdHRhY2htZW50VGhyZXNob2xkID0gMDtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmRyYXdPcmRlclRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hbmltYXRpb25TdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hbmltYXRpb25FbmQgPSBhbmltYXRpb24uZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5hbmltYXRpb25MYXN0ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5uZXh0QW5pbWF0aW9uTGFzdCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuZGVsYXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudHJhY2tUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRyYWNrTGFzdCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZW50cnkubmV4dFRyYWNrTGFzdCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudHJhY2tFbmQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgZW50cnkudGltZVNjYWxlID0gMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmludGVycnVwdEFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm1peFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZW50cnkubWl4RHVyYXRpb24gPSBsYXN0ID09IG51bGwgPyAwIDogdGhpcy5kYXRhLmdldE1peChsYXN0LmFuaW1hdGlvbiwgYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGVudHJ5Lm1peEJsZW5kID0gY29yZS5NaXhCbGVuZC5yZXBsYWNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuZGlzcG9zZU5leHQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmRpc3Bvc2UobmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVudHJ5Lm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuX2FuaW1hdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUlEcy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyYWNrc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudHJ5Lm1peGluZ0Zyb20gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBlbnRyeS5taXhpbmdGcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lm1peGluZ0Zyb20gPT0gbnVsbCB8fCBlbnRyeS5taXhCbGVuZCAhPSBjb3JlLk1peEJsZW5kLmFkZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUhvbGQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm1peGluZ1RvO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGVudHJ5ICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuY29tcHV0ZUhvbGQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0byA9IGVudHJ5Lm1peGluZ1RvO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lcyA9IGVudHJ5LmFuaW1hdGlvbi50aW1lbGluZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVzQ291bnQgPSBlbnRyeS5hbmltYXRpb24udGltZWxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGUgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShlbnRyeS50aW1lbGluZU1vZGUsIHRpbWVsaW5lc0NvdW50KTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRpbWVsaW5lSG9sZE1peC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lRGlwTWl4ID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoZW50cnkudGltZWxpbmVIb2xkTWl4LCB0aW1lbGluZXNDb3VudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlJRHMgPSB0aGlzLnByb3BlcnR5SURzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvICE9IG51bGwgJiYgdG8uaG9sZFByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lTW9kZVtpXSA9IHByb3BlcnR5SURzLmFkZCh0aW1lbGluZXNbaV0uZ2V0UHJvcGVydHlJZCgpKSA/IEFuaW1hdGlvblN0YXRlLkhPTERfRklSU1QgOiBBbmltYXRpb25TdGF0ZS5IT0xEX1NVQlNFUVVFTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dGVyOiBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSB0aW1lbGluZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdGltZWxpbmUuZ2V0UHJvcGVydHlJZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlJRHMuYWRkKGlkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVNb2RlW2ldID0gQW5pbWF0aW9uU3RhdGUuU1VCU0VRVUVOVDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PSBudWxsIHx8IHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5BdHRhY2htZW50VGltZWxpbmUgfHwgdGltZWxpbmUgaW5zdGFuY2VvZiBjb3JlLkRyYXdPcmRlclRpbWVsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHRpbWVsaW5lIGluc3RhbmNlb2YgY29yZS5FdmVudFRpbWVsaW5lIHx8ICF0by5hbmltYXRpb24uaGFzVGltZWxpbmUoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lTW9kZVtpXSA9IEFuaW1hdGlvblN0YXRlLkZJUlNUO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dCA9IHRvLm1peGluZ1RvOyBuZXh0ICE9IG51bGw7IG5leHQgPSBuZXh0Lm1peGluZ1RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5hbmltYXRpb24uaGFzVGltZWxpbmUoaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lm1peER1cmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lTW9kZVtpXSA9IEFuaW1hdGlvblN0YXRlLkhPTERfTUlYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lRGlwTWl4W2ldID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lTW9kZVtpXSA9IEFuaW1hdGlvblN0YXRlLkhPTERfRklSU1Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICh0cmFja0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tJbmRleCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3NbdHJhY2tJbmRleF07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGlzdGVuZXIgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuY2xlYXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5wcm90b3R5cGUuY2xlYXJMaXN0ZW5lck5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5zZXRBbmltYXRpb25CeU5hbWUgPSBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IEFuaW1hdGlvblN0YXRlLnNldEFuaW1hdGlvbkJ5TmFtZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHNldEFuaW1hdGlvbiBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuaW1hdGlvbih0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlLmFkZEFuaW1hdGlvbkJ5TmFtZSA9IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wLCBkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzIpIHtcclxuICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IEFuaW1hdGlvblN0YXRlLmFkZEFuaW1hdGlvbkJ5TmFtZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFkZEFuaW1hdGlvbiBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFuaW1hdGlvbih0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5oYXNBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZGF0YS5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24gIT09IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLnByb3RvdHlwZS5oYXNBbmltYXRpb25CeU5hbWUgPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzMpIHtcclxuICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IEFuaW1hdGlvblN0YXRlLmhhc0FuaW1hdGlvbkJ5TmFtZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGhhc0FuaW1hdGlvbiBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBbmltYXRpb24oYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLmVtcHR5QW5pbWF0aW9uID0gbmV3IGNvcmUuQW5pbWF0aW9uKFwiPGVtcHR5PlwiLCBbXSwgMCk7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLlNVQlNFUVVFTlQgPSAwO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5GSVJTVCA9IDE7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLkhPTERfU1VCU0VRVUVOVCA9IDI7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLkhPTERfRklSU1QgPSAzO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5IT0xEX01JWCA9IDQ7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLlNFVFVQID0gMTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuQ1VSUkVOVCA9IDI7XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZS5kZXByZWNhdGVkV2FybmluZzIgPSBmYWxzZTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGUuZGVwcmVjYXRlZFdhcm5pbmczID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZTtcclxuICAgICAgICB2YXIgVHJhY2tFbnRyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYWNrRW50cnkoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1peEJsZW5kID0gY29yZS5NaXhCbGVuZC5yZXBsYWNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZU1vZGUgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVIb2xkTWl4ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lc1JvdGF0aW9uID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXhpbmdGcm9tID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWl4aW5nVG8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lTW9kZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZUhvbGRNaXgubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmVzUm90YXRpb24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmFuaW1hdGlvbkVuZCAtIHRoaXMuYW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy50cmFja1RpbWUgJSBkdXJhdGlvbikgKyB0aGlzLmFuaW1hdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudHJhY2tUaW1lICsgdGhpcy5hbmltYXRpb25TdGFydCwgdGhpcy5hbmltYXRpb25FbmQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFja0VudHJ5LnByb3RvdHlwZS5zZXRBbmltYXRpb25MYXN0ID0gZnVuY3Rpb24gKGFuaW1hdGlvbkxhc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTGFzdCA9IGFuaW1hdGlvbkxhc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRBbmltYXRpb25MYXN0ID0gYW5pbWF0aW9uTGFzdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhY2tFbnRyeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrVGltZSA+PSB0aGlzLmFuaW1hdGlvbkVuZCAtIHRoaXMuYW5pbWF0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYWNrRW50cnkucHJvdG90eXBlLnJlc2V0Um90YXRpb25EaXJlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZXNSb3RhdGlvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tFbnRyeS5wcm90b3R5cGUsIFwidGltZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYWNrRW50cnkuZGVwcmVjYXRlZFdhcm5pbmcxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3BpbmUgRGVwcmVjYXRpb24gV2FybmluZzogVHJhY2tFbnRyeS50aW1lIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdHJhY2tUaW1lIGZyb20gbm93IG9uLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tUaW1lO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IFRyYWNrRW50cnkudGltZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRyYWNrVGltZSBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tUaW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFja0VudHJ5LnByb3RvdHlwZSwgXCJlbmRUaW1lXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBUcmFja0VudHJ5LmVuZFRpbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0cmFja0VuZCBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrVGltZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2tFbnRyeS5kZXByZWNhdGVkV2FybmluZzIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBUcmFja0VudHJ5LmVuZFRpbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0cmFja0VuZCBmcm9tIG5vdyBvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tUaW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFRyYWNrRW50cnkucHJvdG90eXBlLmxvb3BzQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnRyYWNrVGltZSAvIHRoaXMudHJhY2tFbmQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBUcmFja0VudHJ5LmRlcHJlY2F0ZWRXYXJuaW5nMiA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gVHJhY2tFbnRyeTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVHJhY2tFbnRyeSA9IFRyYWNrRW50cnk7XHJcbiAgICAgICAgdmFyIEV2ZW50UXVldWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKGFuaW1TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlID0gYW5pbVN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEV2ZW50UXVldWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGUuYW5pbWF0aW9uc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5pbnRlcnJ1cHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGUuYW5pbWF0aW9uc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuZGlzcG9zZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEV2ZW50UXVldWUucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChFdmVudFR5cGUuY29tcGxldGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uIChlbnRyeSwgZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKEV2ZW50VHlwZS5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEV2ZW50UXVldWUucHJvdG90eXBlLmRlcHJlY2F0ZVN0dWZmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFFdmVudFF1ZXVlLmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50UXVldWUuZGVwcmVjYXRlZFdhcm5pbmcxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBvbkNvbXBsZXRlLCBvblN0YXJ0LCBvbkVuZCwgb25FdmVudCBhcnQgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBsaXN0ZW5lcnMgZnJvbSBub3cgb24uICdzdGF0ZS5hZGRMaXN0ZW5lcih7IGNvbXBsZXRlOiBmdW5jdGlvbih0cmFjaywgZXZlbnQpIHsgfSB9KSdcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRRdWV1ZS5wcm90b3R5cGUuZHJhaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFpbkRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5EaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmFuaW1TdGF0ZS5saXN0ZW5lcnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iamVjdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gb2JqZWN0c1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLnN0YXJ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuc3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGlzdGVuZXIuc3RhcnQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpaV0uc3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpaV0uc3RhcnQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkub25TdGFydCAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgZW50cnkub25TdGFydChlbnRyeS50cmFja0luZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLm9uU3RhcnQgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIHRoaXMuZGVwcmVjYXRlU3R1ZmYgJiYgdGhpcy5hbmltU3RhdGUub25TdGFydChlbnRyeS50cmFja0luZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5pbnRlcnJ1cHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5pbnRlcnJ1cHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGlzdGVuZXIuaW50ZXJydXB0KGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaWldLmludGVycnVwdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lpXS5pbnRlcnJ1cHQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLmVuZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5saXN0ZW5lciAhPSBudWxsICYmIGVudHJ5Lmxpc3RlbmVyLmVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5saXN0ZW5lci5lbmQoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpaV0uZW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWldLmVuZChlbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbkVuZCAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgZW50cnkub25FbmQoZW50cnkudHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1TdGF0ZS5vbkVuZCAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgdGhpcy5hbmltU3RhdGUub25FbmQoZW50cnkudHJhY2tJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLmRpc3Bvc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5kaXNwb3NlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lmxpc3RlbmVyLmRpc3Bvc2UoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpaV0uZGlzcG9zZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lpXS5kaXNwb3NlKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlLnRyYWNrRW50cnlQb29sLmZyZWUoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLmNvbXBsZXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lmxpc3RlbmVyICE9IG51bGwgJiYgZW50cnkubGlzdGVuZXIuY29tcGxldGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGlzdGVuZXIuY29tcGxldGUoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxpc3RlbmVycy5sZW5ndGg7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpaV0uY29tcGxldGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpaV0uY29tcGxldGUoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gY29yZS5NYXRoVXRpbHMudG9JbnQoZW50cnkubG9vcHNDb3VudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Lm9uQ29tcGxldGUgJiYgdGhpcy5kZXByZWNhdGVTdHVmZigpICYmIGVudHJ5Lm9uQ29tcGxldGUoZW50cnkudHJhY2tJbmRleCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGUub25Db21wbGV0ZSAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgdGhpcy5hbmltU3RhdGUub25Db21wbGV0ZShlbnRyeS50cmFja0luZGV4LCBjb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuZXZlbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMyA9IG9iamVjdHNbaSsrICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubGlzdGVuZXIgIT0gbnVsbCAmJiBlbnRyeS5saXN0ZW5lci5ldmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5saXN0ZW5lci5ldmVudChlbnRyeSwgZXZlbnRfMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2lpXS5ldmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lpXS5ldmVudChlbnRyeSwgZXZlbnRfMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbkV2ZW50ICYmIHRoaXMuZGVwcmVjYXRlU3R1ZmYoKSAmJiBlbnRyeS5vbkV2ZW50KGVudHJ5LnRyYWNrSW5kZXgsIGV2ZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGUub25FdmVudCAmJiB0aGlzLmRlcHJlY2F0ZVN0dWZmKCkgJiYgdGhpcy5hbmltU3RhdGUub25FdmVudChlbnRyeS50cmFja0luZGV4LCBldmVudF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5EaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudFF1ZXVlLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRRdWV1ZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuRXZlbnRRdWV1ZSA9IEV2ZW50UXVldWU7XHJcbiAgICAgICAgdmFyIEV2ZW50VHlwZTtcclxuICAgICAgICAoZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xyXG4gICAgICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wic3RhcnRcIl0gPSAwXSA9IFwic3RhcnRcIjtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImludGVycnVwdFwiXSA9IDFdID0gXCJpbnRlcnJ1cHRcIjtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImVuZFwiXSA9IDJdID0gXCJlbmRcIjtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImRpc3Bvc2VcIl0gPSAzXSA9IFwiZGlzcG9zZVwiO1xyXG4gICAgICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiY29tcGxldGVcIl0gPSA0XSA9IFwiY29tcGxldGVcIjtcclxuICAgICAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcImV2ZW50XCJdID0gNV0gPSBcImV2ZW50XCI7XHJcbiAgICAgICAgfSkoRXZlbnRUeXBlID0gY29yZS5FdmVudFR5cGUgfHwgKGNvcmUuRXZlbnRUeXBlID0ge30pKTtcclxuICAgICAgICB2YXIgQW5pbWF0aW9uU3RhdGVBZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVBZGFwdGVyKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVBZGFwdGVyLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVBZGFwdGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVBZGFwdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlQWRhcHRlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVBZGFwdGVyLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uIChlbnRyeSwgZXZlbnQpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlQWRhcHRlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQW5pbWF0aW9uU3RhdGVBZGFwdGVyID0gQW5pbWF0aW9uU3RhdGVBZGFwdGVyO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEFuaW1hdGlvblN0YXRlRGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGF0YShza2VsZXRvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uRGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNrZWxldG9uRGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNrZWxldG9uRGF0YSA9IHNrZWxldG9uRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZURhdGEucHJvdG90eXBlLnNldE1peCA9IGZ1bmN0aW9uIChmcm9tTmFtZSwgdG9OYW1lLCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGZyb21OYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBmcm9tTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKHRvTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIHRvTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1peFdpdGgoZnJvbSwgdG8sIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZS5zZXRNaXhCeU5hbWUgPSBmdW5jdGlvbiAoZnJvbU5hbWUsIHRvTmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICghQW5pbWF0aW9uU3RhdGVEYXRhLmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEFuaW1hdGlvblN0YXRlRGF0YS5kZXByZWNhdGVkV2FybmluZzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRlcHJlY2F0aW9uIFdhcm5pbmc6IEFuaW1hdGlvblN0YXRlRGF0YS5zZXRNaXhCeU5hbWUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzZXRNaXggZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNaXgoZnJvbU5hbWUsIHRvTmFtZSwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBbmltYXRpb25TdGF0ZURhdGEucHJvdG90eXBlLnNldE1peFdpdGggPSBmdW5jdGlvbiAoZnJvbSwgdG8sIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyb20gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG8gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGZyb20ubmFtZSArIFwiLlwiICsgdG8ubmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lW2tleV0gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZS5nZXRNaXggPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBmcm9tLm5hbWUgKyBcIi5cIiArIHRvLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFuaW1hdGlvblRvTWl4VGltZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRNaXggOiB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQW5pbWF0aW9uU3RhdGVEYXRhLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVEYXRhO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5BbmltYXRpb25TdGF0ZURhdGEgPSBBbmltYXRpb25TdGF0ZURhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQXRsYXNBdHRhY2htZW50TG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQXRsYXNBdHRhY2htZW50TG9hZGVyKGF0bGFzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0bGFzID0gYXRsYXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQXRsYXNBdHRhY2htZW50TG9hZGVyLnByb3RvdHlwZS5uZXdSZWdpb25BdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUsIHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmF0bGFzLmZpbmRSZWdpb24ocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uIG5vdCBmb3VuZCBpbiBhdGxhczogXCIgKyBwYXRoICsgXCIgKHJlZ2lvbiBhdHRhY2htZW50OiBcIiArIG5hbWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBjb3JlLlJlZ2lvbkF0dGFjaG1lbnQobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld01lc2hBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUsIHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmF0bGFzLmZpbmRSZWdpb24ocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uIG5vdCBmb3VuZCBpbiBhdGxhczogXCIgKyBwYXRoICsgXCIgKG1lc2ggYXR0YWNobWVudDogXCIgKyBuYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBuZXcgY29yZS5NZXNoQXR0YWNobWVudChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uID0gcmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUubmV3Qm91bmRpbmdCb3hBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQobmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUubmV3UGF0aEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2tpbiwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLlBhdGhBdHRhY2htZW50KG5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld1BvaW50QXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuUG9pbnRBdHRhY2htZW50KG5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBdGxhc0F0dGFjaG1lbnRMb2FkZXIucHJvdG90eXBlLm5ld0NsaXBwaW5nQXR0YWNobWVudCA9IGZ1bmN0aW9uIChza2luLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuQ2xpcHBpbmdBdHRhY2htZW50KG5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQXRsYXNBdHRhY2htZW50TG9hZGVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5BdGxhc0F0dGFjaG1lbnRMb2FkZXIgPSBBdGxhc0F0dGFjaG1lbnRMb2FkZXI7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQmxlbmRNb2RlO1xyXG4gICAgICAgIChmdW5jdGlvbiAoQmxlbmRNb2RlKSB7XHJcbiAgICAgICAgICAgIEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XHJcbiAgICAgICAgICAgIEJsZW5kTW9kZVtCbGVuZE1vZGVbXCJBZGRpdGl2ZVwiXSA9IDFdID0gXCJBZGRpdGl2ZVwiO1xyXG4gICAgICAgICAgICBCbGVuZE1vZGVbQmxlbmRNb2RlW1wiTXVsdGlwbHlcIl0gPSAyXSA9IFwiTXVsdGlwbHlcIjtcclxuICAgICAgICAgICAgQmxlbmRNb2RlW0JsZW5kTW9kZVtcIlNjcmVlblwiXSA9IDNdID0gXCJTY3JlZW5cIjtcclxuICAgICAgICB9KShCbGVuZE1vZGUgPSBjb3JlLkJsZW5kTW9kZSB8fCAoY29yZS5CbGVuZE1vZGUgPSB7fSkpO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEJvbmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCb25lKGRhdGEsIHNrZWxldG9uLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gbmV3IFBJWEkuTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5heCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF5ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNjYWxlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpZWRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUb1NldHVwUG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb25lLnByb3RvdHlwZSwgXCJ3b3JsZFhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LnR4O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm9uZS5wcm90b3R5cGUsIFwid29ybGRZXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC50eTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHRoaXMueCwgdGhpcy55LCB0aGlzLnJvdGF0aW9uLCB0aGlzLnNjYWxlWCwgdGhpcy5zY2FsZVksIHRoaXMuc2hlYXJYLCB0aGlzLnNoZWFyWSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnVwZGF0ZVdvcmxkVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgodGhpcy54LCB0aGlzLnksIHRoaXMucm90YXRpb24sIHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSwgdGhpcy5zaGVhclgsIHRoaXMuc2hlYXJZKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoID0gZnVuY3Rpb24gKHgsIHksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSwgc2hlYXJYLCBzaGVhclkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXggPSB4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5heSA9IHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJYID0gc2hlYXJYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJZID0gc2hlYXJZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWVkVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciBzeCA9IHRoaXMuc2tlbGV0b24uc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5ID0gQm9uZS55RG93biA/IC10aGlzLnNrZWxldG9uLnNjYWxlWSA6IHRoaXMuc2tlbGV0b24uc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uID0gdGhpcy5za2VsZXRvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb25ZID0gcm90YXRpb24gKyA5MCArIHNoZWFyWTtcclxuICAgICAgICAgICAgICAgICAgICBtLmEgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYICogc3g7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5jID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uWSkgKiBzY2FsZVkgKiBzeDtcclxuICAgICAgICAgICAgICAgICAgICBtLmIgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYICogc3k7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5kID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHJvdGF0aW9uWSkgKiBzY2FsZVkgKiBzeTtcclxuICAgICAgICAgICAgICAgICAgICBtLnR4ID0geCAqIHN4ICsgc2tlbGV0b24ueDtcclxuICAgICAgICAgICAgICAgICAgICBtLnR5ID0geSAqIHN5ICsgc2tlbGV0b24ueTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGEgPSBwYXJlbnQubWF0cml4LmEsIHBiID0gcGFyZW50Lm1hdHJpeC5jLCBwYyA9IHBhcmVudC5tYXRyaXguYiwgcGQgPSBwYXJlbnQubWF0cml4LmQ7XHJcbiAgICAgICAgICAgICAgICBtLnR4ID0gcGEgKiB4ICsgcGIgKiB5ICsgcGFyZW50Lm1hdHJpeC50eDtcclxuICAgICAgICAgICAgICAgIG0udHkgPSBwYyAqIHggKyBwZCAqIHkgKyBwYXJlbnQubWF0cml4LnR5O1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRhdGEudHJhbnNmb3JtTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vcm1hbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb25ZID0gcm90YXRpb24gKyA5MCArIHNoZWFyWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uICsgc2hlYXJYKSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxiID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKHJvdGF0aW9uWSkgKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYyA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZCA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyb3RhdGlvblkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmEgPSBwYSAqIGxhICsgcGIgKiBsYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5jID0gcGEgKiBsYiArIHBiICogbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYiA9IHBjICogbGEgKyBwZCAqIGxjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmQgPSBwYyAqIGxiICsgcGQgKiBsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuVHJhbnNmb3JtTW9kZS5Pbmx5VHJhbnNsYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uWSA9IHJvdGF0aW9uICsgOTAgKyBzaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYSA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvbiArIHNoZWFyWCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYyA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyb3RhdGlvblkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmIgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb24gKyBzaGVhclgpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmQgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcocm90YXRpb25ZKSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vUm90YXRpb25PclJlZmxlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBwYSAqIHBhICsgcGMgKiBwYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID4gMC4wMDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5hYnMocGEgKiBwZCAtIHBiICogcGMpIC8gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhIC89IHRoaXMuc2tlbGV0b24uc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGMgLz0gdGhpcy5za2VsZXRvbi5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYiA9IHBjICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkID0gcGEgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJ4ID0gTWF0aC5hdGFuMihwYywgcGEpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJ4ID0gOTAgLSBNYXRoLmF0YW4yKHBkLCBwYikgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gcm90YXRpb24gKyBzaGVhclggLSBwcng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IHJvdGF0aW9uICsgc2hlYXJZIC0gcHJ4ICsgOTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYSA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyeCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYiA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhyeSkgKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYyA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyeCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZCA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhyeSkgKiBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYSA9IHBhICogbGEgLSBwYiAqIGxjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmMgPSBwYSAqIGxiIC0gcGIgKiBsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5iID0gcGMgKiBsYSArIHBkICogbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZCA9IHBjICogbGIgKyBwZCAqIGxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlT3JSZWZsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3MgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcocm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHphID0gKHBhICogY29zICsgcGIgKiBzaW4pIC8gc3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6YyA9IChwYyAqIGNvcyArIHBkICogc2luKSAvIHN5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGguc3FydCh6YSAqIHphICsgemMgKiB6Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID4gMC4wMDAwMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAxIC8gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgemEgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgemMgKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydCh6YSAqIHphICsgemMgKiB6Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEudHJhbnNmb3JtTW9kZSA9PSBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHBhICogcGQgLSBwYiAqIHBjIDwgMCkgIT0gKEJvbmUueURvd24gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnNrZWxldG9uLnNjYWxlWCA8IDAgIT0gdGhpcy5za2VsZXRvbi5zY2FsZVkgPiAwKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2tlbGV0b24uc2NhbGVYIDwgMCAhPSB0aGlzLnNrZWxldG9uLnNjYWxlWSA8IDApKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLlBJIC8gMiArIE1hdGguYXRhbjIoemMsIHphKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHpiID0gTWF0aC5jb3MocikgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgemQgPSBNYXRoLnNpbihyKSAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYSA9IGNvcmUuTWF0aFV0aWxzLmNvc0RlZyhzaGVhclgpICogc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGIgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcoOTAgKyBzaGVhclkpICogc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGMgPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcoc2hlYXJYKSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxkID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKDkwICsgc2hlYXJZKSAqIHNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hID0gemEgKiBsYSArIHpiICogbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYyA9IHphICogbGIgKyB6YiAqIGxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmIgPSB6YyAqIGxhICsgemQgKiBsYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kID0gemMgKiBsYiArIHpkICogbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG0uYSAqPSBzeDtcclxuICAgICAgICAgICAgICAgIG0uYyAqPSBzeDtcclxuICAgICAgICAgICAgICAgIG0uYiAqPSBzeTtcclxuICAgICAgICAgICAgICAgIG0uZCAqPSBzeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuc2V0VG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IGRhdGEueDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IGRhdGEueTtcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBkYXRhLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gZGF0YS5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWFyWCA9IGRhdGEuc2hlYXJYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclkgPSBkYXRhLnNoZWFyWTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuZ2V0V29ybGRSb3RhdGlvblggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLm1hdHJpeC5iLCB0aGlzLm1hdHJpeC5hKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuZ2V0V29ybGRSb3RhdGlvblkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLm1hdHJpeC5kLCB0aGlzLm1hdHJpeC5jKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUuZ2V0V29ybGRTY2FsZVggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChtLmEgKiBtLmEgKyBtLmMgKiBtLmMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS5nZXRXb3JsZFNjYWxlWSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KG0uYiAqIG0uYiArIG0uZCAqIG0uZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpZWRWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5heCA9IG0udHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5heSA9IG0udHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcm90YXRpb24gPSBNYXRoLmF0YW4yKG0uYiwgbS5hKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVggPSBNYXRoLnNxcnQobS5hICogbS5hICsgbS5iICogbS5iKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVkgPSBNYXRoLnNxcnQobS5jICogbS5jICsgbS5kICogbS5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzaGVhclggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWSA9IE1hdGguYXRhbjIobS5hICogbS5jICsgbS5iICogbS5kLCBtLmEgKiBtLmQgLSBtLmIgKiBtLmMpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwbSA9IHBhcmVudC5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGlkID0gMSAvIChwbS5hICogcG0uZCAtIHBtLmIgKiBwbS5jKTtcclxuICAgICAgICAgICAgICAgIHZhciBkeCA9IG0udHggLSBwbS50eCwgZHkgPSBtLnR5IC0gcG0udHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF4ID0gKGR4ICogcG0uZCAqIHBpZCAtIGR5ICogcG0uYyAqIHBpZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF5ID0gKGR5ICogcG0uYSAqIHBpZCAtIGR4ICogcG0uYiAqIHBpZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWEgPSBwaWQgKiBwbS5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gcGlkICogcG0uYTtcclxuICAgICAgICAgICAgICAgIHZhciBpYiA9IHBpZCAqIHBtLmM7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWMgPSBwaWQgKiBwbS5iO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhID0gaWEgKiBtLmEgLSBpYiAqIG0uYjtcclxuICAgICAgICAgICAgICAgIHZhciByYiA9IGlhICogbS5jIC0gaWIgKiBtLmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmMgPSBpZCAqIG0uYiAtIGljICogbS5hO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJkID0gaWQgKiBtLmQgLSBpYyAqIG0uYztcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNoZWFyWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVggPSBNYXRoLnNxcnQocmEgKiByYSArIHJjICogcmMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXNjYWxlWCA+IDAuMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQgPSByYSAqIHJkIC0gcmIgKiByYztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzY2FsZVkgPSBkZXQgLyB0aGlzLmFzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2hlYXJZID0gTWF0aC5hdGFuMihyYSAqIHJiICsgcmMgKiByZCwgZGV0KSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyb3RhdGlvbiA9IE1hdGguYXRhbjIocmMsIHJhKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNjYWxlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc2NhbGVZID0gTWF0aC5zcXJ0KHJiICogcmIgKyByZCAqIHJkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzaGVhclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJvdGF0aW9uID0gOTAgLSBNYXRoLmF0YW4yKHJkLCByYikgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLndvcmxkVG9Mb2NhbCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gbS5hLCBiID0gbS5jLCBjID0gbS5iLCBkID0gbS5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGludkRldCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHdvcmxkLnggLSBtLnR4LCB5ID0gd29ybGQueSAtIG0udHk7XHJcbiAgICAgICAgICAgICAgICB3b3JsZC54ID0gKHggKiBkICogaW52RGV0IC0geSAqIGIgKiBpbnZEZXQpO1xyXG4gICAgICAgICAgICAgICAgd29ybGQueSA9ICh5ICogYSAqIGludkRldCAtIHggKiBjICogaW52RGV0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JsZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUubG9jYWxUb1dvcmxkID0gZnVuY3Rpb24gKGxvY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBsb2NhbC54LCB5ID0gbG9jYWwueTtcclxuICAgICAgICAgICAgICAgIGxvY2FsLnggPSB4ICogbS5hICsgeSAqIG0uYyArIG0udHg7XHJcbiAgICAgICAgICAgICAgICBsb2NhbC55ID0geCAqIG0uYiArIHkgKiBtLmQgKyBtLnR5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCb25lLnByb3RvdHlwZS53b3JsZFRvTG9jYWxSb3RhdGlvbiA9IGZ1bmN0aW9uICh3b3JsZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gY29yZS5NYXRoVXRpbHMuc2luRGVnKHdvcmxkUm90YXRpb24pLCBjb3MgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcod29ybGRSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihtYXQuYSAqIHNpbiAtIG1hdC5iICogY29zLCBtYXQuZCAqIGNvcyAtIG1hdC5jICogc2luKSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS5wcm90b3R5cGUubG9jYWxUb1dvcmxkUm90YXRpb24gPSBmdW5jdGlvbiAobG9jYWxSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyhsb2NhbFJvdGF0aW9uKSwgY29zID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKGxvY2FsUm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoY29zICogbWF0LmIgKyBzaW4gKiBtYXQuZCwgY29zICogbWF0LmEgKyBzaW4gKiBtYXQuYykgKiBjb3JlLk1hdGhVdGlscy5yYWREZWc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJvbmUucHJvdG90eXBlLnJvdGF0ZVdvcmxkID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXQgPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gbWF0LmEsIGIgPSBtYXQuYywgYyA9IG1hdC5iLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gY29yZS5NYXRoVXRpbHMuY29zRGVnKGRlZ3JlZXMpLCBzaW4gPSBjb3JlLk1hdGhVdGlscy5zaW5EZWcoZGVncmVlcyk7XHJcbiAgICAgICAgICAgICAgICBtYXQuYSA9IGNvcyAqIGEgLSBzaW4gKiBjO1xyXG4gICAgICAgICAgICAgICAgbWF0LmMgPSBjb3MgKiBiIC0gc2luICogZDtcclxuICAgICAgICAgICAgICAgIG1hdC5iID0gc2luICogYSArIGNvcyAqIGM7XHJcbiAgICAgICAgICAgICAgICBtYXQuZCA9IHNpbiAqIGIgKyBjb3MgKiBkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWVkVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQm9uZS55RG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gQm9uZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQm9uZSA9IEJvbmU7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQm9uZURhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCb25lRGF0YShpbmRleCwgbmFtZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVhclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Nb2RlID0gVHJhbnNmb3JtTW9kZS5Ob3JtYWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW5SZXF1aXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IG11c3QgYmUgPj0gMC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBCb25lRGF0YTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQm9uZURhdGEgPSBCb25lRGF0YTtcclxuICAgICAgICB2YXIgVHJhbnNmb3JtTW9kZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFRyYW5zZm9ybU1vZGUpIHtcclxuICAgICAgICAgICAgVHJhbnNmb3JtTW9kZVtUcmFuc2Zvcm1Nb2RlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Nb2RlW1RyYW5zZm9ybU1vZGVbXCJPbmx5VHJhbnNsYXRpb25cIl0gPSAxXSA9IFwiT25seVRyYW5zbGF0aW9uXCI7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybU1vZGVbVHJhbnNmb3JtTW9kZVtcIk5vUm90YXRpb25PclJlZmxlY3Rpb25cIl0gPSAyXSA9IFwiTm9Sb3RhdGlvbk9yUmVmbGVjdGlvblwiO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Nb2RlW1RyYW5zZm9ybU1vZGVbXCJOb1NjYWxlXCJdID0gM10gPSBcIk5vU2NhbGVcIjtcclxuICAgICAgICAgICAgVHJhbnNmb3JtTW9kZVtUcmFuc2Zvcm1Nb2RlW1wiTm9TY2FsZU9yUmVmbGVjdGlvblwiXSA9IDRdID0gXCJOb1NjYWxlT3JSZWZsZWN0aW9uXCI7XHJcbiAgICAgICAgfSkoVHJhbnNmb3JtTW9kZSA9IGNvcmUuVHJhbnNmb3JtTW9kZSB8fCAoY29yZS5UcmFuc2Zvcm1Nb2RlID0ge30pKTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBDb25zdHJhaW50RGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbnN0cmFpbnREYXRhKG5hbWUsIG9yZGVyLCBza2luUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW5SZXF1aXJlZCA9IHNraW5SZXF1aXJlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RyYWludERhdGE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkNvbnN0cmFpbnREYXRhID0gQ29uc3RyYWludERhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudCh0aW1lLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5FdmVudCA9IEV2ZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEV2ZW50RGF0YSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEV2ZW50RGF0YShuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudERhdGE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLkV2ZW50RGF0YSA9IEV2ZW50RGF0YTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBJa0NvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBJa0NvbnN0cmFpbnQoZGF0YSwgc2tlbGV0b24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmVuZERpcmVjdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmV0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWl4ID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29mdG5lc3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbiBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXggPSBkYXRhLm1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29mdG5lc3MgPSBkYXRhLnNvZnRuZXNzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZW5kRGlyZWN0aW9uID0gZGF0YS5iZW5kRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyA9IGRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmV0Y2ggPSBkYXRhLnN0cmV0Y2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYm9uZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib25lcy5wdXNoKHNrZWxldG9uLmZpbmRCb25lKGRhdGEuYm9uZXNbaV0ubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBza2VsZXRvbi5maW5kQm9uZShkYXRhLnRhcmdldC5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBJa0NvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChib25lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkxKGJvbmVzWzBdLCB0YXJnZXQud29ybGRYLCB0YXJnZXQud29ybGRZLCB0aGlzLmNvbXByZXNzLCB0aGlzLnN0cmV0Y2gsIHRoaXMuZGF0YS51bmlmb3JtLCB0aGlzLm1peCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseTIoYm9uZXNbMF0sIGJvbmVzWzFdLCB0YXJnZXQud29ybGRYLCB0YXJnZXQud29ybGRZLCB0aGlzLmJlbmREaXJlY3Rpb24sIHRoaXMuc3RyZXRjaCwgdGhpcy5zb2Z0bmVzcywgdGhpcy5taXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50LnByb3RvdHlwZS5hcHBseTEgPSBmdW5jdGlvbiAoYm9uZSwgdGFyZ2V0WCwgdGFyZ2V0WSwgY29tcHJlc3MsIHN0cmV0Y2gsIHVuaWZvcm0sIGFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvbmUuYXBwbGllZFZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBib25lLnBhcmVudC5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGEgPSBwLmEsIHBiID0gcC5jLCBwYyA9IHAuYiwgcGQgPSBwLmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb25JSyA9IC1ib25lLmFzaGVhclggLSBib25lLmFyb3RhdGlvbiwgdHggPSAwLCB0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJvbmUuZGF0YS50cmFuc2Zvcm1Nb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuT25seVRyYW5zbGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRhcmdldFggLSBib25lLndvcmxkWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSB0YXJnZXRZIC0gYm9uZS53b3JsZFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vUm90YXRpb25PclJlZmxlY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5hYnMocGEgKiBwZCAtIHBiICogcGMpIC8gKHBhICogcGEgKyBwYyAqIHBjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhID0gcGEgLyBib25lLnNrZWxldG9uLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjID0gcGMgLyBib25lLnNrZWxldG9uLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGIgPSAtc2MgKiBzICogYm9uZS5za2VsZXRvbi5zY2FsZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkID0gc2EgKiBzICogYm9uZS5za2VsZXRvbi5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uSUsgKz0gTWF0aC5hdGFuMihzYywgc2EpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGFyZ2V0WCAtIHAudHgsIHkgPSB0YXJnZXRZIC0gcC50eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBwYSAqIHBkIC0gcGIgKiBwYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSAoeCAqIHBkIC0geSAqIHBiKSAvIGQgLSBib25lLmF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9ICh5ICogcGEgLSB4ICogcGMpIC8gZCAtIGJvbmUuYXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbklLICs9IE1hdGguYXRhbjIodHksIHR4KSAqIGNvcmUuTWF0aFV0aWxzLnJhZERlZztcclxuICAgICAgICAgICAgICAgIGlmIChib25lLmFzY2FsZVggPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uSUsgKz0gMTgwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uSUsgPiAxODApXHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb25JSyAtPSAzNjA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3RhdGlvbklLIDwgLTE4MClcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbklLICs9IDM2MDtcclxuICAgICAgICAgICAgICAgIHZhciBzeCA9IGJvbmUuYXNjYWxlWCwgc3kgPSBib25lLmFzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3MgfHwgc3RyZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYm9uZS5kYXRhLnRyYW5zZm9ybU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gdGFyZ2V0WCAtIGJvbmUud29ybGRYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSB0YXJnZXRZIC0gYm9uZS53b3JsZFk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYm9uZS5kYXRhLmxlbmd0aCAqIHN4LCBkZCA9IE1hdGguc3FydCh0eCAqIHR4ICsgdHkgKiB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb21wcmVzcyAmJiBkZCA8IGIpIHx8IChzdHJldGNoICYmIGRkID4gYikgJiYgYiA+IDAuMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IChkZCAvIGIgLSAxKSAqIGFscGhhICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ggKj0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuaWZvcm0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeSAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvbmUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKGJvbmUuYXgsIGJvbmUuYXksIGJvbmUuYXJvdGF0aW9uICsgcm90YXRpb25JSyAqIGFscGhhLCBzeCwgc3ksIGJvbmUuYXNoZWFyWCwgYm9uZS5hc2hlYXJZKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSWtDb25zdHJhaW50LnByb3RvdHlwZS5hcHBseTIgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdGFyZ2V0WCwgdGFyZ2V0WSwgYmVuZERpciwgc3RyZXRjaCwgc29mdG5lc3MsIGFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuYXBwbGllZFZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHggPSBwYXJlbnQuYXgsIHB5ID0gcGFyZW50LmF5LCBwc3ggPSBwYXJlbnQuYXNjYWxlWCwgc3ggPSBwc3gsIHBzeSA9IHBhcmVudC5hc2NhbGVZLCBjc3ggPSBjaGlsZC5hc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBtYXQgPSBwYXJlbnQubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgdmFyIG9zMSA9IDAsIG9zMiA9IDAsIHMyID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChwc3ggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHN4ID0gLXBzeDtcclxuICAgICAgICAgICAgICAgICAgICBvczEgPSAxODA7XHJcbiAgICAgICAgICAgICAgICAgICAgczIgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9zMSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgczIgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBzeSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwc3kgPSAtcHN5O1xyXG4gICAgICAgICAgICAgICAgICAgIHMyID0gLXMyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNzeCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjc3ggPSAtY3N4O1xyXG4gICAgICAgICAgICAgICAgICAgIG9zMiA9IDE4MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvczIgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gY2hpbGQuYXgsIGN5ID0gMCwgY3d4ID0gMCwgY3d5ID0gMCwgYSA9IHBtYXQuYSwgYiA9IHBtYXQuYywgYyA9IHBtYXQuYiwgZCA9IHBtYXQuZDtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gTWF0aC5hYnMocHN4IC0gcHN5KSA8PSAwLjAwMDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3d4ID0gYSAqIGN4ICsgcG1hdC50eDtcclxuICAgICAgICAgICAgICAgICAgICBjd3kgPSBjICogY3ggKyBwbWF0LnR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3kgPSBjaGlsZC5heTtcclxuICAgICAgICAgICAgICAgICAgICBjd3ggPSBhICogY3ggKyBiICogY3kgKyBwbWF0LnR4O1xyXG4gICAgICAgICAgICAgICAgICAgIGN3eSA9IGMgKiBjeCArIGQgKiBjeSArIHBtYXQudHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHAgPSBwYXJlbnQucGFyZW50Lm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIGEgPSBwcC5hO1xyXG4gICAgICAgICAgICAgICAgYiA9IHBwLmM7XHJcbiAgICAgICAgICAgICAgICBjID0gcHAuYjtcclxuICAgICAgICAgICAgICAgIGQgPSBwcC5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gMSAvIChhICogZCAtIGIgKiBjKSwgeCA9IGN3eCAtIHBwLnR4LCB5ID0gY3d5IC0gcHAudHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSAoeCAqIGQgLSB5ICogYikgKiBpZCAtIHB4LCBkeSA9ICh5ICogYSAtIHggKiBjKSAqIGlkIC0gcHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbDEgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCBsMiA9IGNoaWxkLmRhdGEubGVuZ3RoICogY3N4LCBhMSwgYTI7XHJcbiAgICAgICAgICAgICAgICBpZiAobDEgPCAwLjAwMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5MShwYXJlbnQsIHRhcmdldFgsIHRhcmdldFksIGZhbHNlLCBzdHJldGNoLCBmYWxzZSwgYWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aChjeCwgY3ksIDAsIGNoaWxkLmFzY2FsZVgsIGNoaWxkLmFzY2FsZVksIGNoaWxkLmFzaGVhclgsIGNoaWxkLmFzaGVhclkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHggPSB0YXJnZXRYIC0gcHAudHg7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0WSAtIHBwLnR5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHR4ID0gKHggKiBkIC0geSAqIGIpICogaWQgLSBweCwgdHkgPSAoeSAqIGEgLSB4ICogYykgKiBpZCAtIHB5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRkID0gdHggKiB0eCArIHR5ICogdHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29mdG5lc3MgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvZnRuZXNzICo9IHBzeCAqIChjc3ggKyAxKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRkID0gTWF0aC5zcXJ0KGRkKSwgc2QgPSB0ZCAtIGwxIC0gbDIgKiBwc3ggKyBzb2Z0bmVzcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2QgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTWF0aC5taW4oMSwgc2QgLyAoc29mdG5lc3MgKiAyKSkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gKHNkIC0gc29mdG5lc3MgKiAoMSAtIHAgKiBwKSkgLyB0ZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHggLT0gcCAqIHR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eSAtPSBwICogdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkID0gdHggKiB0eCArIHR5ICogdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0ZXI6IGlmICh1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbDIgKj0gcHN4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3MgPSAoZGQgLSBsMSAqIGwxIC0gbDIgKiBsMikgLyAoMiAqIGwxICogbDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3MgPCAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29zID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29zID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4ICo9IChNYXRoLnNxcnQoZGQpIC8gKGwxICsgbDIpIC0gMSkgKiBhbHBoYSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGEyID0gTWF0aC5hY29zKGNvcykgKiBiZW5kRGlyO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBsMSArIGwyICogY29zO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBsMiAqIE1hdGguc2luKGEyKTtcclxuICAgICAgICAgICAgICAgICAgICBhMSA9IE1hdGguYXRhbjIodHkgKiBhIC0gdHggKiBiLCB0eCAqIGEgKyB0eSAqIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHBzeCAqIGwyO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBwc3kgKiBsMjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWEgPSBhICogYSwgYmIgPSBiICogYiwgdGEgPSBNYXRoLmF0YW4yKHR5LCB0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGJiICogbDEgKiBsMSArIGFhICogZGQgLSBhYSAqIGJiO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjMSA9IC0yICogYmIgKiBsMSwgYzIgPSBiYiAtIGFhO1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBjMSAqIGMxIC0gNCAqIGMyICogYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gTWF0aC5zcXJ0KGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYzEgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IC1xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gLShjMSArIHEpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIwID0gcSAvIGMyLCByMSA9IGMgLyBxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGguYWJzKHIwKSA8IE1hdGguYWJzKHIxKSA/IHIwIDogcjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyICogciA8PSBkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguc3FydChkZCAtIHIgKiByKSAqIGJlbmREaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMSA9IHRhIC0gTWF0aC5hdGFuMih5LCByKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gTWF0aC5hdGFuMih5IC8gcHN5LCAociAtIGwxKSAvIHBzeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluQW5nbGUgPSBjb3JlLk1hdGhVdGlscy5QSSwgbWluWCA9IGwxIC0gYSwgbWluRGlzdCA9IG1pblggKiBtaW5YLCBtaW5ZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4QW5nbGUgPSAwLCBtYXhYID0gbDEgKyBhLCBtYXhEaXN0ID0gbWF4WCAqIG1heFgsIG1heFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAtYSAqIGwxIC8gKGFhIC0gYmIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID49IC0xICYmIGMgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gTWF0aC5hY29zKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYSAqIE1hdGguY29zKGMpICsgbDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBiICogTWF0aC5zaW4oYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB4ICogeCArIHkgKiB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IG1pbkRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFuZ2xlID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5ZID0geTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IG1heERpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEFuZ2xlID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0geTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGQgPD0gKG1pbkRpc3QgKyBtYXhEaXN0KSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYTEgPSB0YSAtIE1hdGguYXRhbjIobWluWSAqIGJlbmREaXIsIG1pblgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhMiA9IG1pbkFuZ2xlICogYmVuZERpcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGExID0gdGEgLSBNYXRoLmF0YW4yKG1heFkgKiBiZW5kRGlyLCBtYXhYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBtYXhBbmdsZSAqIGJlbmREaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9zID0gTWF0aC5hdGFuMihjeSwgY3gpICogczI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBwYXJlbnQuYXJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYTEgPSAoYTEgLSBvcykgKiBjb3JlLk1hdGhVdGlscy5yYWREZWcgKyBvczEgLSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChhMSA+IDE4MClcclxuICAgICAgICAgICAgICAgICAgICBhMSAtPSAzNjA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhMSA8IC0xODApXHJcbiAgICAgICAgICAgICAgICAgICAgYTEgKz0gMzYwO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZVdvcmxkVHJhbnNmb3JtV2l0aChweCwgcHksIHJvdGF0aW9uICsgYTEgKiBhbHBoYSwgc3gsIHBhcmVudC5hc2NhbGVZLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gY2hpbGQuYXJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYTIgPSAoKGEyICsgb3MpICogY29yZS5NYXRoVXRpbHMucmFkRGVnIC0gY2hpbGQuYXNoZWFyWCkgKiBzMiArIG9zMiAtIHJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEyID4gMTgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGEyIC09IDM2MDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEyIDwgLTE4MClcclxuICAgICAgICAgICAgICAgICAgICBhMiArPSAzNjA7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVXb3JsZFRyYW5zZm9ybVdpdGgoY3gsIGN5LCByb3RhdGlvbiArIGEyICogYWxwaGEsIGNoaWxkLmFzY2FsZVgsIGNoaWxkLmFzY2FsZVksIGNoaWxkLmFzaGVhclgsIGNoaWxkLmFzaGVhclkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSWtDb25zdHJhaW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ja0NvbnN0cmFpbnQgPSBJa0NvbnN0cmFpbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgSWtDb25zdHJhaW50RGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhJa0NvbnN0cmFpbnREYXRhLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBJa0NvbnN0cmFpbnREYXRhKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIDAsIGZhbHNlKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJlbmREaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcHJlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0cmV0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVuaWZvcm0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1peCA9IDE7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zb2Z0bmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIElrQ29uc3RyYWludERhdGE7XHJcbiAgICAgICAgfShjb3JlLkNvbnN0cmFpbnREYXRhKSk7XHJcbiAgICAgICAgY29yZS5Ja0NvbnN0cmFpbnREYXRhID0gSWtDb25zdHJhaW50RGF0YTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBQYXRoQ29uc3RyYWludCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhdGhDb25zdHJhaW50KGRhdGEsIHNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VydmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5ib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib25lcy5wdXNoKHNrZWxldG9uLmZpbmRCb25lKGRhdGEuYm9uZXNbaV0ubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBza2VsZXRvbi5maW5kU2xvdChkYXRhLnRhcmdldC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjaW5nID0gZGF0YS5zcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVNaXggPSBkYXRhLnJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLnRhcmdldC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShhdHRhY2htZW50IGluc3RhbmNlb2YgY29yZS5QYXRoQXR0YWNobWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZU1peCA9IHRoaXMucm90YXRlTWl4LCB0cmFuc2xhdGVNaXggPSB0aGlzLnRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGUgPSB0cmFuc2xhdGVNaXggPiAwLCByb3RhdGUgPSByb3RhdGVNaXggPiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2xhdGUgJiYgIXJvdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjaW5nTW9kZSA9IGRhdGEuc3BhY2luZ01vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoU3BhY2luZyA9IHNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZU1vZGUgPSBkYXRhLnJvdGF0ZU1vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFuZ2VudHMgPSByb3RhdGVNb2RlID09IGNvcmUuUm90YXRlTW9kZS5UYW5nZW50LCBzY2FsZSA9IHJvdGF0ZU1vZGUgPT0gY29yZS5Sb3RhdGVNb2RlLkNoYWluU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZUNvdW50ID0gdGhpcy5ib25lcy5sZW5ndGgsIHNwYWNlc0NvdW50ID0gdGFuZ2VudHMgPyBib25lQ291bnQgOiBib25lQ291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLnNwYWNlcywgc3BhY2VzQ291bnQpLCBsZW5ndGhzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlIHx8IGxlbmd0aFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLmxlbmd0aHMsIGJvbmVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzcGFjZXNDb3VudCAtIDE7IGkgPCBuOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dXBMZW5ndGggPSBib25lLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dXBMZW5ndGggPCBQYXRoQ29uc3RyYWludC5lcHNpbG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbKytpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHNldHVwTGVuZ3RoICogYm9uZS5tYXRyaXguYSwgeSA9IHNldHVwTGVuZ3RoICogYm9uZS5tYXRyaXguYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzW2ldID0gbGVuZ3RoXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbKytpXSA9IChsZW5ndGhTcGFjaW5nID8gc2V0dXBMZW5ndGggKyBzcGFjaW5nIDogc3BhY2luZykgKiBsZW5ndGhfMSAvIHNldHVwTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzcGFjZXNDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbaV0gPSBzcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuY29tcHV0ZVdvcmxkUG9zaXRpb25zKGF0dGFjaG1lbnQsIHNwYWNlc0NvdW50LCB0YW5nZW50cywgZGF0YS5wb3NpdGlvbk1vZGUgPT0gY29yZS5Qb3NpdGlvbk1vZGUuUGVyY2VudCwgc3BhY2luZ01vZGUgPT0gY29yZS5TcGFjaW5nTW9kZS5QZXJjZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lWCA9IHBvc2l0aW9uc1swXSwgYm9uZVkgPSBwb3NpdGlvbnNbMV0sIG9mZnNldFJvdGF0aW9uID0gZGF0YS5vZmZzZXRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciB0aXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRSb3RhdGlvbiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRpcCA9IHJvdGF0ZU1vZGUgPT0gY29yZS5Sb3RhdGVNb2RlLkNoYWluO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnRhcmdldC5ib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSb3RhdGlvbiAqPSBwLmEgKiBwLmQgLSBwLmIgKiBwLmMgPiAwID8gY29yZS5NYXRoVXRpbHMuZGVnUmFkIDogLWNvcmUuTWF0aFV0aWxzLmRlZ1JhZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gMzsgaSA8IGJvbmVDb3VudDsgaSsrLCBwICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICBtYXQudHggKz0gKGJvbmVYIC0gbWF0LnR4KSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICBtYXQudHkgKz0gKGJvbmVZIC0gbWF0LnR5KSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBvc2l0aW9uc1twXSwgeSA9IHBvc2l0aW9uc1twICsgMV0sIGR4ID0geCAtIGJvbmVYLCBkeSA9IHkgLSBib25lWTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8yID0gbGVuZ3Roc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aF8yICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLyBsZW5ndGhfMiAtIDEpICogcm90YXRlTWl4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5hICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXQuYiAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVYID0geDtcclxuICAgICAgICAgICAgICAgICAgICBib25lWSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdC5hLCBiID0gbWF0LmMsIGMgPSBtYXQuYiwgZCA9IG1hdC5kLCByID0gMCwgY29zID0gMCwgc2luID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHBvc2l0aW9uc1twIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNwYWNlc1tpICsgMV0gPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBwb3NpdGlvbnNbcCArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gTWF0aC5hdGFuMihkeSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByIC09IE1hdGguYXRhbjIoYywgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzMgPSBib25lLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZVggKz0gKGxlbmd0aF8zICogKGNvcyAqIGEgLSBzaW4gKiBjKSAtIGR4KSAqIHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbmVZICs9IChsZW5ndGhfMyAqIChzaW4gKiBhICsgY29zICogYykgLSBkeSkgKiByb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IG9mZnNldFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIC09IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociA8IC1jb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByICo9IHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3Mocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYSA9IGNvcyAqIGEgLSBzaW4gKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYyA9IGNvcyAqIGIgLSBzaW4gKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYiA9IHNpbiAqIGEgKyBjb3MgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuZCA9IHNpbiAqIGIgKyBjb3MgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib25lLmFwcGxpZWRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkUG9zaXRpb25zID0gZnVuY3Rpb24gKHBhdGgsIHNwYWNlc0NvdW50LCB0YW5nZW50cywgcGVyY2VudFBvc2l0aW9uLCBwZXJjZW50U3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSB0aGlzLnNwYWNlcywgb3V0ID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy5wb3NpdGlvbnMsIHNwYWNlc0NvdW50ICogMyArIDIpLCB3b3JsZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VkID0gcGF0aC5jbG9zZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXNMZW5ndGggPSBwYXRoLndvcmxkVmVydGljZXNMZW5ndGgsIGN1cnZlQ291bnQgPSB2ZXJ0aWNlc0xlbmd0aCAvIDYsIHByZXZDdXJ2ZSA9IFBhdGhDb25zdHJhaW50Lk5PTkU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGguY29uc3RhbnRTcGVlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhzID0gcGF0aC5sZW5ndGhzO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlQ291bnQgLT0gY2xvc2VkID8gMSA6IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhMZW5ndGhfMSA9IGxlbmd0aHNbY3VydmVDb3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnRQb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKj0gcGF0aExlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjZW50U3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbaV0gKj0gcGF0aExlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3b3JsZCA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMud29ybGQsIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvID0gMCwgY3VydmUgPSAwOyBpIDwgc3BhY2VzQ291bnQ7IGkrKywgbyArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHNwYWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgJT0gcGF0aExlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gcGF0aExlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkN1cnZlICE9IFBhdGhDb25zdHJhaW50LkJFRk9SRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDdXJ2ZSA9IFBhdGhDb25zdHJhaW50LkJFRk9SRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgMiwgNCwgd29ybGQsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRCZWZvcmVQb3NpdGlvbihwLCB3b3JsZCwgMCwgb3V0LCBvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgPiBwYXRoTGVuZ3RoXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q3VydmUgIT0gUGF0aENvbnN0cmFpbnQuQUZURVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q3VydmUgPSBQYXRoQ29uc3RyYWludC5BRlRFUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgdmVydGljZXNMZW5ndGggLSA2LCA0LCB3b3JsZCwgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFmdGVyUG9zaXRpb24ocCAtIHBhdGhMZW5ndGhfMSwgd29ybGQsIDAsIG91dCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDs7IGN1cnZlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfNCA9IGxlbmd0aHNbY3VydmVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPiBsZW5ndGhfNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgLz0gbGVuZ3RoXzQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGxlbmd0aHNbY3VydmUgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gKHAgLSBwcmV2KSAvIChsZW5ndGhfNCAtIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnZlICE9IHByZXZDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkN1cnZlID0gY3VydmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkICYmIGN1cnZlID09IGN1cnZlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgdmVydGljZXNMZW5ndGggLSA0LCA0LCB3b3JsZCwgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb21wdXRlV29ybGRWZXJ0aWNlcyh0YXJnZXQsIDAsIDQsIHdvcmxkLCA0LCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgY3VydmUgKiA2ICsgMiwgOCwgd29ybGQsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VydmVQb3NpdGlvbihwLCB3b3JsZFswXSwgd29ybGRbMV0sIHdvcmxkWzJdLCB3b3JsZFszXSwgd29ybGRbNF0sIHdvcmxkWzVdLCB3b3JsZFs2XSwgd29ybGRbN10sIG91dCwgbywgdGFuZ2VudHMgfHwgKGkgPiAwICYmIHNwYWNlID09IDApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCArPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy53b3JsZCwgdmVydGljZXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAyLCB2ZXJ0aWNlc0xlbmd0aCAtIDQsIHdvcmxkLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHRhcmdldCwgMCwgMiwgd29ybGQsIHZlcnRpY2VzTGVuZ3RoIC0gNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGljZXNMZW5ndGggLSAyXSA9IHdvcmxkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRpY2VzTGVuZ3RoIC0gMV0gPSB3b3JsZFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlQ291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCAtPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUodGhpcy53b3JsZCwgdmVydGljZXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGguY29tcHV0ZVdvcmxkVmVydGljZXModGFyZ2V0LCAyLCB2ZXJ0aWNlc0xlbmd0aCwgd29ybGQsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnZlcyA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRoaXMuY3VydmVzLCBjdXJ2ZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IHdvcmxkWzBdLCB5MSA9IHdvcmxkWzFdLCBjeDEgPSAwLCBjeTEgPSAwLCBjeDIgPSAwLCBjeTIgPSAwLCB4MiA9IDAsIHkyID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB0bXB4ID0gMCwgdG1weSA9IDAsIGRkZGZ4ID0gMCwgZGRkZnkgPSAwLCBkZGZ4ID0gMCwgZGRmeSA9IDAsIGRmeCA9IDAsIGRmeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdyA9IDI7IGkgPCBjdXJ2ZUNvdW50OyBpKyssIHcgKz0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN4MSA9IHdvcmxkW3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGN5MSA9IHdvcmxkW3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjeDIgPSB3b3JsZFt3ICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgY3kyID0gd29ybGRbdyArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHgyID0gd29ybGRbdyArIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyID0gd29ybGRbdyArIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcHggPSAoeDEgLSBjeDEgKiAyICsgY3gyKSAqIDAuMTg3NTtcclxuICAgICAgICAgICAgICAgICAgICB0bXB5ID0gKHkxIC0gY3kxICogMiArIGN5MikgKiAwLjE4NzU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRkZnggPSAoKGN4MSAtIGN4MikgKiAzIC0geDEgKyB4MikgKiAwLjA5Mzc1O1xyXG4gICAgICAgICAgICAgICAgICAgIGRkZGZ5ID0gKChjeTEgLSBjeTIpICogMyAtIHkxICsgeTIpICogMC4wOTM3NTtcclxuICAgICAgICAgICAgICAgICAgICBkZGZ4ID0gdG1weCAqIDIgKyBkZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICBkZGZ5ID0gdG1weSAqIDIgKyBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICBkZnggPSAoY3gxIC0geDEpICogMC43NSArIHRtcHggKyBkZGRmeCAqIDAuMTY2NjY2Njc7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ5ID0gKGN5MSAtIHkxKSAqIDAuNzUgKyB0bXB5ICsgZGRkZnkgKiAwLjE2NjY2NjY3O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ4ICs9IGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ5ICs9IGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGRmeCArPSBkZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICBkZGZ5ICs9IGRkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ4ICs9IGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgZGZ5ICs9IGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aCArPSBNYXRoLnNxcnQoZGZ4ICogZGZ4ICsgZGZ5ICogZGZ5KTtcclxuICAgICAgICAgICAgICAgICAgICBkZnggKz0gZGRmeCArIGRkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5ICsgZGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aCArPSBNYXRoLnNxcnQoZGZ4ICogZGZ4ICsgZGZ5ICogZGZ5KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZXNbaV0gPSBwYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHgxID0geDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50UG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKj0gcGF0aExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50U3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2VzQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzW2ldICo9IHBhdGhMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnZlTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvID0gMCwgY3VydmUgPSAwLCBzZWdtZW50ID0gMDsgaSA8IHNwYWNlc0NvdW50OyBpKyssIG8gKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHNwYWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCAlPSBwYXRoTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwICs9IHBhdGhMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRCZWZvcmVQb3NpdGlvbihwLCB3b3JsZCwgMCwgb3V0LCBvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgPiBwYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWZ0ZXJQb3NpdGlvbihwIC0gcGF0aExlbmd0aCwgd29ybGQsIHZlcnRpY2VzTGVuZ3RoIC0gNCwgb3V0LCBvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzsgY3VydmUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzUgPSBjdXJ2ZXNbY3VydmVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA+IGxlbmd0aF81KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCAvPSBsZW5ndGhfNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGN1cnZlc1tjdXJ2ZSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IChwIC0gcHJldikgLyAobGVuZ3RoXzUgLSBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnZlICE9IHByZXZDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q3VydmUgPSBjdXJ2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlpID0gY3VydmUgKiA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHdvcmxkW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB3b3JsZFtpaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDEgPSB3b3JsZFtpaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTEgPSB3b3JsZFtpaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDIgPSB3b3JsZFtpaSArIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTIgPSB3b3JsZFtpaSArIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHdvcmxkW2lpICsgNl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gd29ybGRbaWkgKyA3XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1weCA9ICh4MSAtIGN4MSAqIDIgKyBjeDIpICogMC4wMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1weSA9ICh5MSAtIGN5MSAqIDIgKyBjeTIpICogMC4wMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGRkZnggPSAoKGN4MSAtIGN4MikgKiAzIC0geDEgKyB4MikgKiAwLjAwNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGRkZnkgPSAoKGN5MSAtIGN5MikgKiAzIC0geTEgKyB5MikgKiAwLjAwNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGRmeCA9IHRtcHggKiAyICsgZGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkZnkgPSB0bXB5ICogMiArIGRkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZnggPSAoY3gxIC0geDEpICogMC4zICsgdG1weCArIGRkZGZ4ICogMC4xNjY2NjY2NztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZ5ID0gKGN5MSAtIHkxKSAqIDAuMyArIHRtcHkgKyBkZGRmeSAqIDAuMTY2NjY2Njc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlTGVuZ3RoID0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzWzBdID0gY3VydmVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAxOyBpaSA8IDg7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmeCArPSBkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZ5ICs9IGRkZnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZGZ4ICs9IGRkZGZ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGRmeSArPSBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlTGVuZ3RoICs9IE1hdGguc3FydChkZnggKiBkZnggKyBkZnkgKiBkZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNbaWldID0gY3VydmVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZ4ICs9IGRkZng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmeSArPSBkZGZ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZUxlbmd0aCArPSBNYXRoLnNxcnQoZGZ4ICogZGZ4ICsgZGZ5ICogZGZ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNbOF0gPSBjdXJ2ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZ4ICs9IGRkZnggKyBkZGRmeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZ5ICs9IGRkZnkgKyBkZGRmeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVMZW5ndGggKz0gTWF0aC5zcXJ0KGRmeCAqIGRmeCArIGRmeSAqIGRmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzWzldID0gY3VydmVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwICo9IGN1cnZlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzsgc2VnbWVudCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfNiA9IHNlZ21lbnRzW3NlZ21lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA+IGxlbmd0aF82KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwIC89IGxlbmd0aF82O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gc2VnbWVudHNbc2VnbWVudCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHNlZ21lbnQgKyAocCAtIHByZXYpIC8gKGxlbmd0aF82IC0gcHJldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VydmVQb3NpdGlvbihwICogMC4xLCB4MSwgeTEsIGN4MSwgY3kxLCBjeDIsIGN5MiwgeDIsIHkyLCBvdXQsIG8sIHRhbmdlbnRzIHx8IChpID4gMCAmJiBzcGFjZSA9PSAwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuYWRkQmVmb3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocCwgdGVtcCwgaSwgb3V0LCBvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSB0ZW1wW2ldLCB5MSA9IHRlbXBbaSArIDFdLCBkeCA9IHRlbXBbaSArIDJdIC0geDEsIGR5ID0gdGVtcFtpICsgM10gLSB5MSwgciA9IE1hdGguYXRhbjIoZHksIGR4KTtcclxuICAgICAgICAgICAgICAgIG91dFtvXSA9IHgxICsgcCAqIE1hdGguY29zKHIpO1xyXG4gICAgICAgICAgICAgICAgb3V0W28gKyAxXSA9IHkxICsgcCAqIE1hdGguc2luKHIpO1xyXG4gICAgICAgICAgICAgICAgb3V0W28gKyAyXSA9IHI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhdGhDb25zdHJhaW50LnByb3RvdHlwZS5hZGRBZnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHAsIHRlbXAsIGksIG91dCwgbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gdGVtcFtpICsgMl0sIHkxID0gdGVtcFtpICsgM10sIGR4ID0geDEgLSB0ZW1wW2ldLCBkeSA9IHkxIC0gdGVtcFtpICsgMV0sIHIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XHJcbiAgICAgICAgICAgICAgICBvdXRbb10gPSB4MSArIHAgKiBNYXRoLmNvcyhyKTtcclxuICAgICAgICAgICAgICAgIG91dFtvICsgMV0gPSB5MSArIHAgKiBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgICAgIG91dFtvICsgMl0gPSByO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5wcm90b3R5cGUuYWRkQ3VydmVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwLCB4MSwgeTEsIGN4MSwgY3kxLCBjeDIsIGN5MiwgeDIsIHkyLCBvdXQsIG8sIHRhbmdlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocCA9PSAwIHx8IGlzTmFOKHApKVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSAwLjAwMDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSBwICogcCwgdHR0ID0gdHQgKiBwLCB1ID0gMSAtIHAsIHV1ID0gdSAqIHUsIHV1dSA9IHV1ICogdTtcclxuICAgICAgICAgICAgICAgIHZhciB1dCA9IHUgKiBwLCB1dDMgPSB1dCAqIDMsIHV1dDMgPSB1ICogdXQzLCB1dHQzID0gdXQzICogcDtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0geDEgKiB1dXUgKyBjeDEgKiB1dXQzICsgY3gyICogdXR0MyArIHgyICogdHR0LCB5ID0geTEgKiB1dXUgKyBjeTEgKiB1dXQzICsgY3kyICogdXR0MyArIHkyICogdHR0O1xyXG4gICAgICAgICAgICAgICAgb3V0W29dID0geDtcclxuICAgICAgICAgICAgICAgIG91dFtvICsgMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dFtvICsgMl0gPSBNYXRoLmF0YW4yKHkgLSAoeTEgKiB1dSArIGN5MSAqIHV0ICogMiArIGN5MiAqIHR0KSwgeCAtICh4MSAqIHV1ICsgY3gxICogdXQgKiAyICsgY3gyICogdHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQuTk9ORSA9IC0xO1xyXG4gICAgICAgICAgICBQYXRoQ29uc3RyYWludC5CRUZPUkUgPSAtMjtcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQuQUZURVIgPSAtMztcclxuICAgICAgICAgICAgUGF0aENvbnN0cmFpbnQuZXBzaWxvbiA9IDAuMDAwMDE7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXRoQ29uc3RyYWludDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuUGF0aENvbnN0cmFpbnQgPSBQYXRoQ29uc3RyYWludDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBQYXRoQ29uc3RyYWludERhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUGF0aENvbnN0cmFpbnREYXRhLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoQ29uc3RyYWludERhdGEobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgMCwgZmFsc2UpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQYXRoQ29uc3RyYWludERhdGE7XHJcbiAgICAgICAgfShjb3JlLkNvbnN0cmFpbnREYXRhKSk7XHJcbiAgICAgICAgY29yZS5QYXRoQ29uc3RyYWludERhdGEgPSBQYXRoQ29uc3RyYWludERhdGE7XHJcbiAgICAgICAgdmFyIFBvc2l0aW9uTW9kZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFBvc2l0aW9uTW9kZSkge1xyXG4gICAgICAgICAgICBQb3NpdGlvbk1vZGVbUG9zaXRpb25Nb2RlW1wiRml4ZWRcIl0gPSAwXSA9IFwiRml4ZWRcIjtcclxuICAgICAgICAgICAgUG9zaXRpb25Nb2RlW1Bvc2l0aW9uTW9kZVtcIlBlcmNlbnRcIl0gPSAxXSA9IFwiUGVyY2VudFwiO1xyXG4gICAgICAgIH0pKFBvc2l0aW9uTW9kZSA9IGNvcmUuUG9zaXRpb25Nb2RlIHx8IChjb3JlLlBvc2l0aW9uTW9kZSA9IHt9KSk7XHJcbiAgICAgICAgdmFyIFNwYWNpbmdNb2RlO1xyXG4gICAgICAgIChmdW5jdGlvbiAoU3BhY2luZ01vZGUpIHtcclxuICAgICAgICAgICAgU3BhY2luZ01vZGVbU3BhY2luZ01vZGVbXCJMZW5ndGhcIl0gPSAwXSA9IFwiTGVuZ3RoXCI7XHJcbiAgICAgICAgICAgIFNwYWNpbmdNb2RlW1NwYWNpbmdNb2RlW1wiRml4ZWRcIl0gPSAxXSA9IFwiRml4ZWRcIjtcclxuICAgICAgICAgICAgU3BhY2luZ01vZGVbU3BhY2luZ01vZGVbXCJQZXJjZW50XCJdID0gMl0gPSBcIlBlcmNlbnRcIjtcclxuICAgICAgICB9KShTcGFjaW5nTW9kZSA9IGNvcmUuU3BhY2luZ01vZGUgfHwgKGNvcmUuU3BhY2luZ01vZGUgPSB7fSkpO1xyXG4gICAgICAgIHZhciBSb3RhdGVNb2RlO1xyXG4gICAgICAgIChmdW5jdGlvbiAoUm90YXRlTW9kZSkge1xyXG4gICAgICAgICAgICBSb3RhdGVNb2RlW1JvdGF0ZU1vZGVbXCJUYW5nZW50XCJdID0gMF0gPSBcIlRhbmdlbnRcIjtcclxuICAgICAgICAgICAgUm90YXRlTW9kZVtSb3RhdGVNb2RlW1wiQ2hhaW5cIl0gPSAxXSA9IFwiQ2hhaW5cIjtcclxuICAgICAgICAgICAgUm90YXRlTW9kZVtSb3RhdGVNb2RlW1wiQ2hhaW5TY2FsZVwiXSA9IDJdID0gXCJDaGFpblNjYWxlXCI7XHJcbiAgICAgICAgfSkoUm90YXRlTW9kZSA9IGNvcmUuUm90YXRlTW9kZSB8fCAoY29yZS5Sb3RhdGVNb2RlID0ge30pKTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTa2VsZXRvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNrZWxldG9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlUmVzZXQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmJvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVEYXRhID0gZGF0YS5ib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZURhdGEucGFyZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUgPSBuZXcgY29yZS5Cb25lKGJvbmVEYXRhLCB0aGlzLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5ib25lc1tib25lRGF0YS5wYXJlbnQuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lID0gbmV3IGNvcmUuQm9uZShib25lRGF0YSwgdGhpcywgcGFyZW50XzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS5jaGlsZHJlbi5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvbmVzLnB1c2goYm9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdPcmRlciA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3REYXRhID0gZGF0YS5zbG90c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbc2xvdERhdGEuYm9uZURhdGEuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbmV3IGNvcmUuU2xvdChzbG90RGF0YSwgYm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG90cy5wdXNoKHNsb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd09yZGVyLnB1c2goc2xvdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlrQ29uc3RyYWludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5pa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlrQ29uc3RyYWludERhdGEgPSBkYXRhLmlrQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pa0NvbnN0cmFpbnRzLnB1c2gobmV3IGNvcmUuSWtDb25zdHJhaW50KGlrQ29uc3RyYWludERhdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS50cmFuc2Zvcm1Db25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1Db25zdHJhaW50RGF0YSA9IGRhdGEudHJhbnNmb3JtQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cy5wdXNoKG5ldyBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnQodHJhbnNmb3JtQ29uc3RyYWludERhdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aENvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEucGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhDb25zdHJhaW50RGF0YSA9IGRhdGEucGF0aENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aENvbnN0cmFpbnRzLnB1c2gobmV3IGNvcmUuUGF0aENvbnN0cmFpbnQocGF0aENvbnN0cmFpbnREYXRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gbmV3IGNvcmUuQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNhY2hlID0gdGhpcy5fdXBkYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWNoZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZVJlc2V0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUuc29ydGVkID0gYm9uZS5kYXRhLnNraW5SZXF1aXJlZDtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFjdGl2ZSA9ICFib25lLnNvcnRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNraW4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBza2luQm9uZXMgPSB0aGlzLnNraW4uYm9uZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnNraW4uYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1tza2luQm9uZXNbaV0uaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLnNvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9uZSA9IGJvbmUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChib25lICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUNvbnN0cmFpbnRzID0gdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIHZhciBpa0NvdW50ID0gaWtDb25zdHJhaW50cy5sZW5ndGgsIHRyYW5zZm9ybUNvdW50ID0gdHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoLCBwYXRoQ291bnQgPSBwYXRoQ29uc3RyYWludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRDb3VudCA9IGlrQ291bnQgKyB0cmFuc2Zvcm1Db3VudCArIHBhdGhDb3VudDtcclxuICAgICAgICAgICAgICAgIG91dGVyOiBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlrQ291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBpa0NvbnN0cmFpbnRzW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuZGF0YS5vcmRlciA9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRJa0NvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdHJhbnNmb3JtQ291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50c1tpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhdGEub3JkZXIgPT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0VHJhbnNmb3JtQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBwYXRoQ291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBwYXRoQ29uc3RyYWludHNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludC5kYXRhLm9yZGVyID09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKGJvbmVzW2ldKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNvcnRJa0NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5hY3RpdmUgPSBjb25zdHJhaW50LnRhcmdldC5pc0FjdGl2ZSgpICYmICghY29uc3RyYWludC5kYXRhLnNraW5SZXF1aXJlZCB8fCAodGhpcy5za2luICE9IG51bGwgJiYgY29yZS5VdGlscy5jb250YWlucyh0aGlzLnNraW4uY29uc3RyYWludHMsIGNvbnN0cmFpbnQuZGF0YSwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RyYWludC5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNvbnN0cmFpbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbmVkID0gY29uc3RyYWludC5ib25lcztcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb25zdHJhaW5lZFswXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUocGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW5lZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY29uc3RyYWluZWRbY29uc3RyYWluZWQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fdXBkYXRlQ2FjaGUuaW5kZXhPZihjaGlsZCkgPiAtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVSZXNldC5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRSZXNldChwYXJlbnQuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWluZWRbY29uc3RyYWluZWQubGVuZ3RoIC0gMV0uc29ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNvcnRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50LmFjdGl2ZSA9IGNvbnN0cmFpbnQudGFyZ2V0LmJvbmUuaXNBY3RpdmUoKSAmJiAoIWNvbnN0cmFpbnQuZGF0YS5za2luUmVxdWlyZWQgfHwgKHRoaXMuc2tpbiAhPSBudWxsICYmIGNvcmUuVXRpbHMuY29udGFpbnModGhpcy5za2luLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50LmRhdGEsIHRydWUpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gY29uc3RyYWludC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gc2xvdC5kYXRhLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RCb25lID0gc2xvdC5ib25lO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2tpbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudCh0aGlzLnNraW4sIHNsb3RJbmRleCwgc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5kZWZhdWx0U2tpbiAhPSBudWxsICYmIHRoaXMuZGF0YS5kZWZhdWx0U2tpbiAhPSB0aGlzLnNraW4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50KHRoaXMuZGF0YS5kZWZhdWx0U2tpbiwgc2xvdEluZGV4LCBzbG90Qm9uZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuZGF0YS5za2lucy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50KHRoaXMuZGF0YS5za2luc1tpXSwgc2xvdEluZGV4LCBzbG90Qm9uZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLlBhdGhBdHRhY2htZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFBhdGhDb25zdHJhaW50QXR0YWNobWVudFdpdGgoYXR0YWNobWVudCwgc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbmVkID0gY29uc3RyYWludC5ib25lcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lQ291bnQgPSBjb25zdHJhaW5lZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUoY29uc3RyYWluZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2FjaGUucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UmVzZXQoY29uc3RyYWluZWRbaV0uY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib25lQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW5lZFtpXS5zb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc29ydFRyYW5zZm9ybUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5hY3RpdmUgPSBjb25zdHJhaW50LnRhcmdldC5pc0FjdGl2ZSgpICYmICghY29uc3RyYWludC5kYXRhLnNraW5SZXF1aXJlZCB8fCAodGhpcy5za2luICE9IG51bGwgJiYgY29yZS5VdGlscy5jb250YWlucyh0aGlzLnNraW4uY29uc3RyYWludHMsIGNvbnN0cmFpbnQuZGF0YSwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RyYWludC5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShjb25zdHJhaW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWluZWQgPSBjb25zdHJhaW50LmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVDb3VudCA9IGNvbnN0cmFpbmVkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhdGEubG9jYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNvbnN0cmFpbmVkW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKGNoaWxkLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3VwZGF0ZUNhY2hlLmluZGV4T2YoY2hpbGQpID4gLTEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZVJlc2V0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0Qm9uZShjb25zdHJhaW5lZFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2FjaGUucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBib25lQ291bnQ7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UmVzZXQoY29uc3RyYWluZWRbaWldLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBib25lQ291bnQ7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluZWRbaWldLnNvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50ID0gZnVuY3Rpb24gKHNraW4sIHNsb3RJbmRleCwgc2xvdEJvbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IHNraW4uYXR0YWNobWVudHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghYXR0YWNobWVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50V2l0aChhdHRhY2htZW50c1trZXldLCBzbG90Qm9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zb3J0UGF0aENvbnN0cmFpbnRBdHRhY2htZW50V2l0aCA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCBzbG90Qm9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoYXR0YWNobWVudCBpbnN0YW5jZW9mIGNvcmUuUGF0aEF0dGFjaG1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQm9uZXMgPSBhdHRhY2htZW50LmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhCb25lcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydEJvbmUoc2xvdEJvbmUpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBwYXRoQm9uZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lQ291bnQgPSBwYXRoQm9uZXNbaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGkgKyBib25lQ291bnQ7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lSW5kZXggPSBwYXRoQm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKGJvbmVzW2JvbmVJbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc29ydEJvbmUgPSBmdW5jdGlvbiAoYm9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmUuc29ydGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBib25lLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRCb25lKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBib25lLnNvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDYWNoZS5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc29ydFJlc2V0ID0gZnVuY3Rpb24gKGJvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmUuc29ydGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRSZXNldChib25lLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICBib25lLnNvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUudXBkYXRlV29ybGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQ2FjaGVSZXNldCA9IHRoaXMudXBkYXRlQ2FjaGVSZXNldDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdXBkYXRlQ2FjaGVSZXNldC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHVwZGF0ZUNhY2hlUmVzZXRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZS5heCA9IGJvbmUueDtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmF5ID0gYm9uZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUuYXJvdGF0aW9uID0gYm9uZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFzY2FsZVggPSBib25lLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFzY2FsZVkgPSBib25lLnNjYWxlWTtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFzaGVhclggPSBib25lLnNoZWFyWDtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFzaGVhclkgPSBib25lLnNoZWFyWTtcclxuICAgICAgICAgICAgICAgICAgICBib25lLmFwcGxpZWRWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQ2FjaGUgPSB0aGlzLl91cGRhdGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdXBkYXRlQ2FjaGUubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhY2hlW2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc2V0VG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJvbmVzVG9TZXR1cFBvc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2xvdHNUb1NldHVwUG9zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc2V0Qm9uZXNUb1NldHVwUG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBib25lc1tpXS5zZXRUb1NldHVwUG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlrQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBpa0NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQubWl4ID0gY29uc3RyYWludC5kYXRhLm1peDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNvZnRuZXNzID0gY29uc3RyYWludC5kYXRhLnNvZnRuZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmVuZERpcmVjdGlvbiA9IGNvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY29tcHJlc3MgPSBjb25zdHJhaW50LmRhdGEuY29tcHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5zdHJldGNoID0gY29uc3RyYWludC5kYXRhLnN0cmV0Y2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtQ29uc3RyYWludHMgPSB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0cmFuc2Zvcm1Db25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY29uc3RyYWludC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucm90YXRlTWl4ID0gZGF0YS5yb3RhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC50cmFuc2xhdGVNaXggPSBkYXRhLnRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNjYWxlTWl4ID0gZGF0YS5zY2FsZU1peDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnNoZWFyTWl4ID0gZGF0YS5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ29uc3RyYWludHMgPSB0aGlzLnBhdGhDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcGF0aENvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gcGF0aENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY29uc3RyYWludC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuc3BhY2luZyA9IGRhdGEuc3BhY2luZztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnJvdGF0ZU1peCA9IGRhdGEucm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zZXRTbG90c1RvU2V0dXBQb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHNsb3RzLCAwLCB0aGlzLmRyYXdPcmRlciwgMCwgc2xvdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RzW2ldLnNldFRvU2V0dXBQb3NlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5nZXRSb290Qm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvbmVzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9uZXNbMF07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kQm9uZSA9IGZ1bmN0aW9uIChib25lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVOYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm9uZU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib25lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kQm9uZUluZGV4ID0gZnVuY3Rpb24gKGJvbmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9uZU5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib25lTmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmVzW2ldLmRhdGEubmFtZSA9PSBib25lTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kU2xvdCA9IGZ1bmN0aW9uIChzbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3ROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2xvdE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5kYXRhLm5hbWUgPT0gc2xvdE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5maW5kU2xvdEluZGV4ID0gZnVuY3Rpb24gKHNsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbG90TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RzW2ldLmRhdGEubmFtZSA9PSBzbG90TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS5zZXRTa2luQnlOYW1lID0gZnVuY3Rpb24gKHNraW5OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tpbiA9IHRoaXMuZGF0YS5maW5kU2tpbihza2luTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tpbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gbm90IGZvdW5kOiBcIiArIHNraW5OYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2tpbihza2luKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLnNldFNraW4gPSBmdW5jdGlvbiAobmV3U2tpbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1NraW4gPT0gdGhpcy5za2luKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdTa2luICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5za2luICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NraW4uYXR0YWNoQWxsKHRoaXMsIHRoaXMuc2tpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHNsb3QuZGF0YS5hdHRhY2htZW50TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lXzEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3U2tpbi5nZXRBdHRhY2htZW50KGksIG5hbWVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2luID0gbmV3U2tpbjtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmdldEF0dGFjaG1lbnRCeU5hbWUgPSBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRhY2htZW50KHRoaXMuZGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKSwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRhY2htZW50TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5za2luICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5kZWZhdWx0U2tpbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZGVmYXVsdFNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuc2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbG90TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNsb3ROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuZGF0YS5uYW1lID09IHNsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnROYW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoaSwgYXR0YWNobWVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRhY2htZW50IG5vdCBmb3VuZDogXCIgKyBhdHRhY2htZW50TmFtZSArIFwiLCBmb3Igc2xvdDogXCIgKyBzbG90TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZmluZElrQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlrQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlrQ29uc3RyYWludCA9IGlrQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlrQ29uc3RyYWludC5kYXRhLm5hbWUgPT0gY29uc3RyYWludE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpa0NvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmZpbmRUcmFuc2Zvcm1Db25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJhaW50TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtQ29uc3RyYWludHMgPSB0aGlzLnRyYW5zZm9ybUNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0cmFuc2Zvcm1Db25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHRyYW5zZm9ybUNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmRhdGEubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b24ucHJvdG90eXBlLmZpbmRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhDb25zdHJhaW50cyA9IHRoaXMucGF0aENvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwYXRoQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBwYXRoQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuZGF0YS5uYW1lID09IGNvbnN0cmFpbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RyYWludDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbi5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSwgdGVtcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPT09IHZvaWQgMCkgeyB0ZW1wID0gbmV3IEFycmF5KDIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2Zmc2V0IGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2l6ZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyID0gdGhpcy5kcmF3T3JkZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gZHJhd09yZGVyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBjb3JlLlJlZ2lvbkF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHRlbXAsIHZlcnRpY2VzTGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LmJvbmUsIHZlcnRpY2VzLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIGNvcmUuTWVzaEF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc2ggPSBhdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCA9IG1lc2gud29ybGRWZXJ0aWNlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0ZW1wLCB2ZXJ0aWNlc0xlbmd0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdCwgMCwgdmVydGljZXNMZW5ndGgsIHZlcnRpY2VzLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IHZlcnRpY2VzLmxlbmd0aDsgaWkgPCBubjsgaWkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpaV0sIHkgPSB2ZXJ0aWNlc1tpaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnNldChtaW5YLCBtaW5ZKTtcclxuICAgICAgICAgICAgICAgIHNpemUuc2V0KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNrZWxldG9uLnByb3RvdHlwZSwgXCJmbGlwWFwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVggPT0gLTE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVNrZWxldG9uLmRlcHJlY2F0ZWRXYXJuaW5nMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTa2VsZXRvbi5kZXByZWNhdGVkV2FybmluZzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGluZSBEZXByZWNhdGlvbiBXYXJuaW5nOiBgU2tlbGV0b24uZmxpcFgvZmxpcFlgIHdhcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHNjYWxlWC9zY2FsZVlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gdmFsdWUgPyAxLjAgOiAtMS4wO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2tlbGV0b24ucHJvdG90eXBlLCBcImZsaXBZXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWSA9PSAtMTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghU2tlbGV0b24uZGVwcmVjYXRlZFdhcm5pbmcxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrZWxldG9uLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwaW5lIERlcHJlY2F0aW9uIFdhcm5pbmc6IGBTa2VsZXRvbi5mbGlwWC9mbGlwWWAgd2FzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugc2NhbGVYL3NjYWxlWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSB2YWx1ZSA/IDEuMCA6IC0xLjA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFNrZWxldG9uLmRlcHJlY2F0ZWRXYXJuaW5nMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gU2tlbGV0b247XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNrZWxldG9uID0gU2tlbGV0b247XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2tlbGV0b25CaW5hcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTa2VsZXRvbkJpbmFyeShhdHRhY2htZW50TG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlua2VkTWVzaGVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRMb2FkZXIgPSBhdHRhY2htZW50TG9hZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkU2tlbGV0b25EYXRhID0gZnVuY3Rpb24gKGJpbmFyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbkRhdGEgPSBuZXcgY29yZS5Ta2VsZXRvbkRhdGEoKTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5uYW1lID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5ldyBCaW5hcnlJbnB1dChiaW5hcnkpO1xyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmhhc2ggPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEudmVyc2lvbiA9IGlucHV0LnJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbkRhdGEudmVyc2lvbiA9PT0gJzMuOC43NScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBcIlVuc3VwcG9ydGVkIHNrZWxldG9uIGRhdGEsIDMuOC43NSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgZXhwb3J0IHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIFNwaW5lLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS55ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEud2lkdGggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5oZWlnaHQgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBub25lc3NlbnRpYWwgPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5mcHMgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuaW1hZ2VzUGF0aCA9IGlucHV0LnJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuYXVkaW9QYXRoID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICAgICAgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zdHJpbmdzLnB1c2goaW5wdXQucmVhZFN0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gaW5wdXQucmVhZFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMiA9IGkgPT0gMCA/IG51bGwgOiBza2VsZXRvbkRhdGEuYm9uZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5Cb25lRGF0YShpLCBuYW1lXzIsIHBhcmVudF8yKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdGF0aW9uID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS54ID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnkgPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2NhbGVYID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zY2FsZVkgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNoZWFyWCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2hlYXJZID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNmb3JtTW9kZSA9IFNrZWxldG9uQmluYXJ5LlRyYW5zZm9ybU1vZGVWYWx1ZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5za2luUmVxdWlyZWQgPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKGRhdGEuY29sb3IsIGlucHV0LnJlYWRJbnQzMigpKTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuYm9uZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE5hbWUgPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVEYXRhID0gc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuU2xvdERhdGEoaSwgc2xvdE5hbWUsIGJvbmVEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihkYXRhLmNvbG9yLCBpbnB1dC5yZWFkSW50MzIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhcmtDb2xvciA9IGlucHV0LnJlYWRJbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXJrQ29sb3IgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiODg4VG9Db2xvcihkYXRhLmRhcmtDb2xvciA9IG5ldyBjb3JlLkNvbG9yKCksIGRhcmtDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRhY2htZW50TmFtZSA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmJsZW5kTW9kZSA9IFNrZWxldG9uQmluYXJ5LkJsZW5kTW9kZVZhbHVlc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuc2xvdHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5uID0gdm9pZCAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5Ja0NvbnN0cmFpbnREYXRhKGlucHV0LnJlYWRTdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vcmRlciA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5za2luUmVxdWlyZWQgPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5uID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbm47IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYm9uZXMucHVzaChza2VsZXRvbkRhdGEuYm9uZXNbaW5wdXQucmVhZEludCh0cnVlKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGFyZ2V0ID0gc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWl4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zb2Z0bmVzcyA9IGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5iZW5kRGlyZWN0aW9uID0gaW5wdXQucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXByZXNzID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnN0cmV0Y2ggPSBpbnB1dC5yZWFkQm9vbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudW5pZm9ybSA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmlrQ29uc3RyYWludHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5uID0gdm9pZCAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgY29yZS5UcmFuc2Zvcm1Db25zdHJhaW50RGF0YShpbnB1dC5yZWFkU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3JkZXIgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJvbmVzLnB1c2goc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmxvY2FsID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnJlbGF0aXZlID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFJvdGF0aW9uID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRYID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFkgPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0U2NhbGVYID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRTY2FsZVkgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFNoZWFyWSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucm90YXRlTWl4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50cmFuc2xhdGVNaXggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNjYWxlTWl4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zaGVhck1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS50cmFuc2Zvcm1Db25zdHJhaW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbm4gPSB2b2lkIDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50RGF0YShpbnB1dC5yZWFkU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3JkZXIgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJvbmVzLnB1c2goc2tlbGV0b25EYXRhLmJvbmVzW2lucHV0LnJlYWRJbnQodHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5zbG90c1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uTW9kZSA9IFNrZWxldG9uQmluYXJ5LlBvc2l0aW9uTW9kZVZhbHVlc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNwYWNpbmdNb2RlID0gU2tlbGV0b25CaW5hcnkuU3BhY2luZ01vZGVWYWx1ZXNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGVNb2RlID0gU2tlbGV0b25CaW5hcnkuUm90YXRlTW9kZVZhbHVlc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFJvdGF0aW9uID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uTW9kZSA9PSBjb3JlLlBvc2l0aW9uTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNwYWNpbmcgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zcGFjaW5nTW9kZSA9PSBjb3JlLlNwYWNpbmdNb2RlLkxlbmd0aCB8fCBkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BhY2luZyAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdGF0ZU1peCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlTWl4ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnBhdGhDb25zdHJhaW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTa2luID0gdGhpcy5yZWFkU2tpbihpbnB1dCwgc2tlbGV0b25EYXRhLCB0cnVlLCBub25lc3NlbnRpYWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRTa2luICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gPSBkZWZhdWx0U2tpbjtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuc2tpbnMucHVzaChkZWZhdWx0U2tpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBza2VsZXRvbkRhdGEuc2tpbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuc2V0QXJyYXlTaXplKHNrZWxldG9uRGF0YS5za2lucywgbiA9IGkgKyBpbnB1dC5yZWFkSW50KHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNraW5zW2ldID0gdGhpcy5yZWFkU2tpbihpbnB1dCwgc2tlbGV0b25EYXRhLCBmYWxzZSwgbm9uZXNzZW50aWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLmxpbmtlZE1lc2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rZWRNZXNoID0gdGhpcy5saW5rZWRNZXNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNraW4gPSBsaW5rZWRNZXNoLnNraW4gPT0gbnVsbCA/IHNrZWxldG9uRGF0YS5kZWZhdWx0U2tpbiA6IHNrZWxldG9uRGF0YS5maW5kU2tpbihsaW5rZWRNZXNoLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2luID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gbm90IGZvdW5kOiBcIiArIGxpbmtlZE1lc2guc2tpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8zID0gc2tpbi5nZXRBdHRhY2htZW50KGxpbmtlZE1lc2guc2xvdEluZGV4LCBsaW5rZWRNZXNoLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudF8zID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBtZXNoIG5vdCBmb3VuZDogXCIgKyBsaW5rZWRNZXNoLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkTWVzaC5tZXNoLmRlZm9ybUF0dGFjaG1lbnQgPSBsaW5rZWRNZXNoLmluaGVyaXREZWZvcm0gPyBwYXJlbnRfMyA6IGxpbmtlZE1lc2gubWVzaDtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rZWRNZXNoLm1lc2guc2V0UGFyZW50TWVzaChwYXJlbnRfMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZE1lc2hlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuRXZlbnREYXRhKGlucHV0LnJlYWRTdHJpbmdSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnRWYWx1ZSA9IGlucHV0LnJlYWRJbnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmxvYXRWYWx1ZSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc3RyaW5nVmFsdWUgPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdWRpb1BhdGggPSBpbnB1dC5yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYXVkaW9QYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52b2x1bWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5iYWxhbmNlID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5ldmVudHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmFuaW1hdGlvbnMucHVzaCh0aGlzLnJlYWRBbmltYXRpb24oaW5wdXQsIGlucHV0LnJlYWRTdHJpbmcoKSwgc2tlbGV0b25EYXRhKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tlbGV0b25EYXRhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZFNraW4gPSBmdW5jdGlvbiAoaW5wdXQsIHNrZWxldG9uRGF0YSwgZGVmYXVsdFNraW4sIG5vbmVzc2VudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNraW4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFNraW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90Q291bnQgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpbiA9IG5ldyBjb3JlLlNraW4oXCJkZWZhdWx0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpbiA9IG5ldyBjb3JlLlNraW4oaW5wdXQucmVhZFN0cmluZ1JlZigpKTtcclxuICAgICAgICAgICAgICAgICAgICBza2luLmJvbmVzLmxlbmd0aCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBza2luLmJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5ib25lc1tpXSA9IHNrZWxldG9uRGF0YS5ib25lc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uY29uc3RyYWludHMucHVzaChza2VsZXRvbkRhdGEuaWtDb25zdHJhaW50c1tpbnB1dC5yZWFkSW50KHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2luLmNvbnN0cmFpbnRzLnB1c2goc2tlbGV0b25EYXRhLnRyYW5zZm9ybUNvbnN0cmFpbnRzW2lucHV0LnJlYWRJbnQodHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uY29uc3RyYWludHMucHVzaChza2VsZXRvbkRhdGEucGF0aENvbnN0cmFpbnRzW2lucHV0LnJlYWRJbnQodHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpaSA8IG5uOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzMgPSBpbnB1dC5yZWFkU3RyaW5nUmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChpbnB1dCwgc2tlbGV0b25EYXRhLCBza2luLCBzbG90SW5kZXgsIG5hbWVfMywgbm9uZXNzZW50aWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uc2V0QXR0YWNobWVudChzbG90SW5kZXgsIG5hbWVfMywgYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraW47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkQXR0YWNobWVudCA9IGZ1bmN0aW9uIChpbnB1dCwgc2tlbGV0b25EYXRhLCBza2luLCBzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lLCBub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dGFjaG1lbnROYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVJbmRleCA9IGlucHV0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IFNrZWxldG9uQmluYXJ5LkF0dGFjaG1lbnRUeXBlVmFsdWVzW3R5cGVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuUmVnaW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gaW5wdXQucmVhZFN0cmluZ1JlZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGlucHV0LnJlYWRJbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3UmVnaW9uQXR0YWNobWVudChza2luLCBuYW1lLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnggPSB4ICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi55ID0geSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uc2NhbGVYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uc2NhbGVZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLndpZHRoID0gd2lkdGggKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihyZWdpb24uY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb3JlLkF0dGFjaG1lbnRUeXBlLkJvdW5kaW5nQm94OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMucmVhZFZlcnRpY2VzKGlucHV0LCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5vbmVzc2VudGlhbCA/IGlucHV0LnJlYWRJbnQzMigpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdCb3VuZGluZ0JveEF0dGFjaG1lbnQoc2tpbiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3gud29ybGRWZXJ0aWNlc0xlbmd0aCA9IHZlcnRleENvdW50IDw8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveC52ZXJ0aWNlcyA9IHZlcnRpY2VzLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3guYm9uZXMgPSB2ZXJ0aWNlcy5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKGJveC5jb2xvciwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuTWVzaDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gaW5wdXQucmVhZEludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dnMgPSB0aGlzLnJlYWRGbG9hdEFycmF5KGlucHV0LCB2ZXJ0ZXhDb3VudCA8PCAxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMucmVhZFNob3J0QXJyYXkoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnJlYWRWZXJ0aWNlcyhpbnB1dCwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHVsbExlbmd0aCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5yZWFkU2hvcnRBcnJheShpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdNZXNoQXR0YWNobWVudChza2luLCBuYW1lLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc2ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcihtZXNoLmNvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guYm9uZXMgPSB2ZXJ0aWNlcy5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC52ZXJ0aWNlcyA9IHZlcnRpY2VzLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLnRyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5yZWdpb25VVnMgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guaHVsbExlbmd0aCA9IGh1bGxMZW5ndGggPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5lZGdlcyA9IGVkZ2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC53aWR0aCA9IHdpZHRoICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuTGlua2VkTWVzaDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gaW5wdXQucmVhZEludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2luTmFtZSA9IGlucHV0LnJlYWRTdHJpbmdSZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF80ID0gaW5wdXQucmVhZFN0cmluZ1JlZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdERlZm9ybSA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25lc3NlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld01lc2hBdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzaCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKG1lc2guY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC53aWR0aCA9IHdpZHRoICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua2VkTWVzaGVzLnB1c2gobmV3IExpbmtlZE1lc2gobWVzaCwgc2tpbk5hbWUsIHNsb3RJbmRleCwgcGFyZW50XzQsIGluaGVyaXREZWZvcm0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5BdHRhY2htZW50VHlwZS5QYXRoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZWRfMSA9IGlucHV0LnJlYWRCb29sZWFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdGFudFNwZWVkID0gaW5wdXQucmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleENvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5yZWFkVmVydGljZXMoaW5wdXQsIHZlcnRleENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aHMgPSBjb3JlLlV0aWxzLm5ld0FycmF5KHZlcnRleENvdW50IC8gMywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGVuZ3Rocy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzW2ldID0gaW5wdXQucmVhZEZsb2F0KCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gbm9uZXNzZW50aWFsID8gaW5wdXQucmVhZEludDMyKCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdQYXRoQXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNsb3NlZCA9IGNsb3NlZF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbnN0YW50U3BlZWQgPSBjb25zdGFudFNwZWVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnZlcnRpY2VzID0gdmVydGljZXMudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYm9uZXMgPSB2ZXJ0aWNlcy5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5sZW5ndGhzID0gbGVuZ3RocztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKHBhdGguY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZS5BdHRhY2htZW50VHlwZS5Qb2ludDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gbm9uZXNzZW50aWFsID8gaW5wdXQucmVhZEludDMyKCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3UG9pbnRBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC54ID0geCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0geSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9uZXNzZW50aWFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IocG9pbnQuY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmUuQXR0YWNobWVudFR5cGUuQ2xpcHBpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFNsb3RJbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMucmVhZFZlcnRpY2VzKGlucHV0LCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5vbmVzc2VudGlhbCA/IGlucHV0LnJlYWRJbnQzMigpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXAgPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Q2xpcHBpbmdBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAuZW5kU2xvdCA9IHNrZWxldG9uRGF0YS5zbG90c1tlbmRTbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLnZlcnRpY2VzID0gdmVydGljZXMudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAuYm9uZXMgPSB2ZXJ0aWNlcy5ib25lcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmVzc2VudGlhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiYTg4ODhUb0NvbG9yKGNsaXAuY29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkVmVydGljZXMgPSBmdW5jdGlvbiAoaW5wdXQsIHZlcnRleENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXNMZW5ndGggPSB2ZXJ0ZXhDb3VudCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5yZWFkQm9vbGVhbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMudmVydGljZXMgPSB0aGlzLnJlYWRGbG9hdEFycmF5KGlucHV0LCB2ZXJ0aWNlc0xlbmd0aCwgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXNBcnJheSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZXNBcnJheS5wdXNoKGJvbmVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGJvbmVDb3VudDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lc0FycmF5LnB1c2goaW5wdXQucmVhZEludCh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaChpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0cy5wdXNoKGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2goaW5wdXQucmVhZEZsb2F0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnZlcnRpY2VzID0gY29yZS5VdGlscy50b0Zsb2F0QXJyYXkod2VpZ2h0cyk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5ib25lcyA9IGJvbmVzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkRmxvYXRBcnJheSA9IGZ1bmN0aW9uIChpbnB1dCwgbiwgc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgICAgIGlmIChzY2FsZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5wcm90b3R5cGUucmVhZFNob3J0QXJyYXkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gaW5wdXQucmVhZFNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5yZWFkQW5pbWF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBuYW1lLCBza2VsZXRvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBDb2xvcjEgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBDb2xvcjIgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGlpIDwgbm47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lVHlwZSA9IGlucHV0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aW1lbGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuU0xPVF9BVFRBQ0hNRU5UOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuQXR0YWNobWVudFRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRTdHJpbmdSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1tmcmFtZUNvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTa2VsZXRvbkJpbmFyeS5TTE9UX0NPTE9SOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuQ29sb3JUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5Db2xvci5yZ2JhODg4OFRvQ29sb3IodGVtcENvbG9yMSwgaW5wdXQucmVhZEludDMyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aW1lLCB0ZW1wQ29sb3IxLnIsIHRlbXBDb2xvcjEuZywgdGVtcENvbG9yMS5iLCB0ZW1wQ29sb3IxLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA8IGZyYW1lQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoaW5wdXQsIGZyYW1lSW5kZXgsIHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1soZnJhbWVDb3VudCAtIDEpICogY29yZS5Db2xvclRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuU0xPVF9UV09fQ09MT1I6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Ud29Db2xvclRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLkNvbG9yLnJnYmE4ODg4VG9Db2xvcih0ZW1wQ29sb3IxLCBpbnB1dC5yZWFkSW50MzIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuQ29sb3IucmdiODg4VG9Db2xvcih0ZW1wQ29sb3IyLCBpbnB1dC5yZWFkSW50MzIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRpbWUsIHRlbXBDb2xvcjEuciwgdGVtcENvbG9yMS5nLCB0ZW1wQ29sb3IxLmIsIHRlbXBDb2xvcjEuYSwgdGVtcENvbG9yMi5yLCB0ZW1wQ29sb3IyLmcsIHRlbXBDb2xvcjIuYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZShpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyhmcmFtZUNvdW50IC0gMSkgKiBjb3JlLlR3b0NvbG9yVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVJbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGlpIDwgbm47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lVHlwZSA9IGlucHV0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aW1lbGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQk9ORV9ST1RBVEU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Sb3RhdGVUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuUm90YXRlVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTa2VsZXRvbkJpbmFyeS5CT05FX1RSQU5TTEFURTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQk9ORV9TQ0FMRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQk9ORV9TSEVBUjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTY2FsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lVHlwZSA9PSBTa2VsZXRvbkJpbmFyeS5CT05FX1NDQUxFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlNjYWxlVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmVUeXBlID09IFNrZWxldG9uQmluYXJ5LkJPTkVfU0hFQVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuU2hlYXJUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgY29yZS5UcmFuc2xhdGVUaW1lbGluZShmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpICogdGltZWxpbmVTY2FsZSwgaW5wdXQucmVhZEZsb2F0KCkgKiB0aW1lbGluZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuVHJhbnNsYXRlVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbnB1dC5yZWFkSW50KHRydWUpOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuSWtDb25zdHJhaW50VGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuaWtDb25zdHJhaW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpICogc2NhbGUsIGlucHV0LnJlYWRCeXRlKCksIGlucHV0LnJlYWRCb29sZWFuKCksIGlucHV0LnJlYWRCb29sZWFuKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA8IGZyYW1lQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUoaW5wdXQsIGZyYW1lSW5kZXgsIHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1soZnJhbWVDb3VudCAtIDEpICogY29yZS5Ja0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5UcmFuc2Zvcm1Db25zdHJhaW50VGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUudHJhbnNmb3JtQ29uc3RyYWludEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZnJhbWVJbmRleCA9IDA7IGZyYW1lSW5kZXggPCBmcmFtZUNvdW50OyBmcmFtZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5wdXQucmVhZEludCh0cnVlKTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBza2VsZXRvbkRhdGEucGF0aENvbnN0cmFpbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDAsIG5uID0gaW5wdXQucmVhZEludCh0cnVlKTsgaWkgPCBubjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVUeXBlID0gaW5wdXQucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lQ291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRpbWVsaW5lVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTa2VsZXRvbkJpbmFyeS5QQVRIX1BPU0lUSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTa2VsZXRvbkJpbmFyeS5QQVRIX1NQQUNJTkc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU2NhbGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT0gU2tlbGV0b25CaW5hcnkuUEFUSF9TUEFDSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuUGF0aENvbnN0cmFpbnRTcGFjaW5nVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuTGVuZ3RoIHx8IGRhdGEuc3BhY2luZ01vZGUgPT0gY29yZS5TcGFjaW5nTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbk1vZGUgPT0gY29yZS5Qb3NpdGlvbk1vZGUuRml4ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZVNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnBhdGhDb25zdHJhaW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCkgKiB0aW1lbGluZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuUEFUSF9NSVg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5QYXRoQ29uc3RyYWludE1peFRpbWVsaW5lKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnBhdGhDb25zdHJhaW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcmFtZUluZGV4ID0gMDsgZnJhbWVJbmRleCA8IGZyYW1lQ291bnQ7IGZyYW1lSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSW5kZXggPCBmcmFtZUNvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKGZyYW1lQ291bnQgLSAxKSAqIGNvcmUuUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbiA9IHNrZWxldG9uRGF0YS5za2luc1tpbnB1dC5yZWFkSW50KHRydWUpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDAsIG5uID0gaW5wdXQucmVhZEludCh0cnVlKTsgaWkgPCBubjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWlpID0gMCwgbm5uID0gaW5wdXQucmVhZEludCh0cnVlKTsgaWlpIDwgbm5uOyBpaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBza2luLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBpbnB1dC5yZWFkU3RyaW5nUmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodGVkID0gYXR0YWNobWVudC5ib25lcyAhPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gYXR0YWNobWVudC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZvcm1MZW5ndGggPSB3ZWlnaHRlZCA/IHZlcnRpY2VzLmxlbmd0aCAvIDMgKiAyIDogdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lQ291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuRGVmb3JtVGltZWxpbmUoZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lSW5kZXggPSAwOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudDsgZnJhbWVJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmb3JtID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtID0gd2VpZ2h0ZWQgPyBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZGVmb3JtTGVuZ3RoKSA6IHZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm0gPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZGVmb3JtTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICs9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdiA9IHN0YXJ0OyB2IDwgZW5kOyB2KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmb3JtW3ZdID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gc3RhcnQ7IHYgPCBlbmQ7IHYrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1bdl0gPSBpbnB1dC5yZWFkRmxvYXQoKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2VpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSAwLCB2biA9IGRlZm9ybS5sZW5ndGg7IHYgPCB2bjsgdisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVt2XSArPSB2ZXJ0aWNlc1t2XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aW1lLCBkZWZvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKGlucHV0LCBmcmFtZUluZGV4LCB0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbZnJhbWVDb3VudCAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkcmF3T3JkZXJDb3VudCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhd09yZGVyQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuRHJhd09yZGVyVGltZWxpbmUoZHJhd09yZGVyQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90Q291bnQgPSBza2VsZXRvbkRhdGEuc2xvdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhd09yZGVyQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGlucHV0LnJlYWRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0Q291bnQgPSBpbnB1dC5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyID0gY29yZS5VdGlscy5uZXdBcnJheShzbG90Q291bnQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IHNsb3RDb3VudCAtIDE7IGlpID49IDA7IGlpLS0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3JkZXJbaWldID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmNoYW5nZWQgPSBjb3JlLlV0aWxzLm5ld0FycmF5KHNsb3RDb3VudCAtIG9mZnNldENvdW50LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSAwLCB1bmNoYW5nZWRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvZmZzZXRDb3VudDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IGlucHV0LnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCAhPSBzbG90SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jaGFuZ2VkW3VuY2hhbmdlZEluZGV4KytdID0gb3JpZ2luYWxJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW29yaWdpbmFsSW5kZXggKyBpbnB1dC5yZWFkSW50KHRydWUpXSA9IG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IHNsb3RDb3VudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZFt1bmNoYW5nZWRJbmRleCsrXSA9IG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSBzbG90Q291bnQgLSAxOyBpaSA+PSAwOyBpaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdPcmRlcltpaV0gPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW2lpXSA9IHVuY2hhbmdlZFstLXVuY2hhbmdlZEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoaSwgdGltZSwgZHJhd09yZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1tkcmF3T3JkZXJDb3VudCAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBldmVudENvdW50ID0gaW5wdXQucmVhZEludCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkV2ZW50VGltZWxpbmUoZXZlbnRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHNrZWxldG9uRGF0YS5ldmVudHNbaW5wdXQucmVhZEludCh0cnVlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudF80ID0gbmV3IGNvcmUuRXZlbnQodGltZSwgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNC5pbnRWYWx1ZSA9IGlucHV0LnJlYWRJbnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudF80LmZsb2F0VmFsdWUgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNC5zdHJpbmdWYWx1ZSA9IGlucHV0LnJlYWRCb29sZWFuKCkgPyBpbnB1dC5yZWFkU3RyaW5nKCkgOiBldmVudERhdGEuc3RyaW5nVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudF80LmRhdGEuYXVkaW9QYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzQudm9sdW1lID0gaW5wdXQucmVhZEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF80LmJhbGFuY2UgPSBpbnB1dC5yZWFkRmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShpLCBldmVudF80KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1tldmVudENvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkFuaW1hdGlvbihuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkucHJvdG90eXBlLnJlYWRDdXJ2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgZnJhbWVJbmRleCwgdGltZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQucmVhZEJ5dGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2tlbGV0b25CaW5hcnkuQ1VSVkVfU1RFUFBFRDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0U3RlcHBlZChmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTa2VsZXRvbkJpbmFyeS5DVVJWRV9CRVpJRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIGlucHV0LnJlYWRGbG9hdCgpLCBpbnB1dC5yZWFkRmxvYXQoKSwgaW5wdXQucmVhZEZsb2F0KCksIGlucHV0LnJlYWRGbG9hdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LnByb3RvdHlwZS5zZXRDdXJ2ZSA9IGZ1bmN0aW9uICh0aW1lbGluZSwgZnJhbWVJbmRleCwgY3gxLCBjeTEsIGN4MiwgY3kyKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRDdXJ2ZShmcmFtZUluZGV4LCBjeDEsIGN5MSwgY3gyLCBjeTIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5BdHRhY2htZW50VHlwZVZhbHVlcyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2XTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuVHJhbnNmb3JtTW9kZVZhbHVlcyA9IFtjb3JlLlRyYW5zZm9ybU1vZGUuTm9ybWFsLCBjb3JlLlRyYW5zZm9ybU1vZGUuT25seVRyYW5zbGF0aW9uLCBjb3JlLlRyYW5zZm9ybU1vZGUuTm9Sb3RhdGlvbk9yUmVmbGVjdGlvbiwgY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGUsIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1NjYWxlT3JSZWZsZWN0aW9uXTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuUG9zaXRpb25Nb2RlVmFsdWVzID0gW2NvcmUuUG9zaXRpb25Nb2RlLkZpeGVkLCBjb3JlLlBvc2l0aW9uTW9kZS5QZXJjZW50XTtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuU3BhY2luZ01vZGVWYWx1ZXMgPSBbY29yZS5TcGFjaW5nTW9kZS5MZW5ndGgsIGNvcmUuU3BhY2luZ01vZGUuRml4ZWQsIGNvcmUuU3BhY2luZ01vZGUuUGVyY2VudF07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlJvdGF0ZU1vZGVWYWx1ZXMgPSBbY29yZS5Sb3RhdGVNb2RlLlRhbmdlbnQsIGNvcmUuUm90YXRlTW9kZS5DaGFpbiwgY29yZS5Sb3RhdGVNb2RlLkNoYWluU2NhbGVdO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5CbGVuZE1vZGVWYWx1ZXMgPSBbY29yZS5CbGVuZE1vZGUuTm9ybWFsLCBjb3JlLkJsZW5kTW9kZS5BZGRpdGl2ZSwgY29yZS5CbGVuZE1vZGUuTXVsdGlwbHksIGNvcmUuQmxlbmRNb2RlLlNjcmVlbl07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LkJPTkVfUk9UQVRFID0gMDtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQk9ORV9UUkFOU0xBVEUgPSAxO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5CT05FX1NDQUxFID0gMjtcclxuICAgICAgICAgICAgU2tlbGV0b25CaW5hcnkuQk9ORV9TSEVBUiA9IDM7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlNMT1RfQVRUQUNITUVOVCA9IDA7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlNMT1RfQ09MT1IgPSAxO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5TTE9UX1RXT19DT0xPUiA9IDI7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LlBBVEhfUE9TSVRJT04gPSAwO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5QQVRIX1NQQUNJTkcgPSAxO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5QQVRIX01JWCA9IDI7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LkNVUlZFX0xJTkVBUiA9IDA7XHJcbiAgICAgICAgICAgIFNrZWxldG9uQmluYXJ5LkNVUlZFX1NURVBQRUQgPSAxO1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJpbmFyeS5DVVJWRV9CRVpJRVIgPSAyO1xyXG4gICAgICAgICAgICByZXR1cm4gU2tlbGV0b25CaW5hcnk7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNrZWxldG9uQmluYXJ5ID0gU2tlbGV0b25CaW5hcnk7XHJcbiAgICAgICAgdmFyIEJpbmFyeUlucHV0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQmluYXJ5SW5wdXQoZGF0YSwgc3RyaW5ncywgaW5kZXgsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MgPT09IHZvaWQgMCkgeyBzdHJpbmdzID0gbmV3IEFycmF5KCk7IH1cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdm9pZCAwKSB7IGJ1ZmZlciA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBCaW5hcnlJbnB1dC5wcm90b3R5cGUucmVhZEJ5dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuZ2V0SW50OCh0aGlzLmluZGV4KyspO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5hcnlJbnB1dC5wcm90b3R5cGUucmVhZFNob3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0SW50MTYodGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmFyeUlucHV0LnByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5nZXRJbnQzMih0aGlzLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiAob3B0aW1pemVQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYiAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGIgJiAweDgwKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCA3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYiAmIDB4ODApICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IChiICYgMHg3RikgPDwgMTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYiAmIDB4ODApICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gKGIgJiAweDdGKSA8PCAyMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYiAmIDB4ODApICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAoYiAmIDB4N0YpIDw8IDI4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplUG9zaXRpdmUgPyByZXN1bHQgOiAoKHJlc3VsdCA+Pj4gMSkgXiAtKHJlc3VsdCAmIDEpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRTdHJpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnJlYWRJbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnN0cmluZ3NbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluYXJ5SW5wdXQucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZUNvdW50ID0gdGhpcy5yZWFkSW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChieXRlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBieXRlQ291bnQtLTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhckNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUNvdW50Oykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYiA+PiA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYiAmIDB4MUYpIDw8IDYgfCB0aGlzLnJlYWRCeXRlKCkgJiAweDNGKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChiICYgMHgwRikgPDwgMTIgfCAodGhpcy5yZWFkQnl0ZSgpICYgMHgzRikgPDwgNiB8IHRoaXMucmVhZEJ5dGUoKSAmIDB4M0YpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmFyeUlucHV0LnByb3RvdHlwZS5yZWFkRmxvYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5nZXRGbG9hdDMyKHRoaXMuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5hcnlJbnB1dC5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnl0ZSgpICE9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBCaW5hcnlJbnB1dDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHZhciBMaW5rZWRNZXNoID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTGlua2VkTWVzaChtZXNoLCBza2luLCBzbG90SW5kZXgsIHBhcmVudCwgaW5oZXJpdERlZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoID0gbWVzaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbiA9IHNraW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmhlcml0RGVmb3JtID0gaW5oZXJpdERlZm9ybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTGlua2VkTWVzaDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHZhciBWZXJ0aWNlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFZlcnRpY2VzKGJvbmVzLCB2ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVzID09PSB2b2lkIDApIHsgYm9uZXMgPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXMgPT09IHZvaWQgMCkgeyB2ZXJ0aWNlcyA9IG51bGw7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMgPSBib25lcztcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVmVydGljZXM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTa2VsZXRvbkJvdW5kcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNrZWxldG9uQm91bmRzKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5YID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluWSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uUG9vbCA9IG5ldyBjb3JlLlBvb2woZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoMTYpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChza2VsZXRvbiwgdXBkYXRlQWFiYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNrZWxldG9uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2tlbGV0b24gY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ZXMgPSB0aGlzLmJvdW5kaW5nQm94ZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25Qb29sID0gdGhpcy5wb2x5Z29uUG9vbDtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHNrZWxldG9uLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RDb3VudCA9IHNsb3RzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25Qb29sLmZyZWVBbGwocG9seWdvbnMpO1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xvdENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xvdC5ib25lLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIGNvcmUuQm91bmRpbmdCb3hBdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94ZXMucHVzaChib3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvblBvb2wub2J0YWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCAhPSBib3VuZGluZ0JveC53b3JsZFZlcnRpY2VzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGJvdW5kaW5nQm94LndvcmxkVmVydGljZXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIGJvdW5kaW5nQm94LndvcmxkVmVydGljZXNMZW5ndGgsIHBvbHlnb24sIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBYWJiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYWJiQ29tcHV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuYWFiYkNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbjtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDAsIG5uID0gcG9seWdvbi5sZW5ndGg7IGlpIDwgbm47IGlpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1tpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdmVydGljZXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubWluWCA9IG1pblg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhYID0gbWF4WDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4WSA9IG1heFk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5hYWJiQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCA+PSB0aGlzLm1pblggJiYgeCA8PSB0aGlzLm1heFggJiYgeSA+PSB0aGlzLm1pblkgJiYgeSA8PSB0aGlzLm1heFk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5hYWJiSW50ZXJzZWN0c1NlZ21lbnQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh4MSA8PSBtaW5YICYmIHgyIDw9IG1pblgpIHx8ICh5MSA8PSBtaW5ZICYmIHkyIDw9IG1pblkpIHx8ICh4MSA+PSBtYXhYICYmIHgyID49IG1heFgpIHx8ICh5MSA+PSBtYXhZICYmIHkyID49IG1heFkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBtICogKG1pblggLSB4MSkgKyB5MTtcclxuICAgICAgICAgICAgICAgIGlmICh5ID4gbWluWSAmJiB5IDwgbWF4WSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHkgPSBtICogKG1heFggLSB4MSkgKyB5MTtcclxuICAgICAgICAgICAgICAgIGlmICh5ID4gbWluWSAmJiB5IDwgbWF4WSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gKG1pblkgLSB5MSkgLyBtICsgeDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1pblggJiYgeCA8IG1heFgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB4ID0gKG1heFkgLSB5MSkgLyBtICsgeDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1pblggJiYgeCA8IG1heFgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5hYWJiSW50ZXJzZWN0c1NrZWxldG9uID0gZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluWCA8IGJvdW5kcy5tYXhYICYmIHRoaXMubWF4WCA+IGJvdW5kcy5taW5YICYmIHRoaXMubWluWSA8IGJvdW5kcy5tYXhZICYmIHRoaXMubWF4WSA+IGJvdW5kcy5taW5ZO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludFBvbHlnb24ocG9seWdvbnNbaV0sIHgsIHkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQm91bmRzLnByb3RvdHlwZS5jb250YWluc1BvaW50UG9seWdvbiA9IGZ1bmN0aW9uIChwb2x5Z29uLCB4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBwb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5uID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gbm4gLSAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleFkgPSB2ZXJ0aWNlc1tpaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2WSA9IHZlcnRpY2VzW3ByZXZJbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodmVydGV4WSA8IHkgJiYgcHJldlkgPj0geSkgfHwgKHByZXZZIDwgeSAmJiB2ZXJ0ZXhZID49IHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhYID0gdmVydGljZXNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4WCArICh5IC0gdmVydGV4WSkgLyAocHJldlkgLSB2ZXJ0ZXhZKSAqICh2ZXJ0aWNlc1twcmV2SW5kZXhdIC0gdmVydGV4WCkgPCB4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4ID0gaWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuaW50ZXJzZWN0c1NlZ21lbnQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RzU2VnbWVudFBvbHlnb24ocG9seWdvbnNbaV0sIHgxLCB5MSwgeDIsIHkyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3hlc1tpXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkJvdW5kcy5wcm90b3R5cGUuaW50ZXJzZWN0c1NlZ21lbnRQb2x5Z29uID0gZnVuY3Rpb24gKHBvbHlnb24sIHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBwb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5uID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGgxMiA9IHgxIC0geDIsIGhlaWdodDEyID0geTEgLSB5MjtcclxuICAgICAgICAgICAgICAgIHZhciBkZXQxID0geDEgKiB5MiAtIHkxICogeDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDMgPSB2ZXJ0aWNlc1tubiAtIDJdLCB5MyA9IHZlcnRpY2VzW25uIC0gMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbm47IGlpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDQgPSB2ZXJ0aWNlc1tpaV0sIHk0ID0gdmVydGljZXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0MiA9IHgzICogeTQgLSB5MyAqIHg0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aDM0ID0geDMgLSB4NCwgaGVpZ2h0MzQgPSB5MyAtIHk0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQzID0gd2lkdGgxMiAqIGhlaWdodDM0IC0gaGVpZ2h0MTIgKiB3aWR0aDM0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gKGRldDEgKiB3aWR0aDM0IC0gd2lkdGgxMiAqIGRldDIpIC8gZGV0MztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCh4ID49IHgzICYmIHggPD0geDQpIHx8ICh4ID49IHg0ICYmIHggPD0geDMpKSAmJiAoKHggPj0geDEgJiYgeCA8PSB4MikgfHwgKHggPj0geDIgJiYgeCA8PSB4MSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gKGRldDEgKiBoZWlnaHQzNCAtIGhlaWdodDEyICogZGV0MikgLyBkZXQzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCh5ID49IHkzICYmIHkgPD0geTQpIHx8ICh5ID49IHk0ICYmIHkgPD0geTMpKSAmJiAoKHkgPj0geTEgJiYgeSA8PSB5MikgfHwgKHkgPj0geTIgJiYgeSA8PSB5MSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHgzID0geDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5NDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmdldFBvbHlnb24gPSBmdW5jdGlvbiAoYm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZ0JveCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdW5kaW5nQm94IGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuYm91bmRpbmdCb3hlcy5pbmRleE9mKGJvdW5kaW5nQm94KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PSAtMSA/IG51bGwgOiB0aGlzLnBvbHlnb25zW2luZGV4XTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Cb3VuZHMucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTa2VsZXRvbkJvdW5kcztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2tlbGV0b25Cb3VuZHMgPSBTa2VsZXRvbkJvdW5kcztcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTa2VsZXRvbkNsaXBwaW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2tlbGV0b25DbGlwcGluZygpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpYW5ndWxhdG9yID0gbmV3IGNvcmUuVHJpYW5ndWxhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwaW5nUG9seWdvbiA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwT3V0cHV0ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWRWZXJ0aWNlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGVkVHJpYW5nbGVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcmF0Y2ggPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5jbGlwU3RhcnQgPSBmdW5jdGlvbiAoc2xvdCwgY2xpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpcEF0dGFjaG1lbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcEF0dGFjaG1lbnQgPSBjbGlwO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBjbGlwLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZSh0aGlzLmNsaXBwaW5nUG9seWdvbiwgbik7XHJcbiAgICAgICAgICAgICAgICBjbGlwLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIDAsIG4sIHZlcnRpY2VzLCAwLCAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwcGluZ1BvbHlnb24gPSB0aGlzLmNsaXBwaW5nUG9seWdvbjtcclxuICAgICAgICAgICAgICAgIFNrZWxldG9uQ2xpcHBpbmcubWFrZUNsb2Nrd2lzZShjbGlwcGluZ1BvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBwaW5nUG9seWdvbnMgPSB0aGlzLmNsaXBwaW5nUG9seWdvbnMgPSB0aGlzLnRyaWFuZ3VsYXRvci5kZWNvbXBvc2UoY2xpcHBpbmdQb2x5Z29uLCB0aGlzLnRyaWFuZ3VsYXRvci50cmlhbmd1bGF0ZShjbGlwcGluZ1BvbHlnb24pKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuXzIgPSBjbGlwcGluZ1BvbHlnb25zLmxlbmd0aDsgaSA8IG5fMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBjbGlwcGluZ1BvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIFNrZWxldG9uQ2xpcHBpbmcubWFrZUNsb2Nrd2lzZShwb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2gocG9seWdvblswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHBvbHlnb25bMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaXBwaW5nUG9seWdvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5jbGlwRW5kV2l0aFNsb3QgPSBmdW5jdGlvbiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpcEF0dGFjaG1lbnQgIT0gbnVsbCAmJiB0aGlzLmNsaXBBdHRhY2htZW50LmVuZFNsb3QgPT0gc2xvdC5kYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcEVuZCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5jbGlwRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpcEF0dGFjaG1lbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBBdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcHBpbmdQb2x5Z29ucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWRWZXJ0aWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwcGVkVHJpYW5nbGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwaW5nUG9seWdvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLnByb3RvdHlwZS5pc0NsaXBwaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpcEF0dGFjaG1lbnQgIT0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25DbGlwcGluZy5wcm90b3R5cGUuY2xpcFRyaWFuZ2xlcyA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGljZXNMZW5ndGgsIHRyaWFuZ2xlcywgdHJpYW5nbGVzTGVuZ3RoLCB1dnMsIGxpZ2h0LCBkYXJrLCB0d29Db2xvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBPdXRwdXQgPSB0aGlzLmNsaXBPdXRwdXQsIGNsaXBwZWRWZXJ0aWNlcyA9IHRoaXMuY2xpcHBlZFZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBwZWRUcmlhbmdsZXMgPSB0aGlzLmNsaXBwZWRUcmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLmNsaXBwaW5nUG9seWdvbnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnNDb3VudCA9IHRoaXMuY2xpcHBpbmdQb2x5Z29ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4U2l6ZSA9IHR3b0NvbG9yID8gMTIgOiA4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgb3V0ZXI6IGZvciAodmFyIGkgPSAwOyBpIDwgdHJpYW5nbGVzTGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdHJpYW5nbGVzW2ldIDw8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gdmVydGljZXNbdmVydGV4T2Zmc2V0XSwgeTEgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdTEgPSB1dnNbdmVydGV4T2Zmc2V0XSwgdjEgPSB1dnNbdmVydGV4T2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ID0gdHJpYW5nbGVzW2kgKyAxXSA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldF0sIHkyID0gdmVydGljZXNbdmVydGV4T2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUyID0gdXZzW3ZlcnRleE9mZnNldF0sIHYyID0gdXZzW3ZlcnRleE9mZnNldCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCA9IHRyaWFuZ2xlc1tpICsgMl0gPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDMgPSB2ZXJ0aWNlc1t2ZXJ0ZXhPZmZzZXRdLCB5MyA9IHZlcnRpY2VzW3ZlcnRleE9mZnNldCArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1MyA9IHV2c1t2ZXJ0ZXhPZmZzZXRdLCB2MyA9IHV2c1t2ZXJ0ZXhPZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvbHlnb25zQ291bnQ7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGNsaXBwZWRWZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgcG9seWdvbnNbcF0sIGNsaXBPdXRwdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcE91dHB1dExlbmd0aCA9IGNsaXBPdXRwdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBPdXRwdXRMZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkMCA9IHkyIC0geTMsIGQxID0geDMgLSB4MiwgZDIgPSB4MSAtIHgzLCBkNCA9IHkzIC0geTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IDEgLyAoZDAgKiBkMiArIGQxICogKHkxIC0geTMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwT3V0cHV0Q291bnQgPSBjbGlwT3V0cHV0TGVuZ3RoID4+IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcE91dHB1dEl0ZW1zID0gdGhpcy5jbGlwT3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoY2xpcHBlZFZlcnRpY2VzLCBzICsgY2xpcE91dHB1dENvdW50ICogdmVydGV4U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY2xpcE91dHB1dExlbmd0aDsgaWkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gY2xpcE91dHB1dEl0ZW1zW2lpXSwgeSA9IGNsaXBPdXRwdXRJdGVtc1tpaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3NdID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyXSA9IGxpZ2h0LnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDNdID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNF0gPSBsaWdodC5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA1XSA9IGxpZ2h0LmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMwID0geCAtIHgzLCBjMSA9IHkgLSB5MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IChkMCAqIGMwICsgZDEgKiBjMSkgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gKGQ0ICogYzAgKyBkMiAqIGMxKSAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAxIC0gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDZdID0gdTEgKiBhICsgdTIgKiBiICsgdTMgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA3XSA9IHYxICogYSArIHYyICogYiArIHYzICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHdvQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDhdID0gZGFyay5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgOV0gPSBkYXJrLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMF0gPSBkYXJrLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBkYXJrLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdmVydGV4U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBjbGlwcGVkVHJpYW5nbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwcGVkVHJpYW5nbGVzSXRlbXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShjbGlwcGVkVHJpYW5nbGVzLCBzICsgMyAqIChjbGlwT3V0cHV0Q291bnQgLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwT3V0cHV0Q291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBjbGlwT3V0cHV0Q291bnQ7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVHJpYW5nbGVzSXRlbXNbc10gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVHJpYW5nbGVzSXRlbXNbcyArIDFdID0gKGluZGV4ICsgaWkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRUcmlhbmdsZXNJdGVtc1tzICsgMl0gPSAoaW5kZXggKyBpaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGNsaXBPdXRwdXRDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcHBlZFZlcnRpY2VzSXRlbXMgPSBjb3JlLlV0aWxzLnNldEFycmF5U2l6ZShjbGlwcGVkVmVydGljZXMsIHMgKyAzICogdmVydGV4U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzXSA9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDFdID0geTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMl0gPSBsaWdodC5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDNdID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA0XSA9IGxpZ2h0LmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgNV0gPSBsaWdodC5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0d29Db2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA2XSA9IHUxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA3XSA9IHYxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA4XSA9IHgyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA5XSA9IHkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMF0gPSBsaWdodC5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBsaWdodC5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMl0gPSBsaWdodC5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxM10gPSBsaWdodC5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxNF0gPSB1MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTVdID0gdjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE2XSA9IHgzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxN10gPSB5MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMThdID0gbGlnaHQucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTldID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjBdID0gbGlnaHQuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjFdID0gbGlnaHQuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjJdID0gdTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIzXSA9IHYzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDZdID0gdTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDddID0gdjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDhdID0gZGFyay5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyA5XSA9IGRhcmsuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTBdID0gZGFyay5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxMV0gPSBkYXJrLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDEyXSA9IHgyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAxM10gPSB5MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTRdID0gbGlnaHQucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTVdID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTZdID0gbGlnaHQuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMTddID0gbGlnaHQuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMThdID0gdTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDE5XSA9IHYyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyMF0gPSBkYXJrLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDIxXSA9IGRhcmsuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjJdID0gZGFyay5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyM10gPSBkYXJrLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDI0XSA9IHgzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAyNV0gPSB5MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjZdID0gbGlnaHQucjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjddID0gbGlnaHQuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjhdID0gbGlnaHQuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMjldID0gbGlnaHQuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMzBdID0gdTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDMxXSA9IHYzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzMl0gPSBkYXJrLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFZlcnRpY2VzSXRlbXNbcyArIDMzXSA9IGRhcmsuZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVmVydGljZXNJdGVtc1tzICsgMzRdID0gZGFyay5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBwZWRWZXJ0aWNlc0l0ZW1zW3MgKyAzNV0gPSBkYXJrLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zID0gY29yZS5VdGlscy5zZXRBcnJheVNpemUoY2xpcHBlZFRyaWFuZ2xlcywgcyArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZFRyaWFuZ2xlc0l0ZW1zW3NdID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVHJpYW5nbGVzSXRlbXNbcyArIDFdID0gKGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkVHJpYW5nbGVzSXRlbXNbcyArIDJdID0gKGluZGV4ICsgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uQ2xpcHBpbmcucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgY2xpcHBpbmdBcmVhLCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbE91dHB1dCA9IG91dHB1dDtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBwaW5nQXJlYS5sZW5ndGggJSA0ID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IG91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLnNjcmF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnNjcmF0Y2g7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh4MSk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHkxKTtcclxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goeDIpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh5Mik7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHgzKTtcclxuICAgICAgICAgICAgICAgIGlucHV0LnB1c2goeTMpO1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHVzaCh4MSk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHkxKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBwaW5nVmVydGljZXMgPSBjbGlwcGluZ0FyZWE7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpcHBpbmdWZXJ0aWNlc0xhc3QgPSBjbGlwcGluZ0FyZWEubGVuZ3RoIC0gNDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOzsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VYID0gY2xpcHBpbmdWZXJ0aWNlc1tpXSwgZWRnZVkgPSBjbGlwcGluZ1ZlcnRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZVgyID0gY2xpcHBpbmdWZXJ0aWNlc1tpICsgMl0sIGVkZ2VZMiA9IGNsaXBwaW5nVmVydGljZXNbaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBlZGdlWCAtIGVkZ2VYMiwgZGVsdGFZID0gZWRnZVkgLSBlZGdlWTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0VmVydGljZXMgPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRWZXJ0aWNlc0xlbmd0aCA9IGlucHV0Lmxlbmd0aCAtIDIsIG91dHB1dFN0YXJ0ID0gb3V0cHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaW5wdXRWZXJ0aWNlc0xlbmd0aDsgaWkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRYID0gaW5wdXRWZXJ0aWNlc1tpaV0sIGlucHV0WSA9IGlucHV0VmVydGljZXNbaWkgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0WDIgPSBpbnB1dFZlcnRpY2VzW2lpICsgMl0sIGlucHV0WTIgPSBpbnB1dFZlcnRpY2VzW2lpICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlMiA9IGRlbHRhWCAqIChpbnB1dFkyIC0gZWRnZVkyKSAtIGRlbHRhWSAqIChpbnB1dFgyIC0gZWRnZVgyKSA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YVggKiAoaW5wdXRZIC0gZWRnZVkyKSAtIGRlbHRhWSAqIChpbnB1dFggLSBlZGdlWDIpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXRYMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXRZMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzAgPSBpbnB1dFkyIC0gaW5wdXRZLCBjMiA9IGlucHV0WDIgLSBpbnB1dFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWEgPSAoYzIgKiAoZWRnZVkgLSBpbnB1dFkpIC0gYzAgKiAoZWRnZVggLSBpbnB1dFgpKSAvIChjMCAqIChlZGdlWDIgLSBlZGdlWCkgLSBjMiAqIChlZGdlWTIgLSBlZGdlWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWRnZVggKyAoZWRnZVgyIC0gZWRnZVgpICogdWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWRnZVkgKyAoZWRnZVkyIC0gZWRnZVkpICogdWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzAgPSBpbnB1dFkyIC0gaW5wdXRZLCBjMiA9IGlucHV0WDIgLSBpbnB1dFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWEgPSAoYzIgKiAoZWRnZVkgLSBpbnB1dFkpIC0gYzAgKiAoZWRnZVggLSBpbnB1dFgpKSAvIChjMCAqIChlZGdlWDIgLSBlZGdlWCkgLSBjMiAqIChlZGdlWTIgLSBlZGdlWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWRnZVggKyAoZWRnZVgyIC0gZWRnZVgpICogdWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWRnZVkgKyAoZWRnZVkyIC0gZWRnZVkpICogdWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goaW5wdXRYMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChpbnB1dFkyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dFN0YXJ0ID09IG91dHB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPdXRwdXQubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dHB1dFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBjbGlwcGluZ1ZlcnRpY2VzTGFzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsT3V0cHV0ICE9IG91dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3V0cHV0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvdXRwdXQubGVuZ3RoIC0gMjsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPdXRwdXRbaV0gPSBvdXRwdXRbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPdXRwdXQubGVuZ3RoID0gb3JpZ2luYWxPdXRwdXQubGVuZ3RoIC0gMjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbGlwcGVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkNsaXBwaW5nLm1ha2VDbG9ja3dpc2UgPSBmdW5jdGlvbiAocG9seWdvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbjtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlc2xlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSB2ZXJ0aWNlc1t2ZXJ0aWNlc2xlbmd0aCAtIDJdICogdmVydGljZXNbMV0gLSB2ZXJ0aWNlc1swXSAqIHZlcnRpY2VzW3ZlcnRpY2VzbGVuZ3RoIC0gMV0sIHAxeCA9IDAsIHAxeSA9IDAsIHAyeCA9IDAsIHAyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzbGVuZ3RoIC0gMzsgaSA8IG47IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHAxeCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHAxeSA9IHZlcnRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBwMnggPSB2ZXJ0aWNlc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcDJ5ID0gdmVydGljZXNbaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZWEgKz0gcDF4ICogcDJ5IC0gcDJ4ICogcDF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsYXN0WCA9IHZlcnRpY2VzbGVuZ3RoIC0gMiwgbiA9IHZlcnRpY2VzbGVuZ3RoID4+IDE7IGkgPCBuOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHZlcnRpY2VzW2ldLCB5ID0gdmVydGljZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGxhc3RYIC0gaTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXSA9IHZlcnRpY2VzW290aGVyXTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpICsgMV0gPSB2ZXJ0aWNlc1tvdGhlciArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW290aGVyXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbb3RoZXIgKyAxXSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTa2VsZXRvbkNsaXBwaW5nO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ta2VsZXRvbkNsaXBwaW5nID0gU2tlbGV0b25DbGlwcGluZztcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBTa2VsZXRvbkRhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTa2VsZXRvbkRhdGEoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraW5zID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlrQ29uc3RyYWludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29uc3RyYWludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aENvbnN0cmFpbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kQm9uZSA9IGZ1bmN0aW9uIChib25lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmVOYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm9uZU5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZS5uYW1lID09IGJvbmVOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRCb25lSW5kZXggPSBmdW5jdGlvbiAoYm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib25lTmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvbmVOYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZXNbaV0ubmFtZSA9PSBib25lTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZFNsb3QgPSBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbG90TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNsb3ROYW1lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QubmFtZSA9PSBzbG90TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kU2xvdEluZGV4ID0gZnVuY3Rpb24gKHNsb3ROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbG90TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RzW2ldLm5hbWUgPT0gc2xvdE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRTa2luID0gZnVuY3Rpb24gKHNraW5OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tpbk5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJza2luTmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tpbnMgPSB0aGlzLnNraW5zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBza2lucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbiA9IHNraW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2luLm5hbWUgPT0gc2tpbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBza2luO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50RGF0YU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudERhdGFOYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXZlbnREYXRhTmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfNSA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRfNS5uYW1lID09IGV2ZW50RGF0YU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudF81O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uRGF0YS5wcm90b3R5cGUuZmluZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uTmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFuaW1hdGlvbk5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5uYW1lID09IGFuaW1hdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kSWtDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJhaW50TmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWtDb25zdHJhaW50cyA9IHRoaXMuaWtDb25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaWtDb25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGlrQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kVHJhbnNmb3JtQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUNvbnN0cmFpbnRzID0gdGhpcy50cmFuc2Zvcm1Db25zdHJhaW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJhbnNmb3JtQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB0cmFuc2Zvcm1Db25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludC5uYW1lID09IGNvbnN0cmFpbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RyYWludDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkRhdGEucHJvdG90eXBlLmZpbmRQYXRoQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnROYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhDb25zdHJhaW50cyA9IHRoaXMucGF0aENvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwYXRoQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBwYXRoQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQubmFtZSA9PSBjb25zdHJhaW50TmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25EYXRhLnByb3RvdHlwZS5maW5kUGF0aENvbnN0cmFpbnRJbmRleCA9IGZ1bmN0aW9uIChwYXRoQ29uc3RyYWludE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29uc3RyYWludE5hbWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoQ29uc3RyYWludE5hbWUgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhDb25zdHJhaW50cyA9IHRoaXMucGF0aENvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwYXRoQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoQ29uc3RyYWludHNbaV0ubmFtZSA9PSBwYXRoQ29uc3RyYWludE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2tlbGV0b25EYXRhO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ta2VsZXRvbkRhdGEgPSBTa2VsZXRvbkRhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICBjb3JlLkZBSUxfT05fTk9OX0VYSVNUSU5HX1NLSU4gPSBmYWxzZTtcclxuICAgICAgICB2YXIgU2tlbGV0b25Kc29uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2tlbGV0b25Kc29uKGF0dGFjaG1lbnRMb2FkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rZWRNZXNoZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudExvYWRlciA9IGF0dGFjaG1lbnRMb2FkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnByb3RvdHlwZS5yZWFkU2tlbGV0b25EYXRhID0gZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2tlbGV0b25EYXRhID0gbmV3IGNvcmUuU2tlbGV0b25EYXRhKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHR5cGVvZiAoanNvbikgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbk1hcCA9IHJvb3Quc2tlbGV0b247XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b25NYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5oYXNoID0gc2tlbGV0b25NYXAuaGFzaDtcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEudmVyc2lvbiA9IHNrZWxldG9uTWFwLnNwaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbkRhdGEudmVyc2lvbi5zdWJzdHIoMCwgMykgIT09ICczLjgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IFwiUGl4aUpTIFNwaW5lIHBsdWdpbiBzdXBwb3J0cyBvbmx5IGZvcm1hdCBmb3IgU3BpbmUgMy44LiBZb3VyIG1vZGVsIGhhcyB2ZXJzaW9uIFwiICsgc2tlbGV0b25NYXAuc3BpbmUgKyBcIi4gUGxlYXNlIGxvb2sgaW4gcGl4aS1zcGluZSByZXBvc2l0b3J5IFJFQURNRSBmb3IgYW5vdGhlciBicmFuY2guXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b25EYXRhLnZlcnNpb24gPT09ICczLjguNzUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IFwiVW5zdXBwb3J0ZWQgc2tlbGV0b24gZGF0YSwgMy44Ljc1IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBleHBvcnQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgU3BpbmUuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEueCA9IHNrZWxldG9uTWFwLng7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnkgPSBza2VsZXRvbk1hcC55O1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS53aWR0aCA9IHNrZWxldG9uTWFwLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5oZWlnaHQgPSBza2VsZXRvbk1hcC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmZwcyA9IHNrZWxldG9uTWFwLmZwcztcclxuICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuaW1hZ2VzUGF0aCA9IHNrZWxldG9uTWFwLmltYWdlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb290LmJvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290LmJvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lTWFwID0gcm9vdC5ib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF81ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwicGFyZW50XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50TmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfNSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShwYXJlbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfNSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBib25lIG5vdCBmb3VuZDogXCIgKyBwYXJlbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLkJvbmVEYXRhKHNrZWxldG9uRGF0YS5ib25lcy5sZW5ndGgsIGJvbmVNYXAubmFtZSwgcGFyZW50XzUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJsZW5ndGhcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS54ID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInhcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS55ID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zY2FsZVggPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwic2NhbGVYXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNjYWxlWSA9IHRoaXMuZ2V0VmFsdWUoYm9uZU1hcCwgXCJzY2FsZVlcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2hlYXJYID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNoZWFyWFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zaGVhclkgPSB0aGlzLmdldFZhbHVlKGJvbmVNYXAsIFwic2hlYXJZXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRyYW5zZm9ybU1vZGUgPSBTa2VsZXRvbkpzb24udHJhbnNmb3JtTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInRyYW5zZm9ybVwiLCBcIm5vcm1hbFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpblJlcXVpcmVkID0gdGhpcy5nZXRWYWx1ZShib25lTWFwLCBcInNraW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2VsZXRvbkRhdGEuYm9uZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5zbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5zbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE1hcCA9IHJvb3Quc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90TmFtZSA9IHNsb3RNYXAubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVOYW1lID0gc2xvdE1hcC5ib25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZURhdGEgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9uZURhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsb3QgYm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLlNsb3REYXRhKHNrZWxldG9uRGF0YS5zbG90cy5sZW5ndGgsIHNsb3ROYW1lLCBib25lRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJjb2xvclwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGFyayA9IHRoaXMuZ2V0VmFsdWUoc2xvdE1hcCwgXCJkYXJrXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGFyayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmRhcmtDb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXJrQ29sb3Iuc2V0RnJvbVN0cmluZyhkYXJrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmF0dGFjaG1lbnROYW1lID0gdGhpcy5nZXRWYWx1ZShzbG90TWFwLCBcImF0dGFjaG1lbnRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmxlbmRNb2RlID0gU2tlbGV0b25Kc29uLmJsZW5kTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShzbG90TWFwLCBcImJsZW5kXCIsIFwibm9ybWFsXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNsb3RzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuaWspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QuaWsubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRNYXAgPSByb290LmlrW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLklrQ29uc3RyYWludERhdGEoY29uc3RyYWludE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcmRlciA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJvcmRlclwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5za2luUmVxdWlyZWQgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2tpblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29uc3RyYWludE1hcC5ib25lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVOYW1lID0gY29uc3RyYWludE1hcC5ib25lc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib25lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSUsgYm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXROYW1lID0gY29uc3RyYWludE1hcC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGFyZ2V0ID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKHRhcmdldE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklLIHRhcmdldCBib25lIG5vdCBmb3VuZDogXCIgKyB0YXJnZXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5taXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwibWl4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNvZnRuZXNzID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNvZnRuZXNzXCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmVuZERpcmVjdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJiZW5kUG9zaXRpdmVcIiwgdHJ1ZSkgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcHJlc3MgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwiY29tcHJlc3NcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0cmV0Y2ggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic3RyZXRjaFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudW5pZm9ybSA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJ1bmlmb3JtXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmlrQ29uc3RyYWludHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC50cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QudHJhbnNmb3JtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gcm9vdC50cmFuc2Zvcm1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludERhdGEoY29uc3RyYWludE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vcmRlciA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJvcmRlclwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5za2luUmVxdWlyZWQgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2tpblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29uc3RyYWludE1hcC5ib25lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVOYW1lID0gY29uc3RyYWludE1hcC5ib25lc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib25lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmb3JtIGNvbnN0cmFpbnQgYm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXROYW1lID0gY29uc3RyYWludE1hcC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGFyZ2V0ID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKHRhcmdldE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybSBjb25zdHJhaW50IHRhcmdldCBib25lIG5vdCBmb3VuZDogXCIgKyB0YXJnZXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5sb2NhbCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJsb2NhbFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVsYXRpdmUgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicmVsYXRpdmVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFJvdGF0aW9uID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInJvdGF0aW9uXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwieFwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFkgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwieVwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9mZnNldFNjYWxlWCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzY2FsZVhcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0U2NhbGVZID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNjYWxlWVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRTaGVhclkgPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic2hlYXJZXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdGF0ZU1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGVNaXhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlTWl4ID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInRyYW5zbGF0ZU1peFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zY2FsZU1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzY2FsZU1peFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zaGVhck1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJzaGVhck1peFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLnRyYW5zZm9ybUNvbnN0cmFpbnRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5wYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gcm9vdC5wYXRoW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50RGF0YShjb25zdHJhaW50TWFwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm9yZGVyID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcIm9yZGVyXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNraW5SZXF1aXJlZCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJza2luXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb25zdHJhaW50TWFwLmJvbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZU5hbWUgPSBjb25zdHJhaW50TWFwLmJvbmVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoYm9uZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2Zvcm0gY29uc3RyYWludCBib25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJvbmVzLnB1c2goYm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE5hbWUgPSBjb25zdHJhaW50TWFwLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50YXJnZXQgPSBza2VsZXRvbkRhdGEuZmluZFNsb3QodGFyZ2V0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCB0YXJnZXQgc2xvdCBub3QgZm91bmQ6IFwiICsgdGFyZ2V0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucG9zaXRpb25Nb2RlID0gU2tlbGV0b25Kc29uLnBvc2l0aW9uTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInBvc2l0aW9uTW9kZVwiLCBcInBlcmNlbnRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwYWNpbmdNb2RlID0gU2tlbGV0b25Kc29uLnNwYWNpbmdNb2RlRnJvbVN0cmluZyh0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwic3BhY2luZ01vZGVcIiwgXCJsZW5ndGhcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdGF0ZU1vZGUgPSBTa2VsZXRvbkpzb24ucm90YXRlTW9kZUZyb21TdHJpbmcodGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInJvdGF0ZU1vZGVcIiwgXCJ0YW5nZW50XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRSb3RhdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJwb3NpdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb25Nb2RlID09IGNvcmUuUG9zaXRpb25Nb2RlLkZpeGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zcGFjaW5nID0gdGhpcy5nZXRWYWx1ZShjb25zdHJhaW50TWFwLCBcInNwYWNpbmdcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuTGVuZ3RoIHx8IGRhdGEuc3BhY2luZ01vZGUgPT0gY29yZS5TcGFjaW5nTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BhY2luZyAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3RhdGVNaXggPSB0aGlzLmdldFZhbHVlKGNvbnN0cmFpbnRNYXAsIFwicm90YXRlTWl4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRyYW5zbGF0ZU1peCA9IHRoaXMuZ2V0VmFsdWUoY29uc3RyYWludE1hcCwgXCJ0cmFuc2xhdGVNaXhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5wYXRoQ29uc3RyYWludHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5za2lucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5za2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpbk1hcCA9IHJvb3Quc2tpbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2luID0gbmV3IGNvcmUuU2tpbihza2luTWFwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbk1hcC5ib25lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNraW5NYXAuYm9uZXMubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoc2tpbk1hcC5ib25lc1tpaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib25lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gYm9uZSBub3QgZm91bmQ6IFwiICsgc2tpbk1hcC5ib25lc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5ib25lcy5wdXNoKGJvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2luTWFwLmlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2tpbk1hcC5pay5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uRGF0YS5maW5kSWtDb25zdHJhaW50KHNraW5NYXAuaWtbaWldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIElLIGNvbnN0cmFpbnQgbm90IGZvdW5kOiBcIiArIHNraW5NYXAuaWtbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbk1hcC50cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBza2luTWFwLnRyYW5zZm9ybS5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uRGF0YS5maW5kVHJhbnNmb3JtQ29uc3RyYWludChza2luTWFwLnRyYW5zZm9ybVtpaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gdHJhbnNmb3JtIGNvbnN0cmFpbnQgbm90IGZvdW5kOiBcIiArIHNraW5NYXAudHJhbnNmb3JtW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2luLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraW5NYXAucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNraW5NYXAucGF0aC5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNrZWxldG9uRGF0YS5maW5kUGF0aENvbnN0cmFpbnQoc2tpbk1hcC5wYXRoW2lpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2tpbiBwYXRoIGNvbnN0cmFpbnQgbm90IGZvdW5kOiBcIiArIHNraW5NYXAucGF0aFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpbi5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIHNraW5NYXAuYXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90KHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RNYXAgPSBza2luTWFwLmF0dGFjaG1lbnRzW3Nsb3ROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGVudHJ5TmFtZSBpbiBzbG90TWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLnJlYWRBdHRhY2htZW50KHNsb3RNYXBbZW50cnlOYW1lXSwgc2tpbiwgc2xvdC5pbmRleCwgZW50cnlOYW1lLCBza2VsZXRvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW4uc2V0QXR0YWNobWVudChzbG90LmluZGV4LCBlbnRyeU5hbWUsIGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5za2lucy5wdXNoKHNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpbi5uYW1lID09IFwiZGVmYXVsdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmRlZmF1bHRTa2luID0gc2tpbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMubGlua2VkTWVzaGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rZWRNZXNoID0gdGhpcy5saW5rZWRNZXNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNraW4gPSBsaW5rZWRNZXNoLnNraW4gPT0gbnVsbCA/IHNrZWxldG9uRGF0YS5kZWZhdWx0U2tpbiA6IHNrZWxldG9uRGF0YS5maW5kU2tpbihsaW5rZWRNZXNoLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2luID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNraW4gbm90IGZvdW5kOiBcIiArIGxpbmtlZE1lc2guc2tpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF82ID0gc2tpbi5nZXRBdHRhY2htZW50KGxpbmtlZE1lc2guc2xvdEluZGV4LCBsaW5rZWRNZXNoLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudF82ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBtZXNoIG5vdCBmb3VuZDogXCIgKyBsaW5rZWRNZXNoLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkTWVzaC5tZXNoLmRlZm9ybUF0dGFjaG1lbnQgPSBsaW5rZWRNZXNoLmluaGVyaXREZWZvcm0gPyBwYXJlbnRfNiA6IGxpbmtlZE1lc2gubWVzaDtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rZWRNZXNoLm1lc2guc2V0UGFyZW50TWVzaChwYXJlbnRfNik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZE1lc2hlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJvb3QuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudE1hcCA9IHJvb3QuZXZlbnRzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IGNvcmUuRXZlbnREYXRhKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW50VmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcImludFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mbG9hdFZhbHVlID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJmbG9hdFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdHJpbmdWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwic3RyaW5nXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmF1ZGlvUGF0aCA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiYXVkaW9cIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmF1ZGlvUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnZvbHVtZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwidm9sdW1lXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5iYWxhbmNlID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJiYWxhbmNlXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZWxldG9uRGF0YS5ldmVudHMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYW5pbWF0aW9uTmFtZSBpbiByb290LmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk1hcCA9IHJvb3QuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQW5pbWF0aW9uKGFuaW1hdGlvbk1hcCwgYW5pbWF0aW9uTmFtZSwgc2tlbGV0b25EYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tlbGV0b25EYXRhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucHJvdG90eXBlLnJlYWRBdHRhY2htZW50ID0gZnVuY3Rpb24gKG1hcCwgc2tpbiwgc2xvdEluZGV4LCBuYW1lLCBza2VsZXRvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwibmFtZVwiLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwidHlwZVwiLCBcInJlZ2lvblwiKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWdpb25cIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInBhdGhcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3UmVnaW9uQXR0YWNobWVudChza2luLCBuYW1lLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJ4XCIsIDApICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi55ID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwieVwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uc2NhbGVYID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwic2NhbGVYXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uc2NhbGVZID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwic2NhbGVZXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24ucm90YXRpb24gPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLndpZHRoID0gbWFwLndpZHRoICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5oZWlnaHQgPSBtYXAuaGVpZ2h0ICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvdW5kaW5nYm94XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuYXR0YWNobWVudExvYWRlci5uZXdCb3VuZGluZ0JveEF0dGFjaG1lbnQoc2tpbiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3ggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRWZXJ0aWNlcyhtYXAsIGJveCwgbWFwLnZlcnRleENvdW50IDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJjb2xvclwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmtlZG1lc2hcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInBhdGhcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld01lc2hBdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzaCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImNvbG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gud2lkdGggPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJ3aWR0aFwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmhlaWdodCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcImhlaWdodFwiLCAwKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzcgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJwYXJlbnRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfNyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZE1lc2hlcy5wdXNoKG5ldyBMaW5rZWRNZXNoKG1lc2gsIHRoaXMuZ2V0VmFsdWUobWFwLCBcInNraW5cIiwgbnVsbCksIHNsb3RJbmRleCwgcGFyZW50XzcsIHRoaXMuZ2V0VmFsdWUobWFwLCBcImRlZm9ybVwiLCB0cnVlKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IG1hcC51dnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFZlcnRpY2VzKG1hcCwgbWVzaCwgdXZzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gudHJpYW5nbGVzID0gbWFwLnRyaWFuZ2xlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5yZWdpb25VVnMgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guZWRnZXMgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJlZGdlc1wiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5odWxsTGVuZ3RoID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiaHVsbFwiLCAwKSAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGF0aFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1BhdGhBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguY2xvc2VkID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY2xvc2VkXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jb25zdGFudFNwZWVkID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29uc3RhbnRTcGVlZFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleENvdW50ID0gbWFwLnZlcnRleENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRWZXJ0aWNlcyhtYXAsIHBhdGgsIHZlcnRleENvdW50IDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RocyA9IGNvcmUuVXRpbHMubmV3QXJyYXkodmVydGV4Q291bnQgLyAzLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3Rocy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNbaV0gPSBtYXAubGVuZ3Roc1tpXSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aHMgPSBsZW5ndGhzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJjb2xvclwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmNvbG9yLnNldEZyb21TdHJpbmcoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBvaW50XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1BvaW50QXR0YWNobWVudChza2luLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInhcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHRoaXMuZ2V0VmFsdWUobWFwLCBcInlcIiwgMCkgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucm90YXRpb24gPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQuY29sb3Iuc2V0RnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsaXBwaW5nXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXAgPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Q2xpcHBpbmdBdHRhY2htZW50KHNraW4sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmdldFZhbHVlKG1hcCwgXCJlbmRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBza2VsZXRvbkRhdGEuZmluZFNsb3QoZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xpcHBpbmcgZW5kIHNsb3Qgbm90IGZvdW5kOiBcIiArIGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmVuZFNsb3QgPSBzbG90O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IG1hcC52ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkVmVydGljZXMobWFwLCBjbGlwLCB2ZXJ0ZXhDb3VudCA8PCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRWYWx1ZShtYXAsIFwiY29sb3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC5jb2xvci5zZXRGcm9tU3RyaW5nKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5wcm90b3R5cGUucmVhZFZlcnRpY2VzID0gZnVuY3Rpb24gKG1hcCwgYXR0YWNobWVudCwgdmVydGljZXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LndvcmxkVmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IG1hcC52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc0xlbmd0aCA9PSB2ZXJ0aWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVkVmVydGljZXMgPSBjb3JlLlV0aWxzLnRvRmxvYXRBcnJheSh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlICE9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWRWZXJ0aWNlc1tpXSAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC52ZXJ0aWNlcyA9IHNjYWxlZFZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbjspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZUNvdW50ID0gdmVydGljZXNbaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICBib25lcy5wdXNoKGJvbmVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbm4gPSBpICsgYm9uZUNvdW50ICogNDsgaSA8IG5uOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9uZXMucHVzaCh2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaCh2ZXJ0aWNlc1tpICsgMV0gKiBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaCh2ZXJ0aWNlc1tpICsgMl0gKiBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaCh2ZXJ0aWNlc1tpICsgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuYm9uZXMgPSBib25lcztcclxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQudmVydGljZXMgPSBjb3JlLlV0aWxzLnRvRmxvYXRBcnJheSh3ZWlnaHRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tlbGV0b25Kc29uLnByb3RvdHlwZS5yZWFkQW5pbWF0aW9uID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChtYXAuc2xvdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzbG90TmFtZSBpbiBtYXAuc2xvdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RNYXAgPSBtYXAuc2xvdHNbc2xvdE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdEluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0aW1lbGluZU5hbWUgaW4gc2xvdE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lTWFwID0gc2xvdE1hcFt0aW1lbGluZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PSBcImF0dGFjaG1lbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLkF0dGFjaG1lbnRUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCsrLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRpbWVcIiwgMCksIHZhbHVlTWFwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PSBcImNvbG9yXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Db2xvclRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBuZXcgY29yZS5Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5zZXRGcm9tU3RyaW5nKHZhbHVlTWFwLmNvbG9yIHx8IFwiZmZmZmZmZmZcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLkNvbG9yVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwidHdvQ29sb3JcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLlR3b0NvbG9yVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaWdodCA9IG5ldyBjb3JlLkNvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXJrID0gbmV3IGNvcmUuQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlnaHQuc2V0RnJvbVN0cmluZyh2YWx1ZU1hcC5saWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhcmsuc2V0RnJvbVN0cmluZyh2YWx1ZU1hcC5kYXJrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCBsaWdodC5yLCBsaWdodC5nLCBsaWdodC5iLCBsaWdodC5hLCBkYXJrLnIsIGRhcmsuZywgZGFyay5iKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuVHdvQ29sb3JUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lbGluZSB0eXBlIGZvciBhIHNsb3Q6IFwiICsgdGltZWxpbmVOYW1lICsgXCIgKFwiICsgc2xvdE5hbWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmJvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYm9uZU5hbWUgaW4gbWFwLmJvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib25lTWFwID0gbWFwLmJvbmVzW2JvbmVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmVJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZUluZGV4KGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvbmVJbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdGltZWxpbmVOYW1lIGluIGJvbmVNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1hcCA9IGJvbmVNYXBbdGltZWxpbmVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT09IFwicm90YXRlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5Sb3RhdGVUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmJvbmVJbmRleCA9IGJvbmVJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lbGluZU1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXAgPSB0aW1lbGluZU1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcImFuZ2xlXCIsIDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuUm90YXRlVGltZWxpbmUuRU5UUklFU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZWxpbmVOYW1lID09PSBcInRyYW5zbGF0ZVwiIHx8IHRpbWVsaW5lTmFtZSA9PT0gXCJzY2FsZVwiIHx8IHRpbWVsaW5lTmFtZSA9PT0gXCJzaGVhclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVTY2FsZSA9IDEsIGRlZmF1bHRWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJzY2FsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuU2NhbGVUaW1lbGluZSh0aW1lbGluZU1hcC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT09IFwic2hlYXJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgY29yZS5TaGVhclRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuVHJhbnNsYXRlVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ4XCIsIGRlZmF1bHRWYWx1ZSksIHkgPSB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInlcIiwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCB4ICogdGltZWxpbmVTY2FsZSwgeSAqIHRpbWVsaW5lU2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZSh2YWx1ZU1hcCwgdGltZWxpbmUsIGZyYW1lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogY29yZS5UcmFuc2xhdGVUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lbGluZSB0eXBlIGZvciBhIGJvbmU6IFwiICsgdGltZWxpbmVOYW1lICsgXCIgKFwiICsgYm9uZU5hbWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29uc3RyYWludE5hbWUgaW4gbWFwLmlrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gbWFwLmlrW2NvbnN0cmFpbnROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBza2VsZXRvbkRhdGEuZmluZElrQ29uc3RyYWludChjb25zdHJhaW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLklrQ29uc3RyYWludFRpbWVsaW5lKGNvbnN0cmFpbnRNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuaWtDb25zdHJhaW50SW5kZXggPSBza2VsZXRvbkRhdGEuaWtDb25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludE1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gY29uc3RyYWludE1hcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJtaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwic29mdG5lc3NcIiwgMCkgKiBzY2FsZSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJiZW5kUG9zaXRpdmVcIiwgdHJ1ZSkgPyAxIDogLTEsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwiY29tcHJlc3NcIiwgZmFsc2UpLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInN0cmV0Y2hcIiwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEN1cnZlKHZhbHVlTWFwLCB0aW1lbGluZSwgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbKHRpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDEpICogY29yZS5Ja0NvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC50cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb25zdHJhaW50TmFtZSBpbiBtYXAudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50TWFwID0gbWFwLnRyYW5zZm9ybVtjb25zdHJhaW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tlbGV0b25EYXRhLmZpbmRUcmFuc2Zvcm1Db25zdHJhaW50KGNvbnN0cmFpbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludFRpbWVsaW5lKGNvbnN0cmFpbnRNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUudHJhbnNmb3JtQ29uc3RyYWludEluZGV4ID0gc2tlbGV0b25EYXRhLnRyYW5zZm9ybUNvbnN0cmFpbnRzLmluZGV4T2YoY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50TWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXAgPSBjb25zdHJhaW50TWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInJvdGF0ZU1peFwiLCAxKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0cmFuc2xhdGVNaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwic2NhbGVNaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwic2hlYXJNaXhcIiwgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1sodGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMSkgKiBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnRUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29uc3RyYWludE5hbWUgaW4gbWFwLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRNYXAgPSBtYXAucGF0aFtjb25zdHJhaW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNrZWxldG9uRGF0YS5maW5kUGF0aENvbnN0cmFpbnRJbmRleChjb25zdHJhaW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggY29uc3RyYWludCBub3QgZm91bmQ6IFwiICsgY29uc3RyYWludE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNrZWxldG9uRGF0YS5wYXRoQ29uc3RyYWludHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0aW1lbGluZU5hbWUgaW4gY29uc3RyYWludE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lTWFwID0gY29uc3RyYWludE1hcFt0aW1lbGluZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJwb3NpdGlvblwiIHx8IHRpbWVsaW5lTmFtZSA9PT0gXCJzcGFjaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNjYWxlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09PSBcInNwYWNpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50U3BhY2luZ1RpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNwYWNpbmdNb2RlID09IGNvcmUuU3BhY2luZ01vZGUuTGVuZ3RoIHx8IGRhdGEuc3BhY2luZ01vZGUgPT0gY29yZS5TcGFjaW5nTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IGNvcmUuUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lKHRpbWVsaW5lTWFwLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uTW9kZSA9PSBjb3JlLlBvc2l0aW9uTW9kZS5GaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUucGF0aENvbnN0cmFpbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVsaW5lTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcCA9IHRpbWVsaW5lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB0aGlzLmdldFZhbHVlKHZhbHVlTWFwLCBcInRpbWVcIiwgMCksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIHRpbWVsaW5lTmFtZSwgMCkgKiB0aW1lbGluZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuUGF0aENvbnN0cmFpbnRQb3NpdGlvblRpbWVsaW5lLkVOVFJJRVNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVsaW5lTmFtZSA9PT0gXCJtaXhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IG5ldyBjb3JlLlBhdGhDb25zdHJhaW50TWl4VGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5wYXRoQ29uc3RyYWludEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidGltZVwiLCAwKSwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJyb3RhdGVNaXhcIiwgMSksIHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwidHJhbnNsYXRlTWl4XCIsIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ3VydmUodmFsdWVNYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzWyh0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxKSAqIGNvcmUuUGF0aENvbnN0cmFpbnRNaXhUaW1lbGluZS5FTlRSSUVTXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmRlZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGRlZm9ybU5hbWUgaW4gbWFwLmRlZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmb3JtTWFwID0gbWFwLmRlZm9ybVtkZWZvcm1OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNraW4gPSBza2VsZXRvbkRhdGEuZmluZFNraW4oZGVmb3JtTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2luID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLkZBSUxfT05fTk9OX0VYSVNUSU5HX1NLSU4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTa2luIG5vdCBmb3VuZDogXCIgKyBkZWZvcm1OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIGRlZm9ybU1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RNYXAgPSBkZWZvcm1NYXBbc2xvdE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90SW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xvdCBub3QgZm91bmQ6IFwiICsgc2xvdE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpbWVsaW5lTmFtZSBpbiBzbG90TWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lTWFwID0gc2xvdE1hcFt0aW1lbGluZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgdGltZWxpbmVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZvcm0gYXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgdGltZWxpbmVNYXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodGVkID0gYXR0YWNobWVudC5ib25lcyAhPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGF0dGFjaG1lbnQudmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZm9ybUxlbmd0aCA9IHdlaWdodGVkID8gdmVydGljZXMubGVuZ3RoIC8gMyAqIDIgOiB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuRGVmb3JtVGltZWxpbmUodGltZWxpbmVNYXAubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGltZWxpbmVNYXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwID0gdGltZWxpbmVNYXBbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZvcm0gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlc1ZhbHVlID0gdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ2ZXJ0aWNlc1wiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybSA9IHdlaWdodGVkID8gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KGRlZm9ybUxlbmd0aCkgOiB2ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm0gPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoZGVmb3JtTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VmFsdWUodmFsdWVNYXAsIFwib2Zmc2V0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodmVydGljZXNWYWx1ZSwgMCwgZGVmb3JtLCBzdGFydCwgdmVydGljZXNWYWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlICE9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIG4gPSBpICsgdmVydGljZXNWYWx1ZS5sZW5ndGg7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm9ybVtpXSAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2VpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZm9ybUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZvcm1baV0gKz0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdGhpcy5nZXRWYWx1ZSh2YWx1ZU1hcCwgXCJ0aW1lXCIsIDApLCBkZWZvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDdXJ2ZSh2YWx1ZU1hcCwgdGltZWxpbmUsIGZyYW1lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlck5vZGUgPSBtYXAuZHJhd09yZGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdPcmRlck5vZGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBkcmF3T3JkZXJOb2RlID0gbWFwLmRyYXdvcmRlcjtcclxuICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXJOb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBuZXcgY29yZS5EcmF3T3JkZXJUaW1lbGluZShkcmF3T3JkZXJOb2RlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RDb3VudCA9IHNrZWxldG9uRGF0YS5zbG90cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZHJhd09yZGVyTm9kZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd09yZGVyTWFwID0gZHJhd09yZGVyTm9kZVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdPcmRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5nZXRWYWx1ZShkcmF3T3JkZXJNYXAsIFwib2Zmc2V0c1wiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyID0gY29yZS5VdGlscy5uZXdBcnJheShzbG90Q291bnQsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmNoYW5nZWQgPSBjb3JlLlV0aWxzLm5ld0FycmF5KHNsb3RDb3VudCAtIG9mZnNldHMubGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0gMCwgdW5jaGFuZ2VkSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldE1hcCA9IG9mZnNldHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KG9mZnNldE1hcC5zbG90KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdEluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbG90IG5vdCBmb3VuZDogXCIgKyBvZmZzZXRNYXAuc2xvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsSW5kZXggIT0gc2xvdEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNoYW5nZWRbdW5jaGFuZ2VkSW5kZXgrK10gPSBvcmlnaW5hbEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09yZGVyW29yaWdpbmFsSW5kZXggKyBvZmZzZXRNYXAub2Zmc2V0XSA9IG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4IDwgc2xvdENvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZFt1bmNoYW5nZWRJbmRleCsrXSA9IG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzbG90Q291bnQgLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhd09yZGVyW2ldID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3JkZXJbaV0gPSB1bmNoYW5nZWRbLS11bmNoYW5nZWRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCsrLCB0aGlzLmdldFZhbHVlKGRyYXdPcmRlck1hcCwgXCJ0aW1lXCIsIDApLCBkcmF3T3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXAuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gbmV3IGNvcmUuRXZlbnRUaW1lbGluZShtYXAuZXZlbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRNYXAgPSBtYXAuZXZlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnREYXRhID0gc2tlbGV0b25EYXRhLmZpbmRFdmVudChldmVudE1hcC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbm90IGZvdW5kOiBcIiArIGV2ZW50TWFwLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfNiA9IG5ldyBjb3JlLkV2ZW50KGNvcmUuVXRpbHMudG9TaW5nbGVQcmVjaXNpb24odGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJ0aW1lXCIsIDApKSwgZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNi5pbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiaW50XCIsIGV2ZW50RGF0YS5pbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzYuZmxvYXRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiZmxvYXRcIiwgZXZlbnREYXRhLmZsb2F0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudF82LnN0cmluZ1ZhbHVlID0gdGhpcy5nZXRWYWx1ZShldmVudE1hcCwgXCJzdHJpbmdcIiwgZXZlbnREYXRhLnN0cmluZ1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzYuZGF0YS5hdWRpb1BhdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfNi52b2x1bWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50TWFwLCBcInZvbHVtZVwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzYuYmFsYW5jZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnRNYXAsIFwiYmFsYW5jZVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4KyssIGV2ZW50XzYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdGltZWxpbmUuZnJhbWVzW3RpbWVsaW5lLmdldEZyYW1lQ291bnQoKSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihkdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB3aGlsZSBwYXJzaW5nIGFuaW1hdGlvbiwgZHVyYXRpb24gaXMgTmFOXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25EYXRhLmFuaW1hdGlvbnMucHVzaChuZXcgY29yZS5BbmltYXRpb24obmFtZSwgdGltZWxpbmVzLCBkdXJhdGlvbikpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucHJvdG90eXBlLnJlYWRDdXJ2ZSA9IGZ1bmN0aW9uIChtYXAsIHRpbWVsaW5lLCBmcmFtZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5oYXNPd25Qcm9wZXJ0eShcImN1cnZlXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChtYXAuY3VydmUgPT09IFwic3RlcHBlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldFN0ZXBwZWQoZnJhbWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSBtYXAuY3VydmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0Q3VydmUoZnJhbWVJbmRleCwgY3VydmUsIHRoaXMuZ2V0VmFsdWUobWFwLCBcImMyXCIsIDApLCB0aGlzLmdldFZhbHVlKG1hcCwgXCJjM1wiLCAxKSwgdGhpcy5nZXRWYWx1ZShtYXAsIFwiYzRcIiwgMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKG1hcCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwW3Byb3BdICE9PSB1bmRlZmluZWQgPyBtYXBbcHJvcF0gOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5ibGVuZE1vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibm9ybWFsXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuQmxlbmRNb2RlLk5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJhZGRpdGl2ZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLkJsZW5kTW9kZS5BZGRpdGl2ZTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJtdWx0aXBseVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLkJsZW5kTW9kZS5NdWx0aXBseTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJzY3JlZW5cIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5CbGVuZE1vZGUuU2NyZWVuO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBibGVuZCBtb2RlOiBcIiArIHN0cik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5wb3NpdGlvbk1vZGVGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwiZml4ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5Qb3NpdGlvbk1vZGUuRml4ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwicGVyY2VudFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlBvc2l0aW9uTW9kZS5QZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb3NpdGlvbiBtb2RlOiBcIiArIHN0cik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNrZWxldG9uSnNvbi5zcGFjaW5nTW9kZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJsZW5ndGhcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5TcGFjaW5nTW9kZS5MZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwiZml4ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5TcGFjaW5nTW9kZS5GaXhlZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJwZXJjZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuU3BhY2luZ01vZGUuUGVyY2VudDtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcG9zaXRpb24gbW9kZTogXCIgKyBzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24ucm90YXRlTW9kZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJ0YW5nZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuUm90YXRlTW9kZS5UYW5nZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcImNoYWluXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuUm90YXRlTW9kZS5DaGFpbjtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJjaGFpbnNjYWxlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuUm90YXRlTW9kZS5DaGFpblNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3RhdGUgbW9kZTogXCIgKyBzdHIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2VsZXRvbkpzb24udHJhbnNmb3JtTW9kZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJub3JtYWxcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5UcmFuc2Zvcm1Nb2RlLk5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJvbmx5dHJhbnNsYXRpb25cIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5UcmFuc2Zvcm1Nb2RlLk9ubHlUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gXCJub3JvdGF0aW9ub3JyZWZsZWN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVHJhbnNmb3JtTW9kZS5Ob1JvdGF0aW9uT3JSZWZsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBcIm5vc2NhbGVcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5UcmFuc2Zvcm1Nb2RlLk5vU2NhbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IFwibm9zY2FsZW9ycmVmbGVjdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlRyYW5zZm9ybU1vZGUuTm9TY2FsZU9yUmVmbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNmb3JtIG1vZGU6IFwiICsgc3RyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrZWxldG9uSnNvbjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2tlbGV0b25Kc29uID0gU2tlbGV0b25Kc29uO1xyXG4gICAgICAgIHZhciBMaW5rZWRNZXNoID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTGlua2VkTWVzaChtZXNoLCBza2luLCBzbG90SW5kZXgsIHBhcmVudCwgaW5oZXJpdERlZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoID0gbWVzaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbiA9IHNraW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmhlcml0RGVmb3JtID0gaW5oZXJpdERlZm9ybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTGlua2VkTWVzaDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFNraW5FbnRyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNraW5FbnRyeShzbG90SW5kZXgsIG5hbWUsIGF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFNraW5FbnRyeTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2tpbkVudHJ5ID0gU2tpbkVudHJ5O1xyXG4gICAgICAgIHZhciBTa2luID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2tpbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmVzID0gQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLnNldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdEluZGV4LCBuYW1lLCBhdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGFjaG1lbnQgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnRzID0gdGhpcy5hdHRhY2htZW50cztcclxuICAgICAgICAgICAgICAgIGlmIChzbG90SW5kZXggPj0gYXR0YWNobWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzLmxlbmd0aCA9IHNsb3RJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF0dGFjaG1lbnRzW3Nsb3RJbmRleF0pXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHNbc2xvdEluZGV4XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHNbc2xvdEluZGV4XVtuYW1lXSA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLmFkZFNraW4gPSBmdW5jdGlvbiAoc2tpbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBza2luLmJvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBza2luLmJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYm9uZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9uZXNbal0gPT0gYm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvbmVzLnB1c2goYm9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNraW4uY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IHNraW4uY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50c1tqXSA9PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IHNraW4uZ2V0QXR0YWNobWVudHMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0YWNobWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IGF0dGFjaG1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0YWNobWVudChhdHRhY2htZW50LnNsb3RJbmRleCwgYXR0YWNobWVudC5uYW1lLCBhdHRhY2htZW50LmF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5jb3B5U2tpbiA9IGZ1bmN0aW9uIChza2luKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNraW4uYm9uZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IHNraW4uYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5ib25lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib25lc1tqXSA9PSBib25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMucHVzaChib25lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2tpbi5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gc2tpbi5jb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzW2pdID09IGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnRzID0gc2tpbi5nZXRBdHRhY2htZW50cygpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRhY2htZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gYXR0YWNobWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQuYXR0YWNobWVudCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5hdHRhY2htZW50IGluc3RhbmNlb2YgY29yZS5NZXNoQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmF0dGFjaG1lbnQgPSBhdHRhY2htZW50LmF0dGFjaG1lbnQubmV3TGlua2VkTWVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dGFjaG1lbnQoYXR0YWNobWVudC5zbG90SW5kZXgsIGF0dGFjaG1lbnQubmFtZSwgYXR0YWNobWVudC5hdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQuYXR0YWNobWVudC5jb3B5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0YWNobWVudChhdHRhY2htZW50LnNsb3RJbmRleCwgYXR0YWNobWVudC5uYW1lLCBhdHRhY2htZW50LmF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tpbi5wcm90b3R5cGUuZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChzbG90SW5kZXgsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5hdHRhY2htZW50c1tzbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpY3Rpb25hcnkgPyBkaWN0aW9uYXJ5W25hbWVdIDogbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2tpbi5wcm90b3R5cGUucmVtb3ZlQXR0YWNobWVudCA9IGZ1bmN0aW9uIChzbG90SW5kZXgsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5hdHRhY2htZW50c1tzbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpY3Rpb25hcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGljdGlvbmFyeVtuYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLmdldEF0dGFjaG1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRhY2htZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90QXR0YWNobWVudHMgPSB0aGlzLmF0dGFjaG1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90QXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZV80IGluIHNsb3RBdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudHNbbmFtZV80XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChuZXcgU2tpbkVudHJ5KGksIG5hbWVfNCwgYXR0YWNobWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLmdldEF0dGFjaG1lbnRzRm9yU2xvdCA9IGZ1bmN0aW9uIChzbG90SW5kZXgsIGF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdEF0dGFjaG1lbnRzID0gdGhpcy5hdHRhY2htZW50c1tzbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3RBdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfNSBpbiBzbG90QXR0YWNobWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90QXR0YWNobWVudHNbbmFtZV81XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50cy5wdXNoKG5ldyBTa2luRW50cnkoc2xvdEluZGV4LCBuYW1lXzUsIGF0dGFjaG1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNraW4ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTa2luLnByb3RvdHlwZS5hdHRhY2hBbGwgPSBmdW5jdGlvbiAoc2tlbGV0b24sIG9sZFNraW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5zbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RBdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RBdHRhY2htZW50ICYmIHNsb3RJbmRleCA8IG9sZFNraW4uYXR0YWNobWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gb2xkU2tpbi5hdHRhY2htZW50c1tzbG90SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNraW5BdHRhY2htZW50ID0gZGljdGlvbmFyeVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RBdHRhY2htZW50ID09IHNraW5BdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzbG90SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNraW47XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlNraW4gPSBTa2luO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFNsb3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTbG90KGRhdGEsIGJvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmb3JtID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgY2Fubm90IGJlIG51bGwuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvbmUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib25lIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvbmUgPSBib25lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhcmtDb2xvciA9IGRhdGEuZGFya0NvbG9yID09IG51bGwgPyBudWxsIDogbmV3IGNvcmUuQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJsZW5kTW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTbG90LnByb3RvdHlwZS5nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNobWVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2xvdC5wcm90b3R5cGUuc2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChhdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRhY2htZW50ID09IGF0dGFjaG1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudFRpbWUgPSB0aGlzLmJvbmUuc2tlbGV0b24udGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmb3JtLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNsb3QucHJvdG90eXBlLnNldEF0dGFjaG1lbnRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudFRpbWUgPSB0aGlzLmJvbmUuc2tlbGV0b24udGltZSAtIHRpbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNsb3QucHJvdG90eXBlLmdldEF0dGFjaG1lbnRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9uZS5za2VsZXRvbi50aW1lIC0gdGhpcy5hdHRhY2htZW50VGltZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2xvdC5wcm90b3R5cGUuc2V0VG9TZXR1cFBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmRhdGEuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGFya0NvbG9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXJrQ29sb3Iuc2V0RnJvbUNvbG9yKHRoaXMuZGF0YS5kYXJrQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5hdHRhY2htZW50TmFtZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0YWNobWVudCh0aGlzLmJvbmUuc2tlbGV0b24uZ2V0QXR0YWNobWVudCh0aGlzLmRhdGEuaW5kZXgsIHRoaXMuZGF0YS5hdHRhY2htZW50TmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2xvdDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2xvdCA9IFNsb3Q7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgU2xvdERhdGEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTbG90RGF0YShpbmRleCwgbmFtZSwgYm9uZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggbXVzdCBiZSA+PSAwLlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9uZURhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib25lRGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lRGF0YSA9IGJvbmVEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTbG90RGF0YTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuU2xvdERhdGEgPSBTbG90RGF0YTtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBUZXh0dXJlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dHVyZShpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGV4dHVyZS5maWx0ZXJGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGV4dC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTmVhcmVzdDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGluZWFyXCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLkxpbmVhcjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlwbWFwXCI6IHJldHVybiBUZXh0dXJlRmlsdGVyLk1pcE1hcDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlwbWFwbmVhcmVzdG5lYXJlc3RcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTmVhcmVzdE5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pcG1hcGxpbmVhcm5lYXJlc3RcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTGluZWFyTmVhcmVzdDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlwbWFwbmVhcmVzdGxpbmVhclwiOiByZXR1cm4gVGV4dHVyZUZpbHRlci5NaXBNYXBOZWFyZXN0TGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtaXBtYXBsaW5lYXJsaW5lYXJcIjogcmV0dXJuIFRleHR1cmVGaWx0ZXIuTWlwTWFwTGluZWFyTGluZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGV4dHVyZSBmaWx0ZXIgXCIgKyB0ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGV4dHVyZS53cmFwRnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtaXJyb3JlZHRlcGVhdFwiOiByZXR1cm4gVGV4dHVyZVdyYXAuTWlycm9yZWRSZXBlYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYW1wdG9lZGdlXCI6IHJldHVybiBUZXh0dXJlV3JhcC5DbGFtcFRvRWRnZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0XCI6IHJldHVybiBUZXh0dXJlV3JhcC5SZXBlYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZXh0dXJlIHdyYXAgXCIgKyB0ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlRleHR1cmUgPSBUZXh0dXJlO1xyXG4gICAgICAgIHZhciBUZXh0dXJlRmlsdGVyO1xyXG4gICAgICAgIChmdW5jdGlvbiAoVGV4dHVyZUZpbHRlcikge1xyXG4gICAgICAgICAgICBUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJOZWFyZXN0XCJdID0gOTcyOF0gPSBcIk5lYXJlc3RcIjtcclxuICAgICAgICAgICAgVGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTGluZWFyXCJdID0gOTcyOV0gPSBcIkxpbmVhclwiO1xyXG4gICAgICAgICAgICBUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJNaXBNYXBcIl0gPSA5OTg3XSA9IFwiTWlwTWFwXCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVGaWx0ZXJbVGV4dHVyZUZpbHRlcltcIk1pcE1hcE5lYXJlc3ROZWFyZXN0XCJdID0gOTk4NF0gPSBcIk1pcE1hcE5lYXJlc3ROZWFyZXN0XCI7XHJcbiAgICAgICAgICAgIFRleHR1cmVGaWx0ZXJbVGV4dHVyZUZpbHRlcltcIk1pcE1hcExpbmVhck5lYXJlc3RcIl0gPSA5OTg1XSA9IFwiTWlwTWFwTGluZWFyTmVhcmVzdFwiO1xyXG4gICAgICAgICAgICBUZXh0dXJlRmlsdGVyW1RleHR1cmVGaWx0ZXJbXCJNaXBNYXBOZWFyZXN0TGluZWFyXCJdID0gOTk4Nl0gPSBcIk1pcE1hcE5lYXJlc3RMaW5lYXJcIjtcclxuICAgICAgICAgICAgVGV4dHVyZUZpbHRlcltUZXh0dXJlRmlsdGVyW1wiTWlwTWFwTGluZWFyTGluZWFyXCJdID0gOTk4N10gPSBcIk1pcE1hcExpbmVhckxpbmVhclwiO1xyXG4gICAgICAgIH0pKFRleHR1cmVGaWx0ZXIgPSBjb3JlLlRleHR1cmVGaWx0ZXIgfHwgKGNvcmUuVGV4dHVyZUZpbHRlciA9IHt9KSk7XHJcbiAgICAgICAgdmFyIFRleHR1cmVXcmFwO1xyXG4gICAgICAgIChmdW5jdGlvbiAoVGV4dHVyZVdyYXApIHtcclxuICAgICAgICAgICAgVGV4dHVyZVdyYXBbVGV4dHVyZVdyYXBbXCJNaXJyb3JlZFJlcGVhdFwiXSA9IDMzNjQ4XSA9IFwiTWlycm9yZWRSZXBlYXRcIjtcclxuICAgICAgICAgICAgVGV4dHVyZVdyYXBbVGV4dHVyZVdyYXBbXCJDbGFtcFRvRWRnZVwiXSA9IDMzMDcxXSA9IFwiQ2xhbXBUb0VkZ2VcIjtcclxuICAgICAgICAgICAgVGV4dHVyZVdyYXBbVGV4dHVyZVdyYXBbXCJSZXBlYXRcIl0gPSAxMDQ5N10gPSBcIlJlcGVhdFwiO1xyXG4gICAgICAgIH0pKFRleHR1cmVXcmFwID0gY29yZS5UZXh0dXJlV3JhcCB8fCAoY29yZS5UZXh0dXJlV3JhcCA9IHt9KSk7XHJcbiAgICAgICAgdmFyIFRleHR1cmVSZWdpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZXh0dXJlUmVnaW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUElYSS5WRVJTSU9OWzBdID09ICczJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LmNyb3Aud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXgudHJpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LnRyaW0ud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgub3JpZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy50ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQSVhJLlZFUlNJT05bMF0gPT0gJzMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXguY3JvcC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXgudHJpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LnRyaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4Lm9yaWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwidVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLl91dnMueDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJ2XCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuX3V2cy55MDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInUyXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuX3V2cy54MjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInYyXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmUuX3V2cy55MjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcIm9mZnNldFhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4LnRyaW0gPyB0ZXgudHJpbS54IDogMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcIm9mZnNldFlcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRpb24gV2FybmluZzogQEhhY2tlcmhhbTogSSBndWVzcywgaWYgeW91IGFyZSB1c2luZyBQSVhJLVNQSU5FIEFUTEFTIHJlZ2lvbi5vZmZzZXRZLCB5b3Ugd2FudCBhIHRleHR1cmUsIHJpZ2h0PyBVc2UgcmVnaW9uLnRleHR1cmUgZnJvbSBub3cgb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwaW5lT2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInBpeGlPZmZzZXRZXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC50cmltID8gdGV4LnRyaW0ueSA6IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJzcGluZU9mZnNldFlcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEhlaWdodCAtIHRoaXMuaGVpZ2h0IC0gKHRleC50cmltID8gdGV4LnRyaW0ueSA6IDApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwib3JpZ2luYWxXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy50ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQSVhJLlZFUlNJT05bMF0gPT0gJzMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXgudHJpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC50cmltLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXguY3JvcC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC5vcmlnLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwib3JpZ2luYWxIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUElYSS5WRVJTSU9OWzBdID09ICczJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4LnRyaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXgudHJpbS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC5jcm9wLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleC5vcmlnLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVSZWdpb24ucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5mcmFtZS54O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVJlZ2lvbi5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlLmZyYW1lLnk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlUmVnaW9uLnByb3RvdHlwZSwgXCJyb3RhdGVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5yb3RhdGUgIT09IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlUmVnaW9uO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5UZXh0dXJlUmVnaW9uID0gVGV4dHVyZVJlZ2lvbjtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBUZXh0dXJlQXRsYXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZXh0dXJlQXRsYXMoYXRsYXNUZXh0LCB0ZXh0dXJlTG9hZGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpb25zID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXRsYXNUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTcGluZUF0bGFzKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlciwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhcy5wcm90b3R5cGUuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uIChuYW1lLCB0ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFnZXMgPSB0aGlzLnBhZ2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlc1tpXS5iYXNlVGV4dHVyZSA9PT0gdGV4dHVyZS5iYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlID0gcGFnZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYWdlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZSA9IG5ldyBUZXh0dXJlQXRsYXNQYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5uYW1lID0gJ3RleHR1cmVQYWdlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2Uud2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5oZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLm1pbkZpbHRlciA9IHBhZ2UubWFnRmlsdGVyID0gY29yZS5UZXh0dXJlRmlsdGVyLk5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS51V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuQ2xhbXBUb0VkZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS52V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuQ2xhbXBUb0VkZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZXMucHVzaChwYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSBuZXcgVGV4dHVyZUF0bGFzUmVnaW9uKCk7XHJcbiAgICAgICAgICAgICAgICByZWdpb24ubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICByZWdpb24ucGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgICAgICAgICByZWdpb24udGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICByZWdpb24uaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9ucy5wdXNoKHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaW9uO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXMucHJvdG90eXBlLmFkZFRleHR1cmVIYXNoID0gZnVuY3Rpb24gKHRleHR1cmVzLCBzdHJpcEV4dGVuc2lvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUZXh0dXJlKHN0cmlwRXh0ZW5zaW9uICYmIGtleS5pbmRleE9mKCcuJykgIT09IC0xID8ga2V5LnN1YnN0cigwLCBrZXkubGFzdEluZGV4T2YoJy4nKSkgOiBrZXksIHRleHR1cmVzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGV4dHVyZUF0bGFzLnByb3RvdHlwZS5hZGRTcGluZUF0bGFzID0gZnVuY3Rpb24gKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlciwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWQoYXRsYXNUZXh0LCB0ZXh0dXJlTG9hZGVyLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhdGxhc1RleHQsIHRleHR1cmVMb2FkZXIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmVMb2FkZXIgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlTG9hZGVyIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgVGV4dHVyZUF0bGFzUmVhZGVyKGF0bGFzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0ZVBhcnNlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHJlYWRlci5yZWFkTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXBhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBuZXcgVGV4dHVyZUF0bGFzUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5uYW1lID0gbGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucmVhZFR1cGxlKHR1cGxlKSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS53aWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLmhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5taW5GaWx0ZXIgPSBjb3JlLlRleHR1cmUuZmlsdGVyRnJvbVN0cmluZyh0dXBsZVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLm1hZ0ZpbHRlciA9IGNvcmUuVGV4dHVyZS5maWx0ZXJGcm9tU3RyaW5nKHR1cGxlWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZWFkZXIucmVhZFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnVXcmFwID0gY29yZS5UZXh0dXJlV3JhcC5DbGFtcFRvRWRnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UudldyYXAgPSBjb3JlLlRleHR1cmVXcmFwLkNsYW1wVG9FZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcInhcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnVXcmFwID0gY29yZS5UZXh0dXJlV3JhcC5SZXBlYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT0gXCJ5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS52V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuUmVwZWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieHlcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnVXcmFwID0gcGFnZS52V3JhcCA9IGNvcmUuVGV4dHVyZVdyYXAuUmVwZWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUxvYWRlcihsaW5lLCBmdW5jdGlvbiAodGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VzLnNwbGljZShfdGhpcy5wYWdlcy5pbmRleE9mKHBhZ2UpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLmJhc2VUZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHR1cmUudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5zZXRTaXplKHBhZ2Uud2lkdGgsIHBhZ2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFnZXMucHVzaChwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnNldEZpbHRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhZ2Uud2lkdGggfHwgIXBhZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2Uud2lkdGggPSB0ZXh0dXJlLnJlYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5oZWlnaHQgPSB0ZXh0dXJlLnJlYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFnZS53aWR0aCB8fCAhcGFnZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1Igc3BpbmUgYXRsYXMgcGFnZSBcIiArIHBhZ2UubmFtZSArIFwiOiBtZXNoZXMgd29udCB3b3JrIGlmIHlvdSBkb250IHNwZWNpZnkgc2l6ZSBpbiBhdGxhcyAoaHR0cDovL3d3dy5odG1sNWdhbWVkZXZzLmNvbS90b3BpYy8xODg4OC1waXhpLXNwaW5lcy1hbmQtbWVzaGVzLz9wPTEwNzEyMSlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZVBhcnNlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlcy5wdXNoKHBhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gbmV3IFRleHR1cmVBdGxhc1JlZ2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLm5hbWUgPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZVZhbHVlID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlVmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3RhdGVWYWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09IFwiZmFsc2VcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSAoKDcyMCAtIHBhcnNlRmxvYXQocm90YXRlVmFsdWUpKSAlIDM2MCkgLyA0NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludCh0dXBsZVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHR1cGxlWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VJbnQodHVwbGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gcGFnZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAvPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAvPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggLz0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAvPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN3YXBXSCA9IHJvdGF0ZSAlIDQgIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSh4LCB5LCBzd2FwV0ggPyBoZWlnaHQgOiB3aWR0aCwgc3dhcFdIID8gd2lkdGggOiBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBwYXJzZUludCh0dXBsZVsxXSkgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IHBhcnNlSW50KHR1cGxlWzBdKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IHBhcnNlSW50KHR1cGxlWzFdKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCBvcmlnaW5hbFdpZHRoLCBvcmlnaW5hbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IG5ldyBQSVhJLlJlY3RhbmdsZShvZmZzZXRYLCBvcmlnaW5hbEhlaWdodCAtIGhlaWdodCAtIG9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBJWEkuVkVSU0lPTlswXSAhPSAnMycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24udGV4dHVyZSA9IG5ldyBQSVhJLlRleHR1cmUocmVnaW9uLnBhZ2UuYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCByb3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lMiA9IG5ldyBQSVhJLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JvcCA9IGZyYW1lMi5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0ud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0uaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUgPSBuZXcgUElYSS5UZXh0dXJlKHJlZ2lvbi5wYWdlLmJhc2VUZXh0dXJlLCBmcmFtZTIsIGNyb3AsIHRyaW0sIHJvdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb24uaW5kZXggPSBwYXJzZUludChyZWFkZXIucmVhZFZhbHVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUudXBkYXRlVXZzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpb25zLnB1c2gocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRlUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhcy5wcm90b3R5cGUuZmluZFJlZ2lvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lvbnNbaV0ubmFtZSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZXNbaV0uYmFzZVRleHR1cmUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZUF0bGFzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5UZXh0dXJlQXRsYXMgPSBUZXh0dXJlQXRsYXM7XHJcbiAgICAgICAgdmFyIFRleHR1cmVBdGxhc1JlYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRleHR1cmVBdGxhc1JlYWRlcih0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhc1JlYWRlci5wcm90b3R5cGUucmVhZExpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLmxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVzW3RoaXMuaW5kZXgrK107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRleHR1cmVBdGxhc1JlYWRlci5wcm90b3R5cGUucmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnJlYWRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9uID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGluZTogXCIgKyBsaW5lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpLnRyaW0oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGV4dHVyZUF0bGFzUmVhZGVyLnByb3RvdHlwZS5yZWFkVHVwbGUgPSBmdW5jdGlvbiAodHVwbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKFwiOlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvbiA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxpbmU6IFwiICsgbGluZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGxhc3RNYXRjaCA9IGNvbG9uICsgMTtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hID0gbGluZS5pbmRleE9mKFwiLFwiLCBsYXN0TWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYSA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVbaV0gPSBsaW5lLnN1YnN0cihsYXN0TWF0Y2gsIGNvbW1hIC0gbGFzdE1hdGNoKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1hdGNoID0gY29tbWEgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHVwbGVbaV0gPSBsaW5lLnN1YnN0cmluZyhsYXN0TWF0Y2gpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmVBdGxhc1JlYWRlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHZhciBUZXh0dXJlQXRsYXNQYWdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dHVyZUF0bGFzUGFnZSgpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZXh0dXJlQXRsYXNQYWdlLnByb3RvdHlwZS5zZXRGaWx0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09IGNvcmUuVGV4dHVyZUZpbHRlci5MaW5lYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXguc2NhbGVNb2RlID0gUElYSS5TQ0FMRV9NT0RFUy5MSU5FQVI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1pbkZpbHRlciA9PSBjb3JlLlRleHR1cmVGaWx0ZXIuTmVhcmVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleC5zY2FsZU1vZGUgPSBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXgubWlwbWFwID0gUElYSS5NSVBNQVBfTU9ERVMuUE9XMjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09IGNvcmUuVGV4dHVyZUZpbHRlci5NaXBNYXBOZWFyZXN0TmVhcmVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXguc2NhbGVNb2RlID0gUElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4LnNjYWxlTW9kZSA9IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmVBdGxhc1BhZ2U7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlRleHR1cmVBdGxhc1BhZ2UgPSBUZXh0dXJlQXRsYXNQYWdlO1xyXG4gICAgICAgIHZhciBUZXh0dXJlQXRsYXNSZWdpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVGV4dHVyZUF0bGFzUmVnaW9uLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZXh0dXJlQXRsYXNSZWdpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmVBdGxhc1JlZ2lvbjtcclxuICAgICAgICB9KGNvcmUuVGV4dHVyZVJlZ2lvbikpO1xyXG4gICAgICAgIGNvcmUuVGV4dHVyZUF0bGFzUmVnaW9uID0gVGV4dHVyZUF0bGFzUmVnaW9uO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFRyYW5zZm9ybUNvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1Db25zdHJhaW50KGRhdGEsIHNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlTWl4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wID0gbmV3IGNvcmUuVmVjdG9yMigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tlbGV0b24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJza2VsZXRvbiBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVNaXggPSBkYXRhLnJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlTWl4ID0gZGF0YS50cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlTWl4ID0gZGF0YS5zY2FsZU1peDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlYXJNaXggPSBkYXRhLnNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib25lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmJvbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMucHVzaChza2VsZXRvbi5maW5kQm9uZShkYXRhLmJvbmVzW2ldLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gc2tlbGV0b24uZmluZEJvbmUoZGF0YS50YXJnZXQubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sb2NhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGEucmVsYXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlSZWxhdGl2ZUxvY2FsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QWJzb2x1dGVMb2NhbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5yZWxhdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVJlbGF0aXZlV29ybGQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBYnNvbHV0ZVdvcmxkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5QWJzb2x1dGVXb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXgsIHNjYWxlTWl4ID0gdGhpcy5zY2FsZU1peCwgc2hlYXJNaXggPSB0aGlzLnNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldE1hdCA9IHRhcmdldC5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGEgPSB0YXJnZXRNYXQuYSwgdGIgPSB0YXJnZXRNYXQuYywgdGMgPSB0YXJnZXRNYXQuYiwgdGQgPSB0YXJnZXRNYXQuZDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWdSYWRSZWZsZWN0ID0gdGEgKiB0ZCAtIHRiICogdGMgPiAwID8gY29yZS5NYXRoVXRpbHMuZGVnUmFkIDogLWNvcmUuTWF0aFV0aWxzLmRlZ1JhZDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRSb3RhdGlvbiA9IHRoaXMuZGF0YS5vZmZzZXRSb3RhdGlvbiAqIGRlZ1JhZFJlZmxlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0U2hlYXJZID0gdGhpcy5kYXRhLm9mZnNldFNoZWFyWSAqIGRlZ1JhZFJlZmxlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBtYXQuYSwgYiA9IG1hdC5jLCBjID0gbWF0LmIsIGQgPSBtYXQuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmF0YW4yKHRjLCB0YSkgLSBNYXRoLmF0YW4yKGMsIGEpICsgb2Zmc2V0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIC09IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociA8IC1jb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByICo9IHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHIpLCBzaW4gPSBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmEgPSBjb3MgKiBhIC0gc2luICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmMgPSBjb3MgKiBiIC0gc2luICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgPSBzaW4gKiBhICsgY29zICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgPSBzaW4gKiBiICsgY29zICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sb2NhbFRvV29ybGQodGVtcC5zZXQodGhpcy5kYXRhLm9mZnNldFgsIHRoaXMuZGF0YS5vZmZzZXRZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC50eCArPSAodGVtcC54IC0gbWF0LnR4KSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LnR5ICs9ICh0ZW1wLnkgLSBtYXQudHkpICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZU1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQobWF0LmEgKiBtYXQuYSArIG1hdC5iICogbWF0LmIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHMgPSBNYXRoLnNxcnQodGEgKiB0YSArIHRjICogdGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gKHMgKyAodHMgLSBzICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWCkgKiBzY2FsZU1peCkgLyBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYSAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYiAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5zcXJ0KG1hdC5jICogbWF0LmMgKyBtYXQuZCAqIG1hdC5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSBNYXRoLnNxcnQodGIgKiB0YiArIHRkICogdGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gKHMgKyAodHMgLSBzICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWSkgKiBzY2FsZU1peCkgLyBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYyAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuZCAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVhck1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBtYXQuYywgZCA9IG1hdC5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnkgPSBNYXRoLmF0YW4yKGQsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGguYXRhbjIodGQsIHRiKSAtIE1hdGguYXRhbjIodGMsIHRhKSAtIChieSAtIE1hdGguYXRhbjIobWF0LmIsIG1hdC5hKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIC09IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociA8IC1jb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYnkgKyAociArIG9mZnNldFNoZWFyWSkgKiBzaGVhck1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoYiAqIGIgKyBkICogZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5jID0gTWF0aC5jb3MocikgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuZCA9IE1hdGguc2luKHIpICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuYXBwbGllZFZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5UmVsYXRpdmVXb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXgsIHNjYWxlTWl4ID0gdGhpcy5zY2FsZU1peCwgc2hlYXJNaXggPSB0aGlzLnNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldE1hdCA9IHRhcmdldC5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGEgPSB0YXJnZXRNYXQuYSwgdGIgPSB0YXJnZXRNYXQuYywgdGMgPSB0YXJnZXRNYXQuYiwgdGQgPSB0YXJnZXRNYXQuZDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWdSYWRSZWZsZWN0ID0gdGEgKiB0ZCAtIHRiICogdGMgPiAwID8gY29yZS5NYXRoVXRpbHMuZGVnUmFkIDogLWNvcmUuTWF0aFV0aWxzLmRlZ1JhZDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRSb3RhdGlvbiA9IHRoaXMuZGF0YS5vZmZzZXRSb3RhdGlvbiAqIGRlZ1JhZFJlZmxlY3QsIG9mZnNldFNoZWFyWSA9IHRoaXMuZGF0YS5vZmZzZXRTaGVhclkgKiBkZWdSYWRSZWZsZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZU1peCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbWF0LmEsIGIgPSBtYXQuYywgYyA9IG1hdC5iLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5hdGFuMih0YywgdGEpICsgb2Zmc2V0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gY29yZS5NYXRoVXRpbHMuUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIC09IGNvcmUuTWF0aFV0aWxzLlBJMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociA8IC1jb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByICo9IHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHIpLCBzaW4gPSBNYXRoLnNpbihyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmEgPSBjb3MgKiBhIC0gc2luICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmMgPSBjb3MgKiBiIC0gc2luICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmIgPSBzaW4gKiBhICsgY29zICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0LmQgPSBzaW4gKiBiICsgY29zICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWl4ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sb2NhbFRvV29ybGQodGVtcC5zZXQodGhpcy5kYXRhLm9mZnNldFgsIHRoaXMuZGF0YS5vZmZzZXRZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC50eCArPSB0ZW1wLnggKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC50eSArPSB0ZW1wLnkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlTWl4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IChNYXRoLnNxcnQodGEgKiB0YSArIHRjICogdGMpIC0gMSArIHRoaXMuZGF0YS5vZmZzZXRTY2FsZVgpICogc2NhbGVNaXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYSAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuYiAqPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gKE1hdGguc3FydCh0YiAqIHRiICsgdGQgKiB0ZCkgLSAxICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWSkgKiBzY2FsZU1peCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5jICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5kICo9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoZWFyTWl4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGguYXRhbjIodGQsIHRiKSAtIE1hdGguYXRhbjIodGMsIHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPiBjb3JlLk1hdGhVdGlscy5QSSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgLT0gY29yZS5NYXRoVXRpbHMuUEkyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyIDwgLWNvcmUuTWF0aFV0aWxzLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBjb3JlLk1hdGhVdGlscy5QSTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gbWF0LmMsIGQgPSBtYXQuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IE1hdGguYXRhbjIoZCwgYikgKyAociAtIGNvcmUuTWF0aFV0aWxzLlBJIC8gMiArIG9mZnNldFNoZWFyWSkgKiBzaGVhck1peDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoYiAqIGIgKyBkICogZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdC5jID0gTWF0aC5jb3MocikgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQuZCA9IE1hdGguc2luKHIpICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUuYXBwbGllZFZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybUNvbnN0cmFpbnQucHJvdG90eXBlLmFwcGx5QWJzb2x1dGVMb2NhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVNaXggPSB0aGlzLnJvdGF0ZU1peCwgdHJhbnNsYXRlTWl4ID0gdGhpcy50cmFuc2xhdGVNaXgsIHNjYWxlTWl4ID0gdGhpcy5zY2FsZU1peCwgc2hlYXJNaXggPSB0aGlzLnNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuYXBwbGllZFZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGVBcHBsaWVkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYm9uZS5hcHBsaWVkVmFsaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbmUudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IGJvbmUuYXJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGVNaXggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRhcmdldC5hcm90YXRpb24gLSByb3RhdGlvbiArIHRoaXMuZGF0YS5vZmZzZXRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIgLyAzNjApIHwgMCkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiArPSByICogcm90YXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGJvbmUuYXgsIHkgPSBib25lLmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGVNaXggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9ICh0YXJnZXQuYXggLSB4ICsgdGhpcy5kYXRhLm9mZnNldFgpICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9ICh0YXJnZXQuYXkgLSB5ICsgdGhpcy5kYXRhLm9mZnNldFkpICogdHJhbnNsYXRlTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gYm9uZS5hc2NhbGVYLCBzY2FsZVkgPSBib25lLmFzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlTWl4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVYID4gMC4wMDAwMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9IChzY2FsZVggKyAodGFyZ2V0LmFzY2FsZVggLSBzY2FsZVggKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVYKSAqIHNjYWxlTWl4KSAvIHNjYWxlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlWSA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSAoc2NhbGVZICsgKHRhcmdldC5hc2NhbGVZIC0gc2NhbGVZICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWSkgKiBzY2FsZU1peCkgLyBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGVhclkgPSBib25lLmFzaGVhclk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoZWFyTWl4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRhcmdldC5hc2hlYXJZIC0gc2hlYXJZICsgdGhpcy5kYXRhLm9mZnNldFNoZWFyWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAtPSAoMTYzODQgLSAoKDE2Mzg0LjQ5OTk5OTk5OTk5NiAtIHIgLyAzNjApIHwgMCkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnNoZWFyWSArPSByICogc2hlYXJNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHgsIHksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSwgYm9uZS5hc2hlYXJYLCBzaGVhclkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1Db25zdHJhaW50LnByb3RvdHlwZS5hcHBseVJlbGF0aXZlTG9jYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlTWl4ID0gdGhpcy5yb3RhdGVNaXgsIHRyYW5zbGF0ZU1peCA9IHRoaXMudHJhbnNsYXRlTWl4LCBzY2FsZU1peCA9IHRoaXMuc2NhbGVNaXgsIHNoZWFyTWl4ID0gdGhpcy5zaGVhck1peDtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmFwcGxpZWRWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlQXBwbGllZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvbmVzID0gdGhpcy5ib25lcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvbmUgPSBib25lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvbmUuYXBwbGllZFZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib25lLnVwZGF0ZUFwcGxpZWRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBib25lLmFyb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlTWl4ICE9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uICs9ICh0YXJnZXQuYXJvdGF0aW9uICsgdGhpcy5kYXRhLm9mZnNldFJvdGF0aW9uKSAqIHJvdGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGJvbmUuYXgsIHkgPSBib25lLmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGVNaXggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9ICh0YXJnZXQuYXggKyB0aGlzLmRhdGEub2Zmc2V0WCkgKiB0cmFuc2xhdGVNaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gKHRhcmdldC5heSArIHRoaXMuZGF0YS5vZmZzZXRZKSAqIHRyYW5zbGF0ZU1peDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IGJvbmUuYXNjYWxlWCwgc2NhbGVZID0gYm9uZS5hc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZU1peCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlWCA+IDAuMDAwMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVggKj0gKCh0YXJnZXQuYXNjYWxlWCAtIDEgKyB0aGlzLmRhdGEub2Zmc2V0U2NhbGVYKSAqIHNjYWxlTWl4KSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZVkgPiAwLjAwMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZICo9ICgodGFyZ2V0LmFzY2FsZVkgLSAxICsgdGhpcy5kYXRhLm9mZnNldFNjYWxlWSkgKiBzY2FsZU1peCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hlYXJZID0gYm9uZS5hc2hlYXJZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVhck1peCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWFyWSArPSAodGFyZ2V0LmFzaGVhclkgKyB0aGlzLmRhdGEub2Zmc2V0U2hlYXJZKSAqIHNoZWFyTWl4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmUudXBkYXRlV29ybGRUcmFuc2Zvcm1XaXRoKHgsIHksIHJvdGF0aW9uLCBzY2FsZVgsIHNjYWxlWSwgYm9uZS5hc2hlYXJYLCBzaGVhclkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtQ29uc3RyYWludDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVHJhbnNmb3JtQ29uc3RyYWludCA9IFRyYW5zZm9ybUNvbnN0cmFpbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgVHJhbnNmb3JtQ29uc3RyYWludERhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhbnNmb3JtQ29uc3RyYWludERhdGEsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybUNvbnN0cmFpbnREYXRhKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIDAsIGZhbHNlKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYm9uZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJvdGF0ZU1peCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2xhdGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbGVNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hlYXJNaXggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Um90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldFNjYWxlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXRTY2FsZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0U2hlYXJZID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbGF0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2NhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1Db25zdHJhaW50RGF0YTtcclxuICAgICAgICB9KGNvcmUuQ29uc3RyYWludERhdGEpKTtcclxuICAgICAgICBjb3JlLlRyYW5zZm9ybUNvbnN0cmFpbnREYXRhID0gVHJhbnNmb3JtQ29uc3RyYWludERhdGE7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgVHJpYW5ndWxhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJpYW5ndWxhdG9yKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXhQb2x5Z29ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXhQb2x5Z29uc0luZGljZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc0FycmF5ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29uY2F2ZUFycmF5ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWFuZ2xlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uUG9vbCA9IG5ldyBjb3JlLlBvb2woZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5Z29uSW5kaWNlc1Bvb2wgPSBuZXcgY29yZS5Qb29sKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmlhbmd1bGF0b3IucHJvdG90eXBlLnRyaWFuZ3VsYXRlID0gZnVuY3Rpb24gKHZlcnRpY2VzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHZlcnRpY2VzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCA+PiAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXNBcnJheTtcclxuICAgICAgICAgICAgICAgIGluZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0NvbmNhdmUgPSB0aGlzLmlzQ29uY2F2ZUFycmF5O1xyXG4gICAgICAgICAgICAgICAgaXNDb25jYXZlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRleENvdW50OyBpIDwgbjsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uY2F2ZVtpXSA9IFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUoaSwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcztcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZlcnRleENvdW50ID4gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHZlcnRleENvdW50IC0gMSwgaSA9IDAsIG5leHQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyOiBpZiAoIWlzQ29uY2F2ZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gaW5kaWNlc1twcmV2aW91c10gPDwgMSwgcDIgPSBpbmRpY2VzW2ldIDw8IDEsIHAzID0gaW5kaWNlc1tuZXh0XSA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxeCA9IHZlcnRpY2VzW3AxXSwgcDF5ID0gdmVydGljZXNbcDEgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMnggPSB2ZXJ0aWNlc1twMl0sIHAyeSA9IHZlcnRpY2VzW3AyICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcDN4ID0gdmVydGljZXNbcDNdLCBwM3kgPSB2ZXJ0aWNlc1twMyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAobmV4dCArIDEpICUgdmVydGV4Q291bnQ7IGlpICE9IHByZXZpb3VzOyBpaSA9IChpaSArIDEpICUgdmVydGV4Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29uY2F2ZVtpaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gaW5kaWNlc1tpaV0gPDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnggPSB2ZXJ0aWNlc1t2XSwgdnkgPSB2ZXJ0aWNlc1t2ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRvci5wb3NpdGl2ZUFyZWEocDN4LCBwM3ksIHAxeCwgcDF5LCB2eCwgdnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhKHAxeCwgcDF5LCBwMngsIHAyeSwgdngsIHZ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRvci5wb3NpdGl2ZUFyZWEocDJ4LCBwMnksIHAzeCwgcDN5LCB2eCwgdnkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDb25jYXZlW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpID4gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gKG5leHQgKyAxKSAlIHZlcnRleENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChpbmRpY2VzWyh2ZXJ0ZXhDb3VudCArIGkgLSAxKSAlIHZlcnRleENvdW50XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaW5kaWNlc1soaSArIDEpICUgdmVydGV4Q291bnRdKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbmNhdmUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleENvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSAodmVydGV4Q291bnQgKyBpIC0gMSkgJSB2ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gaSA9PSB2ZXJ0ZXhDb3VudCA/IDAgOiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uY2F2ZVtwcmV2aW91c0luZGV4XSA9IFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUocHJldmlvdXNJbmRleCwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbmNhdmVbbmV4dEluZGV4XSA9IFRyaWFuZ3VsYXRvci5pc0NvbmNhdmUobmV4dEluZGV4LCB2ZXJ0ZXhDb3VudCwgdmVydGljZXMsIGluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRleENvdW50ID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChpbmRpY2VzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChpbmRpY2VzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChpbmRpY2VzWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmlhbmdsZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRvci5wcm90b3R5cGUuZGVjb21wb3NlID0gZnVuY3Rpb24gKHZlcnRpY2VzQXJyYXksIHRyaWFuZ2xlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gdmVydGljZXNBcnJheTtcclxuICAgICAgICAgICAgICAgIHZhciBjb252ZXhQb2x5Z29ucyA9IHRoaXMuY29udmV4UG9seWdvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25Qb29sLmZyZWVBbGwoY29udmV4UG9seWdvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29udmV4UG9seWdvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBjb252ZXhQb2x5Z29uc0luZGljZXMgPSB0aGlzLmNvbnZleFBvbHlnb25zSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbkluZGljZXNQb29sLmZyZWVBbGwoY29udmV4UG9seWdvbnNJbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgIGNvbnZleFBvbHlnb25zSW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25JbmRpY2VzID0gdGhpcy5wb2x5Z29uSW5kaWNlc1Bvb2wub2J0YWluKCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLnBvbHlnb25Qb29sLm9idGFpbigpO1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhbkJhc2VJbmRleCA9IC0xLCBsYXN0V2luZGluZyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBuOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSB0cmlhbmdsZXNbaV0gPDwgMSwgdDIgPSB0cmlhbmdsZXNbaSArIDFdIDw8IDEsIHQzID0gdHJpYW5nbGVzW2kgKyAyXSA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHZlcnRpY2VzW3QxXSwgeTEgPSB2ZXJ0aWNlc1t0MSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IHZlcnRpY2VzW3QyXSwgeTIgPSB2ZXJ0aWNlc1t0MiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MyA9IHZlcnRpY2VzW3QzXSwgeTMgPSB2ZXJ0aWNlc1t0MyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFuQmFzZUluZGV4ID09IHQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gcG9seWdvbi5sZW5ndGggLSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZGluZzEgPSBUcmlhbmd1bGF0b3Iud2luZGluZyhwb2x5Z29uW29dLCBwb2x5Z29uW28gKyAxXSwgcG9seWdvbltvICsgMl0sIHBvbHlnb25bbyArIDNdLCB4MywgeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZGluZzIgPSBUcmlhbmd1bGF0b3Iud2luZGluZyh4MywgeTMsIHBvbHlnb25bMF0sIHBvbHlnb25bMV0sIHBvbHlnb25bMl0sIHBvbHlnb25bM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZGluZzEgPT0gbGFzdFdpbmRpbmcgJiYgd2luZGluZzIgPT0gbGFzdFdpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaCh4Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMucHVzaCh0Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVyZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZleFBvbHlnb25zLnB1c2gocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29uc0luZGljZXMucHVzaChwb2x5Z29uSW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25Qb29sLmZyZWUocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbHlnb25JbmRpY2VzUG9vbC5mcmVlKHBvbHlnb25JbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5wb2x5Z29uUG9vbC5vYnRhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcyA9IHRoaXMucG9seWdvbkluZGljZXNQb29sLm9idGFpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcy5wdXNoKHQxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMucHVzaCh0Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25JbmRpY2VzLnB1c2godDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0V2luZGluZyA9IFRyaWFuZ3VsYXRvci53aW5kaW5nKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYW5CYXNlSW5kZXggPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udmV4UG9seWdvbnMucHVzaChwb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29uc0luZGljZXMucHVzaChwb2x5Z29uSW5kaWNlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNvbnZleFBvbHlnb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25JbmRpY2VzID0gY29udmV4UG9seWdvbnNJbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uSW5kaWNlcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSBwb2x5Z29uSW5kaWNlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gcG9seWdvbkluZGljZXNbcG9seWdvbkluZGljZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IGNvbnZleFBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gcG9seWdvbi5sZW5ndGggLSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2UHJldlggPSBwb2x5Z29uW29dLCBwcmV2UHJldlkgPSBwb2x5Z29uW28gKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlggPSBwb2x5Z29uW28gKyAyXSwgcHJldlkgPSBwb2x5Z29uW28gKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RYID0gcG9seWdvblswXSwgZmlyc3RZID0gcG9seWdvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kWCA9IHBvbHlnb25bMl0sIHNlY29uZFkgPSBwb2x5Z29uWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kaW5nID0gVHJpYW5ndWxhdG9yLndpbmRpbmcocHJldlByZXZYLCBwcmV2UHJldlksIHByZXZYLCBwcmV2WSwgZmlyc3RYLCBmaXJzdFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpaSA9PSBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckluZGljZXMgPSBjb252ZXhQb2x5Z29uc0luZGljZXNbaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJJbmRpY2VzLmxlbmd0aCAhPSAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckZpcnN0SW5kZXggPSBvdGhlckluZGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclNlY29uZEluZGV4ID0gb3RoZXJJbmRpY2VzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJMYXN0SW5kZXggPSBvdGhlckluZGljZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclBvbHkgPSBjb252ZXhQb2x5Z29uc1tpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4MyA9IG90aGVyUG9seVtvdGhlclBvbHkubGVuZ3RoIC0gMl0sIHkzID0gb3RoZXJQb2x5W290aGVyUG9seS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRmlyc3RJbmRleCAhPSBmaXJzdEluZGV4IHx8IG90aGVyU2Vjb25kSW5kZXggIT0gbGFzdEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW5kaW5nMSA9IFRyaWFuZ3VsYXRvci53aW5kaW5nKHByZXZQcmV2WCwgcHJldlByZXZZLCBwcmV2WCwgcHJldlksIHgzLCB5Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW5kaW5nMiA9IFRyaWFuZ3VsYXRvci53aW5kaW5nKHgzLCB5MywgZmlyc3RYLCBmaXJzdFksIHNlY29uZFgsIHNlY29uZFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZGluZzEgPT0gd2luZGluZyAmJiB3aW5kaW5nMiA9PSB3aW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlclBvbHkubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVySW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHgzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaCh5Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uSW5kaWNlcy5wdXNoKG90aGVyTGFzdEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQcmV2WCA9IHByZXZYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlByZXZZID0gcHJldlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2WCA9IHgzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlkgPSB5MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb252ZXhQb2x5Z29ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24gPSBjb252ZXhQb2x5Z29uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXhQb2x5Z29ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9seWdvblBvb2wuZnJlZShwb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkluZGljZXMgPSBjb252ZXhQb2x5Z29uc0luZGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZleFBvbHlnb25zSW5kaWNlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9seWdvbkluZGljZXNQb29sLmZyZWUocG9seWdvbkluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXhQb2x5Z29ucztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdG9yLmlzQ29uY2F2ZSA9IGZ1bmN0aW9uIChpbmRleCwgdmVydGV4Q291bnQsIHZlcnRpY2VzLCBpbmRpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRpY2VzWyh2ZXJ0ZXhDb3VudCArIGluZGV4IC0gMSkgJSB2ZXJ0ZXhDb3VudF0gPDwgMTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5kaWNlc1tpbmRleF0gPDwgMTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaW5kaWNlc1soaW5kZXggKyAxKSAlIHZlcnRleENvdW50XSA8PCAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLnBvc2l0aXZlQXJlYSh2ZXJ0aWNlc1twcmV2aW91c10sIHZlcnRpY2VzW3ByZXZpb3VzICsgMV0sIHZlcnRpY2VzW2N1cnJlbnRdLCB2ZXJ0aWNlc1tjdXJyZW50ICsgMV0sIHZlcnRpY2VzW25leHRdLCB2ZXJ0aWNlc1tuZXh0ICsgMV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0b3IucG9zaXRpdmVBcmVhID0gZnVuY3Rpb24gKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwMXggKiAocDN5IC0gcDJ5KSArIHAyeCAqIChwMXkgLSBwM3kpICsgcDN4ICogKHAyeSAtIHAxeSkgPj0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdG9yLndpbmRpbmcgPSBmdW5jdGlvbiAocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gcDJ4IC0gcDF4LCBweSA9IHAyeSAtIHAxeTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwM3ggKiBweSAtIHAzeSAqIHB4ICsgcHggKiBwMXkgLSBwMXggKiBweSA+PSAwID8gMSA6IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVHJpYW5ndWxhdG9yO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5Ucmlhbmd1bGF0b3IgPSBUcmlhbmd1bGF0b3I7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgSW50U2V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSW50U2V0KCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEludFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbnMgPSB0aGlzLmNvbnRhaW5zKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlbdmFsdWUgfCAwXSA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhY29udGFpbnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEludFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5W3ZhbHVlIHwgMF0gIT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBJbnRTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVt2YWx1ZSB8IDBdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBJbnRTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSW50U2V0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5JbnRTZXQgPSBJbnRTZXQ7XHJcbiAgICAgICAgdmFyIENvbG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ29sb3IociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IHZvaWQgMCkgeyByID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGcgPT09IHZvaWQgMCkgeyBnID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGIgPT09IHZvaWQgMCkgeyBiID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkgeyBhID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yID0gcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDb2xvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IucHJvdG90eXBlLnNldEZyb21Db2xvciA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBjLnI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgPSBjLmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBjLmI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmEgPSBjLmE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IucHJvdG90eXBlLnNldEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoaGV4KSB7XHJcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguY2hhckF0KDApID09ICcjJyA/IGhleC5zdWJzdHIoMSkgOiBoZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNikgLyAyNTUuMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoMiwgMiksIDE2KSAvIDI1NS4wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoaGV4LnN1YnN0cig0LCAyKSwgMTYpIC8gMjU1LjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmEgPSAoaGV4Lmxlbmd0aCAhPSA4ID8gMjU1IDogcGFyc2VJbnQoaGV4LnN1YnN0cig2LCAyKSwgMTYpKSAvIDI1NS4wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yICs9IHI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmcgKz0gZztcclxuICAgICAgICAgICAgICAgIHRoaXMuYiArPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hICs9IGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IucHJvdG90eXBlLmNsYW1wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuciA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuciA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yID0gMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmcgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IDA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmcgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZyA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5iID4gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmIgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYSA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDb2xvci5yZ2JhODg4OFRvQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvci5yID0gKCh2YWx1ZSAmIDB4ZmYwMDAwMDApID4+PiAyNCkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjb2xvci5nID0gKCh2YWx1ZSAmIDB4MDBmZjAwMDApID4+PiAxNikgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjb2xvci5iID0gKCh2YWx1ZSAmIDB4MDAwMGZmMDApID4+PiA4KSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIGNvbG9yLmEgPSAoKHZhbHVlICYgMHgwMDAwMDBmZikpIC8gMjU1O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBDb2xvci5yZ2I4ODhUb0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IuciA9ICgodmFsdWUgJiAweDAwZmYwMDAwKSA+Pj4gMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY29sb3IuZyA9ICgodmFsdWUgJiAweDAwMDBmZjAwKSA+Pj4gOCkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBjb2xvci5iID0gKCh2YWx1ZSAmIDB4MDAwMDAwZmYpKSAvIDI1NTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29sb3IuV0hJVEUgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgIENvbG9yLlJFRCA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTtcclxuICAgICAgICAgICAgQ29sb3IuR1JFRU4gPSBuZXcgQ29sb3IoMCwgMSwgMCwgMSk7XHJcbiAgICAgICAgICAgIENvbG9yLkJMVUUgPSBuZXcgQ29sb3IoMCwgMCwgMSwgMSk7XHJcbiAgICAgICAgICAgIENvbG9yLk1BR0VOVEEgPSBuZXcgQ29sb3IoMSwgMCwgMSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuQ29sb3IgPSBDb2xvcjtcclxuICAgICAgICB2YXIgTWF0aFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTWF0aFV0aWxzKCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5jbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5jb3NEZWcgPSBmdW5jdGlvbiAoZGVncmVlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY29zKGRlZ3JlZXMgKiBNYXRoVXRpbHMuZGVnUmFkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnNpbkRlZyA9IGZ1bmN0aW9uIChkZWdyZWVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oZGVncmVlcyAqIE1hdGhVdGlscy5kZWdSYWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuc2lnbnVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IHZhbHVlIDwgMCA/IC0xIDogMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnRvSW50ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4ID4gMCA/IE1hdGguZmxvb3IoeCkgOiBNYXRoLmNlaWwoeCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5jYnJ0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4IDwgMCA/IC15IDogeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnJhbmRvbVRyaWFuZ3VsYXIgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMucmFuZG9tVHJpYW5ndWxhcldpdGgobWluLCBtYXgsIChtaW4gKyBtYXgpICogMC41KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnJhbmRvbVRyaWFuZ3VsYXJXaXRoID0gZnVuY3Rpb24gKG1pbiwgbWF4LCBtb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgICAgIGlmICh1IDw9IChtb2RlIC0gbWluKSAvIGQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguc3FydCh1ICogZCAqIChtb2RlIC0gbWluKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4IC0gTWF0aC5zcXJ0KCgxIC0gdSkgKiBkICogKG1heCAtIG1vZGUpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLlBJID0gMy4xNDE1OTI3O1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuUEkyID0gTWF0aFV0aWxzLlBJICogMjtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLnJhZGlhbnNUb0RlZ3JlZXMgPSAxODAgLyBNYXRoVXRpbHMuUEk7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5yYWREZWcgPSBNYXRoVXRpbHMucmFkaWFuc1RvRGVncmVlcztcclxuICAgICAgICAgICAgTWF0aFV0aWxzLmRlZ3JlZXNUb1JhZGlhbnMgPSBNYXRoVXRpbHMuUEkgLyAxODA7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5kZWdSYWQgPSBNYXRoVXRpbHMuZGVncmVlc1RvUmFkaWFucztcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuTWF0aFV0aWxzID0gTWF0aFV0aWxzO1xyXG4gICAgICAgIHZhciBJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbigpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdGhpcy5hcHBseUludGVybmFsKGEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XHJcbiAgICAgICAgdmFyIFBvdyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQb3csIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvdyhwb3dlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIF90aGlzLnBvd2VyID0gMjtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBvd2VyID0gcG93ZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUG93LnByb3RvdHlwZS5hcHBseUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhIDw9IDAuNSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coYSAqIDIsIHRoaXMucG93ZXIpIC8gMjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygoYSAtIDEpICogMiwgdGhpcy5wb3dlcikgLyAodGhpcy5wb3dlciAlIDIgPT0gMCA/IC0yIDogMikgKyAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUG93O1xyXG4gICAgICAgIH0oSW50ZXJwb2xhdGlvbikpO1xyXG4gICAgICAgIGNvcmUuUG93ID0gUG93O1xyXG4gICAgICAgIHZhciBQb3dPdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUG93T3V0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQb3dPdXQocG93ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwb3dlcikgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQb3dPdXQucHJvdG90eXBlLmFwcGx5SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGEgLSAxLCB0aGlzLnBvd2VyKSAqICh0aGlzLnBvd2VyICUgMiA9PSAwID8gLTEgOiAxKSArIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBQb3dPdXQ7XHJcbiAgICAgICAgfShQb3cpKTtcclxuICAgICAgICBjb3JlLlBvd091dCA9IFBvd091dDtcclxuICAgICAgICB2YXIgVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBVdGlscygpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBVdGlscy5hcnJheUNvcHkgPSBmdW5jdGlvbiAoc291cmNlLCBzb3VyY2VTdGFydCwgZGVzdCwgZGVzdFN0YXJ0LCBudW1FbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNvdXJjZVN0YXJ0LCBqID0gZGVzdFN0YXJ0OyBpIDwgc291cmNlU3RhcnQgKyBudW1FbGVtZW50czsgaSsrLCBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0W2pdID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5zZXRBcnJheVNpemUgPSBmdW5jdGlvbiAoYXJyYXksIHNpemUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDA7IH1cclxuICAgICAgICAgICAgICAgIHZhciBvbGRTaXplID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFNpemUgPT0gc2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFNpemUgPCBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9sZFNpemU7IGkgPCBzaXplOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFV0aWxzLmVuc3VyZUFycmF5Q2FwYWNpdHkgPSBmdW5jdGlvbiAoYXJyYXksIHNpemUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gc2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMuc2V0QXJyYXlTaXplKGFycmF5LCBzaXplLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFV0aWxzLm5ld0FycmF5ID0gZnVuY3Rpb24gKHNpemUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFV0aWxzLm5ld0Zsb2F0QXJyYXkgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLlNVUFBPUlRTX1RZUEVEX0FSUkFZUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2ldID0gMDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFV0aWxzLm5ld1Nob3J0QXJyYXkgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLlNVUFBPUlRTX1RZUEVEX0FSUkFZUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShzaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy50b0Zsb2F0QXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMgPyBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSA6IGFycmF5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy50b1NpbmdsZVByZWNpc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLlNVUFBPUlRTX1RZUEVEX0FSUkFZUyA/IE1hdGguZnJvdW5kKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy53ZWJraXQ2MDJCdWdmaXhIZWxwZXIgPSBmdW5jdGlvbiAoYWxwaGEsIGJsZW5kKSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFV0aWxzLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFycmF5LCBlbGVtZW50LCBpZGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5ID09PSB2b2lkIDApIHsgaWRlbnRpdHkgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09IGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBVdGlscy5TVVBQT1JUU19UWVBFRF9BUlJBWVMgPSB0eXBlb2YgKEZsb2F0MzJBcnJheSkgIT09IFwidW5kZWZpbmVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlscztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuVXRpbHMgPSBVdGlscztcclxuICAgICAgICB2YXIgRGVidWdVdGlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERlYnVnVXRpbHMoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRGVidWdVdGlscy5sb2dCb25lcyA9IGZ1bmN0aW9uIChza2VsZXRvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdCA9IGJvbmUubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJvbmUuZGF0YS5uYW1lICsgXCIsIFwiICsgbWF0LmEgKyBcIiwgXCIgKyBtYXQuYiArIFwiLCBcIiArIG1hdC5jICsgXCIsIFwiICsgbWF0LmQgKyBcIiwgXCIgKyBtYXQudHggKyBcIiwgXCIgKyBtYXQudHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRGVidWdVdGlscztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuRGVidWdVdGlscyA9IERlYnVnVXRpbHM7XHJcbiAgICAgICAgdmFyIFBvb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQb29sKGluc3RhbnRpYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0b3IgPSBpbnN0YW50aWF0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUG9vbC5wcm90b3R5cGUub2J0YWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID4gMCA/IHRoaXMuaXRlbXMucG9wKCkgOiB0aGlzLmluc3RhbnRpYXRvcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQb29sLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlc2V0KVxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUG9vbC5wcm90b3R5cGUuZnJlZUFsbCA9IGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZShpdGVtc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBvb2wucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUG9vbDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuUG9vbCA9IFBvb2w7XHJcbiAgICAgICAgdmFyIFZlY3RvcjIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBWZWN0b3IyKHgsIHkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IDA7IH1cclxuICAgICAgICAgICAgICAgIGlmICh5ID09PSB2b2lkIDApIHsgeSA9IDA7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFZlY3RvcjIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBWZWN0b3IyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVmVjdG9yMi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggLz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSAvPSBsZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlZlY3RvcjIgPSBWZWN0b3IyO1xyXG4gICAgICAgIHZhciBUaW1lS2VlcGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGltZUtlZXBlcigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVsdGEgPSAwLjA2NDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsdGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUaW1lS2VlcGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gbm93IC0gdGhpcy5sYXN0VGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVUaW1lICs9IHRoaXMuZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSArPSB0aGlzLmRlbHRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsdGEgPiB0aGlzLm1heERlbHRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsdGEgPSB0aGlzLm1heERlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IG5vdztcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVUaW1lID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gdGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcmFtZVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBUaW1lS2VlcGVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5UaW1lS2VlcGVyID0gVGltZUtlZXBlcjtcclxuICAgICAgICB2YXIgV2luZG93ZWRNZWFuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gV2luZG93ZWRNZWFuKHdpbmRvd1NpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dTaXplID09PSB2b2lkIDApIHsgd2luZG93U2l6ZSA9IDMyOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZGVkVmFsdWVzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVhbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KHdpbmRvd1NpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFdpbmRvd2VkTWVhbi5wcm90b3R5cGUuaGFzRW5vdWdoRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZGVkVmFsdWVzID49IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgV2luZG93ZWRNZWFuLnByb3RvdHlwZS5hZGRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRWYWx1ZXMgPCB0aGlzLnZhbHVlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRlZFZhbHVlcysrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNbdGhpcy5sYXN0VmFsdWUrK10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RWYWx1ZSA+IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFdpbmRvd2VkTWVhbi5wcm90b3R5cGUuZ2V0TWVhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0Vub3VnaERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWFuID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhbiArPSB0aGlzLnZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYW4gPSBtZWFuIC8gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lYW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFdpbmRvd2VkTWVhbjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuV2luZG93ZWRNZWFuID0gV2luZG93ZWRNZWFuO1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2htZW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgY29yZS5BdHRhY2htZW50ID0gQXR0YWNobWVudDtcclxuICAgICAgICB2YXIgVmVydGV4QXR0YWNobWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhWZXJ0ZXhBdHRhY2htZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBWZXJ0ZXhBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pZCA9IChWZXJ0ZXhBdHRhY2htZW50Lm5leHRJRCsrICYgNjU1MzUpIDw8IDExO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMud29ybGRWZXJ0aWNlc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWZvcm1BdHRhY2htZW50ID0gX3RoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVmVydGV4QXR0YWNobWVudC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXNPbGQgPSBmdW5jdGlvbiAoc2xvdCwgd29ybGRWZXJ0aWNlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlV29ybGRWZXJ0aWNlcyhzbG90LCAwLCB0aGlzLndvcmxkVmVydGljZXNMZW5ndGgsIHdvcmxkVmVydGljZXMsIDAsIDIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBWZXJ0ZXhBdHRhY2htZW50LnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uIChzbG90LCBzdGFydCwgY291bnQsIHdvcmxkVmVydGljZXMsIG9mZnNldCwgc3RyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IG9mZnNldCArIChjb3VudCA+PiAxKSAqIHN0cmlkZTtcclxuICAgICAgICAgICAgICAgIHZhciBza2VsZXRvbiA9IHNsb3QuYm9uZS5za2VsZXRvbjtcclxuICAgICAgICAgICAgICAgIHZhciBkZWZvcm1BcnJheSA9IHNsb3QuZGVmb3JtO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9uZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZvcm1BcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IGRlZm9ybUFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBzbG90LmJvbmUubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gbWF0LnR4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbWF0LnR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbWF0LmEsIGIgPSBtYXQuYywgYyA9IG1hdC5iLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdl8xID0gc3RhcnQsIHcgPSBvZmZzZXQ7IHcgPCBjb3VudDsgdl8xICs9IDIsIHcgKz0gc3RyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2eCA9IHZlcnRpY2VzW3ZfMV0sIHZ5ID0gdmVydGljZXNbdl8xICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbd10gPSB2eCAqIGEgKyB2eSAqIGIgKyB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3cgKyAxXSA9IHZ4ICogYyArIHZ5ICogZCArIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gMCwgc2tpcCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0OyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGJvbmVzW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIHYgKz0gbiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcCArPSBuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uQm9uZXMgPSBza2VsZXRvbi5ib25lcztcclxuICAgICAgICAgICAgICAgIGlmIChkZWZvcm1BcnJheS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSBvZmZzZXQsIGIgPSBza2lwICogMzsgdyA8IGNvdW50OyB3ICs9IHN0cmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3ggPSAwLCB3eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gYm9uZXNbdisrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdiA8IG47IHYrKywgYiArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ID0gc2tlbGV0b25Cb25lc1tib25lc1t2XV0ubWF0cml4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZ4ID0gdmVydGljZXNbYl0sIHZ5ID0gdmVydGljZXNbYiArIDFdLCB3ZWlnaHQgPSB2ZXJ0aWNlc1tiICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3eCArPSAodnggKiBtYXQuYSArIHZ5ICogbWF0LmMgKyBtYXQudHgpICogd2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3kgKz0gKHZ4ICogbWF0LmIgKyB2eSAqIG1hdC5kICsgbWF0LnR5KSAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3ddID0gd3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbdyArIDFdID0gd3k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZm9ybSA9IGRlZm9ybUFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSBvZmZzZXQsIGIgPSBza2lwICogMywgZiA9IHNraXAgPDwgMTsgdyA8IGNvdW50OyB3ICs9IHN0cmlkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3ggPSAwLCB3eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gYm9uZXNbdisrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdiA8IG47IHYrKywgYiArPSAzLCBmICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBza2VsZXRvbkJvbmVzW2JvbmVzW3ZdXS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnggPSB2ZXJ0aWNlc1tiXSArIGRlZm9ybVtmXSwgdnkgPSB2ZXJ0aWNlc1tiICsgMV0gKyBkZWZvcm1bZiArIDFdLCB3ZWlnaHQgPSB2ZXJ0aWNlc1tiICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3eCArPSAodnggKiBtYXQuYSArIHZ5ICogbWF0LmMgKyBtYXQudHgpICogd2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3kgKz0gKHZ4ICogbWF0LmIgKyB2eSAqIG1hdC5kICsgbWF0LnR5KSAqIHdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW3ddID0gd3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbdyArIDFdID0gd3k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBWZXJ0ZXhBdHRhY2htZW50LnByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbiAoYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9uZXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuYm9uZXMgPSBuZXcgQXJyYXkodGhpcy5ib25lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHRoaXMuYm9uZXMsIDAsIGF0dGFjaG1lbnQuYm9uZXMsIDAsIHRoaXMuYm9uZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmJvbmVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2VzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LnZlcnRpY2VzID0gY29yZS5VdGlscy5uZXdGbG9hdEFycmF5KHRoaXMudmVydGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLnZlcnRpY2VzLCAwLCBhdHRhY2htZW50LnZlcnRpY2VzLCAwLCB0aGlzLnZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC52ZXJ0aWNlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LndvcmxkVmVydGljZXNMZW5ndGggPSB0aGlzLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmRlZm9ybUF0dGFjaG1lbnQgPSB0aGlzLmRlZm9ybUF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFZlcnRleEF0dGFjaG1lbnQubmV4dElEID0gMDtcclxuICAgICAgICAgICAgcmV0dXJuIFZlcnRleEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgfShBdHRhY2htZW50KSk7XHJcbiAgICAgICAgY29yZS5WZXJ0ZXhBdHRhY2htZW50ID0gVmVydGV4QXR0YWNobWVudDtcclxuICAgIH0pKGNvcmUgPSBwaXhpX3NwaW5lLmNvcmUgfHwgKHBpeGlfc3BpbmUuY29yZSA9IHt9KSk7XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICB2YXIgY29yZTtcclxuICAgIChmdW5jdGlvbiAoY29yZSkge1xyXG4gICAgICAgIHZhciBBdHRhY2htZW50VHlwZTtcclxuICAgICAgICAoZnVuY3Rpb24gKEF0dGFjaG1lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiUmVnaW9uXCJdID0gMF0gPSBcIlJlZ2lvblwiO1xyXG4gICAgICAgICAgICBBdHRhY2htZW50VHlwZVtBdHRhY2htZW50VHlwZVtcIkJvdW5kaW5nQm94XCJdID0gMV0gPSBcIkJvdW5kaW5nQm94XCI7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiTWVzaFwiXSA9IDJdID0gXCJNZXNoXCI7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiTGlua2VkTWVzaFwiXSA9IDNdID0gXCJMaW5rZWRNZXNoXCI7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiUGF0aFwiXSA9IDRdID0gXCJQYXRoXCI7XHJcbiAgICAgICAgICAgIEF0dGFjaG1lbnRUeXBlW0F0dGFjaG1lbnRUeXBlW1wiUG9pbnRcIl0gPSA1XSA9IFwiUG9pbnRcIjtcclxuICAgICAgICAgICAgQXR0YWNobWVudFR5cGVbQXR0YWNobWVudFR5cGVbXCJDbGlwcGluZ1wiXSA9IDZdID0gXCJDbGlwcGluZ1wiO1xyXG4gICAgICAgIH0pKEF0dGFjaG1lbnRUeXBlID0gY29yZS5BdHRhY2htZW50VHlwZSB8fCAoY29yZS5BdHRhY2htZW50VHlwZSA9IHt9KSk7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQm91bmRpbmdCb3hBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEJvdW5kaW5nQm94QXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQm91bmRpbmdCb3hBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEJvdW5kaW5nQm94QXR0YWNobWVudC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEJvdW5kaW5nQm94QXR0YWNobWVudCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VG8oY29weSk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQm91bmRpbmdCb3hBdHRhY2htZW50O1xyXG4gICAgICAgIH0oY29yZS5WZXJ0ZXhBdHRhY2htZW50KSk7XHJcbiAgICAgICAgY29yZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQgPSBCb3VuZGluZ0JveEF0dGFjaG1lbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgQ2xpcHBpbmdBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENsaXBwaW5nQXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ2xpcHBpbmdBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDAuMjI3NSwgMC4yMjc1LCAwLjgwNzgsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENsaXBwaW5nQXR0YWNobWVudC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IENsaXBwaW5nQXR0YWNobWVudCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VG8oY29weSk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmVuZFNsb3QgPSB0aGlzLmVuZFNsb3Q7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xpcHBpbmdBdHRhY2htZW50O1xyXG4gICAgICAgIH0oY29yZS5WZXJ0ZXhBdHRhY2htZW50KSk7XHJcbiAgICAgICAgY29yZS5DbGlwcGluZ0F0dGFjaG1lbnQgPSBDbGlwcGluZ0F0dGFjaG1lbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgTWVzaEF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoTWVzaEF0dGFjaG1lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lc2hBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGVtcENvbG9yID0gbmV3IGNvcmUuQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLmdldFBhcmVudE1lc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNZXNoO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNZXNoQXR0YWNobWVudC5wcm90b3R5cGUuc2V0UGFyZW50TWVzaCA9IGZ1bmN0aW9uIChwYXJlbnRNZXNoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1lc2ggPSBwYXJlbnRNZXNoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE1lc2ggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9uZXMgPSBwYXJlbnRNZXNoLmJvbmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSBwYXJlbnRNZXNoLnZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud29ybGRWZXJ0aWNlc0xlbmd0aCA9IHBhcmVudE1lc2gud29ybGRWZXJ0aWNlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvblVWcyA9IHBhcmVudE1lc2gucmVnaW9uVVZzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpYW5nbGVzID0gcGFyZW50TWVzaC50cmlhbmdsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odWxsTGVuZ3RoID0gcGFyZW50TWVzaC5odWxsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud29ybGRWZXJ0aWNlc0xlbmd0aCA9IHBhcmVudE1lc2gud29ybGRWZXJ0aWNlc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRNZXNoICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3TGlua2VkTWVzaCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgTWVzaEF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvcHkucmVnaW9uID0gdGhpcy5yZWdpb247XHJcbiAgICAgICAgICAgICAgICBjb3B5LnBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29weVRvKGNvcHkpO1xyXG4gICAgICAgICAgICAgICAgY29weS5yZWdpb25VVnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVnaW9uVVZzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLnJlZ2lvblVWcywgMCwgY29weS5yZWdpb25VVnMsIDAsIHRoaXMucmVnaW9uVVZzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnV2cyA9IG5ldyBBcnJheSh0aGlzLnV2cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy51dnMsIDAsIGNvcHkudXZzLCAwLCB0aGlzLnV2cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29weS50cmlhbmdsZXMgPSBuZXcgQXJyYXkodGhpcy50cmlhbmdsZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHRoaXMudHJpYW5nbGVzLCAwLCBjb3B5LnRyaWFuZ2xlcywgMCwgdGhpcy50cmlhbmdsZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvcHkuaHVsbExlbmd0aCA9IHRoaXMuaHVsbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkZ2VzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5LmVkZ2VzID0gbmV3IEFycmF5KHRoaXMuZWRnZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLmVkZ2VzLCAwLCBjb3B5LmVkZ2VzLCAwLCB0aGlzLmVkZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3B5LndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvcHkuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWVzaEF0dGFjaG1lbnQucHJvdG90eXBlLm5ld0xpbmtlZE1lc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBNZXNoQXR0YWNobWVudCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29weS5yZWdpb24gPSB0aGlzLnJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIGNvcHkucGF0aCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgICAgIGNvcHkuY29sb3Iuc2V0RnJvbUNvbG9yKHRoaXMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgY29weS5kZWZvcm1BdHRhY2htZW50ID0gdGhpcy5kZWZvcm1BdHRhY2htZW50O1xyXG4gICAgICAgICAgICAgICAgY29weS5zZXRQYXJlbnRNZXNoKHRoaXMucGFyZW50TWVzaCAhPSBudWxsID8gdGhpcy5wYXJlbnRNZXNoIDogdGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE1lc2hBdHRhY2htZW50O1xyXG4gICAgICAgIH0oY29yZS5WZXJ0ZXhBdHRhY2htZW50KSk7XHJcbiAgICAgICAgY29yZS5NZXNoQXR0YWNobWVudCA9IE1lc2hBdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFBhdGhBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBhdGhBdHRhY2htZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoQXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25zdGFudFNwZWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhdGhBdHRhY2htZW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgUGF0aEF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29weVRvKGNvcHkpO1xyXG4gICAgICAgICAgICAgICAgY29weS5sZW5ndGhzID0gbmV3IEFycmF5KHRoaXMubGVuZ3Rocy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheUNvcHkodGhpcy5sZW5ndGhzLCAwLCBjb3B5Lmxlbmd0aHMsIDAsIHRoaXMubGVuZ3Rocy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29weS5jbG9zZWQgPSBjbG9zZWQ7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbnN0YW50U3BlZWQgPSB0aGlzLmNvbnN0YW50U3BlZWQ7XHJcbiAgICAgICAgICAgICAgICBjb3B5LmNvbG9yLnNldEZyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUGF0aEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgfShjb3JlLlZlcnRleEF0dGFjaG1lbnQpKTtcclxuICAgICAgICBjb3JlLlBhdGhBdHRhY2htZW50ID0gUGF0aEF0dGFjaG1lbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgUG9pbnRBdHRhY2htZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50QXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRBdHRhY2htZW50KG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IG5ldyBjb3JlLkNvbG9yKDAuMzgsIDAuOTQsIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBvaW50QXR0YWNobWVudC5wcm90b3R5cGUuY29tcHV0ZVdvcmxkUG9zaXRpb24gPSBmdW5jdGlvbiAoYm9uZSwgcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXQgPSBib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHBvaW50LnggPSB0aGlzLnggKiBtYXQuYSArIHRoaXMueSAqIG1hdC5jICsgYm9uZS53b3JsZFg7XHJcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gdGhpcy54ICogbWF0LmIgKyB0aGlzLnkgKiBtYXQuZCArIGJvbmUud29ybGRZO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQb2ludEF0dGFjaG1lbnQucHJvdG90eXBlLmNvbXB1dGVXb3JsZFJvdGF0aW9uID0gZnVuY3Rpb24gKGJvbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXQgPSBib25lLm1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBjb3JlLk1hdGhVdGlscy5jb3NEZWcodGhpcy5yb3RhdGlvbiksIHNpbiA9IGNvcmUuTWF0aFV0aWxzLnNpbkRlZyh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gY29zICogbWF0LmEgKyBzaW4gKiBtYXQuYztcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gY29zICogbWF0LmIgKyBzaW4gKiBtYXQuZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogY29yZS5NYXRoVXRpbHMucmFkRGVnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQb2ludEF0dGFjaG1lbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBQb2ludEF0dGFjaG1lbnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvcHkueCA9IHRoaXMueDtcclxuICAgICAgICAgICAgICAgIGNvcHkueSA9IHRoaXMueTtcclxuICAgICAgICAgICAgICAgIGNvcHkucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50QXR0YWNobWVudDtcclxuICAgICAgICB9KGNvcmUuVmVydGV4QXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuUG9pbnRBdHRhY2htZW50ID0gUG9pbnRBdHRhY2htZW50O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFJlZ2lvbkF0dGFjaG1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVnaW9uQXR0YWNobWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUmVnaW9uQXR0YWNobWVudChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMueCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbG9yID0gbmV3IGNvcmUuQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoOCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51dnMgPSBjb3JlLlV0aWxzLm5ld0Zsb2F0QXJyYXkoOCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50ZW1wQ29sb3IgPSBuZXcgY29yZS5Db2xvcigxLCAxLCAxLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LnByb3RvdHlwZS51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uU2NhbGVYID0gdGhpcy53aWR0aCAvIHRoaXMucmVnaW9uLm9yaWdpbmFsV2lkdGggKiB0aGlzLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpb25TY2FsZVkgPSB0aGlzLmhlaWdodCAvIHRoaXMucmVnaW9uLm9yaWdpbmFsSGVpZ2h0ICogdGhpcy5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxYID0gLXRoaXMud2lkdGggLyAyICogdGhpcy5zY2FsZVggKyB0aGlzLnJlZ2lvbi5vZmZzZXRYICogcmVnaW9uU2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWSA9IC10aGlzLmhlaWdodCAvIDIgKiB0aGlzLnNjYWxlWSArIHRoaXMucmVnaW9uLm9mZnNldFkgKiByZWdpb25TY2FsZVk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxYMiA9IGxvY2FsWCArIHRoaXMucmVnaW9uLndpZHRoICogcmVnaW9uU2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWTIgPSBsb2NhbFkgKyB0aGlzLnJlZ2lvbi5oZWlnaHQgKiByZWdpb25TY2FsZVk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaWFucyA9IHRoaXMucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWENvcyA9IGxvY2FsWCAqIGNvcyArIHRoaXMueDtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFhTaW4gPSBsb2NhbFggKiBzaW47XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxZQ29zID0gbG9jYWxZICogY29zICsgdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsWVNpbiA9IGxvY2FsWSAqIHNpbjtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFgyQ29zID0gbG9jYWxYMiAqIGNvcyArIHRoaXMueDtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFgyU2luID0gbG9jYWxYMiAqIHNpbjtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFkyQ29zID0gbG9jYWxZMiAqIGNvcyArIHRoaXMueTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFkyU2luID0gbG9jYWxZMiAqIHNpbjtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YMV0gPSBsb2NhbFhDb3MgLSBsb2NhbFlTaW47XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTFdID0gbG9jYWxZQ29zICsgbG9jYWxYU2luO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gyXSA9IGxvY2FsWENvcyAtIGxvY2FsWTJTaW47XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTJdID0gbG9jYWxZMkNvcyArIGxvY2FsWFNpbjtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YM10gPSBsb2NhbFgyQ29zIC0gbG9jYWxZMlNpbjtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZM10gPSBsb2NhbFkyQ29zICsgbG9jYWxYMlNpbjtcclxuICAgICAgICAgICAgICAgIG9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YNF0gPSBsb2NhbFgyQ29zIC0gbG9jYWxZU2luO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1k0XSA9IGxvY2FsWUNvcyArIGxvY2FsWDJTaW47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uIChyZWdpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV2cyA9IHRoaXMudXZzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbi5yb3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbMl0gPSByZWdpb24udTtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbM10gPSByZWdpb24udjI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzRdID0gcmVnaW9uLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzVdID0gcmVnaW9uLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzZdID0gcmVnaW9uLnUyO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s3XSA9IHJlZ2lvbi52O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1swXSA9IHJlZ2lvbi51MjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbMV0gPSByZWdpb24udjI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbMF0gPSByZWdpb24udTtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbMV0gPSByZWdpb24udjI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzJdID0gcmVnaW9uLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzNdID0gcmVnaW9uLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzWzRdID0gcmVnaW9uLnUyO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s1XSA9IHJlZ2lvbi52O1xyXG4gICAgICAgICAgICAgICAgICAgIHV2c1s2XSA9IHJlZ2lvbi51MjtcclxuICAgICAgICAgICAgICAgICAgICB1dnNbN10gPSByZWdpb24udjI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQucHJvdG90eXBlLmNvbXB1dGVXb3JsZFZlcnRpY2VzID0gZnVuY3Rpb24gKGJvbmUsIHdvcmxkVmVydGljZXMsIG9mZnNldCwgc3RyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4T2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0ID0gYm9uZS5tYXRyaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG1hdC50eCwgeSA9IG1hdC50eTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gbWF0LmEsIGIgPSBtYXQuYywgYyA9IG1hdC5iLCBkID0gbWF0LmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YMV07XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1kxXTtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0XSA9IG9mZnNldFggKiBhICsgb2Zmc2V0WSAqIGIgKyB4O1xyXG4gICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1tvZmZzZXQgKyAxXSA9IG9mZnNldFggKiBjICsgb2Zmc2V0WSAqIGQgKyB5O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFggPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWDJdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9ZMl07XHJcbiAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW29mZnNldF0gPSBvZmZzZXRYICogYSArIG9mZnNldFkgKiBiICsgeDtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0ICsgMV0gPSBvZmZzZXRYICogYyArIG9mZnNldFkgKiBkICsgeTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGU7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1gzXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFkgPSB2ZXJ0ZXhPZmZzZXRbUmVnaW9uQXR0YWNobWVudC5PWTNdO1xyXG4gICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1tvZmZzZXRdID0gb2Zmc2V0WCAqIGEgKyBvZmZzZXRZICogYiArIHg7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFZlcnRpY2VzW29mZnNldCArIDFdID0gb2Zmc2V0WCAqIGMgKyBvZmZzZXRZICogZCArIHk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHZlcnRleE9mZnNldFtSZWdpb25BdHRhY2htZW50Lk9YNF07XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gdmVydGV4T2Zmc2V0W1JlZ2lvbkF0dGFjaG1lbnQuT1k0XTtcclxuICAgICAgICAgICAgICAgIHdvcmxkVmVydGljZXNbb2Zmc2V0XSA9IG9mZnNldFggKiBhICsgb2Zmc2V0WSAqIGIgKyB4O1xyXG4gICAgICAgICAgICAgICAgd29ybGRWZXJ0aWNlc1tvZmZzZXQgKyAxXSA9IG9mZnNldFggKiBjICsgb2Zmc2V0WSAqIGQgKyB5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgUmVnaW9uQXR0YWNobWVudCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29weS5yZWdpb24gPSB0aGlzLnJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIGNvcHkucmVuZGVyZXJPYmplY3QgPSB0aGlzLnJlbmRlcmVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgY29weS5wYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICAgICAgY29weS54ID0gdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgY29weS55ID0gdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgY29weS5zY2FsZVggPSB0aGlzLnNjYWxlWDtcclxuICAgICAgICAgICAgICAgIGNvcHkuc2NhbGVZID0gdGhpcy5zY2FsZVk7XHJcbiAgICAgICAgICAgICAgICBjb3B5LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvcHkud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29weS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlDb3B5KHRoaXMudXZzLCAwLCBjb3B5LnV2cywgMCwgOCk7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmFycmF5Q29weSh0aGlzLm9mZnNldCwgMCwgY29weS5vZmZzZXQsIDAsIDgpO1xyXG4gICAgICAgICAgICAgICAgY29weS5jb2xvci5zZXRGcm9tQ29sb3IodGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWDEgPSAwO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Lk9ZMSA9IDE7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuT1gyID0gMjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWTIgPSAzO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Lk9YMyA9IDQ7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuT1kzID0gNTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5PWDQgPSA2O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Lk9ZNCA9IDc7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuWDEgPSAwO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlkxID0gMTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMVIgPSAyO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMxRyA9IDM7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzFCID0gNDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMUEgPSA1O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlUxID0gNjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5WMSA9IDc7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuWDIgPSA4O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlkyID0gOTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMlIgPSAxMDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMkcgPSAxMTtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMkIgPSAxMjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5DMkEgPSAxMztcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5VMiA9IDE0O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlYyID0gMTU7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuWDMgPSAxNjtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5ZMyA9IDE3O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMzUiA9IDE4O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMzRyA9IDE5O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMzQiA9IDIwO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LkMzQSA9IDIxO1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50LlUzID0gMjI7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuVjMgPSAyMztcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5YNCA9IDI0O1xyXG4gICAgICAgICAgICBSZWdpb25BdHRhY2htZW50Llk0ID0gMjU7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzRSID0gMjY7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzRHID0gMjc7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzRCID0gMjg7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuQzRBID0gMjk7XHJcbiAgICAgICAgICAgIFJlZ2lvbkF0dGFjaG1lbnQuVTQgPSAzMDtcclxuICAgICAgICAgICAgUmVnaW9uQXR0YWNobWVudC5WNCA9IDMxO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVnaW9uQXR0YWNobWVudDtcclxuICAgICAgICB9KGNvcmUuQXR0YWNobWVudCkpO1xyXG4gICAgICAgIGNvcmUuUmVnaW9uQXR0YWNobWVudCA9IFJlZ2lvbkF0dGFjaG1lbnQ7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxudmFyIHBpeGlfc3BpbmU7XHJcbihmdW5jdGlvbiAocGl4aV9zcGluZSkge1xyXG4gICAgdmFyIGNvcmU7XHJcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcclxuICAgICAgICB2YXIgSml0dGVyRWZmZWN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSml0dGVyRWZmZWN0KGppdHRlclgsIGppdHRlclkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaml0dGVyWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlclkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXJYID0gaml0dGVyWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaml0dGVyWSA9IGppdHRlclk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgSml0dGVyRWZmZWN0LnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uIChza2VsZXRvbikge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBKaXR0ZXJFZmZlY3QucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgdXYsIGxpZ2h0LCBkYXJrKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi54ICs9IGNvcmUuTWF0aFV0aWxzLnJhbmRvbVRyaWFuZ3VsYXIoLXRoaXMuaml0dGVyWCwgdGhpcy5qaXR0ZXJZKTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgKz0gY29yZS5NYXRoVXRpbHMucmFuZG9tVHJpYW5ndWxhcigtdGhpcy5qaXR0ZXJYLCB0aGlzLmppdHRlclkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBKaXR0ZXJFZmZlY3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEppdHRlckVmZmVjdDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGNvcmUuSml0dGVyRWZmZWN0ID0gSml0dGVyRWZmZWN0O1xyXG4gICAgfSkoY29yZSA9IHBpeGlfc3BpbmUuY29yZSB8fCAocGl4aV9zcGluZS5jb3JlID0ge30pKTtcclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIHZhciBjb3JlO1xyXG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XHJcbiAgICAgICAgdmFyIFN3aXJsRWZmZWN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3dpcmxFZmZlY3QocmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU3dpcmxFZmZlY3QucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKHNrZWxldG9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkWCA9IHNrZWxldG9uLnggKyB0aGlzLmNlbnRlclg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkWSA9IHNrZWxldG9uLnkgKyB0aGlzLmNlbnRlclk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFN3aXJsRWZmZWN0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocG9zaXRpb24sIHV2LCBsaWdodCwgZGFyaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZEFuZ2xlID0gdGhpcy5hbmdsZSAqIGNvcmUuTWF0aFV0aWxzLmRlZ3JlZXNUb1JhZGlhbnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHBvc2l0aW9uLnggLSB0aGlzLndvcmxkWDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gcG9zaXRpb24ueSAtIHRoaXMud29ybGRZO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IHRoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gU3dpcmxFZmZlY3QuaW50ZXJwb2xhdGlvbi5hcHBseSgwLCByYWRBbmdsZSwgKHRoaXMucmFkaXVzIC0gZGlzdCkgLyB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggPSBjb3MgKiB4IC0gc2luICogeSArIHRoaXMud29ybGRYO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBzaW4gKiB4ICsgY29zICogeSArIHRoaXMud29ybGRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTd2lybEVmZmVjdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTd2lybEVmZmVjdC5pbnRlcnBvbGF0aW9uID0gbmV3IGNvcmUuUG93T3V0KDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gU3dpcmxFZmZlY3Q7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBjb3JlLlN3aXJsRWZmZWN0ID0gU3dpcmxFZmZlY3Q7XHJcbiAgICB9KShjb3JlID0gcGl4aV9zcGluZS5jb3JlIHx8IChwaXhpX3NwaW5lLmNvcmUgPSB7fSkpO1xyXG59KShwaXhpX3NwaW5lIHx8IChwaXhpX3NwaW5lID0ge30pKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghTWF0aC5mcm91bmQpIHtcclxuICAgICAgICBNYXRoLmZyb3VuZCA9IE1hdGguZnJvdW5kID0gKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVswXSA9IHgsIGFycmF5WzBdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xyXG4gICAgfVxyXG59KSgpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICBwaXhpX3NwaW5lLmNvcmUuQm9uZS55RG93biA9IHRydWU7XHJcbiAgICB2YXIgdGVtcFJnYiA9IFswLCAwLCAwXTtcclxuICAgIHZhciBTcGluZVNwcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwaW5lU3ByaXRlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwaW5lU3ByaXRlKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMucmVnaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMuYXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwaW5lU3ByaXRlO1xyXG4gICAgfShQSVhJLlNwcml0ZSkpO1xyXG4gICAgcGl4aV9zcGluZS5TcGluZVNwcml0ZSA9IFNwaW5lU3ByaXRlO1xyXG4gICAgdmFyIGdwID0gUElYSS5HcmFwaGljc0dlb21ldHJ5LnByb3RvdHlwZTtcclxuICAgIGlmICghZ3AuaW52YWxpZGF0ZSkge1xyXG4gICAgICAgIHZhciB0bXBfMSA9IFtdO1xyXG4gICAgICAgIGdwLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5ncmFwaGljc0RhdGE7XHJcbiAgICAgICAgICAgIHRtcF8xLnB1c2goMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gdG1wXzE7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSB0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgU3BpbmVNZXNoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3BpbmVNZXNoLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwaW5lTWVzaCh0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMucmVnaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMuYXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwaW5lTWVzaDtcclxuICAgIH0oUElYSS5TaW1wbGVNZXNoKSk7XHJcbiAgICBwaXhpX3NwaW5lLlNwaW5lTWVzaCA9IFNwaW5lTWVzaDtcclxuICAgIHZhciBTcGluZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwaW5lLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwaW5lKHNwaW5lRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXNwaW5lRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3BpbmVEYXRhIHBhcmFtIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHNwaW5lRGF0YSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BpbmVEYXRhIHBhcmFtIGNhbnQgYmUgc3RyaW5nLiBQbGVhc2UgdXNlIHNwaW5lLlNwaW5lLmZyb21BdGxhcyhcIllPVVJfUkVTT1VSQ0VfTkFNRVwiKSBmcm9tIG5vdyBvbi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5zcGluZURhdGEgPSBzcGluZURhdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnNrZWxldG9uID0gbmV3IHBpeGlfc3BpbmUuY29yZS5Ta2VsZXRvbihzcGluZURhdGEpO1xyXG4gICAgICAgICAgICBfdGhpcy5za2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZURhdGEgPSBuZXcgcGl4aV9zcGluZS5jb3JlLkFuaW1hdGlvblN0YXRlRGF0YShzcGluZURhdGEpO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuQW5pbWF0aW9uU3RhdGUoX3RoaXMuc3RhdGVEYXRhKTtcclxuICAgICAgICAgICAgX3RoaXMuc2xvdENvbnRhaW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMudGVtcENsaXBDb250YWluZXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gX3RoaXMuc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IF90aGlzLnNrZWxldG9uLnNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gX3RoaXMubmV3Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zbG90Q29udGFpbmVycy5wdXNoKHNsb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkQ2hpbGQoc2xvdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50ZW1wQ2xpcENvbnRhaW5lcnMucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgcGl4aV9zcGluZS5jb3JlLlJlZ2lvbkF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlTmFtZSA9IGF0dGFjaG1lbnQucmVnaW9uLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IF90aGlzLmNyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LCBzcHJpdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9IHNwcml0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHBpeGlfc3BpbmUuY29yZS5NZXNoQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNoID0gX3RoaXMuY3JlYXRlTWVzaChzbG90LCBhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoID0gbWVzaDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoSWQgPSBhdHRhY2htZW50LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQobWVzaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgcGl4aV9zcGluZS5jb3JlLkNsaXBwaW5nQXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUdyYXBoaWNzKHNsb3QsIGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc2xvdC5jbGlwcGluZ0NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzbG90LmN1cnJlbnRHcmFwaGljcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy50aW50UmdiID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pO1xyXG4gICAgICAgICAgICBfdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwaW5lLnByb3RvdHlwZSwgXCJhdXRvVXBkYXRlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHZhbHVlID8gU3BpbmUucHJvdG90eXBlLmF1dG9VcGRhdGVUcmFuc2Zvcm0gOiBQSVhJLkNvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwaW5lLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwaW5lLnByb3RvdHlwZSwgXCJ0aW50XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUElYSS51dGlscy5yZ2IyaGV4KHRoaXMudGludFJnYik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbnRSZ2IgPSBQSVhJLnV0aWxzLmhleDJyZ2IodmFsdWUsIHRoaXMudGludFJnYik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BpbmUucHJvdG90eXBlLCBcImRlbGF5TGltaXRcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IHR5cGVvZiB0aGlzLmxvY2FsRGVsYXlMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbERlbGF5TGltaXQgOiBTcGluZS5nbG9iYWxEZWxheUxpbWl0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxheUxpbWl0ID0gdGhpcy5kZWxheUxpbWl0O1xyXG4gICAgICAgICAgICBpZiAoZHQgPiBkZWxheUxpbWl0KVxyXG4gICAgICAgICAgICAgICAgZHQgPSBkZWxheUxpbWl0O1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZShkdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYXBwbHkodGhpcy5za2VsZXRvbik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5za2VsZXRvbilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5za2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNrZWxldG9uLnNsb3RzO1xyXG4gICAgICAgICAgICB2YXIgZ2xvYmFsQ2xyID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbnVsbCwgZGFyayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChnbG9iYWxDbHIpIHtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ID0gZ2xvYmFsQ2xyLmxpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZGFyayA9IGdsb2JhbENsci5kYXJrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGlnaHQgPSB0aGlzLnRpbnRSZ2I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRoYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHNsb3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gdGhpcy5zbG90Q29udGFpbmVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICghYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZUNvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRDb2xvciA9IGF0dGFjaG1lbnQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHBpeGlfc3BpbmUuY29yZS5SZWdpb25BdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGF0dGFjaG1lbnQucmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudE1lc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2gudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXIgPSByZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2xvdC5jdXJyZW50U3ByaXRlTmFtZSB8fCBzbG90LmN1cnJlbnRTcHJpdGVOYW1lICE9PSBhci5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlTmFtZSA9IGFyLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50U3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlcyA9IHNsb3Quc3ByaXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlc1tzcHJpdGVOYW1lXS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLmNyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LCBzcHJpdGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gc3ByaXRlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzbG90LmN1cnJlbnRTcHJpdGVOYW1lID09PSBhci5uYW1lICYmICFzbG90LmhhY2tSZWdpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3ByaXRlUmVnaW9uKGF0dGFjaG1lbnQsIHNsb3QuY3VycmVudFNwcml0ZSwgcmVnaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gc2xvdENvbnRhaW5lci50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnNldEZyb21NYXRyaXgoc2xvdC5ib25lLm1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZS5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGVDb2xvciA9IHNsb3QuY3VycmVudFNwcml0ZS5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMF0gPSBsaWdodFswXSAqIHNsb3QuY29sb3IuciAqIGF0dENvbG9yLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMV0gPSBsaWdodFsxXSAqIHNsb3QuY29sb3IuZyAqIGF0dENvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMl0gPSBsaWdodFsyXSAqIHNsb3QuY29sb3IuYiAqIGF0dENvbG9yLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS50aW50ID0gUElYSS51dGlscy5yZ2IyaGV4KHRlbXBSZ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUuYmxlbmRNb2RlID0gc2xvdC5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgcGl4aV9zcGluZS5jb3JlLk1lc2hBdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IFBJWEkuVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLl93b3JsZElEID0gc2xvdENvbnRhaW5lci50cmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3QuY3VycmVudE1lc2hJZCB8fCBzbG90LmN1cnJlbnRNZXNoSWQgIT09IGF0dGFjaG1lbnQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc2hJZCA9IGF0dGFjaG1lbnQuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRNZXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90Lm1lc2hlcyA9IHNsb3QubWVzaGVzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5tZXNoZXNbbWVzaElkXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90Lm1lc2hlc1ttZXNoSWRdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc2ggPSB0aGlzLmNyZWF0ZU1lc2goc2xvdCwgYXR0YWNobWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKG1lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2ggPSBzbG90Lm1lc2hlc1ttZXNoSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoTmFtZSA9IGF0dGFjaG1lbnQubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaElkID0gbWVzaElkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmNvbXB1dGVXb3JsZFZlcnRpY2VzT2xkKHNsb3QsIHNsb3QuY3VycmVudE1lc2gudmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRNZXNoLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZUNvbG9yID0gc2xvdC5jdXJyZW50TWVzaC5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMF0gPSBsaWdodFswXSAqIHNsb3QuY29sb3IuciAqIGF0dENvbG9yLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMV0gPSBsaWdodFsxXSAqIHNsb3QuY29sb3IuZyAqIGF0dENvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBSZ2JbMl0gPSBsaWdodFsyXSAqIHNsb3QuY29sb3IuYiAqIGF0dENvbG9yLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2gudGludCA9IFBJWEkudXRpbHMucmdiMmhleCh0ZW1wUmdiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaC5ibGVuZE1vZGUgPSBzbG90LmJsZW5kTW9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBwaXhpX3NwaW5lLmNvcmUuQ2xpcHBpbmdBdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbG90LmN1cnJlbnRHcmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUdyYXBoaWNzKHNsb3QsIGF0dGFjaG1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNsb3QuY2xpcHBpbmdDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFkZENoaWxkKHNsb3QuY3VycmVudEdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljcyhzbG90LCBhdHRhY2htZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFscGhhID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ByaXRlQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcjAgPSBzbG90LmNvbG9yLnIgKiBhdHRDb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnMCA9IHNsb3QuY29sb3IuZyAqIGF0dENvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIwID0gc2xvdC5jb2xvci5iICogYXR0Q29sb3IuYjtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVDb2xvci5zZXRMaWdodChsaWdodFswXSAqIHIwICsgZGFya1swXSAqICgxLjAgLSByMCksIGxpZ2h0WzFdICogZzAgKyBkYXJrWzFdICogKDEuMCAtIGcwKSwgbGlnaHRbMl0gKiBiMCArIGRhcmtbMl0gKiAoMS4wIC0gYjApKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5kYXJrQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjAgPSBzbG90LmRhcmtDb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnMCA9IHNsb3QuZGFya0NvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIwID0gc2xvdC5kYXJrQ29sb3IuYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIwID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnMCA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYjAgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUNvbG9yLnNldERhcmsobGlnaHRbMF0gKiByMCArIGRhcmtbMF0gKiAoMSAtIHIwKSwgbGlnaHRbMV0gKiBnMCArIGRhcmtbMV0gKiAoMSAtIGcwKSwgbGlnaHRbMl0gKiBiMCArIGRhcmtbMl0gKiAoMSAtIGIwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLmFscGhhID0gc2xvdC5jb2xvci5hO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkcmF3T3JkZXIgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlcjtcclxuICAgICAgICAgICAgdmFyIGNsaXBwaW5nQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBjbGlwcGluZ0NvbnRhaW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tkcmF3T3JkZXJbaV0uZGF0YS5pbmRleF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHRoaXMuc2xvdENvbnRhaW5lcnNbZHJhd09yZGVyW2ldLmRhdGEuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwcGluZ0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90Q29udGFpbmVyLnBhcmVudCAhPT0gbnVsbCAmJiBzbG90Q29udGFpbmVyLnBhcmVudCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnBhcmVudC5yZW1vdmVDaGlsZChzbG90Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRHcmFwaGljcyAmJiBzbG90LmdldEF0dGFjaG1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaXBwaW5nQ29udGFpbmVyID0gc2xvdC5jbGlwcGluZ0NvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0F0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0NvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0gPSBzbG90Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwcGluZ0F0dGFjaG1lbnQuZW5kU2xvdCA9PSBzbG90LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdBdHRhY2htZW50LmVuZFNsb3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwcGluZ0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMudGVtcENsaXBDb250YWluZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLnRlbXBDbGlwQ29udGFpbmVyc1tpXSA9IHRoaXMubmV3Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0NvbnRhaW5lci5hZGRDaGlsZChzbG90Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBwaW5nQXR0YWNobWVudC5lbmRTbG90ID09IHNsb3QuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBpbmdDb250YWluZXIucmVuZGVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0NvbnRhaW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGluZ0F0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gc2xvdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIDtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuc2V0U3ByaXRlUmVnaW9uID0gZnVuY3Rpb24gKGF0dGFjaG1lbnQsIHNwcml0ZSwgcmVnaW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGUuYXR0YWNobWVudCA9PT0gYXR0YWNobWVudCAmJiBzcHJpdGUucmVnaW9uID09PSByZWdpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzcHJpdGUucmVnaW9uID0gcmVnaW9uO1xyXG4gICAgICAgICAgICBzcHJpdGUuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIHNwcml0ZS50ZXh0dXJlID0gcmVnaW9uLnRleHR1cmU7XHJcbiAgICAgICAgICAgIHNwcml0ZS5yb3RhdGlvbiA9IGF0dGFjaG1lbnQucm90YXRpb24gKiBwaXhpX3NwaW5lLmNvcmUuTWF0aFV0aWxzLmRlZ1JhZDtcclxuICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnggPSBhdHRhY2htZW50Lng7XHJcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi55ID0gYXR0YWNobWVudC55O1xyXG4gICAgICAgICAgICBzcHJpdGUuYWxwaGEgPSBhdHRhY2htZW50LmNvbG9yLmE7XHJcbiAgICAgICAgICAgIGlmICghcmVnaW9uLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS54ID0gYXR0YWNobWVudC5zY2FsZVggKiBhdHRhY2htZW50LndpZHRoIC8gcmVnaW9uLm9yaWdpbmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUueSA9IC1hdHRhY2htZW50LnNjYWxlWSAqIGF0dGFjaG1lbnQuaGVpZ2h0IC8gcmVnaW9uLm9yaWdpbmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnggPSByZWdpb24uc2l6ZS53aWR0aCAvIHJlZ2lvbi5vcmlnaW5hbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnkgPSAtcmVnaW9uLnNpemUuaGVpZ2h0IC8gcmVnaW9uLm9yaWdpbmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuc2V0TWVzaFJlZ2lvbiA9IGZ1bmN0aW9uIChhdHRhY2htZW50LCBtZXNoLCByZWdpb24pIHtcclxuICAgICAgICAgICAgaWYgKG1lc2guYXR0YWNobWVudCA9PT0gYXR0YWNobWVudCAmJiBtZXNoLnJlZ2lvbiA9PT0gcmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVzaC5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgICAgIG1lc2guYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIG1lc2gudGV4dHVyZSA9IHJlZ2lvbi50ZXh0dXJlO1xyXG4gICAgICAgICAgICByZWdpb24udGV4dHVyZS51cGRhdGVVdnMoKTtcclxuICAgICAgICAgICAgbWVzaC51dkJ1ZmZlci51cGRhdGUoYXR0YWNobWVudC5yZWdpb25VVnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLmF1dG9VcGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChTcGluZS5nbG9iYWxBdXRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gdGhpcy5sYXN0VGltZSB8fCBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IChEYXRlLm5vdygpIC0gdGhpcy5sYXN0VGltZSkgKiAwLjAwMTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUodGltZURlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBJWEkuQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIDtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuY3JlYXRlU3ByaXRlID0gZnVuY3Rpb24gKHNsb3QsIGF0dGFjaG1lbnQsIGRlZk5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGF0dGFjaG1lbnQucmVnaW9uO1xyXG4gICAgICAgICAgICBpZiAoc2xvdC5oYWNrQXR0YWNobWVudCA9PT0gYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uID0gc2xvdC5oYWNrUmVnaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gcmVnaW9uLnRleHR1cmU7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLm5ld1Nwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgc3ByaXRlLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcHJpdGVSZWdpb24oYXR0YWNobWVudCwgc3ByaXRlLCBhdHRhY2htZW50LnJlZ2lvbik7XHJcbiAgICAgICAgICAgIHNsb3Quc3ByaXRlcyA9IHNsb3Quc3ByaXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgc2xvdC5zcHJpdGVzW2RlZk5hbWVdID0gc3ByaXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gc3ByaXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgO1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5jcmVhdGVNZXNoID0gZnVuY3Rpb24gKHNsb3QsIGF0dGFjaG1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGF0dGFjaG1lbnQucmVnaW9uO1xyXG4gICAgICAgICAgICBpZiAoc2xvdC5oYWNrQXR0YWNobWVudCA9PT0gYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uID0gc2xvdC5oYWNrUmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzbG90LmhhY2tSZWdpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdHJpcCA9IHRoaXMubmV3TWVzaChyZWdpb24udGV4dHVyZSwgbmV3IEZsb2F0MzJBcnJheShhdHRhY2htZW50LnJlZ2lvblVWcy5sZW5ndGgpLCBhdHRhY2htZW50LnJlZ2lvblVWcywgbmV3IFVpbnQxNkFycmF5KGF0dGFjaG1lbnQudHJpYW5nbGVzKSwgUElYSS5EUkFXX01PREVTLlRSSUFOR0xFUyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyaXAuX2NhbnZhc1BhZGRpbmcgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHN0cmlwLl9jYW52YXNQYWRkaW5nID0gMS41O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0cmlwLmFscGhhID0gYXR0YWNobWVudC5jb2xvci5hO1xyXG4gICAgICAgICAgICBzdHJpcC5yZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgdGhpcy5zZXRNZXNoUmVnaW9uKGF0dGFjaG1lbnQsIHN0cmlwLCByZWdpb24pO1xyXG4gICAgICAgICAgICBzbG90Lm1lc2hlcyA9IHNsb3QubWVzaGVzIHx8IHt9O1xyXG4gICAgICAgICAgICBzbG90Lm1lc2hlc1thdHRhY2htZW50LmlkXSA9IHN0cmlwO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaXA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICA7XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLmNyZWF0ZUdyYXBoaWNzID0gZnVuY3Rpb24gKHNsb3QsIGNsaXApIHtcclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gdGhpcy5uZXdHcmFwaGljcygpO1xyXG4gICAgICAgICAgICB2YXIgcG9seSA9IG5ldyBQSVhJLlBvbHlnb24oW10pO1xyXG4gICAgICAgICAgICBncmFwaGljcy5jbGVhcigpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhmZmZmZmYsIDEpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5kcmF3UG9seWdvbihwb2x5KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzbG90LmN1cnJlbnRHcmFwaGljcyA9IGdyYXBoaWNzO1xyXG4gICAgICAgICAgICBzbG90LmNsaXBwaW5nQ29udGFpbmVyID0gdGhpcy5uZXdDb250YWluZXIoKTtcclxuICAgICAgICAgICAgc2xvdC5jbGlwcGluZ0NvbnRhaW5lci5tYXNrID0gc2xvdC5jdXJyZW50R3JhcGhpY3M7XHJcbiAgICAgICAgICAgIHJldHVybiBncmFwaGljcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS51cGRhdGVHcmFwaGljcyA9IGZ1bmN0aW9uIChzbG90LCBjbGlwKSB7XHJcbiAgICAgICAgICAgIHZhciBnZW9tID0gc2xvdC5jdXJyZW50R3JhcGhpY3MuZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb20uZ3JhcGhpY3NEYXRhWzBdLnNoYXBlLnBvaW50cztcclxuICAgICAgICAgICAgdmFyIG4gPSBjbGlwLndvcmxkVmVydGljZXNMZW5ndGg7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLmxlbmd0aCA9IG47XHJcbiAgICAgICAgICAgIGNsaXAuY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdCwgMCwgbiwgdmVydGljZXMsIDAsIDIpO1xyXG4gICAgICAgICAgICBnZW9tLmludmFsaWRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5oYWNrVGV4dHVyZUJ5U2xvdEluZGV4ID0gZnVuY3Rpb24gKHNsb3RJbmRleCwgdGV4dHVyZSwgc2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZSA9PT0gdm9pZCAwKSB7IHRleHR1cmUgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IG51bGw7IH1cclxuICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLnNrZWxldG9uLnNsb3RzW3Nsb3RJbmRleF07XHJcbiAgICAgICAgICAgIGlmICghc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgIHZhciByZWdpb24gPSBhdHRhY2htZW50LnJlZ2lvbjtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuVGV4dHVyZVJlZ2lvbigpO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uLnNpemUgPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrUmVnaW9uID0gcmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrQXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90LmhhY2tSZWdpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5oYWNrQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSAmJiBzbG90LmN1cnJlbnRTcHJpdGUucmVnaW9uICE9IHJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTcHJpdGVSZWdpb24oYXR0YWNobWVudCwgc2xvdC5jdXJyZW50U3ByaXRlLCByZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbG90LmN1cnJlbnRNZXNoICYmIHNsb3QuY3VycmVudE1lc2gucmVnaW9uICE9IHJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNZXNoUmVnaW9uKGF0dGFjaG1lbnQsIHNsb3QuY3VycmVudE1lc2gsIHJlZ2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcGluZS5wcm90b3R5cGUuaGFja1RleHR1cmVCeVNsb3ROYW1lID0gZnVuY3Rpb24gKHNsb3ROYW1lLCB0ZXh0dXJlLCBzaXplKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlID09PSB2b2lkIDApIHsgdGV4dHVyZSA9IG51bGw7IH1cclxuICAgICAgICAgICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gbnVsbDsgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNrZWxldG9uLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYWNrVGV4dHVyZUJ5U2xvdEluZGV4KGluZGV4LCB0ZXh0dXJlLCBzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5oYWNrVGV4dHVyZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lLCB0ZXh0dXJlLCBzaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IG51bGw7IH1cclxuICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHRoaXMuc2tlbGV0b24uZmluZFNsb3RJbmRleChzbG90TmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5za2VsZXRvbi5nZXRBdHRhY2htZW50QnlOYW1lKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSk7XHJcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuc2tlbGV0b24uc2xvdHNbc2xvdEluZGV4XTtcclxuICAgICAgICAgICAgaWYgKCFzbG90KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRBdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50TmFtZSA9PT0gY3VycmVudEF0dGFjaG1lbnQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGF0dGFjaG1lbnQucmVnaW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSBuZXcgcGl4aV9zcGluZS5jb3JlLlRleHR1cmVSZWdpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICByZWdpb24udGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uLnNpemUgPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuaGFja1JlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmhhY2tBdHRhY2htZW50ID0gY3VycmVudEF0dGFjaG1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90LmhhY2tSZWdpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3QuaGFja0F0dGFjaG1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSAmJiBzbG90LmN1cnJlbnRTcHJpdGUucmVnaW9uICE9IHJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3ByaXRlUmVnaW9uKGN1cnJlbnRBdHRhY2htZW50LCBzbG90LmN1cnJlbnRTcHJpdGUsIHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlLnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3QuY3VycmVudE1lc2ggJiYgc2xvdC5jdXJyZW50TWVzaC5yZWdpb24gIT0gcmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNZXNoUmVnaW9uKGN1cnJlbnRBdHRhY2htZW50LCBzbG90LmN1cnJlbnRNZXNoLCByZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLm5ld0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQSVhJLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLm5ld1Nwcml0ZSA9IGZ1bmN0aW9uICh0ZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGluZVNwcml0ZSh0ZXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLm5ld0dyYXBoaWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBJWEkuR3JhcGhpY3MoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5uZXdNZXNoID0gZnVuY3Rpb24gKHRleHR1cmUsIHZlcnRpY2VzLCB1dnMsIGluZGljZXMsIGRyYXdNb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BpbmVNZXNoKHRleHR1cmUsIHZlcnRpY2VzLCB1dnMsIGluZGljZXMsIGRyYXdNb2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS50cmFuc2Zvcm1IYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwaW5lLnByb3RvdHlwZS5oYWNrQXR0YWNobWVudEdyb3VwcyA9IGZ1bmN0aW9uIChuYW1lU3VmZml4LCBncm91cCwgb3V0R3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKCFuYW1lU3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxpc3RfZCA9IFtdLCBsaXN0X24gPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gdGhpcy5za2VsZXRvbi5zbG90c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lXzYgPSBzbG90LmN1cnJlbnRTcHJpdGVOYW1lIHx8IHNsb3QuY3VycmVudE1lc2hOYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc2xvdC5jdXJyZW50U3ByaXRlIHx8IHNsb3QuY3VycmVudE1lc2g7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZV82LmVuZHNXaXRoKG5hbWVTdWZmaXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhcmVudEdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdF9uLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG91dEdyb3VwICYmIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXJlbnRHcm91cCA9IG91dEdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RfZC5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtsaXN0X2QsIGxpc3Rfbl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICA7XHJcbiAgICAgICAgU3BpbmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuc2tlbGV0b24uc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuc2tlbGV0b24uc2xvdHNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzcgaW4gc2xvdC5tZXNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Lm1lc2hlc1tuYW1lXzddLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbG90Lm1lc2hlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzggaW4gc2xvdC5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5zcHJpdGVzW25hbWVfOF0uZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnNsb3RDb250YWluZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90Q29udGFpbmVyc1tpXS5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3BpbmVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5za2VsZXRvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdENvbnRhaW5lcnMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDbGlwQ29udGFpbmVycyA9IG51bGw7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3BpbmUuZ2xvYmFsQXV0b1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgU3BpbmUuZ2xvYmFsRGVsYXlMaW1pdCA9IDA7XHJcbiAgICAgICAgU3BpbmUuY2xpcHBpbmdQb2x5Z29uID0gW107XHJcbiAgICAgICAgcmV0dXJuIFNwaW5lO1xyXG4gICAgfShQSVhJLkNvbnRhaW5lcikpO1xyXG4gICAgcGl4aV9zcGluZS5TcGluZSA9IFNwaW5lO1xyXG4gICAgZnVuY3Rpb24gU2xvdENvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybVYzKCkge1xyXG4gICAgICAgIHZhciBwdCA9IHRoaXMucGFyZW50LndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcclxuICAgICAgICB3dC5hID0gbHQuYSAqIHB0LmEgKyBsdC5iICogcHQuYztcclxuICAgICAgICB3dC5iID0gbHQuYSAqIHB0LmIgKyBsdC5iICogcHQuZDtcclxuICAgICAgICB3dC5jID0gbHQuYyAqIHB0LmEgKyBsdC5kICogcHQuYztcclxuICAgICAgICB3dC5kID0gbHQuYyAqIHB0LmIgKyBsdC5kICogcHQuZDtcclxuICAgICAgICB3dC50eCA9IGx0LnR4ICogcHQuYSArIGx0LnR5ICogcHQuYyArIHB0LnR4O1xyXG4gICAgICAgIHd0LnR5ID0gbHQudHggKiBwdC5iICsgbHQudHkgKiBwdC5kICsgcHQudHk7XHJcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XHJcbiAgICB9XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG52YXIgcGl4aV9zcGluZTtcclxuKGZ1bmN0aW9uIChwaXhpX3NwaW5lKSB7XHJcbiAgICBQSVhJLnNwaW5lID0gcGl4aV9zcGluZTtcclxuICAgIHZhciBUZXh0dXJlUHJvdG8gPSBQSVhJLlRleHR1cmUucHJvdG90eXBlO1xyXG4gICAgaWYgKCFUZXh0dXJlUHJvdG8uX3VwZGF0ZVV2cykge1xyXG4gICAgICAgIFRleHR1cmVQcm90by5fdXBkYXRlVXZzID0gVGV4dHVyZVByb3RvLnVwZGF0ZVV2cztcclxuICAgIH1cclxufSkocGl4aV9zcGluZSB8fCAocGl4aV9zcGluZSA9IHt9KSk7XHJcbnZhciBwaXhpX3NwaW5lO1xyXG4oZnVuY3Rpb24gKHBpeGlfc3BpbmUpIHtcclxuICAgIGZ1bmN0aW9uIGlzSnNvbihyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiByZXNvdXJjZS50eXBlID09PSBQSVhJLkxvYWRlclJlc291cmNlLlRZUEUuSlNPTjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQnVmZmVyKHJlc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc291cmNlLnhoclR5cGUgPT09IFBJWEkuTG9hZGVyUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSO1xyXG4gICAgfVxyXG4gICAgUElYSS5Mb2FkZXJSZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlKCdza2VsJywgUElYSS5Mb2FkZXJSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVIpO1xyXG4gICAgdmFyIEF0bGFzUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBdGxhc1BhcnNlcigpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXRsYXNQYXJzZXIudXNlID0gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2UuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNKc29uU3BpbmVNb2RlbCA9IGlzSnNvbihyZXNvdXJjZSkgJiYgcmVzb3VyY2UuZGF0YS5ib25lcztcclxuICAgICAgICAgICAgdmFyIGlzQmluYXJ5U3BpbmVNb2RlbCA9IGlzQnVmZmVyKHJlc291cmNlKSAmJiAocmVzb3VyY2UuZXh0ZW5zaW9uID09PSAnc2tlbCcgfHwgcmVzb3VyY2UubWV0YWRhdGEuc3BpbmVNZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICghaXNKc29uU3BpbmVNb2RlbCAmJiAhaXNCaW5hcnlTcGluZU1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVRvUGFyc2UgPSByZXNvdXJjZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAoaXNKc29uU3BpbmVNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gbmV3IHBpeGlfc3BpbmUuY29yZS5Ta2VsZXRvbkpzb24obnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSBuZXcgcGl4aV9zcGluZS5jb3JlLlNrZWxldG9uQmluYXJ5KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb1BhcnNlID0gbmV3IFVpbnQ4QXJyYXkocmVzb3VyY2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gcmVzb3VyY2UubWV0YWRhdGEgfHwge307XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YVNrZWxldG9uU2NhbGUgPSBtZXRhZGF0YSA/IHJlc291cmNlLm1ldGFkYXRhLnNwaW5lU2tlbGV0b25TY2FsZSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVNrZWxldG9uU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5zY2FsZSA9IG1ldGFkYXRhU2tlbGV0b25TY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFBdGxhcyA9IG1ldGFkYXRhID8gcmVzb3VyY2UubWV0YWRhdGEuc3BpbmVBdGxhcyA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YUF0bGFzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFBdGxhcyAmJiBtZXRhZGF0YUF0bGFzLnBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuYXR0YWNobWVudExvYWRlciA9IG5ldyBwaXhpX3NwaW5lLmNvcmUuQXRsYXNBdHRhY2htZW50TG9hZGVyKG1ldGFkYXRhQXRsYXMpO1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2Uuc3BpbmVEYXRhID0gcGFyc2VyLnJlYWRTa2VsZXRvbkRhdGEoZGF0YVRvUGFyc2UpO1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2Uuc3BpbmVBdGxhcyA9IG1ldGFkYXRhQXRsYXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YUF0bGFzU3VmZml4ID0gbWV0YWRhdGEuc3BpbmVBdGxhc1N1ZmZpeCB8fCAnLmF0bGFzJztcclxuICAgICAgICAgICAgdmFyIGF0bGFzUGF0aCA9IHJlc291cmNlLnVybDtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nUG9zID0gYXRsYXNQYXRoLmluZGV4T2YoJz8nKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nUG9zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYXRsYXNQYXRoID0gYXRsYXNQYXRoLnN1YnN0cigwLCBxdWVyeVN0cmluZ1Bvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXRsYXNQYXRoID0gYXRsYXNQYXRoLnN1YnN0cigwLCBhdGxhc1BhdGgubGFzdEluZGV4T2YoJy4nKSkgKyBtZXRhZGF0YUF0bGFzU3VmZml4O1xyXG4gICAgICAgICAgICBpZiAocmVzb3VyY2UubWV0YWRhdGEgJiYgcmVzb3VyY2UubWV0YWRhdGEuc3BpbmVBdGxhc0ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGF0bGFzUGF0aCA9IHJlc291cmNlLm1ldGFkYXRhLnNwaW5lQXRsYXNGaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0bGFzUGF0aCA9IGF0bGFzUGF0aC5yZXBsYWNlKHRoaXMuYmFzZVVybCwgJycpO1xyXG4gICAgICAgICAgICB2YXIgYXRsYXNPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHJlc291cmNlLmNyb3NzT3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgeGhyVHlwZTogUElYSS5Mb2FkZXJSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLnNwaW5lTWV0YWRhdGEgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlc291cmNlOiByZXNvdXJjZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHJlc291cmNlLmNyb3NzT3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLmltYWdlTWV0YWRhdGEgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlc291cmNlOiByZXNvdXJjZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybCA9IHJlc291cmNlLnVybC5zdWJzdHIoMCwgcmVzb3VyY2UudXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcclxuICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmwucmVwbGFjZSh0aGlzLmJhc2VVcmwsICcnKTtcclxuICAgICAgICAgICAgdmFyIG5hbWVQcmVmaXggPSBtZXRhZGF0YS5pbWFnZU5hbWVQcmVmaXggfHwgKHJlc291cmNlLm5hbWUgKyAnX2F0bGFzX3BhZ2VfJyk7XHJcbiAgICAgICAgICAgIHZhciBhZGFwdGVyID0gbWV0YWRhdGEuaW1hZ2VzID8gc3RhdGljSW1hZ2VMb2FkZXIobWV0YWRhdGEuaW1hZ2VzKVxyXG4gICAgICAgICAgICAgICAgOiBtZXRhZGF0YS5pbWFnZSA/IHN0YXRpY0ltYWdlTG9hZGVyKHsgJ2RlZmF1bHQnOiBtZXRhZGF0YS5pbWFnZSB9KVxyXG4gICAgICAgICAgICAgICAgICAgIDogbWV0YWRhdGEuaW1hZ2VMb2FkZXIgPyBtZXRhZGF0YS5pbWFnZUxvYWRlcih0aGlzLCBuYW1lUHJlZml4LCBiYXNlVXJsLCBpbWFnZU9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW1hZ2VMb2FkZXJBZGFwdGVyKHRoaXMsIG5hbWVQcmVmaXgsIGJhc2VVcmwsIGltYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVTa2VsZXRvbldpdGhSYXdBdGxhcyA9IGZ1bmN0aW9uIChyYXdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgcGl4aV9zcGluZS5jb3JlLlRleHR1cmVBdGxhcyhyYXdEYXRhLCBhZGFwdGVyLCBmdW5jdGlvbiAoc3BpbmVBdGxhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGluZUF0bGFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRhY2htZW50TG9hZGVyID0gbmV3IHBpeGlfc3BpbmUuY29yZS5BdGxhc0F0dGFjaG1lbnRMb2FkZXIoc3BpbmVBdGxhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnNwaW5lRGF0YSA9IHBhcnNlci5yZWFkU2tlbGV0b25EYXRhKGRhdGFUb1BhcnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2Uuc3BpbmVBdGxhcyA9IHNwaW5lQXRsYXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAocmVzb3VyY2UubWV0YWRhdGEgJiYgcmVzb3VyY2UubWV0YWRhdGEuYXRsYXNSYXdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVTa2VsZXRvbldpdGhSYXdBdGxhcyhyZXNvdXJjZS5tZXRhZGF0YS5hdGxhc1Jhd0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQocmVzb3VyY2UubmFtZSArICdfYXRsYXMnLCBhdGxhc1BhdGgsIGF0bGFzT3B0aW9ucywgZnVuY3Rpb24gKGF0bGFzUmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0bGFzUmVzb3VyY2UuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2tlbGV0b25XaXRoUmF3QXRsYXMoYXRsYXNSZXNvdXJjZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEF0bGFzUGFyc2VyO1xyXG4gICAgfSgpKTtcclxuICAgIHBpeGlfc3BpbmUuQXRsYXNQYXJzZXIgPSBBdGxhc1BhcnNlcjtcclxuICAgIGZ1bmN0aW9uIGltYWdlTG9hZGVyQWRhcHRlcihsb2FkZXIsIG5hbWVQcmVmaXgsIGJhc2VVcmwsIGltYWdlT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChiYXNlVXJsICYmIGJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSAhPT0gKGJhc2VVcmwubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgYmFzZVVybCArPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGluZSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lUHJlZml4ICsgbGluZTtcclxuICAgICAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyBsaW5lO1xyXG4gICAgICAgICAgICB2YXIgY2FjaGVkUmVzb3VyY2UgPSBsb2FkZXIucmVzb3VyY2VzW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNhY2hlZFJlc291cmNlLnRleHR1cmUuYmFzZVRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNvdXJjZS50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzb3VyY2Uub25BZnRlck1pZGRsZXdhcmUuYWRkKGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVyLmFkZChuYW1lLCB1cmwsIGltYWdlT3B0aW9ucywgZnVuY3Rpb24gKHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvdXJjZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNvdXJjZS50ZXh0dXJlLmJhc2VUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHBpeGlfc3BpbmUuaW1hZ2VMb2FkZXJBZGFwdGVyID0gaW1hZ2VMb2FkZXJBZGFwdGVyO1xyXG4gICAgZnVuY3Rpb24gc3luY0ltYWdlTG9hZGVyQWRhcHRlcihiYXNlVXJsLCBjcm9zc09yaWdpbikge1xyXG4gICAgICAgIGlmIChiYXNlVXJsICYmIGJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSAhPT0gKGJhc2VVcmwubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgYmFzZVVybCArPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGluZSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soUElYSS5CYXNlVGV4dHVyZS5mcm9tKGxpbmUsIGNyb3NzT3JpZ2luKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHBpeGlfc3BpbmUuc3luY0ltYWdlTG9hZGVyQWRhcHRlciA9IHN5bmNJbWFnZUxvYWRlckFkYXB0ZXI7XHJcbiAgICBmdW5jdGlvbiBzdGF0aWNJbWFnZUxvYWRlcihwYWdlcykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGluZSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIHBhZ2UgPSBwYWdlc1tsaW5lXSB8fCBwYWdlc1snZGVmYXVsdCddO1xyXG4gICAgICAgICAgICBpZiAocGFnZSAmJiBwYWdlLmJhc2VUZXh0dXJlKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socGFnZS5iYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhZ2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwaXhpX3NwaW5lLnN0YXRpY0ltYWdlTG9hZGVyID0gc3RhdGljSW1hZ2VMb2FkZXI7XHJcbiAgICBpZiAoUElYSS5Mb2FkZXIpIHtcclxuICAgICAgICBQSVhJLkxvYWRlci5yZWdpc3RlclBsdWdpbihBdGxhc1BhcnNlcik7XHJcbiAgICB9XHJcbn0pKHBpeGlfc3BpbmUgfHwgKHBpeGlfc3BpbmUgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXhpLXNwaW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pixi-spine/dist/pixi-spine.js\n");

/***/ }),

/***/ "./src/App.ts":
/*!********************!*\
  !*** ./src/App.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"App\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalVariables */ \"./src/GlobalVariables.ts\");\n/* harmony import */ var _Main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Main */ \"./src/Main.ts\");\n/* harmony import */ var _ResourceLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ResourceLoader */ \"./src/ResourceLoader.ts\");\n\r\n\r\n\r\n\r\nclass App {\r\n    constructor() {\r\n        this.getPixiApp = () => {\r\n            PIXI.settings.ROUND_PIXELS = true;\r\n            PIXI.settings.SORTABLE_CHILDREN = true;\r\n            PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\r\n            return new PIXI.Application({\r\n                width: _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width,\r\n                height: _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height,\r\n                view: this.canvas,\r\n                sharedLoader: true,\r\n                sharedTicker: true,\r\n            });\r\n        };\r\n        this.on_resize = () => {\r\n            const multiplier = window.innerHeight / _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.app_height;\r\n            const target_width = window.innerWidth / multiplier;\r\n            this.app.renderer.resize(target_width, _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.app_height);\r\n            if (window.innerWidth < window.innerHeight) {\r\n                _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_landscape = false;\r\n            }\r\n            else {\r\n                _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_landscape = true;\r\n            }\r\n            _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width = this.app.view.width;\r\n            _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height = this.app.view.height;\r\n            _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.notify_all();\r\n            if (this.main) {\r\n                this.main.resize();\r\n            }\r\n        };\r\n        _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.is_mobile = PIXI.utils.isMobile.any;\r\n        this.canvas = document.getElementById(\"root\");\r\n        _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars.localAddress =\r\n            `${window.location.origin}${window.location.pathname}`.replace(\"index.html\", \"\");\r\n        window.rc = _ResourceLoader__WEBPACK_IMPORTED_MODULE_3__.ResourceController;\r\n        this.canvas.style.width = \"100%\";\r\n        this.canvas.style.height = \"100%\";\r\n        this.canvas.style.marginTop = \"0\";\r\n        this.canvas.style.marginLeft = \"0\";\r\n        this.app = this.getPixiApp();\r\n        this.app.renderer.view.style.display = \"none\";\r\n        this.main = new _Main__WEBPACK_IMPORTED_MODULE_2__.Main(this.app);\r\n        this.app.stage.addChildAt(this.main.container, 0);\r\n        window.main = this.main;\r\n        window.gv = _GlobalVariables__WEBPACK_IMPORTED_MODULE_1__.Global_Vars;\r\n        window.onresize = this.on_resize;\r\n        window.onorientationchange = this.on_resize;\r\n        this.on_resize();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQXBwLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFyRUE7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFzQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZXNhbmRib3gvLi9zcmMvQXBwLnRzP2QwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSBcIi4vQ29uZmlnXCI7XHJcbmltcG9ydCB7IEdsb2JhbF9WYXJzIH0gZnJvbSBcIi4vR2xvYmFsVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7IE1haW4gfSBmcm9tIFwiLi9NYWluXCI7XHJcbmltcG9ydCB7IFJlc291cmNlQ29udHJvbGxlciB9IGZyb20gXCIuL1Jlc291cmNlTG9hZGVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQXBwIHtcclxuICAgIHJlYWRvbmx5IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgICByZWFkb25seSBhcHA6IFBJWEkuQXBwbGljYXRpb247XHJcbiAgICBtYWluITogTWFpbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBHbG9iYWxfVmFycy5pc19tb2JpbGUgPSBQSVhJLnV0aWxzLmlzTW9iaWxlLmFueTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHJcbiAgICAgICAgR2xvYmFsX1ZhcnMubG9jYWxBZGRyZXNzID1cclxuICAgICAgICAgICAgYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0ke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX1gLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICBcImluZGV4Lmh0bWxcIixcclxuICAgICAgICAgICAgICAgIFwiXCJcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAod2luZG93IGFzIGFueSkucmMgPSBSZXNvdXJjZUNvbnRyb2xsZXI7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubWFyZ2luVG9wID0gXCIwXCI7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubWFyZ2luTGVmdCA9IFwiMFwiO1xyXG5cclxuICAgICAgICB0aGlzLmFwcCA9IHRoaXMuZ2V0UGl4aUFwcCgpO1xyXG4gICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnZpZXcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cclxuICAgICAgICB0aGlzLm1haW4gPSBuZXcgTWFpbih0aGlzLmFwcCk7XHJcblxyXG4gICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkQXQodGhpcy5tYWluLmNvbnRhaW5lciwgMCk7XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLm1haW4gPSB0aGlzLm1haW47XHJcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLmd2ID0gR2xvYmFsX1ZhcnM7XHJcblxyXG4gICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IHRoaXMub25fcmVzaXplO1xyXG4gICAgICAgIHdpbmRvdy5vbm9yaWVudGF0aW9uY2hhbmdlID0gdGhpcy5vbl9yZXNpemU7XHJcblxyXG4gICAgICAgIHRoaXMub25fcmVzaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGl4aUFwcCA9ICgpID0+IHtcclxuICAgICAgICBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMUyA9IHRydWU7XHJcbiAgICAgICAgUElYSS5zZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTiA9IHRydWU7XHJcbiAgICAgICAgUElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFID0gUElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFBJWEkuQXBwbGljYXRpb24oe1xyXG4gICAgICAgICAgICB3aWR0aDogQ29uZmlnLnByb2plY3Rfd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogQ29uZmlnLnByb2plY3RfaGVpZ2h0LFxyXG4gICAgICAgICAgICB2aWV3OiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgc2hhcmVkTG9hZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBzaGFyZWRUaWNrZXI6IHRydWUsXHJcbiAgICAgICAgICAgIC8vIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBvbl9yZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IHdpbmRvdy5pbm5lckhlaWdodCAvIEdsb2JhbF9WYXJzLmFwcF9oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0X3dpZHRoID0gd2luZG93LmlubmVyV2lkdGggLyBtdWx0aXBsaWVyO1xyXG5cclxuICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci5yZXNpemUodGFyZ2V0X3dpZHRoLCBHbG9iYWxfVmFycy5hcHBfaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIEdsb2JhbF9WYXJzLmlzX2xhbmRzY2FwZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIEdsb2JhbF9WYXJzLmlzX2xhbmRzY2FwZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBDb25maWcucHJvamVjdF93aWR0aCA9IHRoaXMuYXBwLnZpZXcud2lkdGg7XHJcbiAgICAgICAgQ29uZmlnLnByb2plY3RfaGVpZ2h0ID0gdGhpcy5hcHAudmlldy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIEdsb2JhbF9WYXJzLm5vdGlmeV9hbGwoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWFpbikge1xyXG4gICAgICAgICAgICB0aGlzLm1haW4ucmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/App.ts\n");

/***/ }),

/***/ "./src/Config.ts":
/*!***********************!*\
  !*** ./src/Config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Config\": () => (/* binding */ Config)\n/* harmony export */ });\nconst Config = {\r\n    project_width: 1920,\r\n    project_height: 1080,\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29uZmlnLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lc2FuZGJveC8uL3NyYy9Db25maWcudHM/ZjJjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQ29uZmlnID0ge1xyXG4gICAgcHJvamVjdF93aWR0aDogMTkyMCxcclxuICAgIHByb2plY3RfaGVpZ2h0OiAxMDgwLFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Config.ts\n");

/***/ }),

/***/ "./src/GlobalVariables.ts":
/*!********************************!*\
  !*** ./src/GlobalVariables.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Global_Vars\": () => (/* binding */ Global_Vars)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Observer */ \"./src/Observer.ts\");\n\r\n\r\nclass GlobalVariablesClass extends _Observer__WEBPACK_IMPORTED_MODULE_1__.Subject {\r\n    constructor() {\r\n        super();\r\n        this.app_width = _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width;\r\n        this.app_height = _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height;\r\n        this.is_mobile = false;\r\n        this.is_landscape = true;\r\n        this.localAddress = \"\";\r\n    }\r\n}\r\nconst Global_Vars = new GlobalVariablesClass();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvR2xvYmFsVmFyaWFibGVzLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFSQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BpbmVzYW5kYm94Ly4vc3JjL0dsb2JhbFZhcmlhYmxlcy50cz9kNWQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbmZpZyB9IGZyb20gXCIuL0NvbmZpZ1wiO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcIi4vT2JzZXJ2ZXJcIjtcclxuXHJcbmNsYXNzIEdsb2JhbFZhcmlhYmxlc0NsYXNzIGV4dGVuZHMgU3ViamVjdCB7XHJcbiAgICBhcHBfd2lkdGggPSBDb25maWcucHJvamVjdF93aWR0aDtcclxuICAgIGFwcF9oZWlnaHQgPSBDb25maWcucHJvamVjdF9oZWlnaHQ7XHJcblxyXG4gICAgaXNfbW9iaWxlID0gZmFsc2U7XHJcbiAgICBpc19sYW5kc2NhcGUgPSB0cnVlO1xyXG4gICAgbG9jYWxBZGRyZXNzID0gXCJcIjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgR2xvYmFsX1ZhcnMgPSBuZXcgR2xvYmFsVmFyaWFibGVzQ2xhc3MoKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/GlobalVariables.ts\n");

/***/ }),

/***/ "./src/Main.ts":
/*!*********************!*\
  !*** ./src/Main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Main\": () => (/* binding */ Main)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\n/* harmony import */ var _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResourceLoader */ \"./src/ResourceLoader.ts\");\n/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\r\n\r\n\r\n\r\nclass Main {\r\n    constructor(app) {\r\n        this.all = [];\r\n        this.currentBGColor = 0;\r\n        this.setUpGUI = () => {\r\n            this.gui = new dat_gui__WEBPACK_IMPORTED_MODULE_2__.GUI({\r\n                name: \"Spine Sandbox\",\r\n                closed: false,\r\n                closeOnTop: true,\r\n            });\r\n            this.gui.addColor(this.app.renderer, \"backgroundColor\");\r\n        };\r\n        this.showGUI = () => {\r\n            const folder1 = this.gui.addFolder(\"Spine Params\");\r\n            folder1.open();\r\n            const animScale = folder1.add(this.targetAnim.scale, \"x\", 0.1, 3, 0.01);\r\n            animScale.name(\"Animation Scale\");\r\n            animScale.onChange((value) => {\r\n                this.targetAnim.scale.set(value);\r\n            });\r\n            const animSpeed = folder1.add(this.targetAnim.state, \"timeScale\", 0.1, 3, 0.01);\r\n            animSpeed.name(\"Animation Speed\");\r\n            animSpeed.onChange((value) => {\r\n                this.targetAnim.state.timeScale = value;\r\n            });\r\n            const setDefaultSpineParams = {\r\n                add: () => {\r\n                    animScale.setValue(1);\r\n                    animSpeed.setValue(1);\r\n                },\r\n            };\r\n            const setDefaultButton = folder1.add(setDefaultSpineParams, \"add\");\r\n            setDefaultButton.name(\"Set Defaut\");\r\n            const animationsArray = this.targetAnim.state.data.skeletonData.animations.map((a) => a.name);\r\n            const skinsArray = this.targetAnim.skeleton.data.skins.map((a) => a.name);\r\n            const animationParams = {\r\n                animsArray: animationsArray,\r\n                loop: false,\r\n                skins: skinsArray,\r\n                defaultSkin: true,\r\n            };\r\n            const folder2 = this.gui.addFolder(\"Set Animation\");\r\n            folder2.open();\r\n            const chooseAnim = folder2.add(animationParams, \"animsArray\", animationsArray);\r\n            chooseAnim.name(\"Choose Animation\");\r\n            chooseAnim.setValue(\"\");\r\n            chooseAnim.onChange((value) => {\r\n                this.targetAnim.state.setAnimation(0, value, this.loopedAnim || false);\r\n                this.lastAnim = value;\r\n            });\r\n            const loopedAnim = folder2.add(animationParams, \"loop\");\r\n            loopedAnim.name(\"Loop\");\r\n            loopedAnim.onChange((value) => {\r\n                if (this.lastAnim) {\r\n                    this.targetAnim.state.setAnimation(0, this.lastAnim, value);\r\n                }\r\n                this.loopedAnim = value;\r\n            });\r\n            console.log(animationsArray);\r\n            const folder3 = this.gui.addFolder(\"Set Skin\");\r\n            folder3.open();\r\n            const chooseSkin = folder3.add(animationParams, \"skins\", skinsArray);\r\n            chooseSkin.name(\"Choose Skin\");\r\n            chooseSkin.onChange((value) => {\r\n                this.targetAnim.skeleton.setSkinByName(value);\r\n                this.targetAnim.skeleton.setSlotsToSetupPose();\r\n            });\r\n            const destroyAnim = {\r\n                add: () => {\r\n                    const aerusure = confirm(\"Are you sure? Spine animation will be removed.\");\r\n                    if (aerusure)\r\n                        this.destroySpine();\r\n                },\r\n            };\r\n            const destroyAnimButton = this.gui.add(destroyAnim, \"add\");\r\n            destroyAnimButton.name(\"Destroy Animation\");\r\n        };\r\n        this.init = () => {\r\n            console.log(\"App initialized\");\r\n            document.addEventListener(\"loadFile\", this.loadSpine);\r\n        };\r\n        this.validateResources = () => {\r\n            throw new Error();\r\n        };\r\n        this.buttonCb = () => (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {\r\n            const getTargetFileFromArray = (key) => {\r\n                const result = [];\r\n                this.all.forEach((asset) => {\r\n                    const name = asset.file.name.split(\".\").pop();\r\n                    if (name === key)\r\n                        result.push(asset);\r\n                });\r\n                return result;\r\n            };\r\n            const atlasData = getTargetFileFromArray(\"atlas\")[0];\r\n            const atlasLoaderOption = { xhrType: \"text\" };\r\n            PIXI.Loader.shared.add(atlasData.file.name, atlasData.data, atlasLoaderOption);\r\n            const imageData = getTargetFileFromArray(\"png\");\r\n            imageData.forEach((atlasPage) => {\r\n                PIXI.Loader.shared.add(atlasPage.file.name, atlasPage.data);\r\n            });\r\n            yield new Promise((resolve) => {\r\n                PIXI.Loader.shared.load(resolve);\r\n            });\r\n            const imageArr = {};\r\n            imageData.forEach((res) => {\r\n                imageArr[res.file.name] = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(res.file.name).texture.baseTexture;\r\n            });\r\n            console.log(imageArr);\r\n            const spineData = getTargetFileFromArray(\"json\")[0];\r\n            const spineLoaderOptions = {\r\n                metadata: {\r\n                    atlasRawData: _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(atlasData.file.name).data,\r\n                    images: imageArr,\r\n                },\r\n            };\r\n            console.log(_ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getResource(atlasData.file.name).data.split(/\\r\\n|\\r|\\n/));\r\n            PIXI.Loader.shared.add(\"main.json\", spineData.data, spineLoaderOptions);\r\n            PIXI.Loader.shared.load(() => {\r\n                this.createSpineAnimation();\r\n                this.loadingText.visible = false;\r\n            });\r\n        });\r\n        this.changeStageState = (show) => {\r\n            if (show) {\r\n                this.app.renderer.view.style.display = \"\";\r\n                document.getElementById(\"frominput\").style.display = \"none\";\r\n                this.setUpGUI();\r\n                this.loadingText.visible = true;\r\n            }\r\n            else {\r\n                this.app.renderer.view.style.display = \"none\";\r\n                document.getElementById(\"frominput\").style.display = \"flex\";\r\n            }\r\n        };\r\n        this.loadSpine = () => (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {\r\n            console.log(\"loadSpine\");\r\n            const input = document.getElementById(\"fileinput\");\r\n            let files;\r\n            const fr = new FileReader();\r\n            if (typeof window.FileReader !== \"function\") {\r\n                throw new Error(\"The file API isn't supported on this browser yet.\");\r\n            }\r\n            if (!input) {\r\n                throw new Error(\"Um, couldn't find the fileinput element.\");\r\n            }\r\n            else if (!input.files) {\r\n                throw new Error(\"This browser doesn't seem to support the `files` property of file inputs.\");\r\n            }\r\n            else if (!input.files[0]) {\r\n                console.error(\"Please select a file before clicking 'Load'\");\r\n            }\r\n            else {\r\n                const required = [\"atlas\", \"json\", \"png\"];\r\n                files = input.files;\r\n                for (const file of files) {\r\n                    required.splice(required.indexOf(file.name.split(\".\").pop()), 1);\r\n                }\r\n                if (required.length !== 0) {\r\n                    console.error(`Please select ALL spine files. NOT FOUND {${required}}`);\r\n                    return;\r\n                }\r\n                this.changeStageState(true);\r\n                const loadFile = (file) => {\r\n                    return new Promise((resolve) => {\r\n                        fr.onload = (data) => {\r\n                            this.all.push({\r\n                                file,\r\n                                data: data.currentTarget.result,\r\n                            });\r\n                            fr.onload = () => { };\r\n                            resolve();\r\n                        };\r\n                        fr.readAsDataURL(file);\r\n                    });\r\n                };\r\n                for (const file of files) {\r\n                    yield loadFile(file);\r\n                }\r\n                console.log(files);\r\n                this.buttonCb();\r\n            }\r\n        });\r\n        this.createSpineAnimation = () => {\r\n            this.targetAnim = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.getSpine(\"main.json\");\r\n            this.container.addChild(this.targetAnim);\r\n            this.resize();\r\n            this.showGUI();\r\n        };\r\n        this.destroySpine = () => {\r\n            var _a;\r\n            (_a = this.targetAnim) === null || _a === void 0 ? void 0 : _a.destroy({\r\n                children: true,\r\n                texture: true,\r\n                baseTexture: true,\r\n            });\r\n            this.targetAnim = undefined;\r\n            this.lastAnim = undefined;\r\n            this.loopedAnim = undefined;\r\n            this.currentSkin = undefined;\r\n            const loader = _ResourceLoader__WEBPACK_IMPORTED_MODULE_1__.ResourceController.loader;\r\n            for (const res of Object.keys(loader.resources)) {\r\n                delete loader.resources[res];\r\n            }\r\n            this.all.length = 0;\r\n            PIXI.utils.BaseTextureCache = {};\r\n            PIXI.utils.TextureCache = {};\r\n            PIXI.utils.clearTextureCache();\r\n            loader.reset();\r\n            loader.destroy();\r\n            this.gui.destroy();\r\n            this.changeStageState(false);\r\n            document.getElementById(\"frominput\").reset();\r\n        };\r\n        this.resize = () => {\r\n            if (this.targetAnim) {\r\n                this.targetAnim.position.set(_Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_width / 2, _Config__WEBPACK_IMPORTED_MODULE_0__.Config.project_height / 2);\r\n            }\r\n        };\r\n        this.app = app;\r\n        this.container = new PIXI.Container();\r\n        this.loadingText = new PIXI.Text(\"Spine is loading, please wait...\", new PIXI.TextStyle({\r\n            fill: 0xffffff,\r\n            fontSize: 50,\r\n        }));\r\n        this.container.addChild(this.loadingText);\r\n        this.init();\r\n        this.resize();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTWFpbi50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQWFBO0FBVkE7QUFPQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFwVkE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF1VUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZXNhbmRib3gvLi9zcmMvTWFpbi50cz8zNGNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbmZpZyB9IGZyb20gXCIuL0NvbmZpZ1wiO1xyXG5pbXBvcnQgeyBSZXNvdXJjZUNvbnRyb2xsZXIgfSBmcm9tIFwiLi9SZXNvdXJjZUxvYWRlclwiO1xyXG5pbXBvcnQgKiBhcyBkYXQgZnJvbSBcImRhdC5ndWlcIjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcclxuXHJcbmV4cG9ydCBjbGFzcyBNYWluIHtcclxuICAgIGNvbnRhaW5lcjogUElYSS5Db250YWluZXI7XHJcbiAgICBmb3JtITogSFRNTEVsZW1lbnQ7XHJcbiAgICBhbGw6IGFueVtdID0gW107XHJcbiAgICB0YXJnZXRBbmltPzogUElYSS5zcGluZS5TcGluZTtcclxuICAgIGd1aSE6IGRhdC5HVUk7XHJcbiAgICBsYXN0QW5pbT86IHN0cmluZztcclxuICAgIGxvb3BlZEFuaW0/OiBib29sZWFuO1xyXG4gICAgY3VycmVudFNraW4/OiBzdHJpbmc7XHJcbiAgICBhcHA6IFBJWEkuQXBwbGljYXRpb247XHJcbiAgICBjdXJyZW50QkdDb2xvciA9IDA7XHJcbiAgICBsb2FkaW5nVGV4dCE6IFBJWEkuVGV4dDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IFBJWEkuQXBwbGljYXRpb24pIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICAvLyB0aGlzLnNldFVwR1VJKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nVGV4dCA9IG5ldyBQSVhJLlRleHQoXHJcbiAgICAgICAgICAgIFwiU3BpbmUgaXMgbG9hZGluZywgcGxlYXNlIHdhaXQuLi5cIixcclxuICAgICAgICAgICAgbmV3IFBJWEkuVGV4dFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDUwLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5sb2FkaW5nVGV4dCk7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRVcEdVSSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmd1aSA9IG5ldyBkYXQuR1VJKHtcclxuICAgICAgICAgICAgbmFtZTogXCJTcGluZSBTYW5kYm94XCIsXHJcbiAgICAgICAgICAgIGNsb3NlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNsb3NlT25Ub3A6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3VpLmFkZENvbG9yKHRoaXMuYXBwLnJlbmRlcmVyLCBcImJhY2tncm91bmRDb2xvclwiKTtcclxuICAgIH07XHJcblxyXG4gICAgc2hvd0dVSSA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBmb2xkZXIxID0gdGhpcy5ndWkuYWRkRm9sZGVyKFwiU3BpbmUgUGFyYW1zXCIpO1xyXG4gICAgICAgIGZvbGRlcjEub3BlbigpO1xyXG4gICAgICAgIGNvbnN0IGFuaW1TY2FsZSA9IGZvbGRlcjEuYWRkKFxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldEFuaW0hLnNjYWxlLFxyXG4gICAgICAgICAgICBcInhcIixcclxuICAgICAgICAgICAgMC4xLFxyXG4gICAgICAgICAgICAzLFxyXG4gICAgICAgICAgICAwLjAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbmltU2NhbGUubmFtZShcIkFuaW1hdGlvbiBTY2FsZVwiKTtcclxuICAgICAgICBhbmltU2NhbGUub25DaGFuZ2UoKHZhbHVlOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zY2FsZS5zZXQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBhbmltU3BlZWQgPSBmb2xkZXIxLmFkZChcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zdGF0ZSxcclxuICAgICAgICAgICAgXCJ0aW1lU2NhbGVcIixcclxuICAgICAgICAgICAgMC4xLFxyXG4gICAgICAgICAgICAzLFxyXG4gICAgICAgICAgICAwLjAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbmltU3BlZWQubmFtZShcIkFuaW1hdGlvbiBTcGVlZFwiKTtcclxuICAgICAgICBhbmltU3BlZWQub25DaGFuZ2UoKHZhbHVlOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zdGF0ZS50aW1lU2NhbGUgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2V0RGVmYXVsdFNwaW5lUGFyYW1zID0ge1xyXG4gICAgICAgICAgICBhZGQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGFuaW1TY2FsZS5zZXRWYWx1ZSgxKTtcclxuICAgICAgICAgICAgICAgIGFuaW1TcGVlZC5zZXRWYWx1ZSgxKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBzZXREZWZhdWx0QnV0dG9uID0gZm9sZGVyMS5hZGQoc2V0RGVmYXVsdFNwaW5lUGFyYW1zLCBcImFkZFwiKTtcclxuICAgICAgICBzZXREZWZhdWx0QnV0dG9uLm5hbWUoXCJTZXQgRGVmYXV0XCIpO1xyXG5cclxuICAgICAgICBjb25zdCBhbmltYXRpb25zQXJyYXkgPVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldEFuaW0hLnN0YXRlLmRhdGEuc2tlbGV0b25EYXRhLmFuaW1hdGlvbnMubWFwKFxyXG4gICAgICAgICAgICAgICAgKGEpID0+IGEubmFtZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBza2luc0FycmF5ID0gdGhpcy50YXJnZXRBbmltIS5za2VsZXRvbi5kYXRhLnNraW5zLm1hcChcclxuICAgICAgICAgICAgKGEpID0+IGEubmFtZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblBhcmFtcyA9IHtcclxuICAgICAgICAgICAgYW5pbXNBcnJheTogYW5pbWF0aW9uc0FycmF5LFxyXG4gICAgICAgICAgICBsb29wOiBmYWxzZSxcclxuICAgICAgICAgICAgc2tpbnM6IHNraW5zQXJyYXksXHJcbiAgICAgICAgICAgIGRlZmF1bHRTa2luOiB0cnVlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlcjIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoXCJTZXQgQW5pbWF0aW9uXCIpO1xyXG4gICAgICAgIGZvbGRlcjIub3BlbigpO1xyXG4gICAgICAgIGNvbnN0IGNob29zZUFuaW0gPSBmb2xkZXIyLmFkZChcclxuICAgICAgICAgICAgYW5pbWF0aW9uUGFyYW1zLFxyXG4gICAgICAgICAgICBcImFuaW1zQXJyYXlcIixcclxuICAgICAgICAgICAgYW5pbWF0aW9uc0FycmF5XHJcbiAgICAgICAgKTtcclxuICAgICAgICBjaG9vc2VBbmltLm5hbWUoXCJDaG9vc2UgQW5pbWF0aW9uXCIpO1xyXG4gICAgICAgIGNob29zZUFuaW0uc2V0VmFsdWUoXCJcIik7XHJcblxyXG4gICAgICAgIGNob29zZUFuaW0ub25DaGFuZ2UoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5zdGF0ZS5zZXRBbmltYXRpb24oXHJcbiAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3BlZEFuaW0gfHwgZmFsc2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0QW5pbSA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBsb29wZWRBbmltID0gZm9sZGVyMi5hZGQoYW5pbWF0aW9uUGFyYW1zLCBcImxvb3BcIik7XHJcbiAgICAgICAgbG9vcGVkQW5pbS5uYW1lKFwiTG9vcFwiKTtcclxuXHJcbiAgICAgICAgbG9vcGVkQW5pbS5vbkNoYW5nZSgodmFsdWU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdEFuaW0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbSEuc3RhdGUuc2V0QW5pbWF0aW9uKDAsIHRoaXMubGFzdEFuaW0sIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvb3BlZEFuaW0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYW5pbWF0aW9uc0FycmF5KTtcclxuXHJcbiAgICAgICAgY29uc3QgZm9sZGVyMyA9IHRoaXMuZ3VpLmFkZEZvbGRlcihcIlNldCBTa2luXCIpO1xyXG4gICAgICAgIGZvbGRlcjMub3BlbigpO1xyXG4gICAgICAgIGNvbnN0IGNob29zZVNraW4gPSBmb2xkZXIzLmFkZChhbmltYXRpb25QYXJhbXMsIFwic2tpbnNcIiwgc2tpbnNBcnJheSk7XHJcbiAgICAgICAgY2hvb3NlU2tpbi5uYW1lKFwiQ2hvb3NlIFNraW5cIik7XHJcblxyXG4gICAgICAgIGNob29zZVNraW4ub25DaGFuZ2UoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5za2VsZXRvbi5zZXRTa2luQnlOYW1lKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRBbmltIS5za2VsZXRvbi5zZXRTbG90c1RvU2V0dXBQb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lBbmltID0ge1xyXG4gICAgICAgICAgICBhZGQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFlcnVzdXJlID0gY29uZmlybShcclxuICAgICAgICAgICAgICAgICAgICBcIkFyZSB5b3Ugc3VyZT8gU3BpbmUgYW5pbWF0aW9uIHdpbGwgYmUgcmVtb3ZlZC5cIlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmIChhZXJ1c3VyZSkgdGhpcy5kZXN0cm95U3BpbmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBkZXN0cm95QW5pbUJ1dHRvbiA9IHRoaXMuZ3VpLmFkZChkZXN0cm95QW5pbSwgXCJhZGRcIik7XHJcbiAgICAgICAgZGVzdHJveUFuaW1CdXR0b24ubmFtZShcIkRlc3Ryb3kgQW5pbWF0aW9uXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0ID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXBwIGluaXRpYWxpemVkXCIpO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZEZpbGVcIiwgdGhpcy5sb2FkU3BpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YWxpZGF0ZVJlc291cmNlcyA9ICgpOiB2b2lkIHwgbmV2ZXIgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBidXR0b25DYiA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBnZXRUYXJnZXRGaWxlRnJvbUFycmF5ID0gKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8eyBmaWxlOiBGaWxlOyBkYXRhOiBhbnkgfT4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxsLmZvckVhY2goKGFzc2V0OiB7IGZpbGU6IEZpbGU7IGRhdGE6IFByb2dyZXNzRXZlbnQgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGFzc2V0LmZpbGUubmFtZS5zcGxpdChcIi5cIikucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGtleSkgcmVzdWx0LnB1c2goYXNzZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgYXRsYXNEYXRhID0gZ2V0VGFyZ2V0RmlsZUZyb21BcnJheShcImF0bGFzXCIpWzBdO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGF0bGFzRGF0YSk7XHJcbiAgICAgICAgY29uc3QgYXRsYXNMb2FkZXJPcHRpb24gPSB7IHhoclR5cGU6IFwidGV4dFwiIH07XHJcblxyXG4gICAgICAgIFBJWEkuTG9hZGVyLnNoYXJlZC5hZGQoXHJcbiAgICAgICAgICAgIGF0bGFzRGF0YS5maWxlLm5hbWUsXHJcbiAgICAgICAgICAgIGF0bGFzRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBhdGxhc0xvYWRlck9wdGlvblxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGdldFRhcmdldEZpbGVGcm9tQXJyYXkoXCJwbmdcIik7XHJcbiAgICAgICAgaW1hZ2VEYXRhLmZvckVhY2goKGF0bGFzUGFnZSkgPT4ge1xyXG4gICAgICAgICAgICBQSVhJLkxvYWRlci5zaGFyZWQuYWRkKGF0bGFzUGFnZS5maWxlLm5hbWUsIGF0bGFzUGFnZS5kYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgUElYSS5Mb2FkZXIuc2hhcmVkLmxvYWQocmVzb2x2ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGltYWdlQXJyOiB7IFtrZXk6IHN0cmluZ106IFBJWEkuQmFzZVRleHR1cmUgfSA9IHt9O1xyXG5cclxuICAgICAgICBpbWFnZURhdGEuZm9yRWFjaCgocmVzKSA9PiB7XHJcbiAgICAgICAgICAgIGltYWdlQXJyW3Jlcy5maWxlLm5hbWVdID0gUmVzb3VyY2VDb250cm9sbGVyLmdldFJlc291cmNlKFxyXG4gICAgICAgICAgICAgICAgcmVzLmZpbGUubmFtZVxyXG4gICAgICAgICAgICApLnRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGltYWdlQXJyKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3BpbmVEYXRhID0gZ2V0VGFyZ2V0RmlsZUZyb21BcnJheShcImpzb25cIilbMF07XHJcbiAgICAgICAgY29uc3Qgc3BpbmVMb2FkZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgYXRsYXNSYXdEYXRhOiBSZXNvdXJjZUNvbnRyb2xsZXIuZ2V0UmVzb3VyY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgYXRsYXNEYXRhLmZpbGUubmFtZVxyXG4gICAgICAgICAgICAgICAgKS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiBpbWFnZUFycixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgUmVzb3VyY2VDb250cm9sbGVyLmdldFJlc291cmNlKGF0bGFzRGF0YS5maWxlLm5hbWUpLmRhdGEuc3BsaXQoXHJcbiAgICAgICAgICAgICAgICAvXFxyXFxufFxccnxcXG4vXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBQSVhJLkxvYWRlci5zaGFyZWQuYWRkKFwibWFpbi5qc29uXCIsIHNwaW5lRGF0YS5kYXRhLCBzcGluZUxvYWRlck9wdGlvbnMpO1xyXG5cclxuICAgICAgICBQSVhJLkxvYWRlci5zaGFyZWQubG9hZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3BpbmVBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nVGV4dC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNoYW5nZVN0YWdlU3RhdGUgPSAoc2hvdzogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGlmIChzaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnZpZXcuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJvbWlucHV0XCIpIS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VXBHVUkoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nVGV4dC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci52aWV3LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcm9taW5wdXRcIikhLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRTcGluZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImxvYWRTcGluZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXHJcbiAgICAgICAgICAgIFwiZmlsZWlucHV0XCJcclxuICAgICAgICApIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGxldCBmaWxlczogRmlsZUxpc3Q7XHJcbiAgICAgICAgY29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5GaWxlUmVhZGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJUaGUgZmlsZSBBUEkgaXNuJ3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciB5ZXQuXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaW5wdXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW0sIGNvdWxkbid0IGZpbmQgdGhlIGZpbGVpbnB1dCBlbGVtZW50LlwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dC5maWxlcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCB0aGUgYGZpbGVzYCBwcm9wZXJ0eSBvZiBmaWxlIGlucHV0cy5cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlucHV0LmZpbGVzWzBdKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQbGVhc2Ugc2VsZWN0IGEgZmlsZSBiZWZvcmUgY2xpY2tpbmcgJ0xvYWQnXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkID0gW1wiYXRsYXNcIiwgXCJqc29uXCIsIFwicG5nXCJdO1xyXG5cclxuICAgICAgICAgICAgZmlsZXMgPSBpbnB1dC5maWxlcztcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQuc3BsaWNlKFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkLmluZGV4T2YoZmlsZS5uYW1lLnNwbGl0KFwiLlwiKS5wb3AoKSEpLFxyXG4gICAgICAgICAgICAgICAgICAgIDFcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgYFBsZWFzZSBzZWxlY3QgQUxMIHNwaW5lIGZpbGVzLiBOT1QgRk9VTkQgeyR7cmVxdWlyZWR9fWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhZ2VTdGF0ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRGaWxlID0gKGZpbGU6IEZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyLm9ubG9hZCA9IChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGwucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5jdXJyZW50VGFyZ2V0LnJlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSAoKSA9PiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzRGF0YVVSTChmaWxlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkRmlsZShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2IoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNyZWF0ZVNwaW5lQW5pbWF0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0QW5pbSA9IFJlc291cmNlQ29udHJvbGxlci5nZXRTcGluZShcIm1haW4uanNvblwiKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLnRhcmdldEFuaW0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnNob3dHVUkoKTtcclxuICAgIH07XHJcblxyXG4gICAgZGVzdHJveVNwaW5lID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0QW5pbT8uZGVzdHJveSh7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0dXJlOiB0cnVlLFxyXG4gICAgICAgICAgICBiYXNlVGV4dHVyZTogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy50YXJnZXRBbmltID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RBbmltID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubG9vcGVkQW5pbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTa2luID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCBsb2FkZXIgPSBSZXNvdXJjZUNvbnRyb2xsZXIubG9hZGVyO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHJlcyBvZiBPYmplY3Qua2V5cyhsb2FkZXIucmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgbG9hZGVyLnJlc291cmNlc1tyZXNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hbGwubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgUElYSS51dGlscy5CYXNlVGV4dHVyZUNhY2hlID0ge307XHJcbiAgICAgICAgUElYSS51dGlscy5UZXh0dXJlQ2FjaGUgPSB7fTtcclxuXHJcbiAgICAgICAgUElYSS51dGlscy5jbGVhclRleHR1cmVDYWNoZSgpO1xyXG5cclxuICAgICAgICBsb2FkZXIucmVzZXQoKTtcclxuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICB0aGlzLmd1aS5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhZ2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJvbWlucHV0XCIpISBhcyBIVE1MRm9ybUVsZW1lbnQpLnJlc2V0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy50YXJnZXRBbmltKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0QW5pbS5wb3NpdGlvbi5zZXQoXHJcbiAgICAgICAgICAgICAgICBDb25maWcucHJvamVjdF93aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICBDb25maWcucHJvamVjdF9oZWlnaHQgLyAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Main.ts\n");

/***/ }),

/***/ "./src/Observer.ts":
/*!*************************!*\
  !*** ./src/Observer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Subject\": () => (/* binding */ Subject)\n/* harmony export */ });\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n        this.add_observer = (observer) => {\r\n            this.observers.push(observer);\r\n        };\r\n        this.remove_observer = (observer) => {\r\n            const observer_index = this.observers.indexOf(observer);\r\n            if (observer_index !== -1) {\r\n                this.observers.splice(observer_index, 1);\r\n            }\r\n            else {\r\n                console.error(\"No such observer exists!\");\r\n            }\r\n        };\r\n        this.notify_all = () => {\r\n            for (const o of this.observers) {\r\n                if (o.on_state_update) {\r\n                    o.on_state_update();\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvT2JzZXJ2ZXIudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lc2FuZGJveC8uL3NyYy9PYnNlcnZlci50cz8zNzlhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2ZXIge1xyXG4gICAgb25fc3RhdGVfdXBkYXRlPzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN1YmplY3Qge1xyXG4gICAgb2JzZXJ2ZXJzOiBPYnNlcnZlcltdID0gW107XHJcbiAgICBhZGRfb2JzZXJ2ZXIgPSAob2JzZXJ2ZXI6IE9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICB9O1xyXG4gICAgcmVtb3ZlX29ic2VydmVyID0gKG9ic2VydmVyOiBPYnNlcnZlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyX2luZGV4ID0gdGhpcy5vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgaWYgKG9ic2VydmVyX2luZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2Uob2JzZXJ2ZXJfaW5kZXgsIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzdWNoIG9ic2VydmVyIGV4aXN0cyFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG5vdGlmeV9hbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChvLm9uX3N0YXRlX3VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgby5vbl9zdGF0ZV91cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Observer.ts\n");

/***/ }),

/***/ "./src/ResourceLoader.ts":
/*!*******************************!*\
  !*** ./src/ResourceLoader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResourceController\": () => (/* binding */ ResourceController)\n/* harmony export */ });\nclass Loader {\r\n    constructor() {\r\n        this.loader = PIXI.Loader.shared;\r\n        this.getResource = (key) => {\r\n            const resource = this.resources[key];\r\n            if (!resource)\r\n                throw new Error(`There is no resource with name - {${key}}`);\r\n            return resource;\r\n        };\r\n        this.getSpineData = (key) => {\r\n            const resource = this.getResource(key);\r\n            if (resource instanceof PIXI.Texture) {\r\n                throw new Error(`Resource with name {${key}} is not a spine!`);\r\n            }\r\n            const spineData = resource.spineData;\r\n            if (!spineData) {\r\n                if (resource.data) {\r\n                    throw new Error(`Spine with name {${key}} not for version 3.8 or it\\`s not a spine!`);\r\n                }\r\n                else {\r\n                    throw new Error(`There is no spineData in resource - {${key}}!`);\r\n                }\r\n            }\r\n            return spineData;\r\n        };\r\n        this.getSpine = (key) => {\r\n            const spineData = this.getSpineData(key);\r\n            return new PIXI.spine.Spine(spineData);\r\n        };\r\n        this.addResources = (ANIMATIONS) => {\r\n        };\r\n        this.loadResources = () => {\r\n            return new Promise((resolve) => {\r\n                this.loader.load(() => {\r\n                    resolve();\r\n                });\r\n            });\r\n        };\r\n    }\r\n    get resources() {\r\n        return this.loader.resources;\r\n    }\r\n}\r\nconst ResourceController = new Loader();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUmVzb3VyY2VMb2FkZXIudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpEQTtBQUNBO0FBQ0E7QUF1REE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwaW5lc2FuZGJveC8uL3NyYy9SZXNvdXJjZUxvYWRlci50cz8zZmQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSZXNvdXJjZURpY3Rpb25hcnkgfSBmcm9tIFwicGl4aS5qc1wiO1xuXG5jbGFzcyBMb2FkZXIge1xuICAgIGxvYWRlciA9IFBJWEkuTG9hZGVyLnNoYXJlZDtcblxuICAgIHB1YmxpYyBnZXQgcmVzb3VyY2VzKCk6IElSZXNvdXJjZURpY3Rpb25hcnkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIucmVzb3VyY2VzO1xuICAgIH1cblxuICAgIGdldFJlc291cmNlID0gKGtleTogc3RyaW5nKTogUElYSS5Mb2FkZXJSZXNvdXJjZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNba2V5XTtcblxuICAgICAgICBpZiAoIXJlc291cmNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyByZXNvdXJjZSB3aXRoIG5hbWUgLSB7JHtrZXl9fWApO1xuXG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICB9O1xuXG4gICAgZ2V0U3BpbmVEYXRhID0gKGtleTogc3RyaW5nKTogUElYSS5zcGluZS5jb3JlLlNrZWxldG9uRGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5nZXRSZXNvdXJjZShrZXkpO1xuXG4gICAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFBJWEkuVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSB3aXRoIG5hbWUgeyR7a2V5fX0gaXMgbm90IGEgc3BpbmUhYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcGluZURhdGEgPSByZXNvdXJjZS5zcGluZURhdGE7XG5cbiAgICAgICAgaWYgKCFzcGluZURhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlc291cmNlLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgU3BpbmUgd2l0aCBuYW1lIHske2tleX19IG5vdCBmb3IgdmVyc2lvbiAzLjggb3IgaXRcXGBzIG5vdCBhIHNwaW5lIWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBUaGVyZSBpcyBubyBzcGluZURhdGEgaW4gcmVzb3VyY2UgLSB7JHtrZXl9fSFgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGluZURhdGE7XG4gICAgfTtcblxuICAgIGdldFNwaW5lID0gKGtleTogc3RyaW5nKTogUElYSS5zcGluZS5TcGluZSA9PiB7XG4gICAgICAgIGNvbnN0IHNwaW5lRGF0YSA9IHRoaXMuZ2V0U3BpbmVEYXRhKGtleSk7XG4gICAgICAgIHJldHVybiBuZXcgUElYSS5zcGluZS5TcGluZShzcGluZURhdGEpO1xuICAgIH07XG5cbiAgICBhZGRSZXNvdXJjZXMgPSAoQU5JTUFUSU9OUzogYW55KSA9PiB7XG4gICAgICAgIC8vIHRoaXMubG9hZGVyLmFkZChcbiAgICAgICAgLy8gICAgIGFzc2V0LmtleSxcbiAgICAgICAgLy8gICAgIGAke1Nlc3Npb25Db25maWcuQVNTRVRTX0FERFJFU1N9JHthc3NldExpc3QuZGVmYXVsdFBhdGh9JHthc3NldC5wYXRofWBcbiAgICAgICAgLy8gKTtcbiAgICB9O1xuXG4gICAgbG9hZFJlc291cmNlcyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJlc291cmNlQ29udHJvbGxlciA9IG5ldyBMb2FkZXIoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/ResourceLoader.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi-spine */ \"./node_modules/pixi-spine/dist/pixi-spine.js\");\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_spine__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App */ \"./src/App.ts\");\n\r\n\r\n\r\n\r\nfunction init() {\r\n    document.getElementById(\"root\").onmousedown = () => {\r\n        return false;\r\n    };\r\n    const game_name = \"Spine Sandbox\";\r\n    const full_game_name = `${game_name} v${_package_json__WEBPACK_IMPORTED_MODULE_2__.version}`;\r\n    console.log(full_game_name);\r\n    document.title = full_game_name;\r\n    new _App__WEBPACK_IMPORTED_MODULE_3__.App();\r\n}\r\nif (document.readyState !== \"loading\") {\r\n    init();\r\n}\r\nelse {\r\n    document.addEventListener(\"DOMContentLoaded\", init);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGluZXNhbmRib3gvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJwaXhpLXNwaW5lXCI7XHJcbmltcG9ydCBcInBpeGkuanNcIjtcclxuaW1wb3J0IHBhY2thZ2VJbmZvIGZyb20gXCIuLi9wYWNrYWdlLmpzb25cIjtcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vQXBwXCI7XHJcblxyXG5mdW5jdGlvbiBpbml0KCkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpIS5vbm1vdXNlZG93biA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdhbWVfbmFtZSA9IFwiU3BpbmUgU2FuZGJveFwiO1xyXG4gICAgY29uc3QgZnVsbF9nYW1lX25hbWUgPSBgJHtnYW1lX25hbWV9IHYke3BhY2thZ2VJbmZvLnZlcnNpb259YDtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhmdWxsX2dhbWVfbmFtZSk7XHJcblxyXG4gICAgZG9jdW1lbnQudGl0bGUgPSBmdWxsX2dhbWVfbmFtZTtcclxuXHJcbiAgICBuZXcgQXBwKCk7XHJcbn1cclxuXHJcbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xyXG4gICAgaW5pdCgpO1xyXG59IGVsc2Uge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaW5pdCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BpbmVzYW5kYm94Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "pixi.js":
/*!***********************!*\
  !*** external "PIXI" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = PIXI;

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"spinesandbox","version":"1.0.0","description":"sandbox for spine animation","main":"src/index.ts","scripts":{"test":"npm run test","local":"webpack serve --config-name local","dev":"webpack --config-name dev","deploy":"npm run dev && gh-pages -d dist"},"repository":{"type":"git","url":"spine-sandbox"},"keywords":["spine","pixijs","sandbox"],"author":"Vlad Kyiashko","license":"ISC","devDependencies":{"@pixi/core":"^5.3.10","@types/dat.gui":"^0.7.7","@typescript-eslint/eslint-plugin":"^4.27.0","@typescript-eslint/parser":"^4.27.0","clean-webpack-plugin":"^3.0.0","copy-webpack-plugin":"^9.0.0","dat.gui":"^0.7.9","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","eslint-plugin-prettier":"^3.4.0","pixi-spine":"^2.1.10","pixi.js":"^5.3.3","prettier":"^2.3.1","ts-loader":"^9.2.3","tslib":"^2.3.1","typescript":"^4.3.2","url-loader":"^4.1.1","webpack":"^5.39.0","webpack-cli":"^4.7.2","webpack-dev-server":"^4.9.3"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;